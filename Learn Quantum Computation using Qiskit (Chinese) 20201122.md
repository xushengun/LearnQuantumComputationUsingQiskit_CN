<p align="left"><font size=20>Learn Quantum Computation using Qiskitï¼ˆä¸­æ–‡ç‰ˆï¼‰</font></p>
  



<p align="right"><font size=5>https://qiskit.org/</font></p>

  


<center><font size=5>ä¸­æ–‡ç‰ˆè¯‘è€…ï¼šå¾æŸ³é’

ç”µè¯ï¼š18616020096ï¼ˆWechatï¼‰

ç”µå­é‚®ä»¶ï¼š<45045590@qq.com>

Githubï¼šhttps://github.com/xushengun/

æ—¥æœŸï¼š20201016</font></center>


# å‰è¨€

![](pics/media/image1.png)

æ¥è‡ªQiskitç¤¾åŒºå›¢é˜Ÿçš„é—®å€™!æœ¬æ•™ç¨‹æ˜¯Qiskitçš„å¤§å­¦é‡å­ç®—æ³•/è®¡ç®—è¯¾ç¨‹çš„è¡¥å……ï¼š

1.  é‡å­ç®—æ³•èƒŒåçš„æ•°å­¦

2.  å½“ä»Šéå®¹é”™é‡å­è®¾å¤‡çš„ç»†èŠ‚

3.  ç”¨Qiskitç¼–å†™ä»£ç å¹¶åœ¨IBMçš„äº‘é‡å­ç³»ç»Ÿä¸Šå®ç°é‡å­ç®—æ³•

å…³äºæœ¬æ•™ç¨‹
----------

è¿™æ˜¯ä¸€ä¸ªå…è´¹çš„æ•°å­—ç‰ˆæ•™ç¨‹ï¼Œåœ¨ä½¿ç”¨Qiskit
SDKçš„åŒæ—¶é€šè¿‡æœ¬æ•™ç¨‹æ•™æˆé‡å­è®¡ç®—çš„æ¦‚å¿µã€‚

ä»¥å†…è”æ–¹å¼è¿è¡Œä»£ç 
------------------

æœ¬æ•™ç¨‹æ„å»ºäºå¯ä»¥è½»æ¾é˜…è¯»çš„jupyter
notebookæ¡†æ¶ä¸Šï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥è®©è¯»è€…èƒ½å¤Ÿç›´æ¥åœ¨æœ¬æ•™ç¨‹ä¸­ç¼–è¾‘å’Œè¿è¡Œä»£ç ã€‚æœ¬æ•™ç¨‹çš„äº›ç« ä¹Ÿå¯ä»¥åœ¨IBM
Quantum Experienceä¸­ä»¥jupyter notebookçš„æ ¼å¼æ‰“å¼€è€Œæ— éœ€å®‰è£…ï¼

> print(\"This code works!\")
>
> This code works!
>
> from qiskit import QuantumCircuit
>
> qc = QuantumCircuit(2) \# Create circuit with 2 qubits
>
> qc.h(0) \# Do H-gate on q0
>
> qc.cx(0,1) \# Do CNOT on q1 controlled by q0
>
> qc.measure_all()
>
> qc.draw()

![](pics/media/image3.png)

å­¦ä¹ çœŸæ­£çš„é‡å­ç³»ç»Ÿ
------------------

æœ€å¥½çš„å­¦ä¹ æ–¹æ³•æ˜¯å®è·µã€‚Qiskitå…è®¸ç”¨æˆ·åœ¨èˆ’é€‚çš„å®¶ä¸­ä½¿ç”¨æœ€å…ˆè¿›çš„é‡å­è®¾å¤‡è¿›è¡Œå®éªŒã€‚æœ¬æ•™ç¨‹ä¸ä»…æ•™æˆç†è®ºé‡å­è®¡ç®—ï¼Œè€Œä¸”è¿˜æ•™æˆå®ç°ç†è®ºçš„å®éªŒé‡å­ç‰©ç†ã€‚

![](pics/media/image4.png)

ä½¿ç”¨æœ¬æ•™ç¨‹çš„æ–¹æ³•
----------------

### è¯¾ç¨‹æ•´åˆ

æœ¬æ•™ç¨‹å¯ä»¥ä½œä¸ºä¸€ä¸ªç‹¬ç«‹çš„è¯¾ç¨‹ï¼Œä½†å…¶æœ€åˆç›®çš„æ˜¯ä¸ºé…åˆä¼ ç»Ÿçš„å¤§å­¦è¯¾ç¨‹è€Œè®¾è®¡ã€‚æœ¬æ•™ç¨‹å‘å­¦ç”Ÿå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨Qiskitæ¥è¿›è¡Œé‡å­ç®—æ³•å’Œç¡¬ä»¶çš„å®éªŒï¼Œå¹¶ä»¥æ­¤æ¥åŠ å¼ºä»–ä»¬çš„ç†è§£ã€‚

![](pics/media/image5.png)

### è·¯çº¿å›¾

Qiskitæ•™ç¨‹ä¸­æ¶µç›–äº†å¹¿æ³›çš„ææ–™ï¼Œå¹¶éæ‰€æœ‰çš„ææ–™å¯ä»¥åœ¨ä¸€ä¸ªå•ä¸€è¯¾ç¨‹ä¸­æ­ç¤ºã€‚è¯»è€…å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æŒ‡å—æ¥è°ƒæ•´éœ€è¦å­¦ä¹ çš„éƒ¨åˆ†ã€‚ä½†æ˜¯ï¼Œä¸‹é¢çš„æŒ‡å—ä»…æ˜¯ä½¿ç”¨æœ¬æ•™ç¨‹çš„ä¸€ç§å»ºè®®æ–¹æ³•ã€‚

![](pics/media/image6.png)

ä¿¡èª‰
----

### è”ç³»æ–¹å¼

å¦‚æœæ‚¨å¯¹æœ¬æ•™ç¨‹æœ‰ä»»ä½•ç–‘é—®æˆ–å»ºè®®ï¼Œæˆ–è€…æƒ³å°†å…¶çº³å…¥æ‚¨çš„è¯¾ç¨‹è¡¨ï¼Œè¯·è”ç³»Frank
Harkinsï¼ˆFrancis.Harkins\@ibm.comï¼‰ã€‚æœ¬ç€å¼€æ”¾æºä»£ç çš„ç²¾ç¥ï¼Œåœ¨æ­¤GitHubå­˜å‚¨åº“ä¸­æ¬¢è¿ä»»ä½•ç« èŠ‚çš„è´¡çŒ®ã€‚

### è´¡çŒ®è€…

æœ¬æ•™ç¨‹æ˜¯å¤šäººå·¥ä½œçš„ç»“æœã€‚å¦‚æœåœ¨å·¥ä½œä¸­ä½¿ç”¨æœ¬æ•™ç¨‹ï¼Œè¯·å¼•ç”¨[bibæ–‡ä»¶](https://github.com/Qiskit/qiskit-textbook/blob/master/content/qiskit-textbook.bib)æˆ–ç›´æ¥å¼•ç”¨ï¼š

*Abraham Asfaw, Luciano Bello, Yael Ben-Haim, Sergey Bravyi, Lauren
Capelluto, Almudena Carrera Vazquez, Jack Ceroni, Richard Chen, Albert
Frisch, Jay Gambetta, Shelly Garion, Leron Gil, Salvador De La Puente
Gonzalez, Francis Harkins, Takashi Imamichi, David McKay, Antonio
Mezzacapo, Zlatko Minev, Ramis Movassagh, Giacomo Nannicni, Paul Nation,
Anna Phan, Marco Pistoia, Arthur Rattew, Joachim Schaefer, Javad
Shabani, John Smolin, Kristan Temme, Madeleine Tod, Stephen Wood, James
Wootton.*

ä»€ä¹ˆæ˜¯é‡å­ï¼Ÿ
============

"é‡å­ç‰©ç†å­¦"æ˜¯ä¸€ä¸ªè¢«å¹¿æ³›ä½¿ç”¨ä½†å´å¾ˆå°‘è¢«äººç†è§£çš„æœ¯è¯­ã€‚å®ƒæ˜¯ä¸€ç§æ•°å­¦æ¨¡å‹ï¼Œæœ€åˆç”¨äºæè¿°å®éªŒå®¤ä¸­å¾®å°ç‰©ä½“çš„è¡Œä¸ºï¼Œå…¶æ­éœ²äº†å…ˆå‰"ç»å…¸"ç‰©ç†å­¦ç†è®ºçš„ç¼ºé™·ã€‚é‡å­ç†è®ºè§£é‡Šäº†è¿™ç§è¡Œä¸ºï¼Œå¹¶ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæ›´å®Œæ•´çš„å®‡å®™å›¾åƒã€‚äººä»¬å·²ç»æ„è¯†åˆ°å¯ä»¥åˆ©ç”¨è¿™ç§ä»¥å‰æ— æ³•è§£é‡Šçš„è¡Œä¸ºæ¥è¿›è¡ŒæŸäº›ä¹‹å‰è®¤ä¸ºä¸å¯èƒ½çš„è®¡ç®—ã€‚äººä»¬å°†å…¶ç§°ä¹‹ä¸ºé‡å­è®¡ç®—ã€‚

é‡å­è®¡ç®—æ˜¯æ‚¨æ¶‰è¶³é‡å­ç‰©ç†å­¦çš„å®Œç¾æ–¹å¼ã€‚é‡å­è®¡ç®—å°†é‡å­ç‰©ç†å­¦çš„æ ¸å¿ƒæ¦‚å¿µæç‚¼ä¸ºæœ€ç®€å•çš„å½¢å¼ï¼ŒåŒæ—¶å‰¥ç¦»äº†ç‰©ç†ä¸–ç•Œçš„å¤æ‚æ€§ã€‚æœ¬æ–‡å°†å¸¦æ‚¨å»æ¢ç´¢å’Œç†è§£ä¸€äº›å¥‡æ€ªçš„é‡å­ç°è±¡ï¼Œå¹¶è®©æ‚¨å¯¹ä»€ä¹ˆæ˜¯"é‡å­"æœ‰ä¸€ä¸ªåˆæ­¥çš„äº†è§£ã€‚

ç»å…¸æ¦‚ç‡å›é¡¾
------------

è‹¥è¦ç†è§£é‡å­ç°è±¡ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦äº†è§£"ç»å…¸"æ¦‚ç‡ã€‚æ­¤å¤„çš„"ç»å…¸"æ˜¯æŒ‡åœ¨é‡å­ç‰©ç†è¢«å‘ç°ä¹‹å‰ï¼Œæ¯”å¦‚æ‚¨åœ¨ä¸Šå­¦æ—¶å­¦åˆ°çš„æ­£æ€æ¦‚ç‡æ ‘ï¼ˆnormal
probability
treeï¼‰ã€‚å¦‚æœæ‚¨å¯¹å·²ç»ç†Ÿæ‚‰äº†è¿™äº›ææ–™ï¼Œé‚£ä¹ˆè¯·å¿«é€Ÿæµè§ˆä¸€ä¸‹ã€‚å¦‚æœæ‚¨å¯¹è¿™ä¸ªä¸æ˜¯å¾ˆæ„Ÿå…´è¶£ï¼Œä¹Ÿä¸ç”¨æ‹…å¿ƒ------æˆ‘ä»¬åªä¼šæ¶µç›–ä¸€äº›å¯èƒ½æ˜¯æœ€ç®€å•çš„æ¦‚ç‡é—®é¢˜ã€‚

### æ¦‚ç‡æ ‘

å¸Œæœ›æ‚¨è¿˜è®°å¾—ä¸Šå­¦æ—¶å­¦è¿‡çš„æ¦‚ç‡æ ‘ã€‚è¯¥æƒ³æ³•å¾ˆç®€å•------ç”¨ä¸€å¼ å›¾æç»˜å‡ºæ¯ä¸€ç§å¯èƒ½å‘ç”Ÿäº‹æƒ…çš„å¯èƒ½æ€§ï¼Œä»ä¸­è®¡ç®—å‡ºå…¶å‘ç”Ÿçš„å‡ ç‡ã€‚

å‡è®¾æˆ‘ä»¬æœ‰ä¸€æšå‡åŒ€çš„ç¡¬å¸ï¼Œä»¥åŒ…å«å¤´åƒï¼ˆHeadï¼‰çš„ä¸€é¢ä¸ºæ­£é¢ã€‚ç„¶åæŠ›æ·è¿™ä¸€å‡åŒ€ç¡¬å¸å¹¶è§‚å¯Ÿç»“æœï¼Œä¼šå‘çœ‹åˆ°æ­£é¢HåŠåé¢Tçš„æœºç‡å„å 50%ã€‚æˆ‘ä»¬å°†è¿™ä¸€ç»“æœç”»åœ¨ä¸€ä¸ªæ¦‚ç‡æ ‘ä¸Šï¼š

![](pics/media/image7.png)æˆ‘ä»¬åœ¨æ¯ä¸ªåˆ†å‰çš„æœ«ç«¯ç”»å‡ºç»“æœå¹¶åœ¨æ¯ä¸ªåˆ†å‰ä¸Šæ ‡æ³¨å‡ºç°çš„æ¦‚ç‡ã€‚ä¸ä¸Šè¿°æ­¥éª¤ç›¸åŒï¼Œå¦‚æœä»åé¢å¼€å§‹æŠ›æ·è¿™ä¸ªç¡¬å¸ï¼Œä»å„æœ‰50%çš„æœºä¼šçœ‹åˆ°æ­£é¢æˆ–åé¢ã€‚

![](pics/media/image8.png)

æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸æ–­å°è¯•æ¥æµ‹è¯•è¿™ä¸ªè¿‡ç¨‹ã€‚æ‚¨å¯ä»¥æ‰¾å‡ºä¸€æšç¡¬å¸å¹¶æŠ›æ·å¤šæ¬¡ï¼Œç„¶åè®°å½•æ¯ä¸€æ¬¡çš„ç»“æœï¼›æœ€ç»ˆæ‚¨ä¼šçœ‹åˆ°å¤§çº¦æœ‰50%çš„ç»“æœæ˜¯æ­£é¢Hï¼Œ50%æ˜¯åé¢Tã€‚ç»éªŒä¼°è®¡å¤§çº¦éœ€è¦500åˆ°1000æ¬¡æŠ›æ·å°±è¶³ä»¥å¾—å‡ºå¯é çš„ç»“æœã€‚

### å®éªŒ\#1ï¼šå•ç¡¬å¸æŠ›æ·

å¦‚æœæ‚¨æ²¡æœ‰æ—¶é—´è¿›è¡Œè¿™æ ·çš„å®éªŒï¼Ÿè¯·ä¸å¿…æ‹…å¿ƒï¼æ‚¨å¯ä»¥é€šè¿‡ç‚¹å‡»ç½‘é¡µä¸Šçš„"Toss
Coin"æŒ‰é’®æ¥æ¨¡æ‹Ÿè¿™ä¸ªå®éªŒï¼Œå¹¶ä¿å­˜æŠ›æ·çš„ç»“æœã€‚æ‚¨è¿˜å¯ä»¥æ”¹å˜æŠ›æ·æ—¶çš„åˆå§‹çŠ¶æ€ä¸ºæ­£é¢ï¼ˆHeadï¼‰æˆ–åé¢ï¼ˆTailï¼‰ï¼Œæˆ–é€šè¿‡å¢åŠ ç¡¬å¸çš„æ•°é‡æ¥å¿«é€Ÿè·å–å¤§é‡ç»“æœã€‚ç‚¹å‡»"Reset"å¯ä»¥ä¸¢å¼ƒå…ˆå‰çš„ç»“æœå¹¶é‡æ–°å¼€å§‹ã€‚

![](pics/media/image9.png)

### è¿›ä¸€æ­¥æ¢ç´¢

é€šè¿‡ä¸Šé¢çš„å®éªŒå¯ä»¥éªŒè¯ï¼šæ¦‚ç‡æ ‘æ¨¡å‹æ­£ç¡®åœ°é¢„æµ‹äº†å®éªŒçš„ç»“æœã€‚æ­¤æ—¶æˆ‘ä»¬å¯ä»¥æ›´è¿›ä¸€æ­¥ï¼Œé€šè¿‡æŠŠæ¦‚ç‡æ ‘ä¸²è”èµ·æ¥é¢„æµ‹ä¸€è¿ä¸²äº‹ä»¶çš„ç»“æœã€‚å‡è®¾æˆ‘ä»¬ä»æ­£é¢ï¼ˆHeadï¼‰å¼€å§‹æŠ›ç¡¬å¸å¹¶ä¸æ–­é‡å¤ï¼Œç»“æœä¼šæ˜¯ä»€ä¹ˆï¼Ÿæ­¤æ—¶æˆ‘ä»¬å¯ä»¥åˆ©ç”¨æ¦‚ç‡æ ‘è§£è¯»ï¼š

![](pics/media/image10.png)

æ‚¨å¯èƒ½è¿˜è®°å¾—æ²¿ç€æ¦‚ç‡æ ‘ä¸­æ ‘æä¸Šçš„æ¦‚ç‡ç›¸ä¹˜æ¥è®¡ç®—ä¸€ä¸ªäº‹ä»¶çš„ç»„åˆæ¦‚ç‡ï¼š

![](pics/media/image11.gif)

ç„¶åå°†ç»“æœç›¸åŠ ï¼Œè®¡ç®—æ¯ç§ç»“æœçš„æ¦‚ç‡ï¼š

![](pics/media/image12.gif)

å¯ä»¥çœ‹åˆ°åœ¨ä¸¤æ¬¡æŠ›æ·åçœ‹åˆ°æ­£é¢Hçš„æ¦‚ç‡æ˜¯50%ï¼Œåœ¨ä¸¤æ¬¡æŠ›æ·åçœ‹åˆ°åé¢Tçš„æ¦‚ç‡ä¹Ÿæ˜¯50%ã€‚

### å®éªŒ\#2ï¼šåŒç¡¬å¸æŠ›æ·

æ‚¨å¯ä»¥é€šè¿‡æŒ‰ä¸¤æ¬¡"Toss
Coin"æŒ‰é’®æ¥æ¨¡æ‹Ÿå•ç¡¬å¸æŠ›æ·å®éªŒå¹¶è·å¾—æœ€ç»ˆç»“æœã€‚è¿˜å¯ä»¥æ”¹å˜åˆå§‹çŠ¶æ€æˆ–æ”¹å˜åŒæ—¶è¢«æŠ›æ·çš„ç¡¬å¸æ•°é‡æ¥å¿«é€Ÿè·å–å¤§é‡ç»“æœã€‚

![](pics/media/image13.png)

é€šè¿‡è¶³å¤Ÿå¤šæ¬¡çš„æŠ›æ·ï¼Œæˆ‘ä»¬å‘ç°ç»“æœä¸é¢„æœŸç›¸åŒï¼šæ­£é¢Hå’Œåé¢Tçš„å‡ºç°æ¬¡æ•°å‡ ä¹ç›¸åŒã€‚

é‡å­ç¡¬å¸
--------

é€šè¿‡ä¸Šé¢çš„å®éªŒï¼Œæˆ‘ä»¬å¯¹ç»å…¸ç¡¬å¸æœ‰äº†å®Œæ•´çš„äº†è§£ã€‚ç°åœ¨å¼•å…¥é‡å­"ç¡¬å¸"ï¼Œç§°ä¸º"é‡å­æ¯”ç‰¹ï¼ˆqubitï¼‰"ã€‚

å› ä¸ºå…¶å¾ˆéš¾è¢«æ“çºµï¼Œæ‰€ä»¥é‡å­æ¯”ç‰¹åªèƒ½åœ¨å®éªŒå®¤é‡Œç©ã€‚ç»è¿‡å¤šå¹´çš„ç§‘å­¦å’ŒæŠ€æœ¯çš„è¿›æ­¥å·²ç»èƒ½å¤Ÿåˆ›é€ å‡ºç°ä»Šæˆ‘ä»¬æ‰€æ‹¥æœ‰çš„é‡å­æ¯”ç‰¹äº†ï¼Œä½†å­¦ä¹ é‡å­è®¡ç®—çš„ç¾å¦™ä¹‹å¤„åœ¨äºï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥ç‰©ç†çš„å¤æ‚æ€§å¹¶ä»…éœ€è®°ä½å½“æµ‹é‡ä¸€ä¸ªé‡å­æ¯”ç‰¹æ—¶ï¼Œå…¶å°†ä¼šå¤„åœ¨ä¸¤ç§çŠ¶æ€ä¹‹ä¸€ï¼šé‡å­æ¯”ç‰¹çš„çŠ¶æ€$0$å’ŒçŠ¶æ€$1$ã€‚

### å®éªŒ\#3ï¼šé‡å­ç¡¬å¸æŠ›æ·

ç°åœ¨æˆ‘ä»¬ä½¿ç”¨é‡å­ç¡¬å¸æ¥åšè¿›è¡ŒæŠ›æ·å®éªŒã€‚ä¸ä¸Šé¢çš„æŠ›æ·ç»å…¸ç¡¬å¸çš„å®éªŒä¸€æ ·ï¼Œè¿›è¡Œé‡å­æŠ›æ·ã€æµ‹é‡é‡å­ç¡¬å¸çš„çŠ¶æ€å¹¶è®°å½•ã€‚

![](pics/media/image14.png)

ç„¶åï¼Œå°è¯•ç”¨æ¦‚ç‡æ ‘æ¥æè¿°è¿™ä¸€è¿‡ç¨‹ä¸­çš„é‡å­ç¡¬å¸ã€‚åœ¨çŠ¶æ€$0$ä¸‹æŠ›æ·é‡å­ç¡¬å¸æœ‰50%çš„æœºç‡ä¼šå¾—åˆ°$0$æˆ–$1$ï¼Œæˆ‘ä»¬æŠŠè¿™ä¸€ç»“æœç”»åœ¨æ¦‚ç‡æ ‘ä¸Šï¼š

![](pics/media/image15.png)

![](pics/media/image16.png)

ç›¸ç±»ä¼¼çš„ï¼Œåœ¨çŠ¶æ€1ä¸‹å„æœ‰50%çš„æœºç‡æµ‹å¾—ç»“æœä¸º0æˆ–1ï¼Œæ‰€ç»˜åˆ¶çš„æ¦‚ç‡æ ‘ä¸ºï¼š

![](pics/media/image17.png)

### å®éªŒ\#4ï¼šåŒé‡å­ç¡¬å¸æŠ›æ·

è‡ªæ­¤æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªå¯ä»¥é¢„æµ‹é‡å­ç¡¬å¸è¡Œä¸ºçš„æ¨¡å‹ã€‚ç°åœ¨æˆ‘ä»¬æƒ³è¦å¯¹è¿™ä¸ªæ¨¡å‹è¿›è¡Œæµ‹è¯•ï¼Œè§‚å¯Ÿå…¶æ˜¯å¦å¯¹æ–°æƒ…å†µä¹Ÿæˆç«‹ã€‚æµ‹è¯•çš„æ–¹æ³•ä¸ºåƒå‰é¢é‚£æ ·ä¸€æ¬¡æŠ›ä¸¤æšç¡¬å¸ã€‚ä¸ç»å…¸ç¡¬å¸æ¨¡å‹ç›¸åŒï¼Œé‡å­ç¡¬å¸æ¨¡å‹é¢„æµ‹æ— è®ºå¼€å§‹æ—¶å¤„äºå“ªä¸€çŠ¶æ€ï¼Œéƒ½æœ‰50%çš„æœºä¼šæµ‹å¾—0æˆ–1ï¼š

![](pics/media/image18.png)

æˆ‘ä»¬å¯ä»¥é€šè¿‡å·¥å…·æŠ›æ·ä¸€ä¸ªé‡å­ç¡¬å¸ä¸¤æ¬¡ï¼š

![](pics/media/image19.png)

å¯ä»¥çœ‹åˆ°ç»“æœå¹¶éå¦‚æˆ‘ä»¬æ‰€å¸Œæœ›ã€‚å†çœ‹çœ‹æŠŠåˆå§‹çŠ¶æ€è®¾ç½®ä¸º1æ˜¯ä¼šå‘ç”Ÿä»€ä¹ˆï¼

![](pics/media/image20.png)

è¿™ä¸æˆ‘ä»¬çš„é¢„æµ‹å®Œå…¨ä¸ç¬¦ï¼æ¨¡å‹å¤±æ•ˆäº†ï¼è¿™å°±æ˜¯ç‰©ç†å­¦å®¶åœ¨20ä¸–çºªåˆé‡åˆ°çš„ç›¸åŒé—®é¢˜ã€‚å¯»æ‰¾è¿™ä¸€é—®é¢˜ç­”æ¡ˆçš„è¿‡ç¨‹å¯¼è‡´äº†é‡å­ç‰©ç†å­¦çš„å‘å±•ï¼Œæˆ‘ä»¬å°†ç”¨è¿™ä¸€è¿‡ç¨‹æ¥æè¿°æŠ›æ·é‡å­ç¡¬å¸ã€‚

é‡å­æ¨¡å‹
--------

**ç®€è€Œè¨€ä¹‹ï¼Œé‡å­ç†è®ºæ˜¯åŒ…å«è´Ÿæ•°çš„æ¦‚ç‡è®ºã€‚**

è¿™å¥è¯æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿä¸å¯èƒ½æœ‰è´Ÿçš„æ¦‚ç‡ï¼Œå› ä¸ºæ ¹æœ¬æ²¡æœ‰æ„ä¹‰ã€‚ä¸ºäº†åŒ…å®¹è¿™ä¸€æƒ…å†µï¼Œæ­¤å¤„ä½¿ç”¨äº†ä¸€ä¸ªç§°ä¸ºå¹…å€¼ï¼ˆamplitudeï¼‰çš„é‡å¹¶å°†å…¶ç”»åœ¨æ ‘ä¸Šã€‚ç”±äºä¸å¯èƒ½æœ‰è´Ÿçš„æ¦‚ç‡è€Œä¸”æ‰€æœ‰çš„æ¦‚ç‡åŠ èµ·æ¥å¿…é¡»æ˜¯1ï¼Œä¸ºäº†é¿å¼€è¿™ä¸€äº‹å®ï¼Œæ­¤å¤„ä½¿ç”¨äº†ä¸€ä¸ªæ•°å­¦æŠ€å·§ï¼š*ä½¿ç”¨å¹…å€¼çš„å¹³æ–¹æ¥è®¡ç®—æ¦‚ç‡*ã€‚

![](pics/media/image21.png)

ä»ä¸Šå›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œä»çŠ¶æ€0å¼€å§‹æŠ›æ·é‡å­ç¡¬å¸çš„åŠ¨ä½œç»™ä¸¤ç§ç»“æœåˆ†é…äº†ç›¸åŒçš„å¹…å€¼ã€‚å½“å¯¹è¿™äº›å¹…å€¼å–å¹³æ–¹åå°±ç»™å‡ºäº†æµ‹é‡0æˆ–1çš„æ­£ç¡®æ¦‚ç‡ã€‚å¦‚ä½•çŸ¥é“å¹…å€¼ä¸º$\sqrt{\frac{1}{2}}$ï¼Ÿå› ä¸ºæ­£æ˜¯ä¸Šé¢çš„å®éªŒå€¼ç»™å‡ºäº†æ­£ç¡®ç­”æ¡ˆï¼

ä»çŠ¶æ€1å¼€å§‹ï¼Œå¹…å€¼æ ‘å°±ä¼šä¸åŒï¼š

![](pics/media/image22.png)

åœ¨æ­¤å¤„ï¼Œç»“æœçš„å¹…å€¼ä¸­å‡ºç°ç¬¬ä¸€ä¸ªè´Ÿæ•°ã€‚å½“æˆ‘ä»¬å¹³æ–¹å¹…å€¼æ¥è®¡ç®—æ¦‚ç‡æ—¶ï¼Œè¿™ä¸ªè´Ÿå·å°±æ¶ˆå¤±äº†ï¼Œæµ‹å¾—çš„æ¦‚ç‡ä»æ˜¯50%ã€‚å½“æˆ‘ä»¬æŠŠè¿™äº›æ¦‚ç‡ä¸²åœ¨ä¸€èµ·æ—¶ä¼šå‘ç”Ÿä¸€äº›æœ‰è¶£çš„äº‹æƒ…ã€‚

å¯¹åŒé‡å­ç¡¬å¸æŠ›æ·çš„è¯ é‡Š
----------------------

ä¸ç»å…¸æ¦‚ç‡ç›¸åŒï¼Œæˆ‘ä»¬å°†ä¼šæ²¿ç€å¹…å€¼æ ‘çš„åˆ†å‰æ¥è®¡ç®—æ¯ç§æƒ…å†µçš„å¹…å€¼ï¼š

![](pics/media/image23.gif)

ä¸ºäº†è®¡ç®—å‡ºæ¯ä¸ªæµ‹é‡ç»“æœçš„æ¦‚ç‡ï¼Œæˆ‘ä»¬æŠŠè¿™äº›å¹…å€¼ç›¸åŠ åå¹³æ–¹ï¼š

![](pics/media/image24.gif)

å¯ä»¥çœ‹åˆ°å¤„äºçŠ¶æ€1çš„ç¡¬å¸ï¼ˆé‡å­æ¯”ç‰¹ï¼‰å¹…å€¼æŠµæ¶ˆäº†å…¶ä»–è¾“å‡ºï¼Œç§°ä¹‹ä¸º**å¹²æ¶‰æ•ˆåº”**ã€‚æ‚¨åº”è¯¥è¯•ç€è‡ªå·±éªŒè¯è¿™ä¸ªæ¨¡å‹åœ¨åˆå§‹çŠ¶æ€ä¸º1æ—¶æ˜¯å¦å¯ä»¥å·¥ä½œã€‚

ä»€ä¹ˆæ˜¯é‡å­è®¡ç®—ï¼Ÿ
----------------

ä¸Šé¢çš„è¿‡ç¨‹æ˜¯ä¸æ˜¯å¾ˆæœ‰è¶£ï¼Ÿä½†æœ‰ä½•ä½œç”¨å‘¢ï¼Ÿäº‹å®è¯æ˜ï¼šè¿™äº›**å¹²æ¶‰æ•ˆåº”**å¯ä»¥ä¸ºæˆ‘ä»¬æ‰€ç”¨ï¼›æˆ‘ä»¬å¯ä»¥å°†è¿™äº›æ“ä½œç»„åˆèµ·æ¥ï¼Œæ¯”å¦‚é€šè¿‡é‡å­ç¡¬å¸æŠ›æ·æ¥æ„å»ºæ›´é«˜æ•ˆçš„ç®—æ³•ã€‚è¿™äº›ç®—æ³•å¯ä»¥åˆ©ç”¨**å¹²æ¶‰æ•ˆåº”**ä½¿é”™è¯¯çš„ç­”æ¡ˆè¿…é€ŸæŠµæ¶ˆï¼Œå¹¶æœ‰å¾ˆé«˜çš„æ¦‚ç‡æµ‹å¾—æ­£ç¡®ç­”æ¡ˆã€‚è¿™å°±æ˜¯é‡å­è®¡ç®—èƒŒåçš„æ€æƒ³ã€‚

1.  é¢„å¤‡çŸ¥è¯†
    ========

    1.  è®¾ç½®ç¯å¢ƒ
        --------

ä»¥ä¸‹æ˜¯åœ¨æ‚¨çš„ä¸ªäººè®¡ç®—æœºä¸Šè®¾ç½®å¹¶ä½¿ç”¨Qiskit
Textbookç¯å¢ƒçš„å…¨é¢æŒ‡å—ã€‚æœ¬æŒ‡å—å°†å¸®åŠ©æ‚¨é‡ç°åœ¨Qiskit
Textbookç½‘ç«™ä¸Šçœ‹åˆ°çš„ç»“æœã€‚Qiskit Textbookç”¨[Jupyter
Notebook](https://jupyter.org/install)ç¼–å†™ï¼ŒNotebookåŠå…¶[ç½‘ç«™](https://qiskit.org/textbook/preface.html)æ˜¯å”¯ä¸€å®Œå…¨æ”¯æŒæœ¬Textbookçš„åª’ä»‹ã€‚

### å®‰è£…qiskit_textbookè½¯ä»¶åŒ…

qiskit_textbookè½¯ä»¶åŒ…ä¸­ç»™å‡ºäº†ä¸€äº›æœ¬æ•™ç¨‹ç‰¹å®šçš„å·¥å…·å’Œæ§ä»¶ï¼Œä½†åœ¨Qiskitè½¯ä»¶ä¸­æœªæä¾›ã€‚å®‰è£…qiskit_textbookçš„æœ€å¿«æ–¹å¼æ˜¯ä½¿ç”¨[Pip](http://pypi.org/project/pip/)å’Œ[Git](http://git-scm.com/)è¿è¡Œä¸‹é¢çš„å‘½ä»¤ï¼š

> pip install
> git+https://github.com/qiskit-community/qiskit-textbook.git\#subdirectory=qiskit-textbook-src

æ‚¨ä¹Ÿå¯ä»¥ä»Githubä¸Šä¸‹è½½qiskit-textbook-srcï¼ˆhttps://github.com/qiskit-community/qiskit-textbookï¼‰åï¼Œåœ¨è§£å‹åçš„ç›®å½•ä¸­è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š

pip install ./qiskit-textbook-src

### æŒ‰ç…§Qiskit Textbookçš„è¦æ±‚å¤ç°è¾“å‡ºçš„æ­¥éª¤ï¼ˆå¯é€‰æ­¥éª¤ï¼‰

#### 1. å°†é»˜è®¤ä½œå›¾å·¥å…·è®¾ç½®ä¸ºMatPlotLib

QuantumCircuit.draw()ä¸qiskit.visualization.circuit_drawer()çš„é»˜è®¤åç«¯ä¸ºæ–‡æœ¬åç«¯ã€‚å½“ç„¶ï¼Œä¾æ®æ‚¨è®¡ç®—æœºä¸­çš„ç¯å¢ƒæ‚¨å¯èƒ½æƒ³è¦å°†å…¶æ›´æ”¹ä¸ºæ›´åŠ é€‚åˆçš„åç«¯ã€‚è¿™ä¸€æ­¥éª¤å¯ä»¥é€šè¿‡ä¿®æ”¹ç”¨æˆ·é…ç½®æ–‡ä»¶æ¥å®Œæˆï¼Œä½äºç”¨æˆ·ä¸»ç›®å½•çš„.qiskitç›®å½•ä¸­ï¼šsettings.confï¼ˆLinux
æˆ– MacOSï¼‰æˆ–.iniï¼ˆWindowsï¼‰ã€‚

Qiskit
Textbookçš„é»˜è®¤é‡å­å›è·¯ç»˜åˆ¶å·¥å…·æ˜¯MatPlotLibã€‚ä¸ºäº†èƒ½å¤Ÿå†ç°æœ¬æ•™ç¨‹ä¸­ç»™å‡ºçš„å¯è§†åŒ–éƒ¨åˆ†ï¼Œå¯åœ¨.qiskitç›®å½•åˆ›å»ºsettings.confæ–‡ä»¶å¹¶åœ¨å…¶ä¸­æ·»åŠ ï¼š

> \[default\]
>
> circuit_drawer = mpl

#### 2. å°†é»˜è®¤å›¾ç‰‡ç±»å‹è®¾ç½®ä¸ºsvg

æ‚¨è¿˜å¯ä»¥åœ¨ipython_kernel_config.pyæ–‡ä»¶ä¸­æ·»åŠ ä»¥ä¸‹ä»£ç å°†é»˜è®¤çš„å›¾ç‰‡æ ¼å¼ä»PNGæ›´æ”¹æˆå…·æœ‰æ›´ä½³ç¼©æ”¾çš„SVGæ ¼å¼ï¼šï¼ˆipython_kernel_config.pyé€šå¸¸åœ¨ç”¨æˆ·ä¸»ç›®å½•çš„.ipython/profile_default/æ–‡ä»¶å¤¹ä¸­ï¼‰

c.InlineBackend.figure_format = \'svg\'

#### 3. åŒæ­¥TextBookä¸­ä½¿ç”¨çš„Qiskitç‰ˆæœ¬

æ‚¨å°†åœ¨æœ¬æ•™ç¨‹å¤§å¤šæ•°ç« èŠ‚çš„æœ€åæ‰¾åˆ°ä»¥ä¸‹ä»£ç ç‰‡æ®µï¼Œå…¶è¾“å‡ºåŒ…å«äº†åœ¨è¯¥ç« èŠ‚ä¸­æ‰€ä½¿ç”¨çš„Qiskitç‰ˆæœ¬ä¿¡æ¯ã€‚å¦‚æœæ‚¨è¿è¡Œè¿™ä¸€ç« èŠ‚ä¸­çš„ä»£ç æ—¶å‘ç°ä¸ä¸€è‡´çš„è¯­æ³•å’Œ/æˆ–è¾“å‡ºï¼Œè¯·å°½é‡ä½¿ç”¨ç›¸åŒçš„ç‰ˆæœ¬ã€‚

æ‚¨å¯ä»¥åœ¨Pythonç»ˆç«¯å’ŒJupyter
Notebookä¸­è¿è¡Œä¸‹é¢çš„ä»£ç æ¥æŸ¥çœ‹åœ¨æ‚¨ç”µè„‘ä¸Šæ‰€å®‰è£…Qiskitçš„ç‰ˆæœ¬ï¼š

> import qiskit
>
> qiskit.\_\_qiskit_version\_\_

Pythonå’ŒJupyter Notebooks
-------------------------

Pythonæ˜¯ä¸€ç§ä¸éœ€è¦ç¼–è¯‘çš„ç¼–ç¨‹è¯­è¨€ã€‚è¯»è€…å¯ä»¥é€è¡Œè¿è¡Œå…¶ä»£ç ï¼ˆè¿™å°±æ˜¯åœ¨Notebookä¸­ä½¿ç”¨Pythonçš„æ–¹å¼)ã€‚å› æ­¤ï¼Œå¦‚æœæ‚¨å¯¹ç¼–ç¨‹ç›¸å½“é™Œç”Ÿï¼Œé‚£ä¹ˆPythonæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„èµ·ç‚¹ã€‚æˆ‘ä»¬å°†ä½¿ç”¨å½“å‰Python
3ç‰ˆæœ¬ã€‚

ç”¨Pythonç¼–ç çš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨Jupyter
Notebookã€‚è¯¥å·¥å…·å¯èƒ½æ˜¯ç»“åˆç¼–ç¨‹ã€æ–‡æœ¬å’Œå›¾åƒçš„æœ€ä½³æ–¹æ³•ã€‚åœ¨Notebookä¸­æ‰€æœ‰å†…å®¹éƒ½æ”¾ç½®åœ¨å•å…ƒï¼ˆcellï¼‰ä¸­ï¼Œå…¶ä¸­æœ€å¸¸è§çš„æ–‡æœ¬å•å…ƒå’Œä»£ç å•å…ƒã€‚å¦‚æœæ‚¨ç”¨è£…æœ‰Jupyter
Notebookçš„ç”µè„‘æŸ¥çœ‹æœ¬èŠ‚ï¼Œåˆ™ç°åœ¨æ­£åœ¨é˜…è¯»çš„æ–‡æœ¬ä½äºæ–‡æœ¬å•å…ƒä¸­ã€‚æ‚¨å¯ä»¥åœ¨ä¸‹é¢æ‰¾åˆ°ä¸€ä¸ªä»£ç å•å…ƒã€‚

è‹¥è¦è¿è¡Œä»£ç å•å…ƒä¸­çš„å†…å®¹ï¼Œå¯ä»¥å•å‡»è¿›å…¥è¯¥å•å…ƒï¼Œç„¶åæŒ‰Shift +
Enterã€‚æˆ–è€…ï¼Œå¦‚æœå•å…ƒå·¦ä¾§æœ‰ä¸€ä¸ªå°ç®­å¤´ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥å•å‡»è¿è¡Œã€‚

> 1+1
>
> è¾“å‡ºï¼š
>
> 2

å¦‚æœæ‚¨æ˜¯åœ¨Jupyter
Notebookä¸­æŸ¥çœ‹æœ¬èŠ‚ï¼Œå°±å¯ä»¥åœ¨é˜…è¯»è¿‡ç¨‹ä¸­é€ä¸ªè¿è¡Œå…¶ä¸­çš„ä»£ç å•å…ƒã€‚

> a = 1
>
> b = 0.5
>
> a + b
>
> è¾“å‡ºï¼š
>
> 1.5

ä¸Šé¢çš„ä»£ç ä¸­åˆ›å»ºäº†ä¸¤ä¸ªå˜é‡ï¼Œåˆ†åˆ«ä¸ºaå’Œbå¹¶ä¸ºå…¶èµ‹å€¼ï¼Œç„¶åå˜é‡aä¸bç›¸åŠ ã€‚è¿™æ ·çš„ç®€å•ç®—æ³•åœ¨Pythonä¸­ç›¸å½“ç›´æˆªäº†å½“ã€‚

Pythonä¸­çš„å˜é‡æœ‰å¤šç§å½¢å¼ï¼Œä¸‹é¢æ˜¯ä¸€äº›ä¾‹å­ï¼š

> an_integer = 42 \# Just an integer
>
> a_float = 0.1 \# A non-integer number, up to a fixed precision
>
> a_boolean = True \# A value that can be True or False
>
> a_string = \'\'\'just enclose text between two \'s, or two \"s, or do
> what we did for this string\'\'\' \# Text
>
> none_of_the_above = None \# The absence of any actual value or
> variable type

é™¤äº†æ•°å­—ä¹‹å¤–ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨çš„å¦ä¸€ç§æ•°æ®ç»“æ„æ˜¯åˆ—è¡¨ï¼ˆlistï¼‰ã€‚

a_list = \[0,1,2,3\]

åœ¨Pythonä¸­ï¼Œä¸€ä¸ªåˆ—è¡¨çš„ç´¢å¼•æ˜¯ä»0å¼€å§‹ï¼ˆä¸Fortranä¹‹ç±»çš„è¯­è¨€ä¸åŒï¼‰ã€‚ä¸‹é¢çš„ä»£ç æ˜¯å¦‚ä½•è®¿é—®a_liståˆ—è¡¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

> a_list\[0\]
>
> è¾“å‡ºï¼š
>
> 0

ä¸åˆ—è¡¨ç±»ä¼¼çš„æ•°æ®ç»“æ„æ˜¯å…ƒç»„ï¼ˆtupleï¼‰ã€‚

> a_tuple = ( 42, 0.5, True, \[0,1\], None, \'Banana\' )
>
> a_tuple\[0\]
>
> è¾“å‡ºï¼š
>
> 42

åˆ—è¡¨å’Œå…ƒç»„ä¹‹é—´çš„ä¸»è¦åŒºåˆ«æ˜¯åˆ—è¡¨å¯ä»¥æ›´æ”¹å…¶ä¸­çš„å…ƒç´ ï¼Œä½†æ˜¯å…ƒç»„ä¸è¡Œã€‚

> a_list\[5\] = \'apple\'
>
> print(a_list)
>
> è¾“å‡ºï¼š
>
> \[42, 0.5, True, \[0, 1\], None, \'apple\'\]
>
> a_tuple\[5\] = \'apple\'
>
> è¾“å‡ºï¼š
>
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> TypeError Traceback (most recent call last)
>
> \<ipython-input-9-42d08f1e5606\> in \<module\>
>
> \-\-\--\> 1 a_tuple\[5\] = \'apple\'
>
> TypeError: \'tuple\' object does not support item assignment

æˆ‘ä»¬è¿˜å¯ä»¥åœ¨åˆ—è¡¨çš„æœ«å°¾æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œä½†æ˜¯å…ƒç»„åšä¸åˆ°ã€‚

> a_list.append( 3.14 )
>
> print(a_list)
>
> è¾“å‡ºï¼š
>
> \[42, 0.5, True, \[0, 1\], None, \'apple\', 3.14\]

Pythonå¦ä¸€ä¸ªæœ‰ç”¨çš„æ•°æ®ç»“æ„æ˜¯å­—å…¸ï¼ˆdictionaryï¼‰ã€‚å­—å…¸å¯ä»¥å­˜å‚¨ä¸€ç»„å€¼ï¼ˆvalueï¼‰ï¼Œå…¶ä¸­æ¯ä¸ªå€¼éƒ½ç”±ä¸€ä¸ªæƒŸä¸€çš„é”®ï¼ˆkeyï¼‰æ ‡è®°ã€‚

å­—å…¸ä¸­çš„å€¼å¯ä»¥æ˜¯ä»»ä½•æ•°æ®ç±»å‹ï¼Œé”®å¯ä»¥æ˜¯ä»»æ„è¶³å¤Ÿç®€å•çš„ä¸œè¥¿ï¼ˆæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”å€¼ã€å­—ä¸²ï¼‰ã€‚*é”®ä¸èƒ½æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œä½†å¯ä»¥æ˜¯ä¸€ä¸ªå…ƒç»„*ã€‚

> a_dict = { 1:\'This is the value, for the key 1\', \'This is the key
> for a value 1\':1, False:\':)\', (0,1):256 }

è®¿é—®å­—å…¸å€¼çš„æ–¹å¼æ˜¯ä½¿ç”¨å¯¹åº”çš„é”®ï¼š

> a_dict\[\'This is the key for a value 1\'\]
>
> è¾“å‡ºï¼š
>
> 1

åªè¦ä¸ºæ–°çš„é”®æä¾›å€¼ï¼Œå°±å¯ä»¥åœ¨å­—å…¸ä¸­æ·»åŠ æ–°çš„é”®/å€¼å¯¹ã€‚

a_dict\[\'new key\'\] = \'new_value\'

éå†ä¸€ä¸ªæ•°å­—èŒƒå›´çš„è¯­æ³•æ˜¯ï¼š

> for j in range(5):
>
> print(j)
>
> è¾“å‡º:
>
> 0
>
> 1
>
> 2
>
> 3
>
> 4

**æ³¨æ„ï¼Œrange(n)æ˜¯ä»0å¼€å§‹(é»˜è®¤)å¹¶ä»¥n-1ç»“æŸã€‚**

æ‚¨è¿˜å¯ä»¥éå†ä»»ä½•"å¯è¿­ä»£ï¼ˆiterableï¼‰"å¯¹è±¡ï¼Œæ¯”å¦‚åˆ—è¡¨ï¼š

> for j in range(5):
>
> print(j)
>
> è¾“å‡º:
>
> 0
>
> 1
>
> 2
>
> 3
>
> 4

æˆ–å­—å…¸ï¼š

> for key in a_dict:
>
> value = a_dict\[key\]
>
> print(\'key =\',key)
>
> print(\'value =\',value)
>
> print()
>
> è¾“å‡º:
>
> key = 1
>
> value = This is the value, for the key 1
>
> \...
>
> key = new key
>
> value = new_value

Pythonä¸­çš„æ¡ä»¶è¯­å¥ä½¿ç”¨ifã€elifå’Œelseå®Œæˆï¼Œä½¿ç”¨ä»¥ä¸‹è¯­æ³•ï¼š

> if \'strawberry\' in a_list:
>
> print(\'We have a strawberry!\')
>
> elif a_list\[5\]==\'apple\':
>
> print(\'We have an apple!\')
>
> else:
>
> print(\'Not much fruit here!\')
>
> è¾“å‡º:
>
> We have an apple!

å¯¼å…¥Pythonè½¯ä»¶åŒ…ç”¨ä¸€è¡Œä»£ç å°±å¯ä»¥å®Œæˆï¼š

import numpy

NumpyåŒ…æ˜¯Pythonä¸­å¾ˆé‡è¦çš„æ•°å­¦è®¡ç®—åŒ…ï¼š

numpy.sin( numpy.pi/2 )

åœ¨ä¸Šé¢çš„ä»£ç ä¸­å¿…é¡»åœ¨æ¯ä¸ªnumpyä¸­å‘½ä»¤å‰åŠ ä¸Š**numpy.**ï¼Œä»¥ä¾¿è®©PythonçŸ¥é“å¦‚ä½•æŸ¥æ‰¾åœ¨numpyä¸­å®šä¹‰çš„å‘½ä»¤ã€‚ä¸ºäº†å‡å°‘ä»£ç çš„é•¿åº¦ï¼Œé€šå¸¸å¯ä»¥ä½¿ç”¨ï¼š

> import numpy as np
>
> np.sin( np.pi/2 )
>
> è¾“å‡º:
>
> 1.0

ç°åœ¨åªé¡»ä½¿ç”¨numpyçš„ç¼©å†™ã€‚è™½ç„¶å¤§å¤šæ•°äººä½¿ç”¨npï¼Œä½†æ‚¨å¯ä»¥ä½¿ç”¨æ‚¨å–œæ¬¢çš„ç¼©å†™ã€‚

æ‚¨ä¹Ÿå¯ä»¥ç›´æ¥æŠŠnumpyä¸­çš„æ‰€æœ‰ä¸œè¥¿ç›´æ¥å¯¼å…¥Pythonçš„åç§°ç©ºé—´ï¼š

from numpy import \*

ç„¶åå°±å¯ä»¥ç›´æ¥ä½¿ç”¨numpyä¸­çš„å‘½ä»¤ã€‚ä½†è¿™æ ·æ“ä½œå¯èƒ½ä¼šå¯¼è‡´ç¨‹åºåŒ…ä¹‹é—´çš„åç§°æ··ä¹±ï¼Œå› æ­¤ä¸å»ºè®®ä½¿ç”¨ã€‚

> sin( pi/2 )
>
> è¾“å‡º:
>
> 1.0

å¦‚æœæ‚¨è®¡ç®—ä¸‰è§’å‡½æ•°ï¼Œçº¿æ€§ä»£æ•°ç­‰ï¼Œé‚£ä¹ˆä½¿ç”¨numpyå°±å¯ä»¥äº†ã€‚åœ¨Pythonä¸­ç»˜å›¾åˆ™éœ€è¦ä½¿ç”¨matplotlibã€‚å¦‚æœåœ¨Pythonçš„è®¡ç®—ä¸­æ¶‰åŠå›¾è®ºï¼ˆgraph
theoryï¼‰ï¼Œå¯ä»¥ä½¿ç”¨networkxã€‚å½“ç„¶åœ¨Pythonä¸­è¿›è¡Œé‡å­è®¡ç®—ï¼Œå°±éœ€è¦ä½¿ç”¨qiskitäº†ã€‚ä¸ç®¡æ‚¨æƒ³è¦ä»€ä¹ˆï¼Œéƒ½å¯èƒ½ä¼šæœ‰ä¸€ä¸ªé€‚åˆæ‚¨éœ€æ±‚çš„è½¯ä»¶åŒ…ã€‚

åœ¨ä»»ä½•ç¼–ç¨‹è¯­è¨€ä¸­éƒ½éœ€è¦çŸ¥é“çš„æ˜¯å¦‚ä½•æ„é€ å‡½æ•°ã€‚

ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªåç§°ä¸ºdo_some_mathçš„å‡½æ•°ï¼Œæœ‰ä¸¤ä¸ªå‚æ•°åˆ†åˆ«ä¸ºInput1å’ŒInput2ï¼Œè¯¥å‡½æ•°çš„è¾“å‡ºä¸ºthe_answerã€‚

> def do_some_maths ( Input1, Input2 ):
>
> the_answer = Input1 + Input2
>
> return the_answer

Pythonä¸­å‡½æ•°çš„è°ƒç”¨æ–¹å¼å¦‚ä¸‹ï¼š

> x = do_some_maths(1,72)
>
> print(x)
>
> è¾“å‡º:
>
> 73

å¦‚æœç»™ä¸€ä¸ªå‡½æ•°ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”è¿™ä¸ªå‡½æ•°è°ƒç”¨è¿™ä¸€å¯¹è±¡çš„ä¸€ä¸ªæ–¹æ³•æ¥æ”¹å˜å…¶çš„çŠ¶æ€ï¼Œé‚£ä¹ˆè¿™ä¸€å¯¹è±¡çŠ¶æ€çš„æ”¹å˜ä¸ä¼šéšç€å‡½æ•°è¿è¡Œçš„ç»“æŸè€Œæ¶ˆå¤±ã€‚å¦‚æœè¿™å°±æ˜¯æƒ³è¦çš„æ•ˆæœï¼Œé‚£ä¹ˆå‡½æ•°ä¸éœ€è¦è¿”å›ä»»ä½•ä¸œè¥¿ã€‚ä¾‹å¦‚ä½¿ç”¨åˆ—è¡¨çš„appendæ–¹æ³•ï¼š

> def add_sausages ( input_list ):
>
> if \'sausages\' not in input_list:
>
> input_list.append(\'sausages\')
>
> print(\'List before the function\')
>
> print(a_list)
>
> add_sausages(a_list) \# function called without an output
>
> print(\'\\nList after the function\')
>
> print(a_list)
>
> è¾“å‡ºï¼š
>
> List before the function
>
> \[42, 0.5, True, \[0, 1\], None, \'apple\', 3.14\]
>
> List after the function
>
> \[42, 0.5, True, \[0, 1\], None, \'apple\', 3.14, \'sausages\'\]

åœ¨Pythonå¯ä»¥ä½¿ç”¨randomåŒ…ç”Ÿæˆéšæœºæ•°ï¼š

> import random
>
> for j in range(5):
>
> print(\'\* Results from sample\',j+1)
>
> print(\'\\n Random number from 0 to 1:\', random.random() )
>
> print(\"\\n Random choice from our list:\", random.choice( a_list ) )
>
> print(\'\\n\')
>
> è¾“å‡ºï¼š
>
> \* Results from sample 1
>
> Random number from 0 to 1: 0.8871532828770763
>
> Random choice from our list: True
>
> ...

ä»¥ä¸Šæ˜¯Pythonä¸­æœ€åŸºæœ¬çš„è¯­æ³•ã€‚ç°åœ¨æ‚¨æ‰€ä»…éœ€çš„æ˜¯ä¸€ä¸ªæœç´¢å¼•æ“ï¼Œä»¥åŠåœ¨Stack
Exchangeä¸Šå¬å–å“ªä¸€å»ºè®®çš„ç›´è§‰ï¼Œç„¶åå°±å¯ä»¥ç”¨Pythonåšä»»ä½•äº‹æƒ…äº†ã€‚æ‚¨çš„ä»£ç å¯èƒ½ä¸æ˜¯æœ€"pythonåŒ–"çš„ï¼Œä½†åªæœ‰PythonistasçœŸæ­£å…³å¿ƒè¿™ä¸€é—®é¢˜ã€‚

0.2 Qiskit
----------

### åŸºç¡€Qiskitè¯­æ³•

#### å®‰è£…

Qiskitæ˜¯Pythonä¸­ç”¨äºé‡å­è®¡ç®—çš„è½¯ä»¶åŒ…ã€‚

å¦‚æœæ‚¨å°šæœªå®‰è£…ï¼Œåˆ™éœ€è¦å®‰è£…å®Œæˆåæ‰èƒ½åœ¨Pythonä¸­å¯¼å…¥Qiskitã€‚

å®‰è£…Qiskité€šå¸¸éœ€è¦ä¸¤ä¸ªæ­¥éª¤ã€‚ç¬¬ä¸€ä¸ªæ˜¯å®‰è£…Anacondaï¼Œå…¶ä¸­å‡ ä¹åŒ…å«äº†æ‰€æœ‰æ‚¨å°†ä¼šç”¨åˆ°çš„ç›¸å…³è½¯ä»¶åŒ…ã€‚åœ¨å®Œæˆå®‰è£…Anacondaåï¼Œå¯ä»¥åœ¨ç»ˆç«¯ä¸­é€šè¿‡è¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥å®‰è£…Qiskitï¼š

pip install qiskit \#å›½å†…ç”¨æˆ·å»ºè®®å°†pipçš„æºæ›´æ¢ä¸ºé˜¿é‡Œæˆ–æ¸…å

ç›¸å…³è¯¦ç»†çš„å®‰è£…è¯´æ˜ï¼Œè¯·å‚é˜…[Qiskitçš„å®‰è£…æ–‡æ¡£](https://qiskit.org/documentation/install.html)ã€‚

æ³¨ï¼šæœ¬èŠ‚çš„å‰©ä½™éƒ¨åˆ†æ˜¯ä¸ºå·²ç»äº†è§£é‡å­è®¡ç®—åŸºæœ¬æ¦‚å¿µçš„äººå‡†å¤‡çš„ã€‚è¯»è€…å¯ä»¥ç›´æ¥è·³åˆ°åé¢çš„ç« èŠ‚ä¸­ä½¿ç”¨è¿™äº›æ¦‚å¿µã€‚æ‰€æœ‰å…¶ä»–çš„è¯»è€…éƒ½åº”è¯¥ä»é˜…è¯»[Pythonå’ŒJupyter
notebooks](\l)å¼€å§‹ï¼Œç„¶åç›´æ¥è¿›å…¥ç¬¬ä¸€ç« çš„å¼€å¤´ã€‚

#### é‡å­å›è·¯

> from qiskit import \*
>
> \#åœ¨Jupyter Notebooksä¸­ï¼š
>
> %config InlineBackend.figure_format = \'svg\' \#
> å¯æ˜¯ä½¿æ‰€ç”Ÿæˆçš„å›¾ç‰‡çœ‹ä¸Šå»æ›´åŠ æ¸…æ™°

Qiskitçš„æ ¸å¿ƒæ˜¯**é‡å­å›è·¯**ï¼ˆ**quantum
circuitï¼Œä¹Ÿå¯å°†å…¶ç§°ä¹‹ä¸º"é‡å­çº¿è·¯"**ï¼‰ã€‚ä»¥ä¸‹æ˜¯åœ¨Pythonä¸­åˆ›å»ºä¸€ä¸ªé‡å­å›è·¯çš„å®ä¾‹------qcï¼š

qc = QuantumCircuit()

è¿™ä¸€å›è·¯ç›®å‰æ˜¯å®Œå…¨ä¸åŒ…å«ä»»ä½•ä¸œè¥¿ï¼Œæ²¡æœ‰é‡å­æ¯”ç‰¹ï¼Œä¹Ÿå°±ä¸ä¼šæœ‰è¾“å‡ºã€‚

#### é‡å­å¯„å­˜å™¨

ä¸ºäº†ä½¿åˆšæ‰ç”Ÿæˆçš„é‡å­å›è·¯å¹¶éæ¯«æ— ç”¨å¤„ï¼Œéœ€è¦å®šä¹‰ä¸€ä¸ªé‡å­æ¯”ç‰¹å¯„å­˜å™¨ï¼Œä½¿ç”¨QuantumRegisterå¯¹è±¡å®Œæˆã€‚ä¾‹å¦‚ï¼Œå®šä¹‰ä¸€ä¸ªç”±ä¸¤ä¸ªé‡å­æ¯”ç‰¹ç»„æˆçš„å¯„å­˜å™¨ï¼Œç§°ä¹‹ä¸ºqrã€‚

qr = QuantumRegister(2,\'qreg\')

ç»™qrèµ·ä¸€ä¸ªç±»ä¼¼\'qreg\'çš„åå­—æ˜¯å¯é€‰å‚æ•°ã€‚

ç°åœ¨å¯ä»¥ä½¿ç”¨add_registeræ–¹æ³•å°†qræ·»åŠ åˆ°å›è·¯ä¸­ï¼Œå¹¶é€šè¿‡æ£€æŸ¥å›è·¯å¯¹è±¡çš„qregså˜é‡æ¥æŸ¥çœ‹æ˜¯å¦å…¶å·²è¢«æ·»åŠ ã€‚åœ¨Jupter
Notebookä¸­ï¼Œæœ€åçš„ä»£ç å•å…ƒåŠå…¶è¾“å‡ºå¦‚ä¸‹ï¼š

> qc.add_register( qr )
>
> qc.qregs
>
> è¾“å‡ºï¼š
>
> \[QuantumRegister(2, \'qreg\')\]

è‡³æ­¤å›è·¯qcä¸­æœ‰äº†ä¸€äº›é‡å­æ¯”ç‰¹ï¼Œå¯ä»¥ä½¿ç”¨å›è·¯çš„å¦ä¸€ä¸ªå±æ€§draw()æ¥æŸ¥çœ‹å…¶å…·ä½“å½¢æ€ã€‚

> qc.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image25.png)

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°é‡å­æ¯”ç‰¹å·²ç»å‡†å¤‡å¥½å¼€å§‹å…¶æ—…ç¨‹äº†ï¼Œä½†ç›®å‰éƒ½åªæ˜¯å¤„äºæ€\|0âŸ©ï¼ˆå¯¹äºæ­¤å¤„ä¸ç†Ÿæ‚‰çš„å°ä¼™ä¼´å¯ä»¥é˜…è¯»ç‹„æ‹‰å…‹ç¬¦å·åŠå…¶æ„ä¹‰ï¼‰ã€‚

#### ä½¿ç”¨Gateï¼ˆé—¨ï¼‰

ä¸ºäº†å‘ç”Ÿäº›ä»€ä¹ˆäº‹æƒ…ï¼Œéœ€è¦åœ¨å›è·¯å®ä¾‹qcä¸­æ·»åŠ é‡å­é—¨ã€‚ä¾‹å¦‚ï¼Œå°è¯•h()ï¼š

> qc.h()
>
> è¾“å‡ºï¼š
>
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> TypeError Traceback (most recent call last)
>
> \<ipython-input-7-68b196ebf214\> in \<module\>
>
> \-\-\--\> 1 qc.h()
>
> /usr/local/anaconda3/lib/python3.7/site-packages/qiskit/util.py in
> wrapper(\*args, \*\*kwargs)
>
> 106 if kwargs:
>
> 107 \_rename_kwargs(func.\_\_name\_\_, kwargs, kwarg_map)
>
> \--\> 108 return func(\*args, \*\*kwargs)
>
> 109 return wrapper
>
> 110 return decorator
>
> TypeError: h() missing 1 required positional argument: \'qubit\'

è¿™é‡Œå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼Œå› ä¸ºåœ¨æ­¤æ“ä½œä¸­æ²¡æœ‰æŒ‡å®šåº”è¯¥ä½œç”¨äºå“ªä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚å¯„å­˜å™¨qrä¸­æœ‰ä¸¤ä¸ªé‡å­æ¯”ç‰¹åˆ†åˆ«ç§°ä¸ºqr\[0\]å’Œqr\[1\]ã€‚

> qc.h(qr\[0\])
>
> è¾“å‡ºï¼š
>
> \<qiskit.circuit.instructionset.InstructionSet at 0x7fe099f71110\>

è¯·å¿½ç•¥ä¸Šé¢çš„è¾“å‡ºã€‚å½“ä¸€ä¸ªå•å…ƒçš„æœ€åä¸€è¡Œæ²¡æœ‰"="æ—¶ï¼ŒJupyter
Notebookä¼šæ‰“å°å‡ºè¯¥å•å…ƒçš„å†…å®¹ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­æ‰“å°å‡ºæœ‰ä¸€ä¸ªç”±Qiskitå®šä¹‰çš„Hadamardé—¨ã€‚å¯ä»¥ä½¿ç”¨"
; "æŠ‘åˆ¶è¿™ç§è¾“å‡ºã€‚

æˆ‘ä»¬è¿˜å¯ä»¥åœ¨é‡å­å›è·¯ä¸­æ·»åŠ ä¸€ä¸ªå—æ§éé—¨ï¼ˆControlled-NOTï¼‰æ§ä»¶**cx**ï¼Œæ­¤æ“ä½œéœ€è¦ä¸¤ä¸ªå‚æ•°ï¼šæ§åˆ¶é‡å­æ¯”ç‰¹ï¼ˆcontrol
qubitï¼‰å’Œç›®æ ‡é‡å­æ¯”ç‰¹ï¼ˆtarget qubitï¼‰ã€‚

qc.cx(qr\[0\], qr\[1\]);

ç°åœ¨ï¼Œå›è·¯qcä¸­åŒ…å«äº†æ–°çš„å†…å®¹ã€‚

> qc.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image26.png)

#### æ€å‘é‡ï¼ˆstatevectorï¼‰æ¨¡æ‹Ÿå™¨

åˆ°ç°åœ¨ä¸ºæ­¢é‡å­å›è·¯qcä¸­å·²ç»åŒ…å«äº†è¶³å¤Ÿçš„å™¨ä»¶æ¥æ„æˆå›è·¯ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹å›è·¯qcçš„è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ*å…¶è¿‡ç¨‹å…·ä½“ä¸ºä½¿ç”¨"æ€å‘é‡æ¨¡æ‹Ÿå™¨"æ¥æŸ¥çœ‹ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„æ€å‘é‡å‘ç”Ÿäº†ä»€ä¹ˆå˜åŒ–*ã€‚

å‡†å¤‡æ¨¡æ‹Ÿå™¨çš„ä»£ç å¦‚ä¸‹ï¼š

vector_sim = Aer.get_backend(\'statevector_simulator\')

åœ¨Qiskitä¸­ä½¿ç”¨åç«¯ï¼ˆbackendï¼‰å¼•ç”¨é‡å­ç¨‹åºå®é™…è¿è¡Œçš„ä¸œè¥¿ï¼ˆæ¨¡æ‹Ÿå™¨æˆ–çœŸæ­£çš„é‡å­è®¾å¤‡ï¼‰ã€‚è‹¥è¦ä¸ºåç«¯è®¾ç½®ä½œä¸šï¼ˆjobï¼‰ï¼Œéœ€è¦è®¾ç½®ç›¸åº”çš„åç«¯å¯¹è±¡ã€‚

æˆ‘ä»¬æƒ³è¦çš„æ¨¡æ‹Ÿå™¨å®šä¹‰åœ¨Qiskitä¸­ç§°ä¸ºAerçš„éƒ¨åˆ†ã€‚é€šè¿‡åœ¨Aerçš„get_backend()æ–¹æ³•ä¸­ç»™å‡ºæƒ³è¦çš„æ¨¡æ‹Ÿå™¨åç§°ï¼Œå°±å¯ä»¥å¾—åˆ°ç›¸åº”çš„åç«¯å¯¹è±¡ã€‚æœ¬ä¾‹ä¸­åç«¯çš„åç§°ä¸º\'statevector_simulator\'ã€‚

å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„ä»£ç è·å–Aerä¸­æ‰€æœ‰å¯èƒ½çš„æ¨¡æ‹Ÿå™¨åˆ—è¡¨ï¼š

> Aer.backends()
>
> è¾“å‡ºï¼š
>
> \[\<QasmSimulator(\'qasm_simulator\') from AerProvider()\>,
>
> \<StatevectorSimulator(\'statevector_simulator\') from
> AerProvider()\>,
>
> \<UnitarySimulator(\'unitary_simulator\') from AerProvider()\>,
>
> \<PulseSimulator(\'pulse_simulator\') from AerProvider()\>\]

æ‰€æ˜¾ç¤ºçš„æ¨¡æ‹Ÿå™¨éƒ½æ¥è‡ª"æœ¬åœ°"ï¼Œè¡¨æ˜å…¶éƒ½å¯åœ¨é¢„è£…Qiskitçš„æœºå™¨ä¸Šè¿è¡Œã€‚æ‚¨å¯ä»¥åœ¨è‡ªå·±çš„æœºå™¨ä¸Šä½¿ç”¨è¿™äº›æ¨¡æ‹Ÿå™¨ï¼Œè€Œæ— éœ€ç­¾ç½²IBMQç”¨æˆ·åè®®ã€‚

æˆ‘ä»¬é€šè¿‡Qiskitçš„executeå‘½ä»¤è¿è¡Œè¿™äº›æ¨¡æ‹Ÿå™¨ï¼Œè¯¥å‘½ä»¤éœ€è¦çš„å‚æ•°æ˜¯ï¼š

è¦è¿è¡Œçš„å›è·¯å’Œè¿è¡Œè¯¥å›è·¯çš„"åç«¯"ï¼ˆåœ¨æœ¬ä¾‹ä¸­æ˜¯æ¨¡æ‹Ÿå™¨ï¼‰ã€‚

job = execute(qc, vector_sim)

ä¸Šé¢çš„ä»£ç åˆ›å»ºäº†ä¸€ä¸ªå¤„ç†ä½œä¸šï¼ˆjobï¼‰çš„å¯¹è±¡ï¼Œåœ¨è¿™é‡Œç§°ä¸ºä½œä¸šï¼ˆjobï¼‰ã€‚æˆ‘ä»¬åªéœ€ä»ä¸­æå–ç»“æœï¼Œå…·ä½“ä¸ºæå–æ€å‘é‡ã€‚

> ket = job.result().get_statevector()
>
> for amplitude in ket:
>
> print(amplitude)
>
> è¾“å‡ºï¼š**ï¼ˆæ¯ä¸ªç”µè„‘çš„ç»“æœä¸åŒï¼‰**
>
> (0.7071067811865476+0j)
>
> 0j
>
> 0j
>
> (0.7071067811865476+0j)

ç»“æœæ˜¯ä¸€ä¸ªè´å°”æ€ï¼ˆBell
stateï¼‰çš„å‘é‡$(|00\rangle + |11\rangle)/\sqrt{2}$ï¼Œæ­£æ˜¯æˆ‘ä»¬æƒ³è¦å›è·¯qcè¾“å‡ºçš„ç»“æœã€‚

æ˜¾ç„¶ï¼Œæˆ‘ä»¬å·²ç»è·å¾—äº†ä¸€ä¸ªå®Œæ•´å®šä¹‰çš„æ€å‘é‡ï¼Œä½†è¿˜å¯ä»¥é‡‡ç”¨Qiskitçš„å¦ä¸€ä¸ªç‰¹æ€§ï¼šç”¨ä»»æ„çº¯æ€åˆå§‹åŒ–å›è·¯ã€‚

> new_qc = QuantumCircuit(qr)
>
> new_qc.initialize(ket,qr)

#### ç»å…¸å¯„å­˜å™¨ï¼ˆClassicalRegisterï¼‰å’Œqasmæ¨¡æ‹Ÿå™¨

åœ¨ä¸Šé¢çš„ä»¿çœŸä¸­ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªæ€å‘é‡ï¼ˆstatevectorï¼‰ï¼Œä½†å¹¶éæ˜¯ä»çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸­è·å–ï¼Œä¸ºæ­¤éœ€è¦å¯¹å…¶æµ‹é‡ã€‚ä¸ºäº†å¤„ç†æµ‹é‡è¿‡ç¨‹ï¼Œéœ€è¦å®šä¹‰ç»“æœçš„èµ°å‘ã€‚è¿™ä¸€æ­¥éª¤é€šè¿‡ClassicalRegisterå®Œæˆçš„ã€‚ç°åœ¨å®šä¹‰ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªæ¯”ç‰¹ï¼ˆbitï¼‰çš„ç»å…¸å¯„å­˜å™¨ï¼Œç”¨ä»¥æµ‹é‡çš„ä¹‹å‰æ‰€ç”Ÿæˆçš„ä¸¤ä¸ªé‡å­æ¯”ç‰¹ï¼ˆqubitï¼‰ã€‚

> cr = ClassicalRegister(2,\'creg\')
>
> qc.add_register(cr)

ç°åœ¨å¯ä»¥ä½¿ç”¨é‡å­å›è·¯çš„æµ‹é‡æ–¹æ³•äº†ï¼Œè¯¥æ–¹æ³•éœ€è¦ä¸¤ä¸ªå‚æ•°ï¼šæ­£åœ¨æµ‹é‡çš„é‡å­æ¯”ç‰¹ï¼Œä»¥åŠå†™å…¥ç»“æœçš„ä½ã€‚

> qc.measure(qr\[0\],cr\[0\])
>
> qc.measure(qr\[1\],cr\[1\])
>
> qc.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š
>
> ![](pics/media/image27.png)

æˆ‘ä»¬å¯ä»¥æµ‹é‡ä¸¤ä¸ªé‡å­æ¯”ç‰¹ï¼Œå¹¶æŠŠç»“æœå†™å…¥åˆ°ç»å…¸å¯„å­˜å™¨çš„ä¸åŒä½ä¸­ã€‚

ç°åœ¨å¯ä»¥åœ¨æœ¬åœ°æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡Œqcäº†ï¼Œå…¶æ•ˆæœæ˜¯æ¨¡æ‹ŸçœŸå®çš„é‡å­è®¾å¤‡ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å‘æ‰§è¡Œå‡½æ•°shotsæ·»åŠ å¦ä¸€ä¸ªè¾“å…¥ï¼Œè¯¥è¾“å…¥å†³å®šäº†è¿è¡Œå›è·¯è¿›è¡Œç»Ÿè®¡çš„æ¬¡æ•°ã€‚å¦‚æœä¸æä¾›ä»»ä½•shotså€¼ï¼Œåˆ™é»˜è®¤ä¸º1024ã€‚

> emulator = Aer.get_backend(\'qasm_simulator\')
>
> job = execute( qc, emulator, shots=8192 )

ä¸Šé¢ä»£ç çš„ç»“æœæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªPythonå­—å…¸å½¢å¼çš„ç›´æ–¹å›¾ï¼Œå¯ä»¥æ‰“å°å‡ºè¯¥ç»“æœã€‚

> hist = job.result().get_counts()
>
> print(hist)
>
> è¾“å‡ºï¼šï¼ˆç»“æœæ¯å°ç”µè„‘ä¸ä¸€æ ·ï¼‰
>
> {\'00\': 4029, \'11\': 4163}

å¯ä»¥è®©QiskitæŠŠä¸Šé¢çš„è¾“å‡ºç”»æˆæŸ±çŠ¶å›¾ã€‚

> from qiskit.visualization import plot_histogram
>
> plot_histogram(hist)
>
> è¾“å‡ºï¼š

![](pics/media/image28.png)

å¯¹äºå…¼å®¹çš„åç«¯ï¼Œè¿˜å¯ä»¥è¯·æ±‚å¹¶è·å¾—ç»“æœçš„æœ‰åºåˆ—è¡¨ã€‚

> job = execute(qc, emulator, shots=10, memory=True)
>
> samples = job.result().get_memory()
>
> print(samples)
>
> è¾“å‡ºï¼š
>
> \[\'11\', \'11\', \'00\', \'00\', \'00\', \'00\', \'11\', \'11\',
> \'11\', \'00\'\]

æ³¨æ„ä½ï¼ˆbitï¼‰è¢«æ ‡è®°ä¸ºè‡ªå³åˆ°å·¦ï¼Œcr\[0\]æ˜¯æœ€å³è¾¹çš„ï¼Œå…¶ä½™ä»¥æ­¤ç±»æ¨ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œè¿™æ˜¯ä¸€ä¸ª8é‡å­æ¯”ç‰¹å›è·¯ï¼Œå…¶ä¸­**Pauli
X**ï¼ˆæ³¡åˆ©-X é—¨ï¼‰åªåœ¨ç¼–å·7çš„é‡å­æ¯”ç‰¹ä¸Šï¼Œé‚£ä¹ˆå…¶è¾“å‡ºå­˜å‚¨åœ¨ç¼–å·7çš„ä½ä¸Šã€‚

> qubit = QuantumRegister(8)
>
> bit = ClassicalRegister(8)
>
> circuit = QuantumCircuit(qubit,bit)
>
> circuit.x(qubit\[7\])
>
> circuit.measure(qubit,bit)
> \#æ­¤ä¸ºä¸€æ¬¡æ€§å®Œæˆæ‰€æœ‰qc.measure(qr8\[j\],cr8\[j\])çš„æ–¹æ³•
>
> execute(circuit, emulator, shots=8192).result().get_counts()
>
> è¾“å‡ºï¼š
>
> {\'10000000\': 8192}

å¯ä»¥çœ‹åˆ°å‡ºç°åœ¨è¾“å‡ºæœ€å·¦ä¾§çš„æ˜¯1ã€‚

è¿™ç§ç¼–å·æ–¹å¼åæ˜ äº†ä½ï¼ˆbitï¼‰è¡¨ç¤ºæ•´æ•°æ—¶çš„ä½œç”¨ã€‚

$$b_{n - 1}b_{n - 2}\cdots b_{1}b_{0} = \sum_{j}^{}{b_{j}2^{j}}$$

æ‰€ä»¥æˆ‘ä»¬åœ¨ç»“æœä¸­å¾—åˆ°çš„å­—ä¸²æ˜¯äºŒè¿›åˆ¶çš„$2^{7}$ï¼Œå› ä¸ºè¾“å‡ºç»“æœä¸­çš„ç¬¬7ä½ï¼ˆä»0å¼€å§‹ï¼‰æ˜¯1ã€‚

#### ç®€åŒ–ç¬¦å·

å¯ä»¥å°†å¤šä¸ªé‡å­å¯„å­˜å™¨å’Œç»å…¸å¯„å­˜å™¨æ·»åŠ åˆ°ä¸€ä¸ªå›è·¯ä¸­ã€‚ç„¶è€Œï¼Œå¦‚æœåªéœ€è¦å…¶ä¸­çš„ä¸€ä¸ªï¼Œå¯ä»¥ä½¿ç”¨ç®€åŒ–ç¬¦å·ã€‚

ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹å†…å®¹ã€‚

qc = QuantumCircuit(3)

ä¸Šé¢ä»£ç ä¸­QuantumCircuit()çš„å”¯ä¸€å‚æ•°è¢«è§£é‡Šä¸ºéœ€è¦çš„é‡å­æ¯”ç‰¹æ•°é‡ã€‚è¿™ä¸€å›è·¯åªæœ‰ä¸€ä¸ªç”±ä¸‰ä¸ªé‡å­æ¯”ç‰¹ç»„æˆçš„é‡å­å¯„å­˜å™¨ï¼Œæ²¡æœ‰ç»å…¸å¯„å­˜å™¨ã€‚

åœ¨æ·»åŠ é—¨å›è·¯æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°é€šè¿‡å…¶çš„ç´¢å¼•å¼•ç”¨è¿™ä¸‰ä¸ªé‡å­æ¯”ç‰¹ï¼š0ã€1æˆ–2ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç ä¸­å®šä¹‰äº†ä¸€ä¸ªé‡å­æ¯”ç‰¹1å¤„çš„å“ˆè¾¾ç›é—¨ã€‚

> qc.h(1)
>
> qc.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image29.png)

ä¸ºäº†å®šä¹‰åŒæ—¶å…·æœ‰é‡å­å¯„å­˜å™¨å’Œç»å…¸å¯„å­˜å™¨çš„å›è·¯ï¼Œå¯ä»¥å‘QuantumCircuitæä¾›ä¸¤ä¸ªå‚æ•°ã€‚ç¬¬ä¸€ä¸ªå°†è¢«è§£é‡Šä¸ºé‡å­æ¯”ç‰¹çš„æ•°é‡ï¼Œç¬¬äºŒä¸ªæ˜¯ä½çš„æ•°é‡ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„å›è·¯ï¼Œåªå–ä¸€ä¸ªä½çš„è¾“å‡ºã€‚

ä¸ºäº†è§‚å¯Ÿå…¶çš„è¿è¡Œï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å›è·¯ã€‚æ³¨æ„ï¼åœ¨è¿›è¡Œæµ‹é‡æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿé€šè¿‡ç´¢å¼•å¼•ç”¨ç»å…¸å¯„å­˜å™¨ä¸­çš„ä½ã€‚

#### åˆ›å»ºè‡ªå®šä¹‰é—¨

qc = QuantumCircuit(2,1)

> qc.h(0)
>
> qc.cx(0,1)
>
> qc.measure(1,0)
>
> qc.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image30.png)

æ­£å¦‚æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ï¼Œå…·æœ‰æŠŠä¸åŒçš„å›è·¯ç»„åˆæˆæ›´å¤§çš„å›è·¯çš„å¯èƒ½æ€§ã€‚è¿˜å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„ç‰ˆæœ¬æ¥å®šåˆ¶é—¨ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢æœ‰ä¸€ä¸ªå›è·¯ä¸­å®ç°äº†é‡å­æ¯”ç‰¹0å’Œ2ä¹‹é—´çš„cxï¼ˆå—æ§éé—¨ï¼‰ï¼Œä½¿ç”¨é‡å­æ¯”ç‰¹1æ¥åè°ƒè¿™ä¸ªè¿‡ç¨‹ã€‚

> sub_circuit = QuantumCircuit(3, name=\'toggle_cx\')
>
> sub_circuit.cx(0,1)
>
> sub_circuit.cx(1,2)
>
> sub_circuit.cx(0,1)
>
> sub_circuit.cx(1,2)
>
> sub_circuit.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image31.png)

ç°åœ¨æŠŠsub_circuitå˜æˆé—¨å›è·¯ï¼š

toggle_cx = sub_circuit.to_instruction()

ç„¶åç”¨æˆ‘ä»¬é€‰æ‹©å…¶ä»–å›è·¯ä¸­çš„ä»»æ„ä¸€ç»„é‡å­æ¯”ç‰¹æ’å…¥toggle_cxï¼š

> qr = QuantumRegister(4)
>
> new_qc = QuantumCircuit(qr)
>
> new_qc.append(toggle_cx, \[qr\[1\],qr\[2\],qr\[3\]\])
>
> new_qc.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image32.png)

#### è®¿é—®çœŸæ­£çš„é‡å­ç¡¬ä»¶ï¼ˆæœªæ³¨å†Œï¼Œåªæ˜¾ç¤ºä»£ç ä¸æ˜¾ç¤ºè¾“å‡ºï¼‰

æ‚¨è¿˜å¯ä»¥ä½¿ç”¨IBMQåŒ…è®¾ç½®åç«¯å¯¹è±¡ã€‚è¿™äº›åº”ç”¨è¦æ±‚åˆ›å»ºä¸€ä¸ªIBMQå¸æˆ·ã€‚å‡è®¾è®¿é—®å‡­è¯å·²ç»åŠ è½½åˆ°æ‚¨çš„è®¡ç®—æœºä¸Šï¼š

> IBMQ.load_account()
>
> è¾“å‡ºï¼š
>
> \<AccountProvider for IBMQ(hub=\'ibm-q\', group=\'open\',
> project=\'main\')\>

è®©æˆ‘ä»¬çœ‹çœ‹æœ‰å“ªäº›å¯ç”¨çš„åç«¯ï¼š

> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> provider.backends()
>
> è¾“å‡ºï¼š
>
> \[\<IBMQSimulator(\'ibmq_qasm_simulator\') from IBMQ(hub=\'ibm-q\',
> group=\'open\', project=\'main\')\>,
>
> \<IBMQBackend(\'ibmqx2\') from IBMQ(hub=\'ibm-q\', group=\'open\',
> project=\'main\')\>,
>
> \<IBMQBackend(\'ibmq_16_melbourne\') from IBMQ(hub=\'ibm-q\',
> group=\'open\', project=\'main\')\>,
>
> \<IBMQBackend(\'ibmq_vigo\') from IBMQ(hub=\'ibm-q\', group=\'open\',
> project=\'main\')\>,
>
> \<IBMQBackend(\'ibmq_ourense\') from IBMQ(hub=\'ibm-q\',
> group=\'open\', project=\'main\')\>,
>
> \<IBMQBackend(\'ibmq_london\') from IBMQ(hub=\'ibm-q\',
> group=\'open\', project=\'main\')\>,
>
> \<IBMQBackend(\'ibmq_burlington\') from IBMQ(hub=\'ibm-q\',
> group=\'open\', project=\'main\')\>,
>
> \<IBMQBackend(\'ibmq_essex\') from IBMQ(hub=\'ibm-q\', group=\'open\',
> project=\'main\')\>,
>
> \<IBMQBackend(\'ibmq_armonk\') from IBMQ(hub=\'ibm-q\',
> group=\'open\', project=\'main\')\>\]

åœ¨è¾“å‡ºä¸­æœ‰ä¸€ä¸ªæ¨¡æ‹Ÿå™¨ï¼Œä½†å…¶ä½™éƒ½æ˜¯åŸå‹é‡å­è®¾å¤‡ã€‚è¿˜å¯ä»¥é€šè¿‡status()æ–¹æ³•æŸ¥çœ‹å…¶ä½¿ç”¨æ–¹æ³•ã€‚

> for backend in provider.backends():
>
> print(backend.status())
>
> è¾“å‡ºï¼š
>
> BackendStatus(backend_name=\'ibmq_qasm_simulator\',
> backend_version=\'0.1.547\', operational=True, pending_jobs=4,
> status_msg=\'active\')
>
> BackendStatus(backend_name=\'ibmqx2\', backend_version=\'2.0.5\',
> operational=True, pending_jobs=10, status_msg=\'active\')
>
> BackendStatus(backend_name=\'ibmq_16_melbourne\',
> backend_version=\'2.0.6\', operational=True, pending_jobs=15,
> status_msg=\'active\')
>
> BackendStatus(backend_name=\'ibmq_vigo\', backend_version=\'1.0.2\',
> operational=True, pending_jobs=5, status_msg=\'active\')
>
> BackendStatus(backend_name=\'ibmq_ourense\',
> backend_version=\'1.0.1\', operational=True, pending_jobs=5,
> status_msg=\'active\')
>
> BackendStatus(backend_name=\'ibmq_london\', backend_version=\'1.1.0\',
> operational=True, pending_jobs=6, status_msg=\'active\')
>
> BackendStatus(backend_name=\'ibmq_burlington\',
> backend_version=\'1.1.4\', operational=True, pending_jobs=3,
> status_msg=\'active\')
>
> BackendStatus(backend_name=\'ibmq_essex\', backend_version=\'1.0.1\',
> operational=True, pending_jobs=1, status_msg=\'active\')
>
> BackendStatus(backend_name=\'ibmq_armonk\', backend_version=\'1.1.0\',
> operational=True, pending_jobs=33, status_msg=\'active\')

ç°åœ¨è·å–æœ€å¤§å…¬å…±è®¾å¤‡çš„åç«¯å¯¹è±¡ã€‚

real_device = provider.get_backend(\'ibmq_16_melbourne\')

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨real_deviceåœ¨è®¾å¤‡ä¸Šä»¥ä¸æ¨¡æ‹Ÿå™¨å®Œå…¨ç›¸åŒçš„æ–¹å¼è¿è¡Œä½œä¸šï¼ˆjobï¼‰ï¼Œä¹Ÿå¯ä»¥æå–å…¶å±æ€§ã€‚

> properties = real_device.properties()
>
> coupling_map = real_device.configuration().coupling_map

ç”±æ­¤æˆ‘ä»¬å¯ä»¥æ„å»ºä¸€ä¸ªå™ªå£°æ¨¡å‹æ¥æ¨¡æ‹Ÿè®¾å¤‡ä¸Šçš„å™ªå£°ï¼ˆå°†åœ¨ç¨åçš„æ•™ç¨‹ä¸­è¿›ä¸€æ­¥è®¨è®ºå™ªå£°æ¨¡å‹ï¼‰ã€‚

> from qiskit.providers.aer.noise import NoiseModel
>
> noise_model = NoiseModel.from_backend(properties)

ç„¶ååœ¨æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡Œä½œä¸šï¼Œå†ç°çœŸå®è®¾å¤‡çš„æ‰€æœ‰è¿™äº›ç‰¹æ€§ã€‚ä»¥ä¸‹æ˜¯å›è·¯åœ¨æ— å™ªå£°çš„æƒ…å†µä¸‹åº”è¯¥è¾“å‡º\'10\'çš„ä¾‹å­ã€‚

> qc = QuantumCircuit(2,2)
>
> qc.x(1)
>
> qc.measure(0,0)
>
> qc.measure(1,1)
>
> job = execute(qc, emulator, shots=1024, noise_model=noise_model,
>
> coupling_map=coupling_map,
>
> basis_gates=noise_model.basis_gates)
>
> job.result().get_counts()
>
> è¾“å‡ºï¼š
>
> {\'10\': 966, \'11\': 6, \'00\': 52}

è‡³æ­¤æœ¬èŠ‚ä¸­å·²ç»æ¶µç›–äº†Qiskitä¸­çš„æœ€åŸºæœ¬å†…å®¹ï¼Œæ¥ä¸‹æ¥å°†è¦å­¦ä¹ æ›´å¤šé‡å­æ¯”ç‰¹å’Œé‡å­å›è·¯çš„çŸ¥è¯†ã€‚

> import qiskit
>
> qiskit.\_\_qiskit_version\_\_
>
> è¾“å‡ºï¼š
>
> {\'qiskit-terra\': \'0.12.0\',
>
> \'qiskit-aer\': \'0.4.1\',
>
> \'qiskit-ignis\': \'0.2.0\',
>
> \'qiskit-ibmq-provider\': \'0.6.0\',
>
> \'qiskit-aqua\': \'0.6.5\',
>
> \'qiskit\': \'0.17.0\'}

0.3 çº¿æ€§ä»£æ•°
------------

> from matplotlib import pyplot as plt
>
> import numpy as np
>
> from qiskit import \*
>
> from qiskit.visualization import plot_bloch_vector

### ç®€ä»‹

çº¿æ€§ä»£æ•°æ˜¯é‡å­è®¡ç®—çš„è¯­è¨€ã€‚å› æ­¤ç†è§£çº¿æ€§ä»£æ•°æ‰€å»ºç«‹çš„åŸºæœ¬æ•°å­¦æ¦‚å¿µè‡³å…³é‡è¦ï¼Œå¦‚æ­¤æ‰èƒ½ç†è§£é‡å­è®¡ç®—ä¸­å‡ºç°çš„è®¸å¤šæƒŠäººè€Œæœ‰è¶£çš„ç»“æ„ã€‚æœ¬èŠ‚çš„ç›®æ ‡æ˜¯åœ¨æ‚¨çš„å¤§è„‘ä¸­å»ºç«‹åŸºç¡€çš„çº¿æ€§ä»£æ•°çŸ¥è¯†ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šè¯»è€…å¯ä»¥æ„å»ºè‡ªèº«ç ”ç©¶é‡å­è®¡ç®—çš„ç ”ç©¶ã€‚

### å‘é‡å’Œå‘é‡ç©ºé—´

æˆ‘ä»¬å°†é¦–å…ˆè®¨è®ºé‡å­è®¡ç®—ä¸­æœ€é‡è¦çš„æ•°å­¦é‡ä¹‹ä¸€ï¼šå‘é‡ï¼Œå¹¶ä»¥æ­¤å¼€å§‹å¯¹çº¿æ€§ä»£æ•°çš„ä»‹ç»ã€‚

åœ¨å½¢å¼ä¸Š,ä¸€ä¸ªå‘é‡\|vâŸ©è¢«å®šä¹‰ä¸ºä¸€ç»„ç§°ä¸ºå‘é‡ç©ºé—´çš„å…ƒç´ ã€‚æ›´ç›´è§‚ã€æ›´å‡ ä½•çš„å®šä¹‰æ˜¯ï¼šå‘é‡"æ˜¯ä¸€ä¸ªåŒæ—¶å…·æœ‰æ–¹å‘å’Œå¤§å°çš„æ•°å­¦é‡"ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ªå…·æœ‰xå’Œyåˆ†é‡çš„å‘é‡$\left( \frac{3}{5} \right)$ã€‚è¿™ä¸ªå‘é‡å¯ä»¥è¢«æƒ³è±¡æˆä¸€ä¸ªç®­å¤´ï¼ŒæŒ‡å‘xè½´æ­£3ä¸ªå•ä½ï¼ŒæŒ‡å‘yè½´æ­£5ä¸ªå•ä½ï¼š

> plt.figure()
>
> ax = plt.gca()
>
> ax.quiver(\[3\], \[5\], angles=\'xy\', scale_units=\'xy\', scale=1)
>
> ax.set_xlim(\[-1, 10\])
>
> ax.set_ylim(\[-1, 10\])
>
> plt.draw()
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image33.png)

æ³¨æ„ï¼Œå‘é‡çš„"å°¾å·´"ä¸ä¸€å®šè¦å®šä½åœ¨åæ ‡çš„åŸç‚¹ï¼›åªéœ€è¦æŒ‡å‡ºæ­£ç¡®çš„æ–¹å‘ã€‚

åœ¨é‡å­è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸å¤„ç†æ€å‘é‡ï¼Œè¿™äº›å‘é‡æŒ‡å‘ç©ºé—´ä¸­ä¸ç‰¹å®šé‡å­æ€ç›¸å¯¹åº”çš„ç‰¹å®šç‚¹ã€‚å¯ä»¥ç”¨å¸ƒæ´›èµ«çƒï¼ˆBloch
Sphereï¼‰æ¥è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªè¡¨ç¤ºé‡å­ç³»ç»ŸçŠ¶æ€çš„å‘é‡å¯ä»¥åƒä¸€ä¸ªç®­å¤´ä¸€æ ·è¢«åŒ…è£¹åœ¨å¸ƒæ´›èµ«çƒä¸­ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„"æ€ç©ºé—´ï¼ˆstate
spaceï¼‰"ï¼Œæ‰€æœ‰å¯èƒ½çš„ç‚¹éƒ½å¯ä»¥è¢«æ€å‘é‡"æŒ‡å‘"ï¼š

> plot_bloch_vector(\[1, 0, 0\])
>
> è¾“å‡ºï¼š

![](pics/media/image34.png)

> **æ³¨è§£**
>
> **å¸ƒæ´›èµ«çƒ(Bloch
> Sphere)æ˜¯ä¸€ä¸ªå¯ä»¥å°†qubitçš„çŠ¶æ€(çº¯æ€æˆ–æ··åˆæ€)ç›´è§‚åŒ–çš„å·§å¦™å·¥å…·ã€‚**

![å¸ƒæ´›èµ«çƒ(Bloch
Sphere)](pics/media/image35.jpeg)

å‘é‡\|0âŸ©å’Œ\|1âŸ©ä¹‹é—´çš„ç‰¹å®šçŠ¶æ€å¯¹åº”äºä¸€ä¸ªå‡è¡¡çš„å åŠ æ€ï¼ˆç®­å¤´æ˜¯ä»‹äºçƒä½“çš„é¡¶éƒ¨\|0âŸ©å’Œåº•éƒ¨\|1âŸ©ä¹‹é—´ï¼‰ã€‚å‘é‡å¯ä»¥åœ¨çƒé¢ä¸Šä»»æ„æ—‹è½¬ï¼Œçƒé¢ä¸Šçš„æ¯ä¸ªç‚¹éƒ½ä»£è¡¨ä¸åŒçš„é‡å­æ€ã€‚

æˆ‘ä»¬å…ˆå›é¡¾ä¸€ä¸‹å‘é‡æ›´åŠ æ­£å¼çš„å®šä¹‰ï¼Œå³å‘é‡æ˜¯å‘é‡ç©ºé—´çš„ä¸€ä¸ªå…ƒç´ ã€‚ç°åœ¨å¿…é¡»å®šä¹‰ä¸€ä¸ªå‘é‡ç©ºé—´ã€‚å‘é‡ç©ºé—´**V**æ˜¯æ•°åŸŸ**F**ï¼ˆ**field
F**ï¼‰ä¹‹ä¸Šçš„ä¸€ç»„å¯¹è±¡ï¼ˆåŒ…æ‹¬ï¼šå‘é‡å’Œç‚¹ï¼‰ï¼Œæ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ã€‚ç¬¬ä¸€ï¼Œä¸¤ä¸ªå‘é‡\|aâŸ©å’Œ\|bâŸ©çš„å‘é‡åŠ æ³•ï¼ˆ**vector
addition**ï¼‰çš„ç»“æœä»ç„¶åœ¨**V**ä¹‹å†…ã€‚ç¬¬äºŒï¼Œå¯¹äº\|aâŸ© âˆˆ Vä¸æŸä¸€n âˆˆ
Fçš„æ ‡é‡ä¹˜æ³•ï¼ˆ**scalar multiplication**ï¼‰çš„ç»“æœä»ç„¶åœ¨**V**ä¹‹å†…ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬å°†é€šè¿‡ä¸€ä¸ªåŸºæœ¬ç¤ºä¾‹æ¥é˜æ˜åˆšæ‰çš„å®šä¹‰ã€‚è®©æˆ‘ä»¬è¯æ˜é›†R^2^æ˜¯æ•°åŸŸRä¸Šçš„å‘é‡ç©ºé—´ï¼Œæˆ‘ä»¬æ–­è¨€ï¼š

$$\left( \frac{x_{1}}{y_{1}} \right) + \left( \frac{x_{2}}{y_{2}} \right) = \left( \frac{x_{1} + x_{2}}{y_{1} + y_{2}} \right)$$

ä¸Šè¿°å…¬å¼åŒ…å«äºR^2^ã€‚æƒ…å†µæ˜¾ç„¶å¦‚æ­¤ï¼Œä¸¤ä¸ªå®æ•°çš„å’Œä»ç„¶æ˜¯å®æ•°ï¼Œä½¿å¾—æ–°å½¢æˆå‘é‡çš„ä¸¤ä¸ªåˆ†é‡éƒ½æ˜¯å®æ•°ï¼Œç”±æ­¤åŒ…å«äºR^2^ä¸­çš„å‘é‡è¢«å®šä¹‰ã€‚æˆ‘ä»¬è¿˜å¯ä»¥æ–­è¨€ï¼š

$$n\left| v \right\rangle = \left( \frac{\text{nx}}{\text{ny}} \right) \in \text{V\ \ \ }\forall n \in R$$

è¿™ä¹Ÿæˆç«‹ï¼Œå› ä¸ºå®æ•°å’Œå®æ•°çš„ä¹˜ç§¯æ˜¯å®æ•°ï¼Œä½¿å¾—æ•´ä¸ªæ–°çš„å‘é‡æ˜¯å®æ•°ï¼Œä»è€Œè¯æ˜äº†è¿™ä¸ªè¡¨è¿°ã€‚

#### çŸ©é˜µä¸çŸ©é˜µè¿ç®—

ç°åœ¨æˆ‘ä»¬å°†æ³¨æ„åŠ›è½¬å‘å¦ä¸€ä¸ªåŸºç¡€æ¦‚å¿µï¼šçŸ©é˜µã€‚çŸ©é˜µæ˜¯æŠŠä¸€ä¸ªå‘é‡è½¬æ¢ä¸ºå¦ä¸€ä¸ªå‘é‡çš„æ•°å­¦å¯¹è±¡ã€‚

\|ğ‘£âŸ© â†’ \|ğ‘£â€²âŸ© = ğ‘€\|ğ‘£âŸ©

çŸ©é˜µé€šå¸¸å†™ä¸ºæ•°ç»„å½¢å¼çš„æ•°å­—ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

$$M = \left\lbrack \begin{matrix}
1 \\
1 \\
1 + i \\
\end{matrix}\begin{matrix}
 - 2 \\
5i \\
7 \\
\end{matrix}\begin{matrix}
3 \\
0 \\
 - 4 \\
\end{matrix} \right\rbrack$$

æˆ‘ä»¬å¯ä»¥æ‰§è¡ŒçŸ©é˜µä¹˜æ³•å°†ä¸€ä¸ªçŸ©é˜µä¹˜ä»¥ä¸€ä¸ªå‘é‡ã€‚é€šå¸¸ï¼Œä¸¤ä¸ªçŸ©é˜µä¹‹é—´çš„çŸ©é˜µä¹˜æ³•æ¶‰åŠå°†ç¬¬ä¸€ä¸ªçŸ©é˜µä¸­æ¯ä¸€è¡Œçš„å…ƒç´ ä¹˜ä»¥ç¬¬äºŒä¸ªçŸ©é˜µä¸­æ¯ä¸€åˆ—çš„æ¯ä¸€ä¸ªå…ƒç´ ç„¶åå°†ä¹˜ç§¯ç›¸åŠ ï¼Œè¯¥ä¹˜ç§¯æˆä¸ºæ–°çŸ©é˜µä¸­å¯¹åº”è¡Œåˆ—ä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œä»¥æ­¤ç±»æ¨ã€‚ä»¥ä¸‹æ˜¯çŸ©é˜µä¹˜æ³•ï¼ˆå‰ç§¯ï¼‰çš„ä¸€ä¸ªç¤ºä¾‹ï¼š

$$\left( \begin{matrix}
2 \\
5 \\
\end{matrix}\begin{matrix}
\ 0 \\
\  - 1 \\
\end{matrix} \right)\left( \begin{matrix}
 - 3\  \\
2 \\
\end{matrix}\begin{matrix}
1 \\
\ 1 \\
\end{matrix} \right) = \left( \begin{matrix}
\left( 2 \right)\left( - 3 \right) + \left( 0 \right)\left( 2 \right) \\
\left( 5 \right)\left( - 3 \right) + \left( - 1 \right)\left( 2 \right) \\
\end{matrix}\ \begin{matrix}
\left( 2 \right)\left( 1 \right) + \left( 0 \right)\left( 1 \right) \\
\left( 5 \right)\left( 1 \right) + \left( - 1 \right)\left( 1 \right) \\
\end{matrix} \right) = \left( \begin{matrix}
 - 6\  \\
 - 17 \\
\end{matrix}\begin{matrix}
2 \\
\ 4 \\
\end{matrix} \right)$$

ä¸ºäº†è¿›è¡Œé‡å­è®¡ç®—ï¼Œé€šè¿‡å¯¹é‡å­æ€å‘é‡åº”ç”¨ä¸€ä¸ªçŸ©é˜µæ¥å¯¹å…¶æ“ä½œã€‚ä¸€ä¸ªå‘é‡å°±æ˜¯ä¸€ä¸ªåªæœ‰ä¸€åˆ—çš„çŸ©é˜µã€‚å› æ­¤è¦å°†ä¸€ä¸ªçŸ©é˜µåº”ç”¨äºä¸€ä¸ªå‘é‡ï¼Œéœ€è¦éµå¾ªä¸Šé¢æè¿°çš„ç›¸åŒçŸ©é˜µä¹˜æ³•è¿‡ç¨‹ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åº”ç”¨ä¸€ç³»åˆ—çš„é‡å­é—¨ï¼ˆ**quantum
gates**ï¼‰åœ¨é‡å­ç”µè„‘ä¸Šæ“çºµé‡å­æ¯”ç‰¹ã€‚æ¯ä¸ªé‡å­é—¨éƒ½è¢«è¡¨ç¤ºä¸ºå¯åº”ç”¨äºæ€å‘é‡çš„çŸ©é˜µï¼Œä»è€Œæ”¹å˜æ€å‘é‡çš„çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œç»å¸¸å¯è§çš„é‡å­é—¨æ˜¯Pauli-Xé—¨ï¼Œç”¨çŸ©é˜µçš„æ–¹å¼å¦‚ä¸‹ï¼š

$$\sigma_{x} = \left( \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right)$$

è¿™ä¸€é‡å­é—¨çš„è¡Œä¸ºä¸ç»å…¸çš„éé€»è¾‘é—¨ç›¸ä¼¼ã€‚å…¶å°†è®¡ç®—é‡çš„åŸºæ€\|0âŸ©å’Œ\|1âŸ©åˆ†åˆ«æ˜ å°„ä¸º\|1âŸ©å’Œ\|0âŸ©ï¼ˆå°†çŠ¶æ€åè½¬äº†ï¼‰ã€‚æˆ‘ä»¬å°†è¿™ä¸¤ä¸ªåŸºæ€è¡¨è¿°ä¸ºä¸¤ä¸ªåˆ—å‘é‡ï¼š

$$\left| 0 \right\rangle = \begin{pmatrix}
1 \\
0 \\
\end{pmatrix}\text{\ \ }\left| 1 \right\rangle = \begin{pmatrix}
0 \\
1 \\
\end{pmatrix}$$

ç„¶åå°†Pauli-Xé—¨çš„çŸ©é˜µåˆ†åˆ«åº”ç”¨äºè¿™ä¸¤ä¸ªåŸºæ€ï¼š

$$\sigma_{x}\left| 0 \right\rangle = \left( \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right)\begin{pmatrix}
1 \\
0 \\
\end{pmatrix} = \begin{pmatrix}
\left( 0 \right)\left( 1 \right) + \left( 1 \right)\left( 0 \right) \\
\left( 1 \right)\left( 1 \right) + \left( 0 \right)\left( 0 \right) \\
\end{pmatrix} = \begin{pmatrix}
0 \\
1 \\
\end{pmatrix} = \left| 1 \right\rangle$$

$$\sigma_{x}\left| 1 \right\rangle = \left( \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right)\begin{pmatrix}
0 \\
1 \\
\end{pmatrix} = \begin{pmatrix}
\left( 0 \right)\left( 0 \right) + \left( 1 \right)\left( 1 \right) \\
\left( 1 \right)\left( 0 \right) + \left( 0 \right)\left( 1 \right) \\
\end{pmatrix} = \begin{pmatrix}
1 \\
0 \\
\end{pmatrix} = \left| 0 \right\rangle$$

æ€å‘é‡çŸ©é˜µè®¡ç®—çš„ç»“æœä¸æˆ‘ä»¬çš„é¢„æœŸä¸€è‡´ã€‚

åœ¨é‡å­è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸é‡åˆ°ä¸¤ä¸ªéå¸¸é‡è¦çš„çŸ©é˜µï¼šå„ç±³çŸ©é˜µï¼ˆ**Hermitian**ï¼‰å’Œå¹ºæ­£çŸ©é˜µï¼ˆ**Unitary**ï¼‰ã€‚å‰è€…åœ¨é‡å­åŠ›å­¦çš„ç ”ç©¶ä¸­æ›´ä¸ºé‡è¦ï¼Œä½†åœ¨é‡å­è®¡ç®—çš„ç ”ç©¶ä¸­ä»æœ‰å¿…è¦åŠ ä»¥è®¨è®ºã€‚åè€…åœ¨é‡å­åŠ›å­¦å’Œé‡å­è®¡ç®—ä¸­éƒ½å…·æœ‰æ— ä¸ä¼¦æ¯”çš„é‡è¦æ€§ã€‚å¦‚æœæ‚¨åªä»çº¿æ€§ä»£æ•°è¿™ä¸€èŠ‚ä¸­å­¦ä¼šä¸€ä¸ªæ¦‚å¿µï¼Œé‚£ä¹ˆå°±åº”è¯¥æ˜¯ä¸€ä¸ªå¹ºæ­£çŸ©é˜µçš„æ¦‚å¿µã€‚

å„ç±³çŸ©é˜µå°±æ˜¯ä¸€ä¸ªç­‰äºå®ƒçš„å…±è½­è½¬ç½®ï¼ˆ**conjugate
transpose**ï¼‰çš„çŸ©é˜µ(ç”¨â€ ç¬¦å·è¡¨ç¤º)ã€‚è¿™è¡¨æ˜ç¿»è½¬å„ç±³çŸ©é˜µçš„è™šéƒ¨ç¬¦å·ï¼Œç„¶åæ²¿ç€ä¸»å¯¹è§’çº¿ï¼ˆä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’ï¼‰åå°„çŸ©é˜µä¸­çš„å…ƒç´ ï¼Œå°±å¾—åˆ°äº†ä¸€ä¸ªç›¸ç­‰çš„çŸ©é˜µã€‚ä¾‹å¦‚ï¼Œé‡å­è®¡ç®—ä¸­å¸¸ç”¨çš„Pauli-YçŸ©é˜µæ˜¯å„ç±³çŸ©é˜µï¼š

$$\sigma_{y} = \left( \begin{matrix}
0 \\
i \\
\end{matrix}\ \begin{matrix}
 - i \\
0 \\
\end{matrix} \right) \Rightarrow \sigma_{y}^{\dagger} = \left( \begin{matrix}
0 \\
 - \left( - i \right) \\
\end{matrix}\ \begin{matrix}
 - \left( i \right) \\
0 \\
\end{matrix} \right) = \left( \begin{matrix}
0 \\
i \\
\end{matrix}\ \begin{matrix}
 - i \\
0 \\
\end{matrix} \right) = \sigma_{y}$$

æ³¨æ„æˆ‘ä»¬äº¤æ¢äº†ğ‘–å’Œâˆ’ğ‘–çš„ä½ç½®ï¼ˆåæ˜ åœ¨ä¸»å¯¹è§’çº¿ï¼Œ0ä¿æŒä¸å˜ï¼‰,ç„¶åç¿»è½¬çš„ç¬¦å·ã€‚

å¹ºæ­£çŸ©é˜µä¸ä¸Šè¿°éå¸¸ç›¸ä¼¼ã€‚å…·ä½“çš„è¯´ï¼Œå¹ºæ­£çŸ©é˜µæ˜¯ä¸€ä¸ªçŸ©é˜µä½¿å¾—é€†çŸ©é˜µç­‰äºåŸçŸ©é˜µçš„å…±è½­è½¬ç½®ã€‚

çŸ©é˜µAçš„é€†æ ‡æ³¨ä¸º$A^{- 1}$ï¼š

$$A^{- 1}A = AA^{- 1}\mathbb{= I}$$

å…¶ä¸­$\mathbb{I}$æ˜¯å•ä½çŸ©é˜µï¼ˆ**identity
matrix**ï¼‰ï¼Œè¯¥çŸ©é˜µçš„ä¸»å¯¹è§’çº¿å…ƒç´ ä¸º1ï¼Œå…¶ä»–å…ƒç´ çš†ä¸º0ã€‚ä¹‹æ‰€ä»¥å°†è¿™ä¸€çŸ©é˜µç§°ä¸ºå•ä½çŸ©é˜µï¼Œå› ä¸ºä»»ä½•çŸ©é˜µä¸ä¹‹ç›¸ä¹˜éƒ½ç­‰äºå…¶æœ¬èº«ã€‚

å½“ä¸€ä¸ªçŸ©é˜µçš„å¤§å°è¶…è¿‡$2 \times 2$æ—¶ï¼ŒçŸ©é˜µé€†çš„è®¡ç®—å°±å˜å¾—éå¸¸å¤æ‚ï¼Œé€šå¸¸ç”±è®¡ç®—æœºæ¥å®Œæˆã€‚å¯¹äº$2 \times 2$çš„çŸ©é˜µï¼Œå…¶é€†å®šä¹‰ä¸ºï¼š

$$A = {\left( \begin{matrix}
a \\
c \\
\end{matrix}\ \begin{matrix}
b \\
d \\
\end{matrix} \right) \Rightarrow A}^{- 1} = \frac{1}{\text{detA}}\left( \begin{matrix}
d \\
 - c \\
\end{matrix}\ \begin{matrix}
 - b \\
a \\
\end{matrix} \right)$$

å…¶ä¸­det Aæ˜¯çŸ©é˜µAçš„è¡Œåˆ—å¼ï¼ˆ**determinant**ï¼‰ï¼Œåœ¨$2 \times 2$çŸ©é˜µä¸­ï¼Œdet
A=ad-bcã€‚

åœ¨é‡å­è®¡ç®—ä¸­ï¼ŒçŸ©é˜µé€†çš„è®¡ç®—å¾ˆå°‘æ˜¯é‡è¦çš„ã€‚å› ä¸ºæˆ‘ä»¬é‡åˆ°çš„å¤§å¤šæ•°çŸ©é˜µéƒ½æ˜¯å¹ºæ­£çš„ï¼Œå¯ä»¥å‡è®¾çŸ©é˜µçš„é€†å°±æ˜¯é€šè¿‡æ±‚å…±è½­è½¬ç½®å¾—åˆ°çš„ã€‚

è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªåŸºæœ¬çš„ä¾‹å­ã€‚Pauli-YçŸ©é˜µï¼Œå³æ˜¯å„ç±³çŸ©é˜µï¼Œä¹Ÿæ˜¯å¹ºæ­£çŸ©é˜µï¼ˆç­‰äºå®ƒçš„å…±è½­è½¬ç½®ï¼Œä¹Ÿç­‰äºå®ƒçš„é€†ï¼›å› æ­¤ï¼ŒPauli-YçŸ©é˜µæ˜¯å®ƒè‡ªå·±çš„é€†ï¼ï¼‰ã€‚æˆ‘ä»¬å¯ä»¥è¯æ˜è¿™ä¸ªçŸ©é˜µå®é™…ä¸Šæ˜¯å¹ºæ­£çš„ï¼š

$$\sigma_{y} = \left( \begin{matrix}
0 \\
i \\
\end{matrix}\ \begin{matrix}
 - i \\
0 \\
\end{matrix} \right) \Rightarrow \sigma_{y}^{\dagger} = \left( \begin{matrix}
0 \\
i \\
\end{matrix}\ \begin{matrix}
 - i \\
0 \\
\end{matrix} \right) \Rightarrow \sigma_{y}^{\dagger}\sigma_{y} = \left( \begin{matrix}
\left( 0 \right)\left( 0 \right) + \left( - i \right)\left( i \right) \\
\left( i \right)\left( 0 \right) + \left( 0 \right)\left( i \right) \\
\end{matrix}\ \begin{matrix}
\left( 0 \right)\left( - i \right) + \left( - i \right)\left( 0 \right) \\
\left( i \right)\left( - i \right) + \left( 0 \right)\left( 0 \right) \\
\end{matrix} \right) = \left( \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
1 \\
\end{matrix} \right)\mathbb{= I}$$

å¹ºæ­£çŸ©é˜µé‡è¦çš„åŸå› å°†åœ¨å¸Œå°”ä¼¯ç‰¹ç©ºé—´ä¸€èŠ‚ä¸­å˜å¾—æ›´åŠ æ˜æ˜¾ï¼Œåœ¨è¿™æœ¬æ•™ç¨‹çš„é‡å­åŠ›å­¦ç« èŠ‚ä¸­æ›´æ˜¯å¦‚æ­¤ã€‚å…¶åŸºæœ¬æ€æƒ³æ˜¯ï¼Œé‡å­æ€çš„æ¼”åŒ–é€šè¿‡åº”ç”¨å¹ºæ­£çŸ©é˜µ"ä¿æŒ"é‡å­æ€ã€‚

#### ç”Ÿæˆé›†ï¼Œçº¿æ€§ç›¸å…³å’ŒåŸº

æˆ‘ä»¬ç°åœ¨å¼€å§‹è®¨è®ºå‘é‡ç©ºé—´çš„æ„é€ ã€‚è€ƒè™‘æŸä¸ªå‘é‡ç©ºé—´Vã€‚æˆ‘ä»¬è¯´ä¸€äº›å‘é‡çš„é›†åˆSå¼ æˆä¸€ä¸ªå­ç©ºé—´V~S~âŠ‚Vï¼ˆå­é›†åœ¨å‘é‡ç©ºé—´æ“ä½œæ—¶å°é—­ï¼‰çš„å‘é‡ç©ºé—´ï¼Œæˆ‘ä»¬æ˜¯å¦å¯ä»¥å°†å­ç©ºé—´ä¸­çš„ä»»ä½•å‘é‡å†™æˆåŒ…å«äºç”Ÿæˆé›†ä¸­å‘é‡çš„çº¿æ€§ç»„åˆï¼ˆ**linear
combination**ï¼‰ã€‚

åœ¨æ•°åŸŸ**F**ä¸Šçš„ä¸€äº›å‘é‡ç©ºé—´ä¸­çš„ä¸€äº›é€‚é‡é›†åˆ\|ğ‘£~1~âŸ©, \...,
\|ğ‘£~ğ‘›~âŸ©è¢«å®šä¹‰ä¸ºè¿™äº›å‘é‡ï¼ˆå¦ä¸€ç§°ä¹‹ä¸º\|ğ‘£âŸ©çš„å‘é‡ï¼‰çš„ä»»æ„å’Œã€‚

$$\left| v \right\rangle = f_{1}\left| v_{1} \right\rangle + f_{2}\left| v_{2} \right\rangle + \cdots + f_{n}\left| v_{n} \right\rangle = \sum_{i}^{}{f_{i}\left| v_{i} \right\rangle}$$

å…¶ä¸­$f_{i}$æ˜¯æ•°åŸŸ**F**ä¸­çš„å…ƒç´ ã€‚å¦‚æœæœ‰ä¸€å‘é‡é›†å¼ æˆä¸€ä¸ªç©ºé—´ï¼Œé‚£ä¹ˆè¯¥å‘é‡ç©ºé—´ä¸­çš„**ä»»æ„å…¶ä»–å‘é‡**éƒ½å¯è¡¨ç¤ºä¸ºå‘é‡é›†ä¸­çš„å‘é‡çš„çº¿æ€§ç»„åˆã€‚

è¿™ä¸€å‘é‡é›†\|ğ‘£~1~âŸ©, \..., \|ğ‘£~ğ‘›~âŸ©è¢«ç§°ä¸ºçº¿æ€§ç›¸å…³ï¼ˆ**linearly
dependent**ï¼‰ï¼Œå¦‚æœè¯¥é›†ä¸­æ¯ä¸ªå‘é‡éƒ½å­˜åœ¨ç›¸åº”çš„ç³»æ•°$b_{i} \in F$ï¼Œä½¿å¾—ï¼š

$$b_{1}\left| v_{1} \right\rangle + b_{2}\left| v_{2} \right\rangle + \cdots + b_{n}\left| v_{n} \right\rangle = \sum_{i}^{}{b_{i}\left| v_{i} \right\rangle} = 0$$

å…¶ä¸­è‡³å°‘æœ‰ä¸€ä¸ªç³»æ•°$b_{i}$éé›¶ã€‚è¯¥ç­‰å¼ç­‰æ›´ç›´è§‚çš„è¡¨è¿°\"ä¸€ä¸ªå‘é‡é›†å¯ä»¥è¡¨ç¤ºä¸ºå½¼æ­¤çš„çº¿æ€§ç»„åˆ\"ã€‚ä¾‹å¦‚ï¼Œé›†{\|ğ‘£~1~âŸ©,
\..., \|ğ‘£~ğ‘›~âŸ©}ä»¥åŠç›¸åº”ç³»æ•°{\|b~1~âŸ©, \...,
\|b~ğ‘›~âŸ©}çš„çº¿æ€§ç»„åˆç­‰äº0ã€‚å› æ­¤å…¶ä¸­è‡³å°‘æœ‰ä¸€ä¸ªå‘é‡çš„ç³»æ•°ä¸ä¸ºé›¶ï¼Œæˆ‘ä»¬åœ¨è¿™ä¸€çº¿æ€§ç»„åˆä¸­é€‰å–ä¸€é¡¹b~a~\|ğ‘£~a~âŸ©ï¼š

$$\sum_{i}^{}{b_{i}\left| v_{i} \right\rangle} = b_{a}\left| v_{a} \right\rangle + \sum_{i,i \neq a}^{}{b_{i}\left| v_{i} \right\rangle} = 0 \Rightarrow \left| v_{a} \right\rangle = - \sum_{i,i \neq a}^{}{\frac{b_{i}}{b_{a}}\left| v_{i} \right\rangle} = \sum_{i,i \neq a}^{}{c_{i}\left| v_{i} \right\rangle}$$

æ­¤æ—¶ç³»æ•°$b_{a}$æ˜¯å”¯ä¸€çš„éé›¶ç³»æ•°ï¼Œå‘é‡$\left| v_{a} \right\rangle$å¿…ç„¶æ˜¯é›¶å‘é‡ï¼ˆ**null
vevtor**ï¼‰ï¼Œåˆ™è¯¥å‘é‡é›†çº¿æ€§ç›¸å…³ã€‚å¦‚æœä¸æ˜¯è¿™æ ·ï¼Œå‘é‡$\left| v_{a} \right\rangle$å¯å†™ä¸ºéé›¶å‘é‡çš„çº¿æ€§ç»„åˆï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚ä¸ºè¯æ˜è¯¥é€†å‘½é¢˜ï¼Œæˆ‘ä»¬å‡è®¾åœ¨å­ç©ºé—´\|ğ‘£~1~âŸ©,
\...,
\|ğ‘£~ğ‘›~âŸ©ä¸­å­˜åœ¨ä¸€äº›å‘é‡$\left| v_{a} \right\rangle$å¯è¢«å†™ä¸ºè¯¥å­ç©ºé—´ä¸­å…¶ä»–å‘é‡çš„çº¿æ€§ç»„åˆï¼Œè¿™å°±æ˜¯è¯´ï¼š

$$\left| v_{a} \right\rangle = \sum_{s}^{}{b_{s}\left| v_{s} \right\rangle}$$

å…¶ä¸­sæ˜¯å­ç©ºé—´ä¸­æ‰€æœ‰å­é›†çš„ç´¢å¼•ï¼Œå…¶éµå¾ªï¼š

$$\left| v_{a} \right\rangle - \sum_{s}^{}{b_{s}\left| v_{s} \right\rangle} = \left| v_{a} \right\rangle - \left( \left| v_{s_{1}} \right\rangle + \cdots + \left| v_{s_{r}} \right\rangle \right) = 0$$

å¯¹äºæ‰€æœ‰ä¸åŒ…å«åœ¨ç”±ğ‘ ç´¢å¼•å­é›†ä¸­çš„è¯¥å­ç©ºé—´å‘é‡ï¼Œæˆ‘ä»¬è®¾ç½®å…¶ç³»æ•°ç”±ğ‘ç´¢å¼•ä¸”ç­‰äº0ã€‚å› æ­¤,

$$\left| v_{a} \right\rangle - \left( \left| v_{s_{1}} \right\rangle + \cdots + \left| v_{s_{r}} \right\rangle \right) + \left( 0 \right)\left( \left| v_{q_{1}} \right\rangle + \cdots + \left| v_{q_{t}} \right\rangle \right) = 0$$

ä¸Šå¼å³æ˜¯å­ç©ºé—´\|ğ‘£~1~âŸ©, \...,
\|ğ‘£~ğ‘›~âŸ©ä¸­æ‰€æœ‰å…ƒç´ çš„çº¿æ€§ç»„åˆã€‚å…¶ç»„åˆçš„ç»“æœç­‰äº0ï¼Œä»è€Œå®Œæˆäº†çº¿æ€§ç›¸å…³ä¸¤ä¸ªå®šä¹‰ç›¸äº’åŒ…å«çš„è¯æ˜ã€‚

ç°åœ¨è®©æˆ‘ä»¬æ€è€ƒä¸€ä¸ªåŸºç¡€ç¤ºä¾‹ã€‚å‡è®¾åœ¨$\mathbb{R}^{2}$ä¸­çš„ä¸¤ç»„å‘é‡ï¼Œç”±$\left| a \right\rangle = \left( \frac{1}{0} \right)$å’Œ$\left| b \right\rangle = \left( \frac{2}{0} \right)$ç»„æˆã€‚å¦‚æœé€‰æ‹©è¯¥å‘é‡ç©ºé—´åœ¨æ•°åŸŸRä¸Šï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿å¾—è¿™äº›å‘é‡çº¿æ€§ç»„åˆç­‰äº0ã€‚

$$2\left| a \right\rangle - \left| b \right\rangle = 0$$

å½“ä¸€ç»„å‘é‡ä¸­çš„ä¸€ä¸ªå‘é‡ä¸èƒ½è¡¨ç¤ºä¸ºæ‰€æœ‰å…¶ä»–å‘é‡çš„çº¿æ€§ç»„åˆæ—¶ï¼Œæˆ‘ä»¬ç§°è¿™ç»„å‘é‡çº¿æ€§æ— å…³ï¼ˆ**linearly
independent**ï¼‰ã€‚

åŸºï¼ˆ**basis**ï¼‰çš„æ¦‚å¿µå¯ä»¥ç®€å•çš„å®šä¹‰ä¸ºçº¿æ€§æ— å…³å¼ æˆé›†ï¼ˆ**linearly
independent spanning
set**ï¼‰ã€‚ä»è¿™ä¸ªæ„ä¹‰ä¸Šæ¥è¯´ï¼Œå‘é‡ç©ºé—´çš„åŸºæ˜¯å¼ æˆæ•´ä¸ªç©ºé—´çš„æœ€å°å¯èƒ½å‘é‡é›†ã€‚æˆ‘ä»¬å°†å¼ æˆå‘é‡ç©ºé—´çš„ä¸€ç»„åŸºçš„å¤§å°ç§°ä¸ºç»´åº¦ï¼ˆ**dimension**ï¼‰ã€‚

åŸºå’Œå¼ æˆé›†éå¸¸é‡è¦ï¼Œå› ä¸ºå¯ä»¥è®©æˆ‘ä»¬"ç¼©å°"å‘é‡ç©ºé—´ï¼Œå¹¶ä¸”ä»…ç”¨å°‘é‡çš„å‘é‡å°±èƒ½å¤Ÿè¡¨è¾¾ã€‚æˆ‘ä»¬å¯ä»¥å¾—å‡ºå‘é‡ç©ºé—´åŸºçš„ä¸€äº›ç»“è®ºï¼Œå¹¶å¯ä»¥å°†å…¶æ¨å¹¿è‡³æ•´ä¸ªå‘é‡ç©ºé—´ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“ç©ºé—´ä¸­çš„æ¯ä¸ªå‘é‡éƒ½æ˜¯åŸºå‘é‡çš„çº¿æ€§ç»„åˆã€‚

åœ¨é‡å­è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬é‡åˆ°çš„åŸºé€šå¸¸ä¸º\|0âŸ©å’Œ\|1âŸ©ã€‚æˆ‘ä»¬å¯ä»¥å°†ä»»ä¸€é‡å­æ€å†™ä¸ºåŸºå‘é‡çš„çº¿æ€§ç»„åˆã€‚

$$\frac{\left| 0 \right\rangle + \left| 1 \right\rangle}{\sqrt{2}}$$

ä¾‹å¦‚ï¼Œä¸Šé¢çš„çº¿æ€§ç»„åˆé€šè¿‡ç­‰æ¦‚ç‡æµ‹é‡å¤„äºä»»ä¸€åŸºå‘é‡çŠ¶æ€ä¸­çš„é‡å­æ€ï¼Œå‘ˆç°åœ¨åŸºæ€\|0âŸ©å’Œ\|1âŸ©ä¹‹é—´çš„å åŠ æ€ã€‚ï¼ˆç›´è§‚çš„è¯´ï¼Œå› ä¸º"æƒé‡"æˆ–"æ¯ä¸€åŸºå‘é‡çš„æ•°ç›®"åœ¨çº¿æ€§ç»„åˆä¸­ç›¸ç­‰ï¼Œæ‰€ä»¥ä¸¤è€…éƒ½ä¹˜ä»¥1/$\sqrt{2}$ï¼‰

#### å¸Œå°”ä¼¯ç‰¹ç©ºé—´ï¼Œæ­£äº¤æ€§ï¼Œå’Œå†…ç§¯

å¸Œå°”ä¼¯ç‰¹ç©ºé—´æ˜¯é‡å­åŠ›å­¦å’Œé‡å­è®¡ç®—ä¸­æœ€é‡è¦çš„æ•°å­¦ç»“æ„ä¹‹ä¸€ã€‚å¸Œå°”ä¼¯ç‰¹ç©ºé—´å¯ä»¥è¢«è®¤ä¸ºæ˜¯æ‰€æœ‰é‡å­æ€å‘é‡"å±…ä½"çš„æ€ç©ºé—´ã€‚å¸Œå°”ä¼¯ç‰¹ç©ºé—´ä¸ä»»ä½•éšæœºå‘é‡ç©ºé—´çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼Œå¸Œå°”ä¼¯ç‰¹ç©ºé—´æœ‰å†…ç§¯ï¼ˆ**inner
product**ï¼‰ã€‚å†…ç§¯æ˜¯åœ¨ä¸¤ä¸ªå‘é‡ä¹‹é—´æ‰§è¡Œè¿ç®—å¹¶è¿”å›ä¸€ä¸ªæ ‡é‡ã€‚

åœ¨é‡å­åŠ›å­¦å’Œé‡å­è®¡ç®—çš„èƒŒæ™¯ä¸‹ï¼Œä¸¤ä¸ªæ€å‘é‡ä¹‹é—´çš„å†…ç§¯è¿”å›ä¸€ä¸ªæ ‡é‡ï¼Œ*è¡¨ç¤ºç¬¬ä¸€ä¸ªå‘é‡ä¸ç¬¬äºŒä¸ªä¹‹é—´çš„è·ç¦»*ã€‚ç”±æ­¤ï¼Œå¯ä»¥è®¡ç®—å‡ºä¸åŒé‡å­æ€çš„æµ‹é‡æ¦‚ç‡ï¼ˆå°†åœ¨é‡å­åŠ›å­¦çš„å­ä¸»é¢˜ä¸­è¿›è¡Œæ›´å¤šçš„è®¨è®ºï¼‰ã€‚

å¯¹äºåœ¨å¸Œå°”ä¼¯ç‰¹ç©ºé—´ä¸­çš„ä¸¤ä¸ªå‘é‡\|ğ‘âŸ©å’Œ\|ğ‘âŸ©ï¼Œæˆ‘ä»¬å°†å…¶å†…å³è¡¨ç¤ºä¸ºâŸ¨ğ‘\|ğ‘âŸ©ï¼Œå…¶ä¸­âŸ¨ğ‘\|æ˜¯å‘é‡\|ğ‘âŸ©çš„å…±è½­è½¬ç½®ï¼Œè®°ä¸º$\left| a \right\rangle^{\dagger}$ã€‚å› æ­¤ï¼Œå¸Œå°”ä¼¯ç‰¹ç©ºé—´ä¸­ä¸¤ä¸ªå‘é‡çš„å†…ç§¯ç±»ä¼¼äºï¼š

$$\left\langle a \middle| b \right\rangle = \ \left( a_{1}^{*}\ a_{2}^{*}\text{...}a_{n}^{*} \right)\left( \frac{b_{1}}{\begin{matrix}
b_{2} \\
. \\
. \\
. \\
b_{n} \\
\end{matrix}} \right) = \ a_{1}^{*}b_{1} + a_{2}^{*}b_{2} + \ldots + a_{n}^{*}b_{n}$$

å…¶ä¸­âˆ—è¡¨ç¤ºå‘é‡çš„å¤å…±è½­ï¼ˆ**complex conjugate**ï¼‰ã€‚

å¸Œå°”ä¼¯ç‰¹ç©ºé—´è¡¨ç¤ºä¸ºä¸€ä¸ªé‡å­ç³»ç»Ÿçš„æœ€é‡è¦æ¡ä»¶æ˜¯å‘é‡ä¸å…¶è‡ªèº«çš„å†…ç§¯ç­‰äºä¸€ï¼šâŸ¨ğœ“\|ğœ“âŸ©
=
1ã€‚è¿™å°±æ˜¯æ‰€è°“çš„å½’ä¸€åŒ–æ¡ä»¶ï¼Œå³å‘é‡é•¿åº¦çš„å¹³æ–¹å¿…é¡»ç­‰äº1ï¼ˆé€šè¿‡å†…ç§¯çš„å®šä¹‰ï¼Œå‘é‡çš„æ¯ä¸€åˆ†é‡éƒ½è¢«å¹³æ–¹å¹¶åŠ åœ¨ä¸€èµ·ï¼‰ã€‚è¿™ä¸€ç†è®ºçš„ç‰©ç†æ„ä¹‰åœ¨äºï¼Œå‘é‡åœ¨ç‰¹å®šæ–¹å‘ä¸Šçš„é•¿åº¦ä»£è¡¨äº†é‡å­ç³»ç»Ÿåœ¨ç‰¹å®šçŠ¶æ€ä¸‹æµ‹é‡æ‰€å¾—çš„"æ¦‚ç‡æŒ¯å¹…ï¼ˆprobability
amplitudeï¼‰"ã€‚æ˜¾ç„¶ï¼Œé‡å­ç³»ç»Ÿåœ¨å…¶æ‰€å¤„çŠ¶æ€ä¸‹è¢«æµ‹é‡çš„æ¦‚ç‡å¿…é¡»æ˜¯1ï¼ˆæ¯•ç«Ÿï¼Œåœ¨ä»»ä½•ç‰¹å®šçŠ¶æ€ä¸‹å‘ç°é‡å­ç³»ç»Ÿçš„æ¦‚ç‡ä¹‹å’Œå¿…ç­‰äº1ï¼‰ã€‚è€ƒè™‘å¸ƒæ´›èµ«çƒï¼š

> plot_bloch_vector(\[0, 0, 0\])
>
> è¾“å‡ºï¼š

![](pics/media/image36.png)

è¯¥çƒçš„è¡¨é¢è¿åŒé‡å­æ¯”ç‰¹æ€å‘é‡ä¹‹é—´çš„å†…ç§¯æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å¸Œå°”ä¼¯ç‰¹ç©ºé—´ã€‚æ­¤å¤–ï¼Œç”±äºå¸ƒæ´›èµ«çƒçš„åŠå¾„ä¸º1ï¼Œæ‰€ä»¥å½’ä¸€åŒ–æ¡ä»¶ä¹Ÿæˆç«‹ï¼Œå› æ­¤æ¯ä¸ªå‘é‡çš„é•¿åº¦çš„å¹³æ–¹ä¹Ÿå¿…é¡»ç­‰äº1ã€‚

å…³äºå¸Œå°”ä¼¯ç‰¹ç©ºé—´å’Œå†…ç§¯çš„æœ€åä¸€ç‚¹è¯´æ˜æ˜¯å…¶ä¸å¹ºæ­£çŸ©é˜µçš„å…³ç³»ã€‚å¹ºæ­£çŸ©é˜µåœ¨é‡å­è®¡ç®—ä¸­å¾ˆé‡è¦ï¼Œå› å…¶ä¿æœ‰å†…ç§¯ï¼Œè¡¨æ˜æ— è®ºæ‚¨å¦‚ä½•åœ¨ä¸€ä¸ªå¹ºæ­£çŸ©é˜µåºåˆ—ä¸‹å˜æ¢ä¸€ä¸ªå‘é‡ï¼Œå½’ä¸€åŒ–æ¡ä»¶ä»ç„¶æˆç«‹ã€‚è¿™ç‚¹å¯ä»¥é€šè¿‡ä¸‹é¢çš„ç®€çŸ­è¿‡ç¨‹æ¥è¯æ˜ï¼š

$$\left\langle \psi \middle| \psi \right\rangle = 1 \Rightarrow \left| \psi \right\rangle \rightarrow U\left| \psi \right\rangle = \left| \psi^{'} \right\rangle \Rightarrow \left\langle \psi^{'} \middle| \psi^{'} \right\rangle = {(U|\psi\rangle)}^{\dagger}U\left| \psi \right\rangle = \left\langle \psi\left| U^{\dagger}U \right|\psi \right\rangle = \left\langle \psi \middle| \psi \right\rangle = 1$$

ä¸Šå¼è¡¨é¢å¹ºæ­£å˜æ¢å°†é‡å­æ€å‘é€åˆ°å…¶ä»–æœ‰æ•ˆçš„é‡å­æ€ã€‚å¯¹äºä¸€ä¸ªç”±å¸ƒæ´›èµ«çƒè¡¨ç¤ºçš„å•é‡å­æ¯”ç‰¹å¸Œè€³ä¼¯ç‰¹ç©ºé—´ï¼Œå¹ºæ­£å˜æ¢å¯¹åº”äºæ€å‘é‡åœ¨çƒä¸Šä¸åŒç‚¹çš„æ—‹è½¬ï¼Œè€Œä¸ä»¥ä»»ä½•æ–¹å¼æ”¹å˜æ€å‘é‡çš„é•¿åº¦ã€‚

#### æœ¬å¾å‘é‡å’Œæœ¬å¾å€¼

è€ƒè™‘ä¸‹é¢ç­‰å¼çš„å…³ç³»ï¼š

$$A\left| v \right\rangle = \lambda\left| v \right\rangle$$

å…¶ä¸­Aæ˜¯ä¸€ä¸ªçŸ©é˜µï¼Œ$\lambda$æ˜¯ä¸€ä¸ªæ•°å­—ã€‚å¦‚æœç»™å‡ºä¸€ä¸ªçŸ©é˜µAï¼Œè¦æ‰¾å‡ºæ»¡è¶³ä¸Šè¿°å…³ç³»çš„å‘é‡$\left| \upsilon \right\rangle$å’Œæ•°å­—$\lambda$ï¼Œæˆ‘ä»¬ç§°è¿™äº›å‘é‡æ˜¯æœ¬å¾å‘é‡ï¼ˆ**eigenvector**ï¼‰ï¼Œæ‰€å¯¹åº”çš„ä¹˜æ•°ä¸ºæœ¬å¾å€¼ï¼ˆ**eigenvalue**ï¼‰ã€‚æœ¬å¾å‘é‡å’Œæœ¬å¾å€¼åœ¨é‡å­åŠ›å­¦ä¸­å…·æœ‰éå¸¸é‡è¦çš„ç‰©ç†æ„ä¹‰ï¼Œå› æ­¤åœ¨é‡å­è®¡ç®—ä¸­ä¹ŸåŒæ ·é‡è¦ã€‚ç»™å‡ºçŸ©é˜µğ´ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ä¸€ä¸ªæœ‰è¶£çš„æŠ€å·§æ‰¾åˆ°ç›¸åº”æœ¬å¾å‘é‡å’Œæœ¬å¾å€¼çš„é›†åˆã€‚æŠŠä¸Šé¢çš„ç­‰å¼é‡æ–°æ•´ç†ä¸€ä¸‹ï¼š

$$A\left| v \right\rangle - \lambda\left| v \right\rangle = 0 \Rightarrow \left( A - \lambda\mathbb{I} \right)\left| v \right\rangle = 0$$

å¦‚æœæ–¹ç¨‹ä¸¤è¾¹åŒæ—¶ä¹˜ä»¥é€†çŸ©é˜µ$\left( A - \lambda\mathbb{I} \right)^{- 1}$ï¼Œå°†ä¼šå¾—åˆ°$\left| v \right\rangle = 0$ã€‚è¿™æ˜¯ä¸€ä¸ªæ— å…³çš„è§£ï¼ˆæˆ‘ä»¬ä¸å…è®¸æœ¬å¾å‘é‡æ˜¯é›¶å‘é‡ï¼Œå¦åˆ™ä»»æ„æœ¬å¾å€¼/çŸ©é˜µç»„åˆéƒ½ä¼šæ»¡è¶³æœ¬å¾å‘é‡-æœ¬å¾å€¼å…³ç³»)ã€‚å› æ­¤ï¼Œä¸ºäº†æ‰¾åˆ°å…è®¸çš„æœ¬å¾å‘é‡å’Œæœ¬å¾å€¼ï¼Œæˆ‘ä»¬å‡è®¾çŸ©é˜µ$\left( A - \lambda\mathbb{I} \right)$ä¸å¯é€†ï¼ˆ**non-invertible**ï¼‰ã€‚å›å¿†ä¸€ä¸‹å‰é¢çš„ä¾‹å­ï¼ŒçŸ©é˜µçš„é€†æ˜¯ï¼š

$$M^{- 1} = \frac{1}{\det\left( M \right)}F\left( M \right)$$

å…¶ä¸­$F\left( M \right)$æ˜¯æŸä¸ªåŸºäºäº$M$çš„æ–°çŸ©é˜µï¼ˆè¿™äº›ç»†èŠ‚åœ¨è¿™é‡Œå¹¶ä¸é‡è¦ï¼‰ã€‚è¿™ä¸€ç­‰å¼ä¸­æˆ‘ä»¬æ„Ÿå…´è¶£çš„éƒ¨åˆ†æ˜¯è¡Œåˆ—å¼çš„é€†ã€‚å¦‚æœçŸ©é˜µ$M$çš„è¡Œåˆ—å¼ç­‰äº0ï¼Œåˆ™è¯¥çŸ©é˜µçš„é€†æ— å®šä¹‰ï¼Œå› æ­¤é€†ä¹Ÿå°±æ— å®šä¹‰ï¼Œä½¿å¾—çŸ©é˜µ$M$ä¸å¯é€†ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¦æ±‚ï¼š

$$\det\left( A - \text{Î»I} \right) = \mathbf{0}$$

ç„¶åæˆ‘ä»¬å°±å¯ä»¥ç¡®å®š$\lambda$ï¼Œæ¥ç€å°†æ¯ä¸ª$\lambda$å€¼ä»£å…¥åŸæ–¹ç¨‹è·å¾—æœ¬å¾å€¼ã€‚ä¾‹å¦‚ï¼Œæ‰¾åˆ°Pauli-ZçŸ©é˜µçš„æœ¬å¾å‘é‡å’Œæœ¬å¾å€¼$\sigma_{\mathcal{z}}$ã€‚

$$\det\left( \sigma_{\mathcal{z}} - \lambda\mathbb{I} \right) = det\left( \frac{1 - \lambda}{0}\frac{0}{- 1 - \lambda} \right) = \left( - 1 - \lambda \right)\left( 1 - \lambda \right) = 1 - \lambda^{2} = 0 \Rightarrow \lambda = \pm 1$$

è¿™ä¸€ç­‰å¼ä¾æ®$\lambda$æ‰€è§£å‡ºçš„è¡Œåˆ—å¼ç§°ä¹‹ä¸ºç‰¹å¾å¤šé¡¹å¼ï¼ˆ**characteristic
polynomial**ï¼‰ã€‚ç„¶åå°†æ¯ä¸ªå€¼ä»£å…¥åŸæ¥çš„ç­‰å¼ï¼Œä»¥$\lambda = 1$å¼€å§‹ï¼š

$$\left( \frac{1}{0}\frac{0}{- 1} \right)\left| v \right\rangle = \left| v \right\rangle \Rightarrow \left( \frac{1}{0}\frac{0}{- 1} \right)\left( \frac{a}{b} \right) = \left( \frac{a}{b} \right) \Rightarrow \left( \frac{a}{- b} \right) = \left( \frac{a}{b} \right)$$

å› æ­¤aå¯ä»¥æ˜¯ä»»ä¸€æ•°å­—ï¼Œbä¸º0ï¼›å‘é‡$\left( \frac{1}{0} \right)$æ„æˆäº†æ‰€æœ‰æ»¡è¶³å…³ç³»å‘é‡çš„ä¸€ç»„åŸºï¼Œå› æ­¤è¯¥æœ¬å¾å‘é‡æ˜¯å¯¹åº”äºæœ¬å¾å€¼1ã€‚ç”¨åŒæ ·çš„æ–¹å¼å¸¦ä»£å…¥$\lambda = - 1$ï¼š

$$\left( \frac{1}{0}\frac{0}{- 1} \right)\left| v \right\rangle = - \left| v \right\rangle \Rightarrow \left( \frac{1}{0}\frac{0}{- 1} \right)\left( \frac{a}{b} \right) = \left( \frac{- a}{- b} \right) \Rightarrow \left( \frac{a}{- b} \right) = \left( \frac{- a}{- b} \right)$$

æ­¤æ—¶bå¯ä»¥æ˜¯ä»»ä¸€æ•°å­—ï¼Œaä¸º0ï¼›å› æ­¤åŸºå‘é‡æ˜¯$\left( \frac{0}{1} \right)$ï¼ˆå¯¹åº”äºäº-1çš„æœ¬å¾å‘é‡ï¼‰ã€‚å¯ä»¥çœ‹åˆ°Pauli-ZçŸ©é˜µçš„æœ¬å¾å‘é‡æ˜¯é‡å­è®¡ç®—ä¸­çš„åŸºæ€\|0âŸ©å’Œ\|1âŸ©ï¼Œæ­¤å¹¶éå·§åˆã€‚ä¾‹å¦‚ï¼Œå½“æˆ‘ä»¬æµ‹é‡ZåŸºä¸Šçš„é‡å­æ¯”ç‰¹æ—¶ï¼Œæ‰€è°“çš„æµ‹é‡æ˜¯æŒ‡é‡å é‡å­æ¯”ç‰¹çš„çŠ¶æ€åˆ°ZçŸ©é˜µçš„æœ¬å¾å‘é‡\|0âŸ©æˆ–\|1âŸ©ã€‚

#### çŸ©é˜µæŒ‡æ•°

çŸ©é˜µæŒ‡æ•°ï¼ˆ**Matrix
Exponential**ï¼‰çš„æ¦‚å¿µæ˜¯ä¸€ä¸ªéå¸¸å…·ä½“ä½†åˆéå¸¸é‡è¦çš„æ¦‚å¿µã€‚æˆ‘ä»¬ç»å¸¸çœ‹åˆ°ä»¥ä¸‹å½¢å¼çš„å¹ºæ­£å˜æ¢ï¼š

$$U = \mathcal{e}^{\text{iÎ³H}}$$

å…¶ä¸­Hæ˜¯å„ç±³çŸ©é˜µï¼ˆ**Hermitian
matrix**ï¼‰ï¼ŒÎ³æ˜¯å®æ•°ã€‚ä¸Šé¢çš„ç­‰å¼ç›¸å½“ç®€å•åœ°è¯æ˜äº†è¿™ä¸€å½¢å¼çš„æ‰€æœ‰çŸ©é˜µéƒ½æ˜¯å¹ºæ­£ã€‚å¯¹ç­‰å¼ä¸­çš„çŸ©é˜µUè¿›è¡Œå…±è½­è½¬ç½®ï¼š

$$U^{\mathbf{\dagger}}\mathbf{=}\left( \mathcal{e}^{\text{iÎ³H}} \right)^{\mathbf{\dagger}}\mathbf{=}\mathcal{e}^{\mathbf{-}\text{iÎ³}H^{\mathbf{\dagger}}}$$

ä½†æ˜¯ç”±äºçŸ©é˜µHæ˜¯å„ç±³çŸ©é˜µï¼Œæ‰€ä»¥$H^{\mathbf{\dagger}} = H$ï¼š

$$\mathcal{e}^{\mathbf{-}\text{iÎ³}H^{\mathbf{\dagger}}} = \mathcal{e}^{\mathbf{-}\text{iÎ³}H} \Rightarrow U^{\mathbf{\dagger}}U = \mathcal{e}^{\mathbf{-}\text{iÎ³}H}\mathcal{e}^{\text{iÎ³}H} = \mathbb{I}$$

æ‚¨å¯èƒ½æƒ³çŸ¥é“ä¸ºä»€ä¹ˆæŒ‡æ•°ä¸­çš„çŸ©é˜µä»ç„¶å¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªçŸ©é˜µã€‚å½“æˆ‘ä»¬æŠŠæŒ‡æ•°å‡½æ•°å±•å¼€æˆæ³°å‹’çº§æ•°æ—¶ï¼Œç­”æ¡ˆå°±å˜å¾—æ›´æ¸…æ¥šäº†ã€‚å›æƒ³ä¸€ä¸‹å¾®ç§¯åˆ†ä¸­æ³°å‹’çº§æ•°æœ¬è´¨ä¸Šæ˜¯ç¼–å†™æ— ç©·æ¬¡å¤šé¡¹å¼ï¼ˆinfinite-degree
polynomialï¼‰å‡½æ•°ï¼Œå…¶ä¸»è¦æ€æƒ³æ˜¯ä¾æ®æˆ‘ä»¬å°è¯•å°†å…¶è½¬æ¢ä¸ºå¤šé¡¹å¼çš„å‡½æ•°ä¾æ¬¡é€‰æ‹©å¤šé¡¹å¼å‡½æ•°åŠå…¶ä¸­å¿ƒç‚¹$x_{0}$ï¼Œè¯¸å¦‚ç¬¬é›¶ã€ç¬¬ä¸€ã€ç¬¬äºŒã€ç¬¬ä¸‰ç­‰ï¼Œå…¶å¯¼æ•°æ˜¯ç›¸åŒçš„åŸå§‹å‡½æ•°å’Œå¤šé¡¹å¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†æ³°å‹’çº§æ•°å†™æˆï¼š

$$g\left( x \right) = \sum_{n = 0}^{\infty}f^{\left( n \right)}\left( x_{0} \right)\frac{\left( x - x_{0} \right)^{n}}{n!}$$

å…¶ä¸­g(x)æ˜¯ä¸€ä¸ªå¤šé¡¹å¼ï¼Œf(x)æ˜¯åŸå‡½æ•°ï¼Œ$f^{\left( n \right)}$æ˜¯å‡½æ•°fçš„né˜¶å¯¼æ•°ï¼Œ$x_{0}$æ˜¯å‡½æ•°çš„ä¸­å¿ƒç‚¹ã€‚å› ä¸ºæˆ‘ä»¬ä¸æ˜¯åœ¨æ±‚è¿‘ä¼¼è§£ï¼Œæ‰€ä»¥$x_{0}$æ— å…³ç´§è¦ï¼Œä¸ºäº†ç®€å•èµ·è§é€‰æ‹©$x_{0}$=0ï¼Œæ³°å‹’çº§æ•°å°±å˜æˆäº†éº¦å…‹åŠ³æ—çº§æ•°ï¼ˆ**Maclaurin
series**ï¼‰ï¼š

$$g\left( x \right) = \sum_{n = 0}^{\infty}f^{\left( n \right)}\left( 0 \right)\frac{\left( x \right)^{n}}{n!}$$

å¦‚æœé€‰æ‹©$f\left( x \right) = \mathcal{e}^{x}$ï¼Œå°±èƒ½ä½¿ç”¨éº¦å…‹åŠ³æ—çº§æ•°åˆ›å»ºç­‰ä»·çš„å¤šé¡¹å¼ã€‚ç”±äº$\mathcal{e}^{x}$çš„å¯¼æ•°å°±æ˜¯å…¶æœ¬èº«å¹¶ä¸”$\mathcal{e}^{0} = 1$ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š

$$g\left( x \right) = \sum_{n = 0}^{\infty}\frac{\left( x \right)^{n}}{n!} = \mathcal{e}^{x}$$

å› æ­¤å¯¹äºæŸäº›çŸ©é˜µ$\text{iÎ³H}$ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š

$$\mathcal{e}^{\text{iÎ³H}} = \sum_{n = 0}^{\infty}\frac{\left( \text{iÎ³H} \right)^{n}}{n!}$$

æ‰€ä»¥çŸ©é˜µæŒ‡æ•°å°±æ˜¯çŸ©é˜µï¼Œæ˜¯ä¸€ä¸ªæ— ç©·æ¬¡å¹‚çŸ©é˜µçš„å’Œï¼Œçœ‹èµ·æ¥éå¸¸å¤æ‚......ä½†è¿™é‡Œçš„å…³é”®æ˜¯çŸ©é˜µæŒ‡æ•°ç¡®å®æ˜¯ä¸€ä¸ªçŸ©é˜µã€‚

æˆ‘ä»¬ç°åœ¨å¯ä»¥è¯æ˜ä¸€ä¸ªéå¸¸é‡è¦çš„äº‹å®ï¼šå¦‚æœæˆ‘ä»¬æœ‰ä¸€äº›çŸ©é˜µBä½¿å¾—$B^{2}\mathbb{= I}$ï¼ˆinvolutory
matrixï¼Œ**å¯¹åˆçŸ©é˜µ**ï¼‰ã€‚

$$\mathcal{e}^{\text{iÎ³}B} = \text{co}s\left( \gamma \right)\mathbb{I +}\text{isin}\left( \gamma \right)B$$

æˆ‘ä»¬ä»éº¦è€ƒæ—çº§æ•°å¼€å§‹ï¼š

$$\mathcal{e}^{\text{iÎ³}B} = \sum_{n = 0}^{\infty}\frac{\left( \text{iÎ³B} \right)^{n}}{n!}$$

ä¾æ®æ€»å’Œçš„æ¯ä¸€é¡¹ä¸­ğ‘›æ˜¯å¦æ˜¯å¥‡æ•°è¿˜æ˜¯å¶æ•°ï¼Œå¯ä»¥å°†ä¸Šå¼æ‹†åˆ†ä¸ºè™šéƒ¨å’Œå®éƒ¨ï¼š

$$\sum_{n = 0}^{\infty}\frac{\left( \text{iÎ³B} \right)^{n}}{n!} = \sum_{n = 0}^{\infty}\frac{\left( - 1 \right)^{n}\left( \gamma \right)^{2n}\left( B \right)^{2n}}{\left( 2n \right)!} + i\sum_{n = 0}^{\infty}\frac{\left( - 1 \right)^{n}\left( \gamma \right)^{2n + 1}\left( B \right)^{2n + 1}}{\left( 2n + 1 \right)!}$$

ç°åœ¨æ‰¾å‡ºsinxå’Œcosxçš„éº¦è€ƒæ—çº§æ•°ã€‚ä»f(x)=sinxå¼€å§‹ï¼š

$$\text{sinx} = \sum_{n = 0}^{\infty}f^{n}\left( 0 \right)\frac{\left( x \right)^{n}}{n!}$$

åœ¨æŸç§æ„ä¹‰ä¸Šsinxçš„å¯¼æ•°æ˜¯å‘¨æœŸæ€§çš„ï¼ˆæ¯ä¸ªç®­å¤´ä»£è¡¨å‰ä¸€å‡½æ•°çš„å¯¼æ•°ï¼‰ï¼š

$$sinx\  \rightarrow \ cosx\  \rightarrow \  - sinx\  \rightarrow \  - cosx\  \rightarrow \ sinx$$

ç”±äºsin(0)=0å’Œcos(0)=1ï¼Œæ‰€æœ‰ä¸ºå¶æ•°çš„néƒ½å˜æˆäº†0ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ°ï¼š

$$\sum_{n = 0}^{\infty}f^{n}\left( 0 \right)\frac{\left( x \right)^{n}}{n!} = \sum_{n = 0}^{\infty}\frac{\left( - 1 \right)^{n}x^{2n + 1}}{\left( 2n + 1 \right)!}$$

ä¸Šå¼çœ‹èµ·æ¥å¾ˆåƒåŸæ–¹ç¨‹çš„å¥‡æ•°é¡¹ã€‚äº‹å®ä¸Šå¦‚æœè®©$x = \ \text{Î³B}$ï¼Œä¸¤è€…å°±å®Œå…¨ç›¸åŒäº†ã€‚æˆ‘ä»¬éµå¾ªä¸€ä¸ªå‡ ä¹å®Œå…¨ç›¸åŒçš„è¿‡ç¨‹æ¥è¯æ˜å¶æ•°é¡¹ä¸f(x)=cosxçš„éº¦å…‹åŠ³æ—çº§æ•°ç›¸åŒã€‚

$$\text{cosx} = \sum_{n = 0}^{\infty}f^{n}\left( 0 \right)\frac{x^{n}}{n!}$$

$$\Rightarrow \ cosx\  \rightarrow \  - sinx\  \rightarrow \  - cosx\  \rightarrow \ sinx\  \rightarrow \ cosx$$

$$\Rightarrow \ \sum_{n = 0}^{\infty}f^{n}\left( 0 \right)\frac{x^{n}}{n!} = \sum_{n = 0}^{\infty}\frac{\left( - 1 \right)^{n}x^{2n}}{\left( 2n \right)!}$$

ç°åœ¨å›åˆ°åŸæ–¹ç¨‹ï¼Œä¼šæƒ³ä¸€ä¸‹$B^{2}\mathbb{= I}$ã€‚å¯¹äºä»»ä¸€nï¼Œæˆ‘ä»¬æœ‰ï¼š

$$B^{2n} = {{(B}^{2})}^{n} = \mathbb{I}^{n}\mathbb{= I}$$

$$B^{2n + 1} = B{(B^{2})}^{n} = B\mathbb{I}^{n} = B\mathbb{I =}B$$

ä»£å…¥è¿™ä¸ªæ–°ä¿¡æ¯ï¼Œå¾—åˆ°:

$$\sum_{n = 0}^{\infty}\frac{\left( - 1 \right)^{n}\left( \gamma \right)^{2n}\left( B \right)^{2n}}{\left( 2n \right)!} + i\sum_{n = 0}^{\infty}\frac{\left( - 1 \right)^{n}\left( \gamma \right)^{2n + 1}\left( B \right)^{2n + 1}}{\left( 2n + 1 \right)!}\mathbb{= I}\sum_{n = 0}^{\infty}\frac{\left( - 1 \right)^{n}\gamma^{2n}}{\left( 2n \right)!} + iB\sum_{n = 0}^{\infty}{\frac{\left( - 1 \right)^{n}\gamma^{2n + 1}}{\left( 2n + 1 \right)!} = \text{co}s\left( \gamma \right)\mathbb{I +}\text{isin}\left( \gamma \right)B}$$

è¿™ä¸€äº‹å®åœ¨é‡å­è®¡ç®—ä¸­éå¸¸æœ‰ç”¨ã€‚è€ƒè™‘PauliçŸ©é˜µï¼š

$$\sigma_{x} = \left( \frac{0}{1}\ \frac{1}{0} \right)$$

$$\sigma_{y} = \left( \frac{0}{- i}\ \frac{i}{0} \right)$$

$$\sigma_{z} = \left( \frac{1}{0}\ \frac{0}{- 1} \right)$$

è¿™äº›çŸ©é˜µæ˜¯ç”¨æ¥æ“ä½œé‡å­æ¯”ç‰¹çš„åŸºæœ¬"é‡å­é—¨**quantum
gate**"ä¹‹ä¸€ã€‚è¿™äº›æ“ä½œå¹¶éåªæœ‰å¹ºæ­£Unitaryï¼Œè¿˜æœ‰å„ç±³Hermitianå’Œå¯¹åˆInvolutoryã€‚è¡¨æ˜å½¢ä¼¼$e^{\text{iÎ³Ïƒk}}k \in x,y,z$çš„çŸ©é˜µä¸ä»…æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å¹ºæ­£çŸ©é˜µï¼Œè¿˜å¯ä»¥ä½œç”¨äºé‡å­æ€å‘é‡ï¼ˆä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼‰ï¼Œè€Œä¸”å¯ä»¥ç”¨æˆ‘ä»¬åˆšåˆšè¯æ˜çš„æ­£å¼¦ä½™å¼¦ï¼ˆsine-cosineï¼‰å…³ç³»æ¥è¡¨ç¤ºã€‚è¿™ä¸€ç‚¹éå¸¸å¼ºå¤§ï¼Œåœ¨æ•´ä¸ªé‡å­è®¡ç®—ç†è®ºä¸­éƒ½å¯ä»¥çœ‹åˆ°ï¼Œå› ä¸ºæ­¤ç§ç±»å‹çš„é—¨ä¸€ç›´éƒ½åœ¨ä½¿ç”¨ã€‚

å…³äºçŸ©é˜µæŒ‡æ•°æœ€åä¸€ä¸ªé‡è¦çš„äº‹å®ï¼šå¦‚æœæˆ‘ä»¬æœ‰ä¸€äº›çŸ©é˜µğ‘€,ä¸æœ¬å¾å‘é‡\|ğ‘£âŸ©å’Œç›¸åº”çš„æœ¬å¾å€¼ğ‘£,ç„¶åï¼š

$$e^{M}\left| v \right\rangle = e^{v}\left| v \right\rangle$$

ä¸Šå¼æ›´å®¹æ˜“è¯æ˜ï¼š

$$e^{M}\left| v \right\rangle = \sum_{n = 0}^{\infty}\frac{B^{n}\left| v \right\rangle}{n!} = \sum_{n = 0}^{\infty}\frac{v^{n}\left| v \right\rangle}{n!} = e^{v}\left| v \right\rangle$$

è¿™ä¸€äº‹å®ä¹Ÿéå¸¸æœ‰ç”¨ã€‚å½“åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿå“ˆå¯†é¡¿ç®—å­ï¼ˆHamiltonianï¼‰çš„é‡å­å›è·¯ï¼ˆç‰¹åˆ«æ˜¯å˜åˆ†å›è·¯**variational
circuit**ï¼‰æ—¶ï¼Œæˆ‘ä»¬æ—¶å¸¸ä½¿ç”¨$\mathcal{e}^{\text{iÎ³}\sigma_{z}}$å½¢å¼çš„é‡å­é—¨ã€‚ç”±äº$\left| 0 \right\rangle$å’Œ$\left| 1 \right\rangle$æ˜¯$\sigma_{z}$çš„æœ¬å¾å€¼ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“ä»æ•°å­¦ä¸Šç¡®è®¤$\mathcal{e}^{\text{iÎ³}\sigma_{z}}$åŠ ä¸Šç›¸ä½$\mathcal{e}^{\text{iÎ³}}$åå˜ä¸º\|0âŸ©ï¼ŒåŠ ä¸Šç›¸ä½$\mathcal{e}^{- i\gamma}$åå˜ä¸º\|1âŸ©ã€‚å› ä¸ºçŸ¥é“è¯¥é‡å­é—¨æ•°å­¦ç»“æœçš„è®¡ç®—åŸºç¡€ï¼Œæˆ‘ä»¬å¯ä»¥ä¾æ®$\text{CNOT}$å’Œç›¸ä½/æ—‹è½¬é—¨å¾ˆå®¹æ˜“æ„å»ºè¿™ä¸€é‡å­é—¨ã€‚

è¿™ä¸€äº‹å®ä¸ä»…èƒ½åº”ç”¨äº$\sigma_{z}$é—¨çš„æŒ‡æ•°ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®è®¤æœ¬å¾å‘é‡$\sigma_{x}$ä¸Šå½¢å¦‚$\mathcal{e}^{\text{iÎ³}\sigma_{x}}$é—¨çš„ç»“æœ$(|0\rangle + |1\rangle)/\sqrt{2}$å’Œ$(|0\rangle - |1\rangle)/\sqrt{2}$ã€‚åŒæ ·çš„æ“ä½œè¿˜å¯ç”¨äº$\sigma_{z}$çŸ©é˜µã€‚

#### å‚è€ƒæ–‡çŒ®

\[1\] Cayley, Arthur. "A Memoir on the Theory of Matrices."
Philosophical Transactions of the Royal Society of London, vol. 148,
1858, pp. 17--37. JSTOR.

\[2\] A New Branch of Mathematics: The Ausdehnungslehre of 1844 and
Other Works: Hermann Grassmann, Lloyd C. Kannenberg: 9780812692761

1. é‡å­æ€ä¸é‡å­æ¯”ç‰¹
===================

1.1 ç®€ä»‹
--------

å¦‚æœé‡å­åŠ›å­¦å¬èµ·æ¥å¾ˆæœ‰æŒ‘æˆ˜æ€§ï¼Œé‚£ä¹ˆæ‚¨å¹¶ä¸å­¤å†›å¥‹æˆ˜ã€‚æˆ‘ä»¬æ‰€æœ‰çš„ç›´è§‰éƒ½æ˜¯å»ºç«‹åœ¨æ—¥å¸¸ç»éªŒçš„åŸºç¡€ä¸Šï¼Œå› æ­¤æ¯”èµ·åŸå­åŠç”µå­çš„è¡Œä¸ºæ›´å®¹æ˜“ç†è§£çƒå’Œé¦™è•‰çš„è¡Œä¸ºã€‚è™½ç„¶é‡å­å¯¹è±¡ä¸€å¼€å§‹çœ‹èµ·æ¥æ˜¯éšæœºå’Œæ··ä¹±ï¼Œä½†å®ƒä»¬åªæ˜¯éµå¾ªä¸€å¥—ä¸åŒçš„è§„åˆ™ã€‚ä¸€æ—¦æˆ‘ä»¬çŸ¥é“äº†è¿™äº›è§„åˆ™ï¼Œå°±å¯ä»¥åˆ©ç”¨å®ƒä»¬æ¥åˆ›é€ æ–°çš„å¼ºå¤§æŠ€æœ¯ã€‚é‡å­è®¡ç®—å°†æ˜¯è¿™æ–¹é¢æœ€å…·é©å‘½æ€§çš„ä¾‹å­ã€‚

![](pics/media/image37.png)

ä¸ºäº†è®©æ‚¨å¼€å§‹é‡å­è®¡ç®—ä¹‹æ—…ï¼Œå…ˆæµ‹è¯•ä¸€ä¸‹å·²æœ‰çš„çŸ¥è¯†ã€‚ä¸‹åˆ—å“ªä¸€é¡¹æ˜¯å¯¹bitï¼ˆæ¯”ç‰¹ã€ä½ï¼‰çš„æ­£ç¡®æè¿°?

-   æœ¨åŒ ç”¨çš„åˆ€ã€‚

-   æœ€å°çš„ä¿¡æ¯å•ä½0æˆ–1ã€‚

-   æ”¾è¿›é©¬å˜´é‡Œçš„ä¸œè¥¿ã€‚

äº‹å®ä¸Šä¸Šé¢è®²çš„éƒ½å¯¹ï¼ä½†å¦‚æœæ‚¨é€‰æ‹©äº†ç¬¬äºŒä¸ªï¼Œè¡¨æ˜æ‚¨å·²ç»åœ¨æ²¿ç€æ­£ç¡®çš„æ–¹å‘æ€è€ƒäº†ã€‚ä¿¡æ¯å¯ä»¥å­˜å‚¨å’Œå¤„ç†ä¸ºä¸€ç³»åˆ—çš„0å’Œ1æ˜¯ä¸€ä¸ªå·¨å¤§çš„æ¦‚å¿µéšœç¢ï¼Œä½†ä»Šå¤©å¤§å¤šæ•°äººç”šè‡³ä¸åŠ æ€è€ƒå°±çŸ¥é“äº†è¿™ä¸€ç‚¹ã€‚ä»¥æ­¤ä¸ºå‡ºå‘ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹æƒ³è±¡ç¬¦åˆé‡å­åŠ›å­¦è§„åˆ™çš„æ¯”ç‰¹ã€‚è¿™äº›é‡å­æ¯”ç‰¹ï¼ˆ***qubit***ï¼‰ï¼Œå¯ä»¥è®©æˆ‘ä»¬ä»¥æ–°çš„ã€ä¸åŒçš„æ–¹å¼å¤„ç†ä¿¡æ¯ã€‚

![](pics/media/image38.png)

æˆ‘ä»¬å°†å¼€å§‹æ·±å…¥ç ”ç©¶é‡å­æ¯”ç‰¹çš„ä¸–ç•Œï¼Œä¸ºæ­¤éœ€è¦æŸç§æ–¹æ³•æ¥è·Ÿè¸ªä½¿ç”¨é‡å­é—¨æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚æœ€æœ‰æ•ˆçš„æ–¹æ³•æ˜¯ä½¿ç”¨å‘é‡å’ŒçŸ©é˜µçš„æ•°å­¦è¯­è¨€ã€‚

å¯¹äºå·²ç»ç†Ÿæ‚‰å‘é‡å’ŒçŸ©é˜µçš„è¯»è€…æ¥è¯´ï¼Œæœ¬ç« å°†ä¼šäº§ç”Ÿé¢„æœŸç»“æœã€‚é‚£äº›ä¸ç†Ÿæ‚‰çš„äººå¯èƒ½ä¹Ÿä¸ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Œå¯ä»¥å¶å°”å‚è€ƒä¸€ä¸‹å‰ä¸€ç« ä¸­é‡å­è®¡ç®—çš„çº¿æ€§ä»£æ•°ä»‹ç»å¯èƒ½ä¼šå¾ˆæœ‰ç”¨ã€‚

å› ä¸ºæˆ‘ä»¬å°†ä½¿ç”¨Qiskitï¼ŒåŸºäºPythonçš„é‡å­è®¡ç®—æ¡†æ¶ï¼Œäº†è§£Pythonçš„åŸºç¡€çŸ¥è¯†ä¹Ÿä¼šå¾ˆæœ‰ç”¨ã€‚é‚£äº›éœ€è¦å…¥é—¨çš„äººå¯ä»¥æŸ¥é˜…Pythonå’ŒJupyter
Notebookçš„ä»‹ç»ã€‚

1.2 è®¡ç®—çš„åŸºå…ƒ
--------------

ç°ä»Šï¼Œä»»ä½•äººéƒ½å¯ä»¥åœ¨è‡ªå·±èˆ’é€‚çš„å®¶ä¸­ä¸ºé‡å­è®¡ç®—æœºç¼–ç¨‹ã€‚

ä½†æ˜¯åˆ›é€ äº†ä»€ä¹ˆå‘¢ï¼Ÿé‡å­ç¨‹åºåˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿäº‹å®ä¸Šï¼Œä»€ä¹ˆæ˜¯é‡å­è®¡ç®—æœºï¼Ÿ

è¿™äº›é—®é¢˜å¯ä»¥é€šè¿‡ä¸æ ‡å‡†æ•°å­—è®¡ç®—æœºè¿›è¡Œæ¯”è¾ƒæ¥å›ç­”ã€‚ä½†éå¸¸ä¸å¹¸çš„æ˜¯å¤§å¤šæ•°äººä¹Ÿä¸çŸ¥é“æ•°å­—è®¡ç®—æœºçš„å·¥ä½œåŸç†ã€‚åœ¨æœ¬èŠ‚ä¸­æˆ‘ä»¬å°†äº†è§£è¿™äº›è®¾å¤‡èƒŒåçš„åŸºæœ¬åŸç†ã€‚ä¸ºäº†å¸®åŠ©æˆ‘ä»¬ä»¥åè¿‡æ¸¡åˆ°é‡å­è®¡ç®—ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸é‡å­è®¡ç®—ç›¸åŒçš„å·¥å…·ã€‚

å¦‚æœæƒ³ä½¿ç”¨æœ¬é¡µä¸­çš„å…¶ä»–ä»£ç ï¼Œéœ€è¦è¿è¡Œä¸‹é¢çš„Pythonä»£ç ï¼š

> from qiskit import QuantumCircuit, execute, Aer
>
> from qiskit.visualization import plot_histogram

### 1. æŠŠä¿¡æ¯åˆ†è§£æˆæ¯”ç‰¹

æˆ‘ä»¬éœ€è¦çŸ¥é“çš„ç¬¬ä¸€ä»¶äº‹æ˜¯æ¯”ç‰¹ï¼ˆbitï¼‰çš„æ¦‚å¿µã€‚æ¯”ç‰¹è¢«è®¾è®¡æˆä¸–ç•Œä¸Šæœ€ç®€å•çš„å­—æ¯è¡¨ã€‚åªæœ‰ä¸¤ä¸ªå­—ç¬¦ï¼š0å’Œ1ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ¥è¡¨ç¤ºä»»ä½•ä¿¡æ¯ã€‚

æ•°å­—å°±æ˜¯ä¸€ä¸ªä¾‹å­ã€‚æ‚¨å¯èƒ½å·²ç»ä¹ æƒ¯äº†é€šè¿‡ä¸€ä¸ªç”±10ä¸ªæ•°å­—ç»„æˆçš„å­—ä¸²æ¥è¡¨ç¤ºæ•°å­—0ã€1ã€2ã€3ã€4ã€5ã€6ã€7ã€8å’Œ9ã€‚åœ¨è¿™ä¸²æ•°å­—ä¸­ï¼Œæ¯ä¸ªæ•°å­—è¡¨ç¤ºè¯¥æ•°å­—åŒ…å«åçš„ä¸€å®šæ¬¡æ–¹çš„æ¬¡æ•°ã€‚ä¾‹å¦‚ï¼Œå½“æˆ‘ä»¬å†™9213æ—¶ï¼š

$$9000 + 200 + 10 + 3$$

æˆ–è€…ï¼Œç”¨ä¸€ç§å¼ºè°ƒåçš„å¹‚çš„æ–¹å¼æ¥è¡¨è¾¾ï¼š

$$9\mathbf{\times}10^{3} + 2\mathbf{\times}10^{2} + 10\mathbf{\times}10^{1} + 3\mathbf{\times}10^{0}$$

è™½ç„¶æˆ‘ä»¬é€šå¸¸ä½¿ç”¨åŸºäºæ•°å­—10çš„ç³»ç»Ÿï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥å¾ˆå®¹æ˜“åœ°ä½¿ç”¨åŸºäºä»»ä½•å…¶ä»–æ•°å­—çš„ç³»ç»Ÿã€‚ä¾‹å¦‚ï¼ŒäºŒè¿›åˆ¶æ•°å­—ç³»ç»Ÿæ˜¯åŸºäºæ•°å­—2ï¼Œè¡¨æ˜ä½¿ç”¨ä¸¤ä¸ªå­—ç¬¦0å’Œ1å°†æ•°å­—è¡¨ç¤ºä¸º2çš„å¹‚çš„å€æ•°ã€‚ä¾‹å¦‚ï¼ŒæŠŠ9213å˜æˆäº†10001111111101ï¼Œå› ä¸ºï¼š

$$9213\mathbf{=}\left( 1\mathbf{\times}2^{13} \right)\mathbf{+}\left( 0\mathbf{\times}2^{12} \right)\mathbf{+}\left( 0\mathbf{\times}2^{11} \right)\mathbf{+}\left( 0\mathbf{\times}2^{10} \right)\mathbf{+}\left( 1\mathbf{\times}2^{9} \right)\mathbf{+}\left( 1\mathbf{\times}2^{8} \right)\mathbf{+}\left( 1\mathbf{\times}2^{7} \right)\mathbf{+}\left( 1\mathbf{\times}2^{6} \right)\mathbf{+}\left( 1\mathbf{\times}2^{5} \right)\mathbf{+}\left( 1\mathbf{\times}2^{4} \right)\mathbf{+}\left( 1\mathbf{\times}2^{3} \right)\mathbf{+}\left( 1\mathbf{\times}2^{2} \right)\mathbf{+}\left( 0\mathbf{\times}2^{1} \right)\mathbf{+}\left( 1\mathbf{\times}2^{0} \right)$$

åœ¨ä¸Šå¼ä¸­æˆ‘ä»¬å°†æ•°å­—è¡¨ç¤ºä¸º2ã€4ã€8ã€16ã€32ç­‰çš„å€æ•°ï¼Œè€Œé10ã€100ã€1000...ã€‚

è¿™ä¸€ç³»åˆ—æ¯”ç‰¹ï¼Œå³æ‰€è°“çš„äºŒè¿›åˆ¶åºåˆ—ï¼Œå¯ä»¥ç”¨æ¥è¡¨ç¤ºçš„ä¸ä»…ä»…æ˜¯æ•°å­—ã€‚ä¾‹å¦‚ï¼Œæœ‰ä¸€ç§ä½¿ç”¨æ¯”ç‰¹è¡¨ç¤ºä»»ä½•æ–‡æœ¬çš„æ–¹æ³•ã€‚å¯¹äºè¦ä½¿ç”¨çš„ä»»ä½•å­—æ¯ã€æ•°å­—æˆ–æ ‡ç‚¹ç¬¦å·ï¼Œå¯ä»¥ä½¿ç”¨è¡¨1æ‰¾åˆ°æœ€å¤š8ä½çš„å¯¹åº”å­—ä¸²ã€‚è™½ç„¶è¿™äº›éƒ½æ˜¯å¾ˆéšæ„çš„ï¼Œä½†è¿™æ˜¯ä¸€ä¸ªè¢«å¹¿æ³›æ¥å—çš„æ ‡å‡†ã€‚äº‹å®ä¸Šï¼Œæ­£æ˜¯åº”ç”¨è¯¥è¡¨ä¸­çš„å®šä¹‰é€šè¿‡äº’è”ç½‘æŠŠè¿™ç¯‡æ–‡ç« å‘é€ç»™æ‚¨ã€‚

è¡¨1ï¼šASCIIã€åè¿›åˆ¶ã€åå…­è¿›åˆ¶ã€å…«è¿›åˆ¶å’ŒäºŒè¿›åˆ¶å€¼ä¹‹é—´çš„è½¬æ¢

| ASCII                     | Decimal | Hexadecimal | Octal | Binary   |
| ------------------------- | ------- | ----------- | ----- | -------- |
| null                      | 0       | 0           | 0     | 0        |
| start of header           | 1       | 1           | 1     | 1        |
| start of text             | 2       | 2           | 2     | 10       |
| end of text               | 3       | 3           | 3     | 11       |
| end of transmission       | 4       | 4           | 4     | 100      |
| enquire                   | 5       | 5           | 5     | 101      |
| acknowledge               | 6       | 6           | 6     | 110      |
| bell                      | 7       | 7           | 7     | 111      |
| backspace                 | 8       | 8           | 10    | 1000     |
| horizontal tab            | 9       | 9           | 11    | 1001     |
| linefeed                  | 10      | A           | 12    | 1010     |
| vertical tab              | 11      | B           | 13    | 1011     |
| form feed                 | 12      | C           | 14    | 1100     |
| carriage return           | 13      | D           | 15    | 1101     |
| shift out                 | 14      | E           | 16    | 1110     |
| shift in                  | 15      | F           | 17    | 1111     |
| data link escape          | 16      | 10          | 20    | 10000    |
| device control 1/Xon      | 17      | 11          | 21    | 10001    |
| device control 2          | 18      | 12          | 22    | 10010    |
| device control 3/Xoff     | 19      | 13          | 23    | 10011    |
| device control 4          | 20      | 14          | 24    | 10100    |
| negative acknowledge      | 21      | 15          | 25    | 10101    |
| synchronous idle          | 22      | 16          | 26    | 10110    |
| end of transmission block | 23      | 17          | 27    | 10111    |
| cancel                    | 24      | 18          | 30    | 11000    |
| end of medium             | 25      | 19          | 31    | 11001    |
| end of file/ substitute   | 26      | 1A          | 32    | 11010    |
| escape                    | 27      | 1B          | 33    | 11011    |
| file separator            | 28      | 1C          | 34    | 11100    |
| group separator           | 29      | 1D          | 35    | 11101    |
| record separator          | 30      | 1E          | 36    | 11110    |
| unit separator            | 31      | 1F          | 37    | 11111    |
| space                     | 32      | 20          | 40    | 100000   |
| !                         | 33      | 21          | 41    | 100001   |
| "                         | 34      | 22          | 42    | 100010   |
| #                         | 35      | 23          | 43    | 100011   |
| $                         | 36      | 24          | 44    | 100100   |
| %                         | 37      | 25          | 45    | 100101   |
| &                         | 38      | 26          | 46    | 100110   |
| '                         | 39      | 27          | 47    | 100111   |
| (                         | 40      | 28          | 50    | 101000   |
| )                         | 41      | 29          | 51    | 101001   |
| *                         | 42      | 2A          | 52    | 101010   |
| +                         | 43      | 2B          | 53    | 101011   |
| ,                         | 44      | 2C          | 54    | 101100   |
| -                         | 45      | 2D          | 55    | 101101   |
| .                         | 46      | 2E          | 56    | 101110   |
| /                         | 47      | 2F          | 57    | 101111   |
| 0                         | 48      | 30          | 60    | 110000   |
| 1                         | 49      | 31          | 61    | 110001   |
| 2                         | 50      | 32          | 62    | 110010   |
| 3                         | 51      | 33          | 63    | 110011   |
| 4                         | 52      | 34          | 64    | 110100   |
| 5                         | 53      | 35          | 65    | 110101   |
| 6                         | 54      | 36          | 66    | 110110   |
| 7                         | 55      | 37          | 67    | 110111   |
| 8                         | 56      | 38          | 70    | 111000   |
| 9                         | 57      | 39          | 71    | 111001   |
| :                         | 58      | 3A          | 72    | 111010   |
| ;                         | 59      | 3B          | 73    | 111011   |
| <                         | 60      | 3C          | 74    | 111100   |
| =                         | 61      | 3D          | 75    | 111101   |
| >                         | 62      | 3E          | 76    | 111110   |
| ?                         | 63      | 3F          | 77    | 111111   |
| @                         | 64      | 40          | 100   | 1000000  |
| A                         | 65      | 41          | 101   | 1000001  |
| B                         | 66      | 42          | 102   | 1000010  |
| C                         | 67      | 43          | 103   | 1000011  |
| D                         | 68      | 44          | 104   | 1000100  |
| E                         | 69      | 45          | 105   | 1000101  |
| F                         | 70      | 46          | 106   | 1000110  |
| G                         | 71      | 47          | 107   | 1000111  |
| H                         | 72      | 48          | 110   | 1001000  |
| I                         | 73      | 49          | 111   | 1001001  |
| J                         | 74      | 4A          | 112   | 1001010  |
| K                         | 75      | 4B          | 113   | 1001011  |
| L                         | 76      | 4C          | 114   | 1001100  |
| M                         | 77      | 4D          | 115   | 1001101  |
| N                         | 78      | 4E          | 116   | 1001110  |
| O                         | 79      | 4F          | 117   | 1001111  |
| P                         | 80      | 50          | 120   | 1010000  |
| Q                         | 81      | 51          | 121   | 1010001  |
| R                         | 82      | 52          | 122   | 1010010  |
| S                         | 83      | 53          | 123   | 1010011  |
| T                         | 84      | 54          | 124   | 1010100  |
| U                         | 85      | 55          | 125   | 1010101  |
| V                         | 86      | 56          | 126   | 1010110  |
| W                         | 87      | 57          | 127   | 1010111  |
| X                         | 88      | 58          | 130   | 1011000  |
| Y                         | 89      | 59          | 131   | 1011001  |
| Z                         | 90      | 5A          | 132   | 1011010  |
| [                         | 91      | 5B          | 133   | 1011011  |
| \                         | 92      | 5C          | 134   | 1011100  |
| ]                         | 93      | 5D          | 135   | 1011101  |
| ^                         | 94      | 5E          | 136   | 1011110  |
| _                         | 95      | 5F          | 137   | 1011111  |
| `                         | 96      | 60          | 140   | 1100000  |
| a                         | 97      | 61          | 141   | 1100001  |
| b                         | 98      | 62          | 142   | 1100010  |
| c                         | 99      | 63          | 143   | 1100011  |
| d                         | 100     | 64          | 144   | 1100100  |
| e                         | 101     | 65          | 145   | 1100101  |
| f                         | 102     | 66          | 146   | 1100110  |
| g                         | 103     | 67          | 147   | 1100111  |
| h                         | 104     | 68          | 150   | 1101000  |
| i                         | 105     | 69          | 151   | 1101001  |
| j                         | 106     | 6A          | 152   | 1101010  |
| k                         | 107     | 6B          | 153   | 1101011  |
| l                         | 108     | 6C          | 154   | 1101100  |
| m                         | 109     | 6D          | 155   | 1101101  |
| n                         | 110     | 6E          | 156   | 1101110  |
| o                         | 111     | 6F          | 157   | 1101111  |
| p                         | 112     | 70          | 160   | 1110000  |
| q                         | 113     | 71          | 161   | 1110001  |
| r                         | 114     | 72          | 162   | 1110010  |
| s                         | 115     | 73          | 163   | 1110011  |
| t                         | 116     | 74          | 164   | 1110100  |
| u                         | 117     | 75          | 165   | 1110101  |
| v                         | 118     | 76          | 166   | 1110110  |
| w                         | 119     | 77          | 167   | 1110111  |
| x                         | 120     | 78          | 170   | 1111000  |
| y                         | 121     | 79          | 171   | 1111001  |
| z                         | 122     | 7A          | 172   | 1111010  |
| {                         | 123     | 7B          | 173   | 1111011  |
| \|                        | 124     | 7C          | 174   | 1111100  |
| }                         | 125     | 7D          | 175   | 1111101  |
| ~                         | 126     | 7E          | 176   | 1111110  |
| DEL                       | 127     | 7F          | 177   | 1111111  |
|                           | 128     | 80          | 200   | 10000000 |
|                           | 129     | 81          | 201   | 10000001 |
|                           | 130     | 82          | 202   | 10000010 |
|                           | 131     | 83          | 203   | 10000011 |
|                           | 132     | 84          | 204   | 10000100 |
|                           | 133     | 85          | 205   | 10000101 |
|                           | 134     | 86          | 206   | 10000110 |
|                           | 135     | 87          | 207   | 10000111 |
|                           | 136     | 88          | 210   | 10001000 |
|                           | 137     | 89          | 211   | 10001001 |
|                           | 138     | 8A          | 212   | 10001010 |
|                           | 139     | 8B          | 213   | 10001011 |
|                           | 140     | 8C          | 214   | 10001100 |
|                           | 141     | 8D          | 215   | 10001101 |
|                           | 142     | 8E          | 216   | 10001110 |
|                           | 143     | 8F          | 217   | 10001111 |
|                           | 144     | 90          | 220   | 10010000 |
|                           | 145     | 91          | 221   | 10010001 |
|                           | 146     | 92          | 222   | 10010010 |
|                           | 147     | 93          | 223   | 10010011 |
|                           | 148     | 94          | 224   | 10010100 |
|                           | 149     | 95          | 225   | 10010101 |
|                           | 150     | 96          | 226   | 10010110 |
|                           | 151     | 97          | 227   | 10010111 |
|                           | 152     | 98          | 230   | 10011000 |
|                           | 153     | 99          | 231   | 10011001 |
|                           | 154     | 9A          | 232   | 10011010 |
|                           | 155     | 9B          | 233   | 10011011 |
|                           | 156     | 9C          | 234   | 10011100 |
|                           | 157     | 9D          | 235   | 10011101 |
|                           | 158     | 9E          | 236   | 10011110 |
|                           | 159     | 9F          | 237   | 10011111 |
|                           | 160     | A0          | 240   | 10100000 |
|                           | 161     | A1          | 241   | 10100001 |
|                           | 162     | A2          | 242   | 10100010 |
|                           | 163     | A3          | 243   | 10100011 |
|                           | 164     | A4          | 244   | 10100100 |
|                           | 165     | A5          | 245   | 10100101 |
|                           | 166     | A6          | 246   | 10100110 |
|                           | 167     | A7          | 247   | 10100111 |
|                           | 168     | A8          | 250   | 10101000 |
|                           | 169     | A9          | 251   | 10101001 |
|                           | 170     | AA          | 252   | 10101010 |
|                           | 171     | AB          | 253   | 10101011 |
|                           | 172     | AC          | 254   | 10101100 |
|                           | 173     | AD          | 255   | 10101101 |
|                           | 174     | AE          | 256   | 10101110 |
|                           | 175     | AF          | 257   | 10101111 |
|                           | 176     | B0          | 260   | 10110000 |
|                           | 177     | B1          | 261   | 10110001 |
|                           | 178     | B2          | 262   | 10110010 |
|                           | 179     | B3          | 263   | 10110011 |
|                           | 180     | B4          | 264   | 10110100 |
|                           | 181     | B5          | 265   | 10110101 |
|                           | 182     | B6          | 266   | 10110110 |
|                           | 183     | B7          | 267   | 10110111 |
|                           | 184     | B8          | 270   | 10111000 |
|                           | 185     | B9          | 271   | 10111001 |
|                           | 186     | BA          | 272   | 10111010 |
|                           | 187     | BB          | 273   | 10111011 |
|                           | 188     | BC          | 274   | 10111100 |
|                           | 189     | BD          | 275   | 10111101 |
|                           | 190     | BE          | 276   | 10111110 |
|                           | 191     | BF          | 277   | 10111111 |
|                           | 192     | C0          | 300   | 11000000 |
|                           | 193     | C1          | 301   | 11000001 |
|                           | 194     | C2          | 302   | 11000010 |
|                           | 195     | C3          | 303   | 11000011 |
|                           | 196     | C4          | 304   | 11000100 |
|                           | 197     | C5          | 305   | 11000101 |
|                           | 198     | C6          | 306   | 11000110 |
|                           | 199     | C7          | 307   | 11000111 |
|                           | 200     | C8          | 310   | 11001000 |
|                           | 201     | C9          | 311   | 11001001 |
|                           | 202     | CA          | 312   | 11001010 |
|                           | 203     | CB          | 313   | 11001011 |
|                           | 204     | CC          | 314   | 11001100 |
|                           | 205     | CD          | 315   | 11001101 |
|                           | 206     | CE          | 316   | 11001110 |
|                           | 207     | CF          | 317   | 11001111 |
|                           | 208     | D0          | 320   | 11010000 |
|                           | 209     | D1          | 321   | 11010001 |
|                           | 210     | D2          | 322   | 11010010 |
|                           | 211     | D3          | 323   | 11010011 |
|                           | 212     | D4          | 324   | 11010100 |
|                           | 213     | D5          | 325   | 11010101 |
|                           | 214     | D6          | 326   | 11010110 |
|                           | 215     | D7          | 327   | 11010111 |
|                           | 216     | D8          | 330   | 11011000 |
|                           | 217     | D9          | 331   | 11011001 |
|                           | 218     | DA          | 332   | 11011010 |
|                           | 219     | DB          | 333   | 11011011 |
|                           | 220     | DC          | 334   | 11011100 |
|                           | 221     | DD          | 335   | 11011101 |
|                           | 222     | DE          | 336   | 11011110 |
|                           | 223     | DF          | 337   | 11011111 |
|                           | 224     | E0          | 340   | 11100000 |
|                           | 225     | E1          | 341   | 11100001 |
|                           | 226     | E2          | 342   | 11100010 |
|                           | 227     | E3          | 343   | 11100011 |
|                           | 228     | E4          | 344   | 11100100 |
|                           | 229     | E5          | 345   | 11100101 |
|                           | 230     | E6          | 346   | 11100110 |
|                           | 231     | E7          | 347   | 11100111 |
|                           | 232     | E8          | 350   | 11101000 |
|                           | 233     | E9          | 351   | 11101001 |
|                           | 234     | EA          | 352   | 11101010 |
|                           | 235     | EB          | 353   | 11101011 |
|                           | 236     | EC          | 354   | 11101100 |
|                           | 237     | ED          | 355   | 11101101 |
|                           | 238     | EE          | 356   | 11101110 |
|                           | 239     | EF          | 357   | 11101111 |
|                           | 240     | F0          | 360   | 11110000 |
|                           | 241     | F1          | 361   | 11110001 |
|                           | 242     | F2          | 362   | 11110010 |
|                           | 243     | F3          | 363   | 11110011 |
|                           | 244     | F4          | 364   | 11110100 |
|                           | 245     | F5          | 365   | 11110101 |
|                           | 246     | F6          | 366   | 11110110 |
|                           | 247     | F7          | 367   | 11110111 |
|                           | 248     | F8          | 370   | 11111000 |
|                           | 249     | F9          | 371   | 11111001 |
|                           | 250     | FA          | 372   | 11111010 |
|                           | 251     | FB          | 373   | 11111011 |
|                           | 252     | FC          | 374   | 11111100 |
|                           | 253     | FD          | 375   | 11111101 |
|                           | 254     | FE          | 376   | 11111110 |
|                           | 255     | FF          | 377   | 11111111 |

ä»¥ä¸Šå°±æ˜¯æ‰€æœ‰ä¿¡æ¯åœ¨è®¡ç®—æœºä¸­è¡¨ç¤ºçš„æ–¹å¼ã€‚æ— è®ºæ˜¯æ•°å­—ã€å­—æ¯ã€å›¾åƒè¿˜æ˜¯å£°éŸ³ï¼Œéƒ½ä»¥äºŒè¿›åˆ¶å­—ä¸²çš„å½¢å¼å­˜åœ¨ã€‚

å’Œæ ‡å‡†æ•°å­—è®¡ç®—æœºä¸€æ ·ï¼Œé‡å­è®¡ç®—æœºä¹Ÿæ˜¯åŸºäºç›¸åŒçš„åŸºæœ¬åŸç†ã€‚å…¶ä¸»è¦çš„åŒºåˆ«æ˜¯é‡å­è®¡ç®—æœºä½¿ç”¨é‡å­æ¯”ç‰¹ï¼Œé‡å­æ¯”ç‰¹æ˜¯é‡å­åŠ›å­¦çš„å»¶ä¼¸ã€‚åœ¨è¿™æœ¬æ•™ç¨‹çš„å…¶ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†æ¢ç´¢ä»€ä¹ˆæ˜¯é‡å­æ¯”ç‰¹ï¼Œèƒ½åšä»€ä¹ˆä»¥åŠå¦‚ä½•åšåˆ°ã€‚ç„¶è€Œï¼Œåœ¨æœ¬èŠ‚ä¸­æˆ‘ä»¬ä¸è®¨è®ºé‡å­ã€‚æ‰€ä»¥æˆ‘ä»¬ä»…åƒæ¯”ç‰¹ä¸€æ ·ä½¿ç”¨é‡å­æ¯”ç‰¹ã€‚

#### å¿«é€Ÿç»ƒä¹ 

2.  éšæ„çš„æƒ³å‡ºä¸€ä¸ªæ•°å­—ï¼Œå¹¶è¯•ç€ç”¨äºŒè¿›åˆ¶å†™ä¸‹æ¥ã€‚

3.  å¦‚æœä½ æœ‰nä¸ªæ¯”ç‰¹ï¼Œå¯ä»¥è¡¨ç¤ºå¤šå°‘ç§ä¸åŒçš„çŠ¶æ€ï¼Ÿ

### ç”¨å›¾è§£é‡Šè®¡ç®—

æ— è®ºæˆ‘ä»¬ä½¿ç”¨é‡å­æ¯”ç‰¹è¿˜æ˜¯ç»å…¸æ¯”ç‰¹ï¼Œéƒ½éœ€è¦å¯¹å…¶è¿›è¡Œæ“ä½œï¼Œä»¥ä¾¿å°†è¾“å…¥è½¬æ¢æˆéœ€è¦çš„è¾“å‡ºã€‚å¯¹äºéå¸¸ç®€å•çš„å°æ¯”ç‰¹ç¨‹åºæ¥è¯´ï¼Œç”¨å›è·¯å›¾æ¥è¡¨ç¤ºè¿™ä¸ªè¿‡ç¨‹å°±éå¸¸ç›´è§‚äº†ã€‚å·¦è¾¹æ˜¯è¾“å…¥ï¼Œå³è¾¹æ˜¯è¾“å‡ºï¼Œä¸­é—´æ˜¯ç”¨ç¥ç§˜ç¬¦å·è¡¨ç¤ºçš„æ“ä½œã€‚è¿™äº›æ“ä½œè¢«ç§°ä¸º"gateï¼ˆé—¨ï¼‰"ï¼Œè¯¥åç§°çš„å‡ºå¤„æ˜¯å‡ºäºå†å²çš„åŸå› ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªæ ‡å‡†çš„åŸºäºç»å…¸æ¯”ç‰¹çš„è®¡ç®—æœºå›è·¯ä¾‹å­ã€‚æ‚¨ä¸éœ€è¦äº†è§£å…¶çš„åŠŸèƒ½ï¼Œè¯¥å›è·¯åªæ˜¯è®©æ‚¨çŸ¥é“è¿™äº›å›è·¯çš„å¤§æ¦‚æ ·å­ã€‚

![](pics/media/image39.png)

å¯¹äºé‡å­è®¡ç®—æœºï¼Œæˆ‘ä»¬ä½¿ç”¨ç›¸åŒçš„åŸºæœ¬æ€æƒ³ï¼Œä½†å¯¹äºè¡¨ç¤ºè¾“å…¥ã€è¾“å‡ºå’Œç”¨äºæ“ä½œçš„ç¬¦å·æœ‰ä¸åŒçš„çº¦å®šã€‚ä¸‹é¢çš„å°±æ˜¯ä¸€ä¸ªé‡å­å›è·¯ï¼Œè¡¨ç¤ºäº†ä¸ä¸Šå›¾ç›¸åŒçš„è¿‡ç¨‹ã€‚

![](pics/media/image40.png)

åœ¨æœ¬èŠ‚çš„å…¶ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†è§£é‡Šå¦‚ä½•æ„å»ºé‡å­å›è·¯ã€‚åœ¨æœ€åæ‚¨ä¼šçŸ¥é“å¦‚ä½•åˆ›å»ºä¸Šé¢çš„å›è·¯ï¼ŒåŠå…¶ä½œç”¨å’Œæ„ä¹‰ã€‚

### ç¬¬ä¸€ä¸ªé‡å­å›è·¯

åœ¨å›è·¯ä¸­ï¼Œé€šå¸¸éœ€è¦åšä¸‰ä»¶äº‹ï¼šé¦–å…ˆå¯¹è¾“å…¥è¿›è¡Œç¼–ç ï¼Œç„¶åè¿›è¡Œä¸€äº›å®é™…çš„è®¡ç®—ï¼Œæœ€åæå–è¾“å‡ºã€‚å¯¹äºæ‚¨çš„ç¬¬ä¸€ä¸ªé‡å­å›è·¯ï¼Œæˆ‘ä»¬å°†èšç„¦åœ¨è¿™äº›å·¥ä½œçš„æœ€åä¸€ä¸ªã€‚æˆ‘ä»¬é¦–å…ˆåˆ›å»ºä¸€ä¸ªæœ‰8ä¸ªé‡å­æ¯”ç‰¹å’Œ8ä¸ªè¾“å‡ºçš„å›è·¯ã€‚

> n = 8
>
> n_q = n
>
> n_b = n
>
> qc_output = QuantumCircuit(n_q,n_b)

åœ¨ä¸Šè¿°ä»£ç ä¸­åˆ›å»ºçš„é‡å­å›è·¯ç§°ä¹‹ä¸ºqc_outputï¼Œæ˜¯ç”±Qiskitä½¿ç”¨QuantumCircuitåˆ›å»ºçš„ã€‚æ•°å­—n_qå®šä¹‰äº†å›è·¯ä¸­é‡å­æ¯”ç‰¹æ•°é‡ã€‚n_bå®šä¹‰ä¸ºä»æœ€åçš„å›è·¯ä¸­æå–çš„è¾“å‡ºæ¯”ç‰¹æ•°é‡ã€‚

åœ¨é‡å­å›è·¯ä¸­ï¼Œè¾“å‡ºçš„æå–æ˜¯é€šè¿‡ä¸€ç§å«åš**æµ‹é‡ï¼ˆmeasure**ï¼‰çš„æ“ä½œæ¥å®Œæˆçš„ã€‚æ¯ä¸ªæµ‹é‡éƒ½å‘Šè¯‰ä¸€ä¸ªç‰¹å®šé‡å­æ¯”ç‰¹ç»™å‡ºä¸€ä¸ªç‰¹å®šçš„è¾“å‡ºæ¯”ç‰¹ã€‚ä¸‹é¢çš„ä»£ç å‘8ä¸ªé‡å­æ¯”ç‰¹ä¸­çš„æ¯ä¸€ä¸ªéƒ½æ·»åŠ ä¸€ä¸ªæµ‹é‡æ“ä½œã€‚é‡å­æ¯”ç‰¹å’Œæ¯”ç‰¹éƒ½æ˜¯ç”±0åˆ°7çš„æ•°å­—æ ‡è®°çš„ï¼ˆå› ä¸ºç¨‹åºå‘˜å–œæ¬¢è¿™æ ·åšï¼‰ã€‚qc.measure(j,j)å‘½ä»¤å‘å›è·¯qcæ·»åŠ ä¸€ä¸ªæµ‹é‡ï¼Œå‘Šè¯‰é‡å­æ¯”ç‰¹jå‘æ¯”ç‰¹jç»™å‡ºä¸€ä¸ªè¾“å‡ºã€‚

> for j in range(n):
>
> qc_output.measure(j,j)

ç°åœ¨æˆ‘ä»¬çš„å›è·¯ä¸­æœ‰ä¸€äº›ä¸œè¥¿ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ã€‚

qc_output.draw()

![](pics/media/image41.png)

é‡å­æ¯”ç‰¹æ€»æ˜¯åˆå§‹åŒ–ä¸ºè¾“å‡º0ã€‚å› ä¸ºæˆ‘ä»¬æœªå¯¹ä¸Šé¢å›è·¯ä¸­çš„é‡å­æ¯”ç‰¹åšä»»ä½•å¤„ç†ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬æµ‹é‡é‡å­æ¯”ç‰¹æ—¶å¾—åˆ°çš„ç»“æœã€‚å¯ä»¥é€šè¿‡å¤šæ¬¡è¿è¡Œå›è·¯å¹¶å°†ç»“æœç»˜åˆ¶æˆæŸ±çŠ¶å›¾æ¥äº†è§£è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬ä¼šå‘ç°æ¯ä¸ªé‡å­æ¯”ç‰¹çš„ç»“æœæ€»ä¸º00000000ã€‚

> counts =
> execute(qc_output,Aer.get_backend(\'qasm_simulator\')).result().get_counts()
>
> plot_histogram(counts)

![](pics/media/image42.png)

è¿è¡Œå¤šæ¬¡å¹¶å°†ç»“æœæ˜¾ç¤ºä¸ºæŸ±çŠ¶å›¾çš„åŸå› æ˜¯ï¼Œé‡å­è®¡ç®—æœºçš„ç»“æœå¯èƒ½å­˜åœ¨ä¸€äº›éšæœºæ€§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç”±äºæ²¡æœ‰åšä»»ä½•é‡å­è®¡ç®—ï¼Œåªç¡®å®šå¾—åˆ°äº†00000000çš„ç»“æœã€‚

è¯·æ³¨æ„ï¼Œè¿™ä¸€ç»“æœæ¥è‡ªäºä¸€ä¸ªé‡å­æ¨¡æ‹Ÿå™¨ï¼Œå…¶æœ¬è´¨ä»æ˜¯ä¸€ä¸ªæ ‡å‡†çš„è®¡ç®—æœºï¼Œç†æƒ³çš„é‡å­è®¡ç®—æœºä¼šåšä»€ä¹ˆï¼Ÿæ¨¡æ‹Ÿå™¨åªå¯èƒ½è¿è¡Œå°‘é‡çš„é‡å­æ¯”ç‰¹ï¼ˆå¤§çº¦30ä¸ª)ï¼Œä½†ä»æ˜¯è®¾è®¡ç¬¬ä¸€ä¸ªé‡å­å›è·¯æ—¶éå¸¸æœ‰ç”¨çš„å·¥å…·ã€‚è‹¥è¦åœ¨å®é™…è®¾å¤‡ä¸Šè¿è¡Œï¼Œåªéœ€å°†Aer.get_backend(\'qasm_simulator\')æ›¿æ¢ä¸ºæ‚¨æƒ³è¦ä½¿ç”¨è®¾å¤‡çš„åç«¯å¯¹è±¡ã€‚

4.  ### ç¤ºä¾‹ï¼šåˆ›å»ºä¸€ä¸ªåŠ æ³•å›è·¯

    1.  #### ç¼–ç è¾“å…¥

ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•å°†ä¸åŒçš„äºŒè¿›åˆ¶å­—ä¸²ç¼–ç ä¸ºè¾“å…¥ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªè¢«ç§°ä¸º"éé—¨NOT
gate"çš„ä¸œè¥¿ã€‚è¿™æ˜¯æ‚¨åœ¨ç”µè„‘ä¸Šèƒ½åšçš„æœ€åŸºæœ¬æ“ä½œã€‚éé—¨å¯å°†æ¯”ç‰¹å€¼0ç¿»è½¬ä¸º1ï¼Œ1ç¿»è½¬ä¸º0ã€‚åœ¨é‡å­è®¡ç®—ä¸­ä¸€ä¸ªå«åšxçš„è¿ç®—æ¥å®Œæˆ"éé—¨"çš„å·¥ä½œã€‚

åœ¨æœ¬å°èŠ‚ä¸­æˆ‘ä»¬å°†åˆ›å»ºäº†ä¸€ä¸ªåç§°ä¸ºqc_encodeçš„ç”¨äºç¼–ç è¾“å…¥çš„æ–°å›è·¯ã€‚ç°åœ¨åªæŒ‡å®šé‡å­æ¯”ç‰¹çš„æ•°ç›®ã€‚

> qc_encode = QuantumCircuit(n)
>
> qc_encode.x(7)
>
> qc_encode.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image43.png)

æå–ç»“æœå¯ä»¥ä½¿ç”¨ä¹‹å‰çš„å›è·¯ï¼šqc_outputã€‚ä½¿ç”¨qc_encode +
qc_outputå°†åˆ›å»ºä¸€ä¸ªæ–°çš„å›è·¯ï¼Œå…¶ä¸­åŒ…å«æå–åœ¨å›è·¯æœ«ç«¯è¾“å‡ºæ‰€éœ€çš„æ‰€æœ‰å†…å®¹ã€‚

> qc = qc_encode + qc_output
>
> qc.draw(output=\'mpl\',justify=\'none\')
>
> è¾“å‡ºï¼š

![](pics/media/image44.png)

ç°åœ¨å¯ä»¥è¿è¡Œä¸Šè¿°çš„ç»„åˆå›è·¯å¹¶æŸ¥çœ‹ç»“æœã€‚

å¯ä»¥çœ‹åˆ°ç°åœ¨è®¡ç®—æœºè¾“å‡ºçš„æ˜¯å­—ä¸²10000000ã€‚

> counts =
> execute(qc,Aer.get_backend(\'qasm_simulator\')).result().get_counts()
>
> plot_histogram(counts)
>
> è¾“å‡ºï¼š

![](pics/media/image45.png)

æˆ‘ä»¬æ‰€ç¿»è½¬çš„é‚£ä¸ªæ¯”ç‰¹ï¼Œæ¥è‡ªäºé‡å­æ¯”ç‰¹7ï¼Œä½äºå­—ä¸²çš„æœ€å·¦è¾¹ã€‚è¿™æ˜¯å› ä¸ºQiskitå°†å­—ä¸²ä¸­çš„æ¯”ç‰¹ä»å³åˆ°å·¦ç¼–å·ã€‚æœ‰äº›äººå–œæ¬¢ç”¨å¦ä¸€ç§æ–¹å¼ç»™æ¯”ç‰¹ç¼–å·ï¼Œä½†æ˜¯å½“æˆ‘ä»¬ç”¨æ¯”ç‰¹æ¥è¡¨ç¤ºæ•°å­—æ—¶ï¼ŒQiskitçš„ç³»ç»Ÿè‚¯å®šæœ‰å…¶ä¼˜åŠ¿ã€‚å…·ä½“æ¥è¯´ï¼Œé‡å­æ¯”ç‰¹7å‘Šè¯‰æˆ‘ä»¬åœ¨æ•°å­—ä¸­æœ‰å¤šå°‘ä¸ª$2^{7}$ã€‚é€šè¿‡ç¿»è½¬è¿™ä¸ªæ¯”ç‰¹ï¼Œæˆ‘ä»¬ç°åœ¨å·²ç»èƒ½å¤Ÿåœ¨ä¸€ä¸ªç®€å•çš„8ä½è®¡ç®—æœºä¸­å†™å…¥äº†æ•°å­—128ã€‚

ç°åœ¨æ‚¨å¯ä»¥è¯•ç€å†å†™ä¸€ä¸ªæ•°å­—ï¼Œæ¯”å¦‚æ‚¨çš„å¹´é¾„ã€‚åªè¦ç”¨æœç´¢å¼•æ“æ‰¾å‡ºç›¸å¯¹åº”çš„äºŒè¿›åˆ¶æ•°å­—ï¼Œç„¶åå¦‚æœä½ å°äº64å²ï¼Œåœ¨å·¦è¾¹åŠ å‡ ä¸ª0ã€‚

> qc_encode = QuantumCircuit(n)
>
> qc_encode.x(1)
>
> qc_encode.x(5)
>
> qc_encode.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image46.png)

è‡³æ­¤æˆ‘ä»¬äº†è§£äº†å¦‚ä½•åœ¨è®¡ç®—æœºä¸­å¯¹ä¿¡æ¯è¿›è¡Œç¼–ç ã€‚ä¸‹ä¸€æ­¥æ˜¯å¯¹å…¶è¿›è¡Œå¤„ç†ï¼šå°†ç¼–ç çš„è¾“å…¥è½¬æ¢ä¸ºéœ€è¦çš„è¾“å‡ºã€‚

#### 4.2 å›æƒ³å¦‚ä½•åšåŠ æ³•

ä¸ºäº†å°†è¾“å…¥è½¬åŒ–ä¸ºè¾“å‡ºï¼Œæˆ‘ä»¬éœ€è¦è§£å†³ä¸€ä¸ªé—®é¢˜ã€‚ç°åœ¨è®©æˆ‘ä»¬åšä¸€äº›åŸºæœ¬çš„æ•°å­¦è¿ç®—ã€‚åœ¨å°å­¦æ—¶æ‚¨ä¼šå­¦åˆ°å¦‚ä½•æŠŠå¤§çš„æ•°å­¦é—®é¢˜åˆ†è§£æˆå¯å¤„ç†çš„å—ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¦‚ä½•è§£å†³ä¸‹é¢çš„é—®é¢˜ï¼Ÿ

$$\frac{\begin{matrix}
\ \ \ \ \ \ 9213 \\
 + \ \ \ 1854 \\
\end{matrix}}{= \ \ \ \ \ ????}$$

ä¸€ç§æ–¹æ³•æ˜¯ä»å³åˆ°å·¦ä¸€ä½æ•°ä¸€ä½æ•°åœ°ç›¸åŠ ã€‚ä»3+4å¼€å§‹ï¼š

$$\frac{\begin{matrix}
\ \ \ \ \ \ 9213 \\
 + \ \ \ 1854 \\
\end{matrix}}{= \ \ \ \ \ ???7}$$

ç„¶åæ˜¯ï¼š

$$\frac{\begin{matrix}
\ \ \ \ \ \ 9213 \\
 + \ \ \ 1854 \\
\end{matrix}}{= \ \ \ \ \ ??67}$$

æ¥ç€2+8=10ã€‚å› ä¸ºæ‰€å¾—æ˜¯ä¸€ä¸ªä¸¤ä½æ•°çš„ç­”æ¡ˆï¼Œéœ€è¦æŠŠç­”æ¡ˆä¸­çš„1ç§»åˆ°ä¸‹ä¸€åˆ—ã€‚

$$\frac{\begin{matrix}
\ \ \ \ \ \ 9213 \\
 + \ \ \ 1854 \\
\end{matrix}}{\begin{matrix}
 = \ \ \ \ \ ?167 \\
\ \ \ \ \ \ \ \ \ 1\ \ \ \ \ \ \ \ \  \\
\end{matrix}}$$

æœ€åè®¡ç®—9+1+1=11ï¼Œå°±èƒ½è·å–æœ€ç»ˆç»“æœï¼š

$$\frac{\begin{matrix}
\ \ \ \ \ \ 9213 \\
 + \ \ \ 1854 \\
\end{matrix}}{\begin{matrix}
 = \ 11167 \\
\ \ \ \ \ \ \ \ \ 1\ \ \ \ \ \ \ \ \  \\
\end{matrix}}$$

è¿™ä¹Ÿè®¸åªæ˜¯ç®€å•çš„åŠ æ³•ï¼Œä½†å…¶æ¼”ç¤ºäº†æ‰€æœ‰ç®—æ³•èƒŒåçš„åŸç†ã€‚æ— è®ºè¿™ä¸ªç®—æ³•æ˜¯ç”¨æ¥è§£å†³æ•°å­¦é—®é¢˜ï¼Œè¿˜æ˜¯ç”¨æ¥å¤„ç†æ–‡æœ¬æˆ–å›¾åƒï¼Œæˆ‘ä»¬æ€»æ˜¯æŠŠå¤§ä»»åŠ¡åˆ†è§£æˆå°è€Œç®€å•çš„æ­¥éª¤ã€‚

è‹¥è¦åœ¨è®¡ç®—æœºä¸Šè¿è¡Œï¼Œç®—æ³•éœ€è¦è¢«ç¼–è¯‘åˆ°æœ€å°ä¸”æœ€ç®€å•çš„æ­¥éª¤ã€‚ä¸ºäº†çœ‹çœ‹ç®—æ³•çš„æ ·å­ï¼Œæˆ‘ä»¬ç”¨äºŒè¿›åˆ¶å†åšä¸€éä¸Šé¢çš„åŠ æ³•é—®é¢˜ã€‚

$$\frac{\begin{matrix}
\ \ \ \ \ \ 10001111111101 \\
 + \ \ \ 00011100111110 \\
\end{matrix}}{= \ \ \ ?????????????}$$

æ³¨æ„ç¬¬äºŒä¸ªæ•°çš„å·¦è¾¹æœ‰ä¸€ä¸²é¢å¤–çš„0ï¼Œæ˜¯ä¸ºäº†è®©ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ç›¸åŒã€‚

æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä»»åŠ¡æ˜¯å¯¹å³è¾¹çš„åˆ—æ‰§è¡Œ1+0ã€‚äºŒè¿›åˆ¶ä¸ä»»ä½•æ•°å­—ç³»ç»Ÿä¸­ä¸€æ ·ï¼Œå…¶ç»“æœæ˜¯1ã€‚å¯¹äºç¬¬äºŒåˆ—çš„0+1æˆ‘ä»¬å¾—åˆ°äº†ç›¸åŒçš„ç»“æœã€‚

$$\frac{\begin{matrix}
\ \ \ \ \ \ 10001111111101 \\
 + \ \ \ 00011100111110 \\
\end{matrix}}{= \ \ \ ???????????11}$$

ç„¶åæ˜¯1+1ã€‚æ‚¨è‚¯å®šçŸ¥é“1+1=2ã€‚åœ¨äºŒè¿›åˆ¶ä¸­ï¼Œæ•°å­—2è¢«å†™æˆ10ï¼Œå› æ­¤éœ€è¦ä¸¤ä½ï¼Œè¡¨æ˜æˆ‘ä»¬è¦è¿›ä½1ï¼Œå¦‚åŒåœ¨åè¿›åˆ¶ä¸­è¦è¿›ä½10ä¸€æ ·ã€‚

$$\frac{\begin{matrix}
\ \ \ \ \ \ 10001111111101 \\
 + \ \ \ 00011100111110 \\
\end{matrix}}{\begin{matrix}
 = \ \ \ ??????????011 \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1 \\
\end{matrix}}$$

ä¸‹ä¸€åˆ—ç°åœ¨è¦æ±‚è®¡ç®—1+1+1ï¼Œéœ€è¦æŠŠä¸‰ä¸ªæ•°å­—åŠ åœ¨ä¸€èµ·ï¼Œæ‰€ä»¥å¯¹äºè®¡ç®—æœºæ¥è¯´ï¼Œäº‹æƒ…å˜å¾—è¶Šæ¥è¶Šå¤æ‚ã€‚ä½†æ˜¯æˆ‘ä»¬ä»ç„¶å¯ä»¥æŠŠå°†å…¶ç¼–è¯‘æˆæ›´ç®€å•çš„æ“ä½œï¼Œå¹¶ä¸”åªéœ€è¦æŠŠä¸¤ä¸ªæ¯”ç‰¹åŠ åœ¨ä¸€èµ·å°±å¯ä»¥äº†ï¼Œå¯ä»¥ä»å‰ä¸¤ä¸ª1å¼€å§‹ã€‚

$$\frac{\begin{matrix}
\ \ \ \ \ \ \ \ 1 \\
 + \ \ \ \ \ 1 \\
\end{matrix}}{= \ \ 10}$$

ç°åœ¨éœ€è¦æŠŠè¿™ä¸ª10ä¸æœ€åä¸€ä¸ª1ç›¸åŠ ï¼Œæ­¤æ—¶å¯ä»¥æˆ‘ä»¬ç”¨é€šå¸¸çš„æ–¹æ³•æ¥åšã€‚

$$\frac{\begin{matrix}
\ \ \ \ \ \ \ \ 11 \\
 + \ \ \ \ \ 10 \\
\end{matrix}}{= \ \ \ \ 11}$$

æœ€ç»ˆçš„ç»“æœæ˜¯11ï¼ˆä¹Ÿå°±æ˜¯åè¿›åˆ¶çš„3ï¼‰ã€‚

ç°åœ¨å›åˆ°é—®é¢˜çš„å…¶ä½™éƒ¨åˆ†ã€‚æœ‰äº†ç­”æ¡ˆ11ï¼Œæˆ‘ä»¬å°±æœ‰äº†å¦ä¸€ä¸ªè¿›ä½ã€‚

$$\frac{\begin{matrix}
\ \ \ \ \ \ 10001111111101 \\
 + \ \ \ 00011100111110 \\
\end{matrix}}{\begin{matrix}
 = \ \ \ \ ?????????1011 \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 11 \\
\end{matrix}}$$

ç°åœ¨æˆ‘ä»¬è¿˜æœ‰å¦ä¸€ä¸ª1+1+1è¦æ“ä½œã€‚ä½†æˆ‘ä»¬å·²ç»çŸ¥é“æ€ä¹ˆåšäº†ï¼Œæ‰€ä»¥æ²¡ä»€ä¹ˆå¤§ä¸äº†çš„ã€‚

äº‹å®ä¸Šï¼Œåˆ°ç›®å‰ä¸ºæ­¢å‰©ä¸‹çš„äº‹æƒ…æˆ‘ä»¬éƒ½å·²ç»çŸ¥é“å¦‚ä½•å»åšäº†ã€‚è¿™æ˜¯å› ä¸ºï¼Œå¦‚æœæ‚¨æŠŠæ‰€æœ‰çš„ä¸œè¥¿éƒ½åˆ†è§£æˆåŠ 2ä¸ªæ¯”ç‰¹ï¼Œé‚£ä¹ˆå°±åªéœ€è¦è®¡ç®—4ä¸­å¯èƒ½æƒ…å†µã€‚ä»¥ä¸‹æ˜¯å››ä¸­åŸºæœ¬çš„å’Œï¼Œå…¶ä¸­æŠŠæ‰€æœ‰çš„ç­”æ¡ˆç”¨æ¥2ä¸ªæ¯”ç‰¹è¡¨ç¤ºï¼Œä»¥ä¿æŒä¸€è‡´ã€‚

0+0 = 00 (åè¿›åˆ¶ 0+0=0)

0+1 = 01 (åè¿›åˆ¶ 0+1=1)

1+0 = 01 (åè¿›åˆ¶ 1+0=1)

1+1 = 10 (åè¿›åˆ¶ 1+1=2)

è¿™å«åšåŠåŠ å™¨ï¼ˆ**half
adder**ï¼‰ã€‚å¦‚æœæˆ‘ä»¬çš„è®¡ç®—æœºå¯ä»¥å®ç°ï¼Œå¹¶ä¸”å¦‚æœè¯¥è®¡ç®—æœºå¯ä»¥æŠŠè¿™äº›æ“ä½œé“¾æ¥åœ¨ä¸€èµ·ï¼Œé‚£ä¹ˆè¿™ä¸€è®¡ç®—æœºå°±å¯ä»¥ç´¯åŠ ä»»ä¸€å€¼ã€‚

#### 4.3 ä½¿ç”¨Qiskitè¿›è¡ŒåŠ æ³•æ“ä½œ

ç°åœ¨ç”¨Qiskitåˆ¶ä½œæˆ‘ä»¬è‡ªå·±çš„åŠåŠ å™¨ã€‚è¿™ä¸€é‡å­åŠåŠ å™¨ä¸­å°†åŒ…æ‹¬å¯¹è¾“å…¥è¿›è¡Œç¼–ç ã€æ‰§è¡Œç®—æ³•å’Œæå–ç»“æœçš„å›è·¯ã€‚æ¯å½“æˆ‘ä»¬æƒ³è¦ä½¿ç”¨ä¸€ä¸ªæ–°çš„è¾“å…¥æ—¶ï¼Œç¬¬ä¸€ç¼–ç è¾“å…¥éƒ¨åˆ†å°±éœ€è¦æ”¹å˜ï¼Œä½†å…¶ä½™éƒ¨åˆ†å°†ä¼šå§‹ç»ˆä¿æŒä¸å˜ã€‚

![image3](pics/media/image47.png)

æˆ‘ä»¬æƒ³è¦åŠ å…¥çš„ä¸¤ä¸ªæ¯”ç‰¹è¢«ç¼–ç æˆé‡å­æ¯”ç‰¹0å’Œ1ã€‚ä¸Šå›¾çš„ä¾‹å­ä¸­å°†è¿™ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¸­éƒ½ç¼–ç ä¸º1ï¼Œå› æ­¤å…¶å¯»æ±‚çš„æ˜¯1+1çš„è§£ã€‚ç»“æœæ˜¯ä¸€ä¸ªç”±ä¸¤ä¸ªæ¯”ç‰¹ç»„æˆçš„å­—ä¸²ï¼Œå°†ä»é‡å­æ¯”ç‰¹2å’Œ3ä¸­è¯»å‡ºã€‚å‰©ä¸‹çš„å°±æ˜¯å¡«å†™å®é™…ç¨‹åºï¼Œä½äºä¸­é—´çš„ç©ºç™½åŒºåŸŸã€‚

å›¾ä¸­çš„è™šçº¿ä»…æ˜¯ä¸ºäº†åŒºåˆ†å›è·¯çš„ä¸åŒéƒ¨åˆ†ï¼ˆå°½ç®¡ä¹Ÿå¯ä»¥æœ‰æ›´æœ‰è¶£çš„ç”¨é€”ï¼‰ã€‚è™šçº¿æ˜¯ä½¿ç”¨barrierå‘½ä»¤ç”Ÿæˆã€‚

è®¡ç®—çš„åŸºæœ¬æ“ä½œè¢«ç§°ä¸ºé€»è¾‘é—¨ï¼ˆlogic
gateï¼‰ã€‚ä¸Šæ–‡ä¸­æˆ‘ä»¬å·²ç»ä½¿ç”¨äº†éé—¨ï¼Œä½†ä»…æœ‰éé—¨å¹¶ä¸è¶³ä»¥ä½¿å®ç°åŠåŠ å™¨ï¼Œåªèƒ½ç”¨éé—¨æ¥æ‰‹åŠ¨å†™å‡ºç­”æ¡ˆã€‚ä½†æ˜¯æ—¢ç„¶æˆ‘ä»¬æƒ³è®©è®¡ç®—æœºä¸ºæˆ‘ä»¬åšå®é™…çš„è®¡ç®—ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¸€äº›æ›´ä¸ºå¼ºå¤§çš„é€»è¾‘é—¨ã€‚

ä¸ºäº†äº†è§£æˆ‘ä»¬éœ€è¦ä»€ä¹ˆï¼Œå†çœ‹çœ‹åŠåŠ å™¨éœ€è¦åšä»€ä¹ˆã€‚

0+0 = 00

0+1 = 01

1+0 = 01

1+1 = 10

ä¸Šé¢çš„å››ä¸ªç­”æ¡ˆä¸­æœ€å³è¾¹çš„æ¯”ç‰¹å®Œå…¨å–å†³äºæˆ‘ä»¬æ·»åŠ çš„ä¸¤ä¸ªæ¯”ç‰¹æ˜¯ç›¸åŒçš„è¿˜æ˜¯ä¸åŒçš„ã€‚å¯¹äº0+0å’Œ1+1çš„ç­”æ¡ˆæœ€å³è¾¹çš„æ¯”ç‰¹æ˜¯0ã€‚å¯¹äº0+1å’Œ1+0ï¼Œå½“ä¸åŒçš„æ¯”ç‰¹å€¼ç›¸åŠ æ—¶ï¼Œæœ€å³è¾¹çš„æ¯”ç‰¹æ˜¯1ã€‚

ä¸ºäº†ä½¿è¿™éƒ¨åˆ†è§£æ­£ç¡®ï¼Œéœ€è¦ä¸€äº›ä¸œè¥¿æ¥åˆ¤æ–­ä¸¤ä½æ˜¯å¦ä¸åŒã€‚åœ¨ä¼ ç»Ÿæ•°å­—è®¡ç®—çš„ç ”ç©¶ä¸­è¢«ç§°ä¸ºå¼‚æˆ–é—¨ï¼ˆ**XOR
gate**ï¼‰ã€‚

|**Input 1**   |**Input 2**   |**XOR Output**|
|:--|:--|:--|
|0             |0             |0|
|0             |1             |1|
|1             |0             |1|
|1             |1             |0|

åœ¨é‡å­è®¡ç®—æœºä¸­ï¼Œå¼‚æˆ–é—¨çš„å·¥ä½œç”±å—æ§éé—¨ï¼ˆcontrolled-NOT gateï¼‰å®Œæˆçš„ã€‚

> qc_cnot = QuantumCircuit(2)
>
> qc_cnot.cx(0,1)
>
> qc_cnot.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image48.png)

å› ä¸ºè¯¥åå­—å¾ˆé•¿ï¼Œæ‰€ä»¥é€šå¸¸å°±å«åšCNOTï¼ŒQiskitä¸­çš„åå­—æ˜¯cxï¼Œç”šè‡³æ›´çŸ­ã€‚å›è·¯å›¾å¦‚ä¸‹æ‰€ç¤ºï¼š

ä¸Šé¢çš„CNOTä½œç”¨äºä¸€ä¸ªé‡å­æ¯”ç‰¹å¯¹ã€‚å…¶ä¸­ä¸€ä¸ªä½œä¸ºæ§åˆ¶é‡å­æ¯”ç‰¹ï¼ˆæœ‰å°é»‘ç‚¹çš„ï¼‰ã€‚å¦ä¸€ä¸ªä¸ºç›®æ ‡é‡å­æ¯”ç‰¹ï¼ˆæœ‰xçš„ï¼‰ã€‚

ç†è®ºä¸Šæœ‰å¤šç§æ–¹æ³•å¯ä»¥è§£é‡ŠCNOTçš„æ•ˆæœã€‚ä¸€ç§è¯´æ³•æ˜¯å®ƒä¼šæŸ¥çœ‹ä¸¤ä¸ªè¾“å…¥æ¯”ç‰¹ï¼Œæ£€æŸ¥å…¶æ˜¯ç›¸åŒè¿˜æ˜¯ä¸åŒï¼Œç„¶åæŠŠç­”æ¡ˆå†™åœ¨ç›®æ ‡é‡å­æ¯”ç‰¹ä¸Šã€‚å¦‚æœå®ƒä»¬ç›¸åŒï¼Œåˆ™ç›®æ ‡ä¸º0ï¼Œå¦‚æœä¸åŒï¼Œåˆ™ç›®æ ‡ä¸º1ã€‚

![](pics/media/image49.png)

å¦ä¸€ç§è§£é‡ŠCNOTçš„æ–¹æ³•æ˜¯ï¼Œå¦‚æœæ§åˆ¶ç«¯ä¸º1ï¼Œåˆ™å…¶å¯¹ç›®æ ‡æ‰§è¡ŒNOTï¼Œè€Œä¸æ‰§è¡Œå…¶ä»–æ“ä½œã€‚è¿™ä¸€è§£é‡Šå’Œå‰ä¸€è§£é‡ŠåŒæ ·æœ‰æ•ˆï¼ˆäº‹å®ä¸Šï¼Œæ­£æ˜¯ç”±äºè¿™ä¸€è§£é‡Šæ‰ç»™äºˆè¿™ä¸€é€»è¾‘é—¨CNOTçš„åç§°ï¼‰ã€‚

æ‚¨å¯ä»¥é€šè¿‡æ¯ç§å¯èƒ½çš„è¾“å…¥æ¥æµ‹è¯•CNOTã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªç”¨è¾“å…¥01æµ‹è¯•CNOTçš„å›è·¯ã€‚

> qc = QuantumCircuit(2,2)
>
> qc.x(0)
>
> qc.cx(0,1)
>
> qc.measure(0,0)
>
> qc.measure(1,1)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image50.png)

å¦‚æœäº‘å¿ƒè¿™ä¸€å›è·¯ï¼Œæ‚¨ä¼šå‘ç°è¾“å‡ºæ˜¯11ï¼Œè¿™æ˜¯ç”±äºä¸‹è¿°åŸå› ä¹‹ä¸€ï¼š

-   CNOTè®¡ç®—è¾“å…¥å€¼æ˜¯å¦ä¸åŒï¼Œè‹¥å‘ç°ä¸åŒåˆ™è¾“å‡º1ã€‚é€šè¿‡å†™å…¥é‡å­æ¯”ç‰¹1çš„çŠ¶æ€ï¼ˆè®°ä½ï¼Œå®ƒåœ¨æ¯”ç‰¹å­—ä¸²çš„å·¦è¾¹ï¼‰ï¼Œå°†01å˜æˆ11æ¥å®ç°è¿™ä¸€ç‚¹ã€‚

-   CNOTçœ‹åˆ°é‡å­æ¯”ç‰¹0å¤„äºçŠ¶æ€1ï¼Œæ‰€ä»¥å¯¹é‡å­æ¯”ç‰¹1åº”ç”¨NOTã€‚è¿™æ ·å°±æŠŠé‡å­æ¯”ç‰¹1çš„0å˜æˆäº†1ï¼Œä»è€ŒæŠŠ01å˜æˆäº†11ã€‚

ä¸‹é¢æ˜¯CNOTé—¨çš„æ‰€æœ‰å¯èƒ½è¾“å…¥ä¸å¯¹åº”è¾“å‡ºçš„è¡¨æ ¼ï¼š

| Input  (q1 q0) | Output (q1 q0) |
| :------------: | :------------: |
|       0        |       0        |
|       1        |       11       |
|       10       |       10       |
|       11       |       1        |

å¯¹äºåŠåŠ å™¨ï¼Œæˆ‘ä»¬å¹¶ä¸æƒ³è¦è¦†å†™ä¸€ä¸ªè¾“å…¥ã€‚ç›¸åï¼Œæˆ‘ä»¬æƒ³æŠŠç»“æœå†™åœ¨å¦ä¸€å¯¹é‡å­æ¯”ç‰¹ä¸Šï¼Œä¸ºæ­¤å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªCNOTã€‚

> qc_ha = QuantumCircuit(4,2)
>
> \# encode inputs in qubits 0 and 1
>
> qc_ha.x(0) \# For a=0, remove this line. For a=1, leave it.
>
> qc_ha.x(1) \# For b=0, remove this line. For b=1, leave it.
>
> qc_ha.barrier()
>
> \# use cnots to write the XOR of the inputs on qubit 2
>
> qc_ha.cx(0,2)
>
> qc_ha.cx(1,2)
>
> qc_ha.barrier()
>
> \# extract outputs
>
> qc_ha.measure(2,0) \# extract XOR value
>
> qc_ha.measure(3,1)
>
> qc_ha.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image51.png)

æˆ‘ä»¬ç°åœ¨å®ç°äº†ä¸€ä¸ªå®Œå…¨åŠåŠ å™¨çš„ä¸€åŠåŠŸèƒ½ã€‚åªå‰©ä¸‹ç”¨äºè¾“å‡ºçš„æ¯”ç‰¹è¦å¤„ç†ï¼šå­˜åœ¨äºé‡å­æ¯”ç‰¹4ä¸Šçš„æ¯”ç‰¹ã€‚

è‹¥å†çœ‹ä¸€ä¸‹å››ç§å¯èƒ½çš„å’Œï¼Œæ‚¨ä¼šæ³¨æ„åˆ°åªæœ‰ä¸€ç§æƒ…å†µæ˜¯1ä»£æ›¿0ï¼š1+1=10ã€‚åªæœ‰å½“æˆ‘ä»¬åŠ çš„ä¸¤ä¸ªæ¯”ç‰¹éƒ½æ˜¯1æ—¶æ‰ä¼šå‘ç”Ÿã€‚

ä¸ºäº†è®¡ç®—è¿™éƒ¨åˆ†çš„è¾“å‡ºï¼Œæˆ‘ä»¬å¯ä»¥è®©è®¡ç®—æœºçœ‹çœ‹æ˜¯å¦ä¸¤ä¸ªè¾“å…¥éƒ½æ˜¯1ã€‚å½“ä¸”ä»…å½“éƒ½æ˜¯1æ—¶------æˆ‘ä»¬éœ€è¦åœ¨é‡å­æ¯”ç‰¹4ä¸Šåšä¸€ä¸ªéé—¨ï¼ŒæŠŠå€¼ç¿»è½¬åˆ°æ‰€éœ€çš„å€¼1ï¼ˆä»…åœ¨æœ¬ä¾‹ä¸­ï¼‰ï¼Œä»è€Œå¾—åˆ°æƒ³è¦çš„è¾“å‡ºã€‚

ä¸ºæ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°çš„é€»è¾‘é—¨ï¼šä¸CNOTç±»ä¼¼ï¼Œä½†æ§åˆ¶ç«¯åœ¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹è€Œéä¸€ä¸ªã€‚åªæœ‰å½“ä¸¤ä¸ªæ§åˆ¶ç«¯éƒ½å¤„äºçŠ¶æ€1æ—¶ï¼Œæ‰ä¼šå¯¹ç›®æ ‡é‡å­æ¯”ç‰¹æ‰§è¡ŒNOTã€‚è¿™ä¸€æ–°çš„é€»è¾‘é—¨å«åš***Toffolié—¨***ã€‚å¯¹äºç†Ÿæ‚‰å¸ƒå°”é€»è¾‘é—¨çš„äººæ¥è¯´ï¼Œå…¶åŸºæœ¬ä¸Šå°±æ˜¯ä¸€ä¸ªä¸é—¨ï¼ˆ**AND
gate**ï¼‰ã€‚

åœ¨Qiskitä¸­ï¼ŒToffoliç”¨ccxå‘½ä»¤è¡¨ç¤ºã€‚

> qc_ha = QuantumCircuit(4,2)
>
> \# encode inputs in qubits 0 and 1
>
> qc_ha.x(0) \# For a=0, remove the this line. For a=1, leave it.
>
> qc_ha.x(1) \# For b=0, remove the this line. For b=1, leave it.
>
> qc_ha.barrier()
>
> \# use cnots to write the XOR of the inputs on qubit 2
>
> qc_ha.cx(0,2)
>
> qc_ha.cx(1,2)
>
> \# use ccx to write the AND of the inputs on qubit 3
>
> qc_ha.ccx(0,1,3)
>
> qc_ha.barrier()
>
> \# extract outputs
>
> qc_ha.measure(2,0) \# extract XOR value
>
> qc_ha.measure(3,1) \# extract AND value
>
> qc_ha.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image52.png)

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­è®¡ç®—äº†1+1ï¼Œç”±äºä¸¤ä¸ªè¾“å…¥æ¯”ç‰¹éƒ½æ˜¯1ï¼Œçœ‹çœ‹èƒ½å¾—åˆ°ä»€ä¹ˆã€‚

> counts =
> execute(qc_ha,Aer.get_backend(\'qasm_simulator\')).result().get_counts()
>
> plot_histogram(counts)
>
> è¾“å‡ºï¼š

![](pics/media/image53.png)

ç»“æœæ˜¯10ï¼Œæ˜¯åè¿›åˆ¶æ•°å­—2çš„äºŒè¿›åˆ¶è¡¨ç¤ºã€‚æˆ‘ä»¬å·²ç»å»ºç«‹äº†ä¸€ä¸ªèƒ½å¤Ÿè§£å†³è‘—åçš„æ•°å­¦é—®é¢˜1+1çš„è®¡ç®—å™¨ã€‚

ç°åœ¨æ‚¨å¯ä»¥ç”¨å…¶ä»–ä¸‰ç§å¯èƒ½çš„è¾“å…¥è¿›è¡Œå°è¯•ï¼Œå¹¶è¯æ˜ä¸Šè¿°çš„ç®—æ³•ä¹Ÿç»™å‡ºäº†æ­£ç¡®ç»“æœã€‚

åŠåŠ å™¨åŒ…å«äº†æ‰€æœ‰éœ€è¦çš„åŠ æ³•ã€‚ä½¿ç”¨NOTã€CNOTå’ŒToffolié—¨ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºç´¯åŠ ä»»æ„å¤§å°çš„ä»»æ„æ•°å­—çš„ç¨‹åºã€‚

è¿™ä¸‰ä¸ªé—¨ä¹Ÿè¶³ä»¥åœ¨è®¡ç®—æœºé¢†åŸŸåšä»»ä½•äº‹æƒ…ã€‚äº‹å®ä¸Šï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥ä¸ä½¿ç”¨CNOTï¼Œè€Œéé—¨å®é™…ä¸Šåªéœ€è¦åˆ›å»ºå€¼ä¸º1çš„æ¯”ç‰¹ã€‚Toffolié—¨å®è´¨ä¸Šæ˜¯æ•°å­¦çš„åŸºå…ƒï¼Œæ˜¯å…¶ä»–æ‰€æœ‰é—®é¢˜è§£å†³æŠ€æœ¯éƒ½å¯ä»¥ç¼–è¯‘æˆçš„æœ€ç®€å•å…ƒç´ ã€‚

æ­£å¦‚ä¸‹é¢çš„ä»£ç çš„è¾“å‡ºæ‰€ç¤ºï¼Œåœ¨é‡å­è®¡ç®—ä¸­æˆ‘ä»¬ä¼šæ‹†åˆ†åŸºå…ƒã€‚

> import qiskit
>
> qiskit.\_\_qiskit_version\_\_
>
> è¾“å‡ºï¼š
>
> {\'qiskit-terra\': \'0.14.1\',
>
> \'qiskit-aer\': \'0.5.1\',
>
> \'qiskit-ignis\': \'0.3.0\',
>
> \'qiskit-ibmq-provider\': \'0.7.1\',
>
> \'qiskit-aqua\': \'0.7.1\',
>
> \'qiskit\': \'0.19.2\'}

1.3 å‘ˆç°é‡å­æ¯”ç‰¹çš„çŠ¶æ€
----------------------

ç°åœ¨æ‚¨å¯¹æ¯”ç‰¹å’Œæ‰€ç†Ÿæ‚‰çš„æ•°å­—è®¡ç®—æœºçš„å·¥ä½œåŸç†æœ‰äº†ä¸€äº›äº†è§£ã€‚åœ¨ç°ä»£è½¯ä»¶ä¸­ä½¿ç”¨çš„æ‰€æœ‰å¤æ‚å˜é‡ã€å¯¹è±¡å’Œæ•°æ®ç»“æ„åŸºæœ¬ä¸Šéƒ½æ˜¯ä¸€å¤§å †æ¯”ç‰¹ã€‚ä»äº‹é‡å­è®¡ç®—çš„äººç§°ä¹‹ä¸ºç»å…¸å˜é‡ã€‚ä½¿ç”¨ç»å…¸å˜é‡çš„è®¡ç®—æœºï¼Œå°±åƒæ‚¨ç”¨æ¥é˜…è¯»è¿™ç¯‡æ–‡ç« çš„è®¡ç®—æœºï¼Œç§°ä¹‹ä¸ºç»å…¸è®¡ç®—æœºã€‚

åœ¨é‡å­è®¡ç®—æœºä¸­ï¼Œæˆ‘ä»¬çš„åŸºæœ¬å˜é‡æ˜¯é‡å­æ¯”ç‰¹ï¼šæ¯”ç‰¹çš„é‡å­å˜ä½“ã€‚é‡å­æ¯”ç‰¹æ‰€æœ‰çš„é™åˆ¶ä¸ç»å…¸æ¯”ç‰¹å®Œå…¨ç›¸åŒï¼šåªèƒ½å­˜å‚¨å•ä¸ªäºŒè¿›åˆ¶æ¯”ç‰¹çš„ä¿¡æ¯ï¼Œå¹¶ä¸”åªèƒ½è¾“å‡º0æˆ–1ã€‚ç„¶è€Œï¼Œé‡å­æ¯”ç‰¹ä¹Ÿå¯ä»¥è¢«æ“çºµï¼Œä½†åªèƒ½ç”¨é‡å­åŠ›å­¦æ¥æè¿°ã€‚è¿™ä¸€ç‚¹ç»™æˆ‘ä»¬æä¾›äº†æ–°çš„é€‰æ‹©ï¼Œè®©æˆ‘ä»¬å¯ä»¥æ‰¾åˆ°è®¾è®¡ç®—æ³•çš„æ–°æ–¹æ³•ã€‚

è‹¥è¦å®Œå…¨ç†è§£è¿™äº›æ–°çš„é‡å­é—¨ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦ç†è§£å¦‚ä½•å†™å‡ºé‡å­æ€ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å‘é‡ã€çŸ©é˜µå’Œå¤æ•°çš„æ•°å­¦æ–¹æ³•ã€‚è™½ç„¶æˆ‘ä»¬å°†åœ¨è¿›è¡Œè¿‡ç¨‹ä¸­ä»‹ç»è¿™äº›æ¦‚å¿µï¼Œä½†æ˜¯æœ€å¥½æ‚¨å¯¹å…¶æœ‰æ‰€ç†Ÿæ‚‰ã€‚å¦‚æœéœ€è¦æ›´æ·±å…¥çš„è§£é‡Šæˆ–å¤ä¹ ï¼Œå¯ä»¥åœ¨æœ¬æ•™ç¨‹"0.é¢„å¤‡çŸ¥è¯†"çš„çº¿æ€§ä»£æ•°ä¸­æ‰¾åˆ°ç›¸åº”çš„æŒ‡å—ã€‚

### æœ¬èŠ‚çš„å†…å®¹

1.  ç»å…¸æ¯”ç‰¹ä¸é‡å­æ¯”ç‰¹

    1.  æ€å‘é‡

    2.  é‡å­æ¯”ç‰¹çš„è¡¨ç¤ºæ³•

    3.  ä½¿ç”¨Qiskitæ¢ç´¢é‡å­æ¯”ç‰¹

2.  æµ‹é‡è§„åˆ™

> 2.1 ä¸€æ¡éå¸¸é‡è¦çš„è§„åˆ™
>
> 2.2 è¿™ä¸€è§„åˆ™çš„å¯“æ„

3.  Blochçƒ

    1.  æè¿°å—é™é‡å­æ¯”ç‰¹çš„çŠ¶æ€

    2.  ç›´è§‚åœ°å‘ˆç°ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„çŠ¶æ€

```{=html}
<!-- -->
```
1.  ### ç»å…¸æ¯”ç‰¹ä¸é‡å­æ¯”ç‰¹

    1.  #### æ€å‘é‡

åœ¨é‡å­ç‰©ç†ä¸­æˆ‘ä»¬ä½¿ç”¨æ€å‘é‡ï¼ˆ**statevector**ï¼‰æè¿°ä¸€ä¸ªç³»ç»Ÿçš„çŠ¶æ€ã€‚å‡è®¾æˆ‘ä»¬æƒ³æè¿°ä¸€è¾†è½¦æ²¿ç€è½¨é“çš„ä½ç½®ï¼Œåœ¨è¿™ä¸€ç»å…¸çš„ç³»ç»Ÿä¸­å¯ä»¥ç”¨ä¸€ä¸ªæ•°å­—xæè¿°ï¼š

![](pics/media/image54.png)

æˆ–è€…ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªåä¸ºstatevectorå‘é‡ä¸­çš„æ•°å­—é›†åˆæ¥æè¿°ã€‚statevectorä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½å«æœ‰åœ¨æŸä¸€ä½ç½®æ‰¾åˆ°æ±½è½¦çš„æ¦‚ç‡ï¼š

![](pics/media/image55.png)

è¿™ä¸­è¡¨ç¤ºæ–¹æ³•å¹¶ä¸å±€é™äºä½ç½®ï¼Œè¿˜å¯ä»¥ç”¨æ€å‘é‡è®°å½•æ‰€æœ‰å¯èƒ½çš„é€Ÿåº¦ä»¥åŠæ‰€æœ‰å¯èƒ½çš„é¢œè‰²ã€‚åœ¨ç»å…¸ç³»ç»Ÿä¸­ï¼ˆå¦‚ä¸Šé¢çš„æ±½è½¦ä¾‹å­ï¼‰ï¼Œè¿™æ˜¯ä¸€ä»¶æ„šè ¢çš„äº‹æƒ…ï¼Œå› ä¸ºå½“æˆ‘ä»¬åªéœ€è¦ä¸€ä¸ªæ•°å­—æ—¶ï¼Œè¯¥ç³»ç»Ÿéœ€è¦åŒ…å«å·¨é‡çš„å‘é‡ã€‚ä½†æ˜¯æ­£å¦‚æˆ‘ä»¬å°†åœ¨æœ¬ç« ä¸­çœ‹åˆ°çš„ï¼Œæ€å‘é‡ç¢°å·§æ˜¯æŒç»­è·Ÿè¸ªé‡å­ç³»ç»Ÿï¼ˆåŒ…æ‹¬é‡å­è®¡ç®—æœºï¼‰ä¸€ç§éå¸¸å¥½çš„æ–¹æ³•ã€‚

#### é‡å­æ¯”ç‰¹è¡¨ç¤ºæ³•

ç»å…¸æ¯”ç‰¹æ€»æ˜¯æœ‰ä¸€ä¸ªå®Œå…¨è‰¯å¥½å®šä¹‰çš„çŠ¶æ€ï¼šåœ¨è®¡ç®—è¿‡ç¨‹ä¸­çš„æ¯ä¸€ä¸ªç‚¹éƒ½æ˜¯0æˆ–1ã€‚æˆ‘ä»¬ä¸èƒ½åœ¨è¿™ä¸€æ ·çš„ä¸€ä¸ªæ¯”ç‰¹ä¸Šå¢åŠ çŠ¶æ€çš„ç»†èŠ‚ã€‚æ‰€ä»¥è¦å†™å…¥ç»å…¸æ¯”ç‰¹(c)çŠ¶æ€aï¼Œæˆ‘ä»¬ä»…èƒ½ç”¨è¿™ä¸¤ä¸ªäºŒè¿›åˆ¶å€¼ã€‚ä¾‹å¦‚ï¼š

c = 0

é‡å­æ¯”ç‰¹çš„è¿™ç§é™åˆ¶è¢«è§£é™¤äº†ã€‚æ— è®ºæˆ‘ä»¬ä»ä¸€ä¸ªé‡å­æ¯”ç‰¹å¾—åˆ°0è¿˜æ˜¯1ï¼Œåªéœ€è¦åœ¨è¿›è¡Œæµ‹é‡ä»¥æå–è¾“å‡ºæ—¶å®šä¹‰æ¸…æ¥šå³å¯ã€‚æ­¤æ—¶ï¼Œå…¶å¿…é¡»æäº¤æ‰€ä½¿ç”¨çš„è¿™ä¸¤ä¸ªé€‰é¡¹ä¸­çš„ä¸€ä¸ªã€‚åœ¨å…¶ä»–ä»»ä½•æ—¶å€™ï¼Œå…¶çŠ¶æ€éƒ½æ¯”ä¸€ä¸ªç®€å•çš„äºŒè¿›åˆ¶å€¼æ‰€èƒ½æ•æ‰åˆ°çš„è¦å¤æ‚ã€‚

ä¸ºäº†äº†è§£å¦‚ä½•æè¿°è¿™äº›ï¼Œæˆ‘ä»¬å¯ä»¥é¦–å…ˆå…³æ³¨ä¸¤ä¸ªæœ€ç®€å•çš„æƒ…å†µã€‚æ­£å¦‚æˆ‘ä»¬åœ¨ä¸Šä¸€èŠ‚ä¸­æ‰€çœ‹åˆ°çš„ï¼Œæœ‰å¯èƒ½å‡†å¤‡ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼Œä½¿å…¶åœ¨æµ‹é‡æ—¶çš„ç»“æœæ˜ç¡®ä¸º0ã€‚

æˆ‘ä»¬éœ€è¦ä¸ºè¿™ä¸€çŠ¶æ€å‘½åï¼Œå°±å«åš0å§ã€‚ç±»ä¼¼åœ°ï¼Œå­˜åœ¨ä¸€ä¸ªä¸€å®šä¼šè¾“å‡º1çš„é‡å­æ¯”ç‰¹çŠ¶æ€ï¼Œå«åš1ã€‚è¿™ä¸¤ç§çŠ¶æ€å®Œå…¨äº’æ–¥ã€‚è¦ä¹ˆé‡å­æ¯”ç‰¹æ˜ç¡®è¾“å‡º0ï¼Œè¦ä¹ˆæ˜ç¡®è¾“å‡º1ï¼Œæ²¡æœ‰é‡å ã€‚ç”¨æ•°å­¦è¡¨ç¤ºå®ƒçš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ä¸¤ä¸ªæ­£äº¤çš„å‘é‡ã€‚

$$\left| 0 \right\rangle = \begin{bmatrix}
1 \\
0 \\
\end{bmatrix}\text{\ \ }\left| 1 \right\rangle = \begin{bmatrix}
0 \\
1 \\
\end{bmatrix}$$

è¿™æ˜¯ä¸€ä¸ªå¾ˆå¤æ‚çš„æ¦‚å¿µã€‚é¦–å…ˆè®©æˆ‘ä»¬äº†è§£å¥‡æ€ªçš„ç¬¦å·\|å’ŒâŸ©ã€‚è¿™ä¸¤ä¸ªç¬¦å·çš„ä½œç”¨æœ¬è´¨ä¸Šå°±æ˜¯æé†’æˆ‘ä»¬ï¼Œæ‰€è®¨è®ºçš„æ˜¯è¡¨ç¤ºé‡å­æ¯”ç‰¹çŠ¶æ€çš„å‘é‡ï¼Œæ ‡è®°ä¸º0å’Œ1ã€‚è¿™äº›ç¬¦å·æœ‰åŠ©äºæˆ‘ä»¬å°†å…¶ä¸è¯¸å¦‚æ¯”ç‰¹å€¼0å’Œ1æˆ–æ•°å­—0å’Œ1ä¹‹ç±»çš„ä¸œè¥¿åŒºåˆ†å¼€æ¥ã€‚ä¸¤ä¸ªç¬¦å·æ˜¯ç”±ç‹„æ‹‰å…‹å¼•å…¥çš„"ç‹„æ‹‰å…‹ç¬¦å·ï¼ˆbra-ket
notationï¼‰"çš„ä¸€éƒ¨åˆ†ã€‚

å¦‚æœæ‚¨ä¸ç†Ÿæ‚‰å‘é‡ï¼Œå¯ä»¥æŠŠå®ƒä»¬æƒ³è±¡æˆä¸€ä¸²ç”¨ä¸€äº›ç‰¹å®šçš„è§„åˆ™å¤„ç†çš„æ•°å­—ã€‚å¦‚æœæ‚¨åœ¨é«˜ä¸­ç‰©ç†è¯¾ä¸Šç†Ÿæ‚‰å‘é‡ï¼Œå°±ä¼šçŸ¥é“è¿™äº›è§„åˆ™ä½¿å‘é‡éå¸¸é€‚åˆæè¿°æœ‰å¤§å°å’Œæ–¹å‘çš„é‡ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªç‰©ä½“çš„é€Ÿåº¦å¯ä»¥ç”¨å‘é‡å®Œç¾åœ°æè¿°ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ç”¨å‘é‡è¡¨ç¤ºé‡å­æ€çš„æ–¹å¼ä¸æ­¤ç¨æœ‰ä¸åŒã€‚æ‰€ä»¥ä¸è¦å¤ªæ‰§ç€äºä¹‹å‰çš„ç›´è§‰ï¼Œæ˜¯æ—¶å€™åšä¸€äº›æ–°çš„äº‹æƒ…äº†!

é€šè¿‡å‘é‡æˆ‘ä»¬å¯ä»¥æè¿°æ›´å¤æ‚çš„çŠ¶æ€ï¼Œè€Œä¸ä»…ä»…æ˜¯\|0âŸ©å’Œ\|1âŸ©ï¼Œæ¯”å¦‚å‘é‡ï¼š

$$\left| q_{0} \right\rangle = \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{i}{\sqrt{2}} \\
\end{bmatrix}$$

ä¸ºäº†ç†è§£è¿™ä¸€çŠ¶æ€æ‰€ä»£è¡¨çš„å«ä¹‰ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨æ•°å­¦è§„åˆ™æ¥å¤„ç†è¿™ä¸ªå‘é‡ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦ç†è§£å¦‚ä½•å°†å‘é‡ç›¸åŠ ä»¥åŠå¦‚ä½•ä¸æ ‡é‡ç›¸ä¹˜ï¼ˆ**scalar**ï¼‰ã€‚

**æç¤ºï¼šæŒ‰æ ‡é‡è¿›è¡ŒçŸ©é˜µåŠ æ³•å’Œä¹˜æ³•**

ä¸¤ä¸ªå‘é‡ç›¸åŠ ï¼ŒæŠŠå®ƒä»¬çš„å…ƒç´ ç›¸åŠ ï¼š

$$\left| a \right\rangle = \begin{bmatrix}
a_{0} \\
a_{1} \\
 \vdots \\
a_{n} \\
\end{bmatrix}\ ,\ \left| b \right\rangle = \begin{bmatrix}
b_{0} \\
b_{1} \\
 \vdots \\
b_{n} \\
\end{bmatrix}$$

$$\left| a \right\rangle + \left| b \right\rangle = \begin{bmatrix}
a_{0} + b_{0} \\
a_{1} + b_{1} \\
 \vdots \\
a_{n} + b_{n} \\
\end{bmatrix}$$

å°†ä¸€ä¸ªå‘é‡ä¹˜ä»¥ä¸€ä¸ªæ ‡é‡ï¼Œå°±æ˜¯å°†å‘é‡ä¸­çš„æ¯ä¸ªå…ƒç´ ä¹˜ä»¥æ ‡é‡ï¼š

$$x\left| a \right\rangle = \begin{bmatrix}
x \times a_{0} \\
x \times a_{1} \\
 \vdots \\
x \times a_{n} \\
\end{bmatrix}$$

è¿™ä¸¤ä¸ªè§„åˆ™ç”¨äºé‡å†™å‘é‡$\left| q_{0} \right\rangle$(å¦‚ä¸Šæ‰€ç¤º):

$${\left| q_{0} \right\rangle = \frac{1}{\sqrt{2}}\left| 0 \right\rangle + \frac{i}{\sqrt{2}}\left| 1 \right\rangle
}{= \frac{1}{\sqrt{2}}\begin{bmatrix}
1 \\
0 \\
\end{bmatrix} + \frac{i}{\sqrt{2}}\begin{bmatrix}
0 \\
1 \\
\end{bmatrix}
}{= \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
0 \\
\end{bmatrix} + \begin{bmatrix}
0 \\
\frac{i}{\sqrt{2}} \\
\end{bmatrix}
}{= \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{i}{\sqrt{2}} \\
\end{bmatrix}}$$

**æç¤ºï¼šæ ‡å‡†æ­£äº¤åŸº(Orthonormal Base)**

æ­£å¦‚åœ¨ä¹‹å‰ç”³æ˜çš„ä¸€æ ·ï¼Œä¸¤ä¸ªå‘é‡\|0âŸ©å’Œ\|1âŸ©æ­£äº¤ï¼Œè¡¨æ˜è¿™ä¸¤ä¸ªå‘é‡éƒ½æ˜¯æ­£äº¤å’Œæ­£è§„åŒ–ï¼ˆnormalisedï¼‰ã€‚æ­£äº¤è¡¨ç¤ºä¸¤ä¸ªå‘é‡æˆç›´è§’:

![](pics/media/image56.png)

æ­£è§„åŒ–è¡¨ç¤ºå‘é‡çš„å¤§å°ï¼ˆç®­å¤´çš„é•¿åº¦ï¼‰ç­‰äº1ã€‚è‹¥ä¸¤ä¸ªå‘é‡\|0âŸ©å’Œ\|1âŸ©æ˜¯çº¿æ€§æ— å…³,è¡¨æ˜æˆ‘ä»¬ä¸èƒ½æè¿°ç”¨\|1âŸ©æè¿°\|0âŸ©ï¼Œåä¹‹äº¦ç„¶ã€‚ç„¶è€Œ,ä½¿ç”¨å‘é‡\|0âŸ©å’Œ\|1âŸ©ä»¥åŠåŠ æ³•å’Œæ ‡é‡ä¹˜æ³•çš„è§„åˆ™,æˆ‘ä»¬å¯ä»¥æè¿°æ‰€æœ‰å¯èƒ½çš„2Dç©ºé—´ä¸­å‘é‡:

![](pics/media/image57.png)

ç”±äºå‘é‡\|0âŸ©ä¸\|1âŸ©çº¿æ€§æ— å…³,å¹¶ä¸”å¯ä»¥é€šè¿‡ä½¿ç”¨å‘é‡åŠ æ³•å’Œæ ‡é‡ä¹˜æ³•æ¥æè¿°åœ¨2Dç©ºé—´ä¸­çš„ä»»ä¸€å‘é‡,æˆ‘ä»¬è¯´å‘é‡\|0âŸ©å’Œ\|1âŸ©æ˜¯2Dç©ºé—´çš„åŸºã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªå‘é‡éƒ½æ˜¯æ­£äº¤å’Œæ­£è§„ï¼Œæ‰€ä»¥ç§°ä¹‹ä¸ºæ ‡å‡†æ­£äº¤åŸºï¼ˆorthonormal
basisï¼‰ã€‚

ç”±äºçŠ¶æ€\|0âŸ©å’Œ\|1âŸ©å½¢æˆäº†ä¸€ç»„æ ‡å‡†æ­£äº¤åŸºï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è¿™ä¸¤ä¸ªçŠ¶æ€çš„ç»„åˆä»£è¡¨ä»»ä¸€2Då‘é‡ã€‚è¿™å°±å¯ä»¥è®©æˆ‘ä»¬æŠŠé‡å­æ¯”ç‰¹çš„çŠ¶æ€å†™æˆå¦ä¸€ç§å½¢å¼ï¼š

$$\left| q_{0} \right\rangle = \frac{1}{\sqrt{2}}\left| 0 \right\rangle + \frac{i}{\sqrt{2}}\left| 1 \right\rangle$$

å‘é‡$\left| q_{0} \right\rangle$è¢«ç§°ä¸ºé‡å­æ¯”ç‰¹çš„æ€å‘é‡ï¼ˆ**statevector**ï¼‰ï¼Œå‘Šè¯‰æˆ‘ä»¬é‡å­æ¯”ç‰¹æ‰€èƒ½çŸ¥é“çš„ä¸€åˆ‡ã€‚è‡³æ­¤ï¼Œæˆ‘ä»¬åªèƒ½å¾—å‡ºä¸€äº›æœ‰å…³è¿™ä¸€ç‰¹å®šæ€å‘é‡ä¾‹å­çš„ç®€å•ç»“è®ºï¼šå¹¶ä¸å®Œå…¨ä¸º\|0âŸ©ï¼Œä¹Ÿä¸å®Œå…¨ä¸º\|1âŸ©ã€‚ç›¸åï¼Œä¸Šé¢çš„æ€å‘é‡æ˜¯ç”±$\left| 0 \right\rangle$ä¸$\left| 1 \right\rangle$çš„çº¿æ€§ç»„åˆæ¥æè¿°çš„ã€‚åœ¨é‡å­åŠ›å­¦ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸ç”¨"å åŠ ï¼ˆ**superposition**ï¼‰"è¿™ä¸ªè¯æ¥æè¿°ç±»ä¼¼çš„çº¿æ€§ç»„åˆã€‚

æ˜¾ç„¶æˆ‘ä»¬çš„æ€å‘é‡$\left| q_{0} \right\rangle$çš„ç¤ºä¾‹å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ª\|0âŸ©å’Œ\|1âŸ©çš„å åŠ ï¼Œæ²¡æœ‰æ¯”å…¶æ›´èƒ½æ˜ç¡®ä¸”è‰¯å¥½å®šä¹‰çš„é‡å­æ¯”ç‰¹çŠ¶æ€äº†ã€‚ä¸ºäº†è¯´æ˜è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¼€å§‹æ¢ç´¢å¦‚ä½•æ“çºµä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚

#### ä½¿ç”¨Qiskitæ¢ç´¢é‡å­æ¯”ç‰¹

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åœ¨Pythonä¸­å¯¼å…¥éœ€è¦çš„æ‰€æœ‰å·¥å…·ï¼š

> from qiskit import QuantumCircuit, execute, Aer
>
> from qiskit.visualization import plot_histogram, plot_bloch_vector
>
> from math import sqrt, pi

åœ¨Qiskitä¸­ä½¿ç”¨QuantumCircuitå¯¹è±¡æ¥å­˜å‚¨é‡å­å›è·¯ï¼Œæœ¬è´¨ä¸Šæ˜¯å›è·¯ä¸­çš„é‡å­ä»¥åŠæ‰€ä½œç”¨é‡å­æ¯”ç‰¹çš„åˆ—è¡¨ã€‚

qc = QuantumCircuit(1) \# Create a quantum circuit with one qubit

åœ¨é‡å­å›è·¯ä¸­ï¼Œé‡å­æ¯”ç‰¹æ€»æ˜¯ä»¥çŠ¶æ€\|0âŸ©å¼€å§‹ã€‚å¯ä»¥ä½¿ç”¨initialize()æ–¹æ³•å°†å…¶è½¬æ¢ä¸ºä»»ä¸€çŠ¶æ€ã€‚æˆ‘ä»¬ä»¥åˆ—è¡¨çš„å½¢å¼ç»™ä¸æ–¹æ³•initialize()æƒ³è¦çš„å‘é‡ï¼Œå¹¶å‘Šè¯‰å®ƒåˆå§‹åŒ–å“ªä¸€é‡å­æ¯”ç‰¹ä¸ºè¿™ä¸€çŠ¶æ€ï¼š

> qc = QuantumCircuit(1) \# Create a quantum circuit with one qubit
>
> initial_state = \[0,1\] \# Define initial_state as
> $\left| 1 \right\rangle$
>
> qc.initialize(initial_state, 0) \# Apply initialisation operation to
> the 0th qubit
>
> qc.draw() \# Let\'s view our circuit
>
> è¾“å‡ºï¼š

![](pics/media/image58.png)

ç„¶åï¼Œä½¿ç”¨Qiskitçš„æ¨¡æ‹Ÿå™¨ä¹‹ä¸€æ¥æŸ¥çœ‹é‡å­æ¯”ç‰¹çš„ç»“æœçŠ¶æ€ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†ä½¿ç”¨statevectoræ¨¡æ‹Ÿå™¨ï¼Œå°†åœ¨ç¨åè§£é‡Šä¸åŒçš„æ¨¡æ‹Ÿå™¨åŠå…¶ç”¨é€”ã€‚

backend = Aer.get_backend(\'statevector_simulator\') \# Tell Qiskit how
to simulate our circuit

ä¸ºäº†ä»å›è·¯ä¸­å¾—åˆ°ç»“æœï¼Œé€šè¿‡å°†å›è·¯å’Œåç«¯ï¼ˆbackendï¼‰ä½œä¸ºå‚æ•°è¾“å…¥executeä¸­æ¥è¿è¡Œè¯¥å›è·¯ã€‚ç„¶åä½¿ç”¨.result()æ¥è·å¾—ä»¥ä¸‹ç»“æœï¼š

> qc = QuantumCircuit(1) \# Create a quantum circuit with one qubit
>
> initial_state = \[0,1\] \# Define initial_state as
> $\left| 1 \right\rangle$
>
> qc.initialize(initial_state, 0) \# Apply initialisation operation to
> the 0th qubit
>
> result = execute(qc,backend).result() \# Do the simulation, returning
> the result

æ ¹æ®resultï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨.get_statevector()è·å¾—æœ€ç»ˆçš„statevectorï¼š

> qc = QuantumCircuit(1) \# Create a quantum circuit with one qubit
>
> initial_state = \[0,1\] \# Define initial_state as \|1\>
>
> qc.initialize(initial_state, 0) \# Apply initialisation operation to
> the 0th qubit
>
> result = execute(qc,backend).result() \# Do the simulation, returning
> the result
>
> out_state = result.get_statevector()
>
> print(out_state) \# Display the output state vector
>
> è¾“å‡ºï¼š
>
> \[0.+0.j 1.+0.j\]

**æ³¨æ„**ï¼šPythonä½¿ç”¨jè¡¨ç¤ºå¤æ•°çš„iã€‚ä»è¾“å‡ºä¸­å¯ä»¥çœ‹åˆ°ä¸€ä¸ªæœ‰ä¸¤ä¸ªå¤å…ƒç´ çš„å‘é‡ï¼š0.+0.j
= 0ï¼Œå’Œ1 +0.j = 1ã€‚

ç°åœ¨è®©æˆ‘ä»¬åƒåœ¨çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸­ä¸€æ ·æµ‹é‡é‡å­æ¯”ç‰¹ï¼Œæ¥çœ‹çœ‹ç»“æœï¼š

> qc.measure_all()
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image59.png)

è¿™æ¬¡ï¼Œæˆ‘ä»¬ä¸å†ä½¿ç”¨statevectorï¼Œè€Œæ˜¯ä½¿ç”¨.get_counts()æ¥è·å–0å’Œ1ç»“æœçš„è®¡æ•°ï¼š

> result = execute(qc,backend).result()
>
> counts = result.get_counts()
>
> plot_histogram(counts)
>
> è¾“å‡ºï¼š

![](pics/media/image60.png)

å¯ä»¥çœ‹åˆ°,æ¯«æ— ç–‘é—®çš„æœ‰100%çš„æœºä¼šæµ‹é‡å€¼ä¸º\|1âŸ©ã€‚è¿™ä¸€æ¬¡ï¼ŒæŠŠé‡å­æ¯”ç‰¹æ”¾åˆ°å åŠ ä½ç½®ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼Œåœ¨æ­¤æˆ‘ä»¬å°†ä½¿ç”¨åœ¨æœ¬èŠ‚ä¸­ä¹‹å‰çš„çŠ¶æ€$\left| q_{0} \right\rangle$ï¼š

$$\left| q_{0} \right\rangle = \frac{1}{\sqrt{2}}\left| 0 \right\rangle + \frac{i}{\sqrt{2}}\left| 1 \right\rangle$$

æˆ‘ä»¬éœ€è¦å°†è¿™äº›å¹…å€¼æ·»åŠ åˆ°pythonåˆ—è¡¨ä¸­ã€‚ä¸ºäº†è¡¨è¿°å¤æ•°å¹…å€¼ï¼Œæˆ‘ä»¬ä½¿ç”¨å¤æ•°å¹¶ç»™å‡ºå®éƒ¨å’Œè™šéƒ¨ä½œä¸ºå‚æ•°ï¼š

initial_state = \[1/sqrt(2), 1j/sqrt(2)\] \# Define state \|q\>

ç„¶åæˆ‘ä»¬é‡å¤åˆå§‹åŒ–é‡å­æ¯”ç‰¹çš„æ­¥éª¤ï¼š

> qc = QuantumCircuit(1) \# Must redefine qc
>
> qc.initialize(initial_state, 0) \# Initialise the 0th qubit in the
> state \`initial_state\`
>
> state = execute(qc,backend).result().get_statevector() \# Execute the
> circuit
>
> print(state) \# Print the result
>
> è¾“å‡ºï¼š
>
> \[0.70710678+0.j 0.+0.70710678j\]
>
> results = execute(qc,backend).result().get_counts()
>
> plot_histogram(results)
>
> è¾“å‡ºï¼š

![](pics/media/image61.png)

å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æµ‹é‡\|0âŸ©æˆ–\|1âŸ©æ‰€å¾—æ¦‚ç‡ç›¸ç­‰ã€‚ä¸ºäº†å‘æ‚¨è§£é‡Šè¿™ä¸€ç‚¹ï¼Œéœ€è¦è°ˆä¸€è°ˆæµ‹é‡ã€‚

2.  ### æµ‹é‡è§„åˆ™

    1.  #### ä¸€æ¡éå¸¸é‡è¦çš„è§„åˆ™

æœ‰ä¸€æ¡ç®€å•çš„æµ‹é‡è§„åˆ™ã€‚æ‰¾å‡ºåœ¨æˆ‘ä»¬æ‰€åˆ›å»ºçš„æ€$\left| x \right\rangle$ä¸­æµ‹é‡å‡ºæ€$\left| \psi \right\rangle$çš„æ¦‚ç‡ï¼š

$$p(|\psi\rangle) = \left| \left\langle \psi \middle| x \right\rangle \right|^{2}$$

å…¶ä¸­ç¬¦å·âŸ¨å’Œ\|è¡¨ç¤º$\left\langle \psi \right|$æ˜¯ä¸€ä¸ªè¡Œå‘é‡ã€‚åœ¨é‡å­åŠ›å­¦ä¸­ï¼Œæˆ‘ä»¬ç§°åˆ—å‘é‡ä¸ºå³çŸ¢ï¼ˆketï¼‰ï¼Œç§°è¡Œå‘é‡ä¸ºå·¦çŸ¢ï¼ˆbraï¼‰ï¼Œåˆåœ¨ä¸€èµ·æ„æˆäº†ç‹„æ‹‰å…‹ç¬¦å·ã€‚ä»»ä½•å³çŸ¢$\left| a \right\rangle$éƒ½æœ‰å¯¹åº”çš„å·¦çŸ¢$\left\langle a \right|$ï¼Œå¯ä»¥ä½¿ç”¨å…±è½­è½¬ç½®ï¼ˆconjugate
transposeï¼‰å¯¹å…¶è¿›è¡Œè½¬æ¢ã€‚

**æç¤ºï¼šå†…ç§¯ï¼ˆInner Productï¼‰**

å‘é‡ç›¸ä¹˜æœ‰ä¸åŒçš„æ–¹æ³•ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ç”¨å†…ç§¯ã€‚å†…ç§¯æ˜¯ç‚¹ç§¯ï¼ˆ*dot
product*ï¼‰çš„ä¸€èˆ¬åŒ–ï¼Œå¯¹äºç‚¹ç§¯æ‚¨å¯èƒ½å·²ç»å¾ˆç†Ÿæ‚‰äº†ã€‚åœ¨æœ¬æŒ‡å—ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªå·¦çŸ¢(è¡Œå‘é‡)å’Œä¸€ä¸ªå³çŸ¢(åˆ—å‘é‡)ä¹‹é—´çš„å†…ç§¯ï¼Œå…¶éµå¾ªä»¥ä¸‹è§„åˆ™:

$$\langle a| = \left\lbrack a_{0}^{*},a_{1}^{*},\cdots,a_{n}^{*} \right\rbrack\ ,\left| b \right\rangle = \begin{bmatrix}
b_{0} \\
b_{1} \\
 \vdots \\
b_{n} \\
\end{bmatrix}$$

$$\left\langle a \middle| b \right\rangle = a_{0}^{*}b_{0} + a_{1}^{*}b_{1} + \cdots + a_{n}^{*}b_{n}$$

å¯ä»¥çœ‹åˆ°ä¸¤ä¸ªå‘é‡çš„å†…ç§¯æ€»æ˜¯ç»™å‡ºä¸€ä¸ªæ ‡é‡ã€‚è®°ä½å…¶ä¸­ä¸€ä¸ªæœ‰ç”¨çš„æ¦‚å¿µï¼š**ä¸¤ä¸ªæ­£äº¤å‘é‡çš„å†…ç§¯ä¸º0**ã€‚ä¾‹å¦‚,å¦‚æœæœ‰ä¸¤ä¸ªæ­£äº¤å‘é‡$|0\rangle$å’Œ$|1\rangle$ï¼š

$$\left\langle 0 \middle| 1 \right\rangle = \left\lbrack 0,1 \right\rbrack\begin{bmatrix}
1 \\
0 \\
\end{bmatrix} = 0$$

å¦å¤–ï¼Œä¹Ÿåº”è®°ä½å‘é‡$|0\rangle$å’Œ$|1\rangle$ä¹Ÿéƒ½æ˜¯æ­£è§„åŒ–çš„ï¼ˆå¤§å°ç­‰äº1ï¼‰ï¼š

$$\left\langle 0 \middle| 0 \right\rangle = \left\lbrack 1,0 \right\rbrack\begin{bmatrix}
1 \\
0 \\
\end{bmatrix} = 1$$

$$\left\langle 1 \middle| 1 \right\rangle = \left\lbrack 0,1 \right\rbrack\begin{bmatrix}
0 \\
1 \\
\end{bmatrix} = 1$$

åœ¨ä¸Šé¢çš„ç­‰å¼ä¸­ï¼Œ$\left| x \right\rangle$å¯ä»¥æ˜¯é‡å­æ¯”ç‰¹çš„ä»»ä¸€çŠ¶æ€ã€‚ä¸ºäº†æ‰¾å‡ºæµ‹é‡$\left| x \right\rangle$çš„æ¦‚ç‡ï¼Œæˆ‘ä»¬å–$\left| x \right\rangle$å’Œæ‰€æµ‹çŠ¶æ€ï¼ˆæœ¬ç¤ºä¾‹ä¸­ä¸º$\left| \psi \right\rangle$ï¼‰çš„å†…ç§¯ï¼Œç„¶åå¯¹èµ·ç»“æœå–å¹³æ–¹ã€‚å¬ä¸Šå»æœ‰ç‚¹å¤æ‚ï¼Œä½†å¾ˆå¿«å°±ä¼šæˆä¸ºæ‚¨çš„ç¬¬äºŒå¤©æ€§ã€‚

å¦‚æœæˆ‘ä»¬å›å¤´çœ‹ä¸€ä¸‹ä¹‹å‰çš„æ€$\left| q_{0} \right\rangle$ï¼Œèƒ½å¤Ÿçœ‹åˆ°æµ‹é‡$\left| 0 \right\rangle$çš„æ¦‚ç‡æ˜¯0.5ã€‚

$${\left| q_{0} \right\rangle = \frac{1}{\sqrt{2}}\left| 0 \right\rangle + \frac{i}{\sqrt{2}}\left| 1 \right\rangle
}{\langle q_{0}| = \frac{1}{\sqrt{2}}\langle 0| - \frac{i}{\sqrt{2}}\langle 1|
}{\left\langle q_{0} \middle| 0 \right\rangle = \frac{1}{\sqrt{2}}\left\langle 0 \middle| 0 \right\rangle - \frac{i}{\sqrt{2}}\left\langle 1 \middle| 0 \right\rangle
}{\left\langle q_{0} \middle| 0 \right\rangle = \frac{1}{\sqrt{2}} \bullet 1 - \frac{i}{\sqrt{2}} \bullet 0
}{\left\langle q_{0} \middle| 0 \right\rangle = \frac{1}{\sqrt{2}} \Rightarrow {|\left\langle q_{0} \middle| 0 \right\rangle|}^{2} = \frac{1}{2}}$$

æ‚¨å¯ä»¥æŠŠéªŒè¯æµ‹é‡$\left| 1 \right\rangle$çš„æ¦‚ç‡å½“ä½œç»ƒä¹ ã€‚

è¿™ä¸€è§„åˆ™æ”¯é…ç€æˆ‘ä»¬å¦‚ä½•ä»é‡å­æ€å¾—åˆ°ä¿¡æ¯ï¼Œå› æ­¤å¯¹æˆ‘ä»¬åœ¨é‡å­è®¡ç®—ä¸­æ‰€åšçš„ä¸€åˆ‡éƒ½éå¸¸é‡è¦ã€‚è¯¥è§„åˆ™ä¹Ÿç›´æ¥æš—ç¤ºäº†ä¸€äº›é‡è¦çš„äº‹å®ã€‚

#### è¿™ä¸€æ¡è§„åˆ™çš„å¯“æ„

##### \#1 æ ‡å‡†åŒ–ã€æ­£æ€åŒ–ï¼ˆNormalisationï¼‰

è¿™æ¡è§„åˆ™å‘Šè¯‰æˆ‘ä»¬å¹…å€¼ä¸æ¦‚ç‡æœ‰å…³ã€‚å¦‚æœæƒ³è®©æ¦‚ç‡åŠ èµ·æ¥ç­‰äº1ï¼Œéœ€è¦ç¡®ä¿æ€å‘é‡æ°å½“åœ°å½’ä¸€åŒ–ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦æ€å‘é‡çš„å¤§å°ä¸º1ã€‚

$$\left\langle \psi \middle| \psi \right\rangle = 1$$

å› æ­¤ï¼Œå¦‚æœï¼š

$$\left| \psi \right\rangle = \alpha\left| 0 \right\rangle + \beta\left| 1 \right\rangle$$

ç„¶åï¼š

$$\sqrt{\left| \alpha \right|^{2} + \left| \beta \right|^{2}} = 1$$

è¿™å°±è§£é‡Šäº†åœ¨æœ¬ç« ä¸­è§åˆ°è¿‡çš„å› å­$\sqrt{2}$ã€‚äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬è¯•å›¾ç»™initialize()ä¸€ä¸ªæ­£è§„åŒ–çš„å‘é‡ï¼Œå°±ä¼šç»™å‡ºä¸€ä¸ªé”™è¯¯ï¼š

> vector = \[1,1\]
>
> qc.initialize(vector, 0)
>
> è¾“å‡ºï¼š
>
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> QiskitError Traceback (most recent call last)
>
> \<ipython-input-28-ddc73828b990\> in \<module\>
>
> 1 vector = \[1,1\]
>
> \-\-\--\> 2 qc.initialize(vector, 0)
>
> \~/anaconda3/lib/python3.7/site-packages/qiskit/extensions/quantum_initializer/initializer.py
> in initialize(self, params, qubits)
>
> 252 if not isinstance(qubits, list):
>
> 253 qubits = \[qubits\]
>
> \--\> 254 return self.append(Initialize(params), qubits)
>
> 255
>
> 256
>
> \~/anaconda3/lib/python3.7/site-packages/qiskit/extensions/quantum_initializer/initializer.py
> in \_\_init\_\_(self, params)
>
> 56 if not math.isclose(sum(np.absolute(params) \*\* 2), 1.0,
>
> 57 abs_tol=\_EPS):
>
> \-\--\> 58 raise QiskitError(\"Sum of amplitudes-squared does not
> equal one.\")
>
> 59
>
> 60 num_qubits = int(num_qubits)
>
> QiskitError: \'Sum of amplitudes-squared does not equal one.\'

###### å¿«é€Ÿç»ƒä¹ 

1.  æ„å»ºä¸€ä¸ªæ€å‘é‡ï¼Œå…¶èƒ½åœ¨æµ‹é‡$\left| 0 \right\rangle$æ—¶ç»™å‡º1/3çš„æ¦‚ç‡ã€‚

2.  æ„å»ºä¸€ä¸ªä¸åŒçš„æ€å‘é‡ï¼Œä½†èƒ½å¤Ÿç»™å‡ºç›¸åŒçš„æµ‹é‡æ¦‚ç‡ã€‚

3.  éªŒè¯æµ‹é‡$\left| 1 \right\rangle$çš„ä¸¤ä¸ªè¿™ä¸¤ä¸ªæ€çš„æ¦‚ç‡æ˜¯2/3ã€‚

æ‚¨å¯ä»¥åœ¨ä¸‹é¢çš„å°å·¥å…·ä¸­æŸ¥çœ‹ç­”æ¡ˆï¼ˆä½ å¯ä»¥åœ¨å‘é‡ä¸­ä½¿ç”¨"pi"å’Œ"sqrt"ï¼‰ï¼š

> \# Run the code in this cell to interact with the widget
>
> from qiskit_textbook.widgets import state_vector_exercise
>
> state_vector_exercise(target=1/3)
>
> \#qiskit_textbookè¿™ä¸ªæ¨¡å—ä¸€ç›´éƒ½æ²¡æœ‰æ‰¾åˆ°

##### \#2 æ›¿ä»£æµ‹é‡

æµ‹é‡è§„åˆ™ç»™å‡ºäº†$\left| x \right\rangle$ä¸­æµ‹å¾—$\left| \psi \right\rangle$çš„æ¦‚ç‡$p(|x\rangle)$ï¼Œè¿˜å‘Šè¯‰æˆ‘ä»¬$\left| x \right\rangle$è¦ä¹ˆæ˜¯$\left| 0 \right\rangle$ï¼Œè¦ä¹ˆæ˜¯$\left| 1 \right\rangle$ã€‚

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬æ‰€è€ƒè™‘çš„æµ‹é‡å®é™…ä¸Šåªæ˜¯æµ‹é‡ä¸€ä¸ªé‡å­æ¯”ç‰¹æ— æ•°å¯èƒ½æ–¹æ³•ä¸­çš„ä¸€ç§ã€‚å¯¹äºä»»ä½•æ­£äº¤çš„çŠ¶æ€å¯¹ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªåº¦é‡ï¼Œä½¿é‡å­æ¯”ç‰¹åœ¨è¿™ä¸¤ä¸ªçŠ¶æ€ä¹‹é—´è¿›è¡Œé€‰æ‹©ã€‚

ä¸‹ä¸€èŠ‚å°†è¿›ä¸€æ­¥æ¢è®¨è¿™ç§å¯èƒ½æ€§ã€‚ç°åœ¨,è¯·ä»…è®°ä½$\left| x \right\rangle$å¹¶ä¸å±€é™äºåªæ˜¯$\left| 0 \right\rangle$æˆ–$\left| 1 \right\rangle$ã€‚

##### \#3 å…¨å±€ç›¸ä½ï¼ˆGlobal Phaseï¼‰

æˆ‘ä»¬çŸ¥é“æµ‹é‡æ€\|1âŸ©å°†ç»™å‡ºç¡®å®šè¾“å‡º1ã€‚ä½†æ˜¯æˆ‘ä»¬ä¹Ÿå¯ä»¥å†™å‡ºç±»ä¼¼ä»¥ä¸‹çš„çŠ¶æ€ï¼š

$$\begin{bmatrix}
0 \\
i \\
\end{bmatrix} = i\left| 1 \right\rangle$$

ä¸ºäº†äº†è§£å…¶è¡Œä¸ºï¼Œå¯¹å…¶åº”ç”¨æµ‹é‡è§„åˆ™ã€‚

$$\left| \left\langle x \middle| \left( i \middle| 1 \right\rangle \right) \right|^{2} = \left| i\left\langle x \middle| 1 \right\rangle \right|^{2} = \left| \left\langle x \middle| 1 \right\rangle \right|^{2}$$

æ­¤å¤„æˆ‘ä»¬å‘ç°ï¼šä¸€æ—¦å–å¤æ•°çš„å¤§å°æ—¶$i$å°±æ¶ˆå¤±äº†ã€‚è¿™ä¸€æ•ˆæœå®Œå…¨ç‹¬ç«‹äºæ€$\left| x \right\rangle$çš„æµ‹é‡ã€‚æ‰€ä»¥å…¶ä¸æˆ‘ä»¬æƒ³è¦æµ‹é‡çš„æ— å…³ï¼Œæ‰€æµ‹å¾—æ€$i\left| x \right\rangle$çš„æ¦‚ç‡ä¸æµ‹é‡æ€$\left| 1 \right\rangle$å®Œå…¨ä¸€è‡´ã€‚ç”±äºæµ‹é‡æ˜¯æˆ‘ä»¬ä»ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸­æå–ä¿¡æ¯çš„å”¯ä¸€æ–¹æ³•ï¼Œè¡¨æ˜è¿™ä¸¤ç§çŠ¶æ€åœ¨ç‰©ç†ç›¸å…³çš„æ‰€æœ‰æ–¹é¢éƒ½æ˜¯ç­‰ä»·çš„ã€‚

æ›´æ™®éçš„æƒ…å†µæ˜¯ï¼Œæˆ‘ä»¬å°†åœ¨çŠ¶æ€ä¸º$\left| \gamma \right| = 1$ä¸­çš„ä»»ä¸€æ€»ä½“å› å­$\gamma$æŒ‡ç§°ä¸º"å…¨å±€ç›¸ä½"ã€‚ä»…å› å…¨å±€ç›¸ä½è€Œä¸åŒçš„çŠ¶æ€åœ¨ç‰©ç†ä¸Šæ˜¯æ— æ³•åŒºåˆ†çš„ã€‚

$$\left| \left\langle x \middle| \left( \gamma \middle| a \right\rangle \right) \right|^{2} = \left| \gamma\left\langle x \middle| a \right\rangle \right|^{2} = \left| \left\langle x \middle| a \right\rangle \right|^{2}$$

æ³¨æ„ï¼ä¸Šè¿°æ‰€è®²çš„ä¸åŒäºå åŠ ä¹‹é—´çš„ç›¸ä½å·®ï¼Œå åŠ å³æ‰€è°“çš„"ç›¸å¯¹ç›¸ä½ï¼ˆ**relative
phase**ï¼‰"ã€‚ä¸€æ—¦æˆ‘ä»¬è€ƒè™‘ä¸åŒç±»å‹çš„åº¦é‡æ—¶å°±ä¼šå˜ä¸ºç›¸å…³ã€‚

##### \#4 è§‚å¯Ÿè€…æ•ˆåº”ï¼ˆThe Observer Effectï¼‰

æˆ‘ä»¬å·²ç»çŸ¥é“å¹…å€¼åŒ…å«äº†æˆ‘ä»¬åœ¨ç‰¹å®šçŠ¶æ€ä¸‹æ‰¾åˆ°é‡å­æ¯”ç‰¹æ¦‚ç‡çš„ä¿¡æ¯ï¼Œä½†æ˜¯ä¸€æ—¦æˆ‘ä»¬æµ‹é‡äº†é‡å­æ¯”ç‰¹ï¼Œå°±ç¡®åˆ‡åœ°çŸ¥é“äº†é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œå¦‚æœåœ¨ä¸€ä¸ªçŠ¶æ€ä¸‹æµ‹é‡é‡å­æ¯”ç‰¹ï¼š

$$\left| q \right\rangle = \alpha\left| 0 \right\rangle + \beta\left| 1 \right\rangle$$

å‘ç°è¯¥é‡å­æ¯”ç‰¹å¤„äºæ€$\left| 0 \right\rangle$ï¼Œå¦‚æœæˆ‘ä»¬å†æ¬¡æµ‹é‡ï¼Œåˆ™å¯ä»¥100%ç¡®å®šè¯¥é‡å­æ¯”ç‰¹å¤„äºæ€$\left| 0 \right\rangle$ã€‚è¡¨æ˜æµ‹é‡æ“ä½œæ”¹å˜ï¼ˆ*change*ï¼‰äº†é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚

$$\left| q \right\rangle = \begin{bmatrix}
\alpha \\
\beta \\
\end{bmatrix}\overset{\text{Measure}\left| 0 \right\rangle}{\rightarrow}\left| q \right\rangle = \left| 0 \right\rangle = \begin{bmatrix}
1 \\
0 \\
\end{bmatrix}$$

æˆ‘ä»¬æœ‰æ—¶æŠŠè¿™ç§°ä¸ºå¡Œç¼©é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚è¿™æ˜¯ä¸€ç§å¼ºæœ‰åŠ›çš„å½±å“ï¼Œå› æ­¤å¿…é¡»æ˜æ™ºåœ°åŠ ä»¥åˆ©ç”¨ã€‚ä¾‹å¦‚,æˆ‘ä»¬åœ¨æ¯æ¬¡è®¡ç®—æ—¶ä¸æ–­åœ°æµ‹é‡æ¯ä¸ªé‡å­æ¯”ç‰¹æ¥è·Ÿè¸ªå®ƒä»¬çš„å€¼ï¼Œè¿™äº›é‡å­æ¯”ç‰¹éƒ½åªæ˜¯åœ¨è¢«å®šä¹‰æ˜ç¡®çš„çŠ¶æ€\|0âŸ©æˆ–\|1âŸ©ä¹‹ä¸€ã€‚å› æ­¤ï¼Œé‡å­æ¯”ç‰¹ä¸ç»å…¸æ¯”ç‰¹æ²¡æœ‰ä»€ä¹ˆä¸åŒï¼Œæˆ‘ä»¬çš„è®¡ç®—å¯ä»¥å¾ˆå®¹æ˜“è¢«ç»å…¸è®¡ç®—æ‰€å–ä»£ã€‚ä¸ºäº†è·å¾—çœŸæ­£çš„é‡å­è®¡ç®—ï¼Œæˆ‘ä»¬å¿…é¡»å…è®¸é‡å­æ¯”ç‰¹æ¢ç´¢æ›´å¤æ‚çš„çŠ¶æ€ã€‚å› æ­¤ï¼Œåªæœ‰åœ¨éœ€è¦æå–è¾“å‡ºæ—¶æ‰æµ‹é‡ï¼Œå…¶æ„ä¹‰æ˜¯æˆ‘ä»¬ç»å¸¸æŠŠæ‰€æœ‰çš„æµ‹é‡æ”¾åœ¨é‡å­å›è·¯çš„æœ«ç«¯ã€‚

å¯ä»¥ä½¿ç”¨Qiskitçš„statevectoræ¨¡æ‹Ÿå™¨æ¥æ¼”ç¤ºè¿™ä¸€ç‚¹ã€‚é¦–å…ˆåˆå§‹åŒ–ä¸€ä¸ªå åŠ æ€é‡å­æ¯”ç‰¹ï¼š

> qc = QuantumCircuit(1) \# Redefine qc
>
> initial_state = \[0.+1.j/sqrt(2),1/sqrt(2)+0.j\]
>
> qc.initialize(initial_state, 0)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image62.png)

ä¸Šé¢çš„ä»£ç åˆå§‹åŒ–ä¸€ä¸ªé‡å­æ¯”ç‰¹å¤„äºæ€ï¼š

$$\left| q \right\rangle = \frac{i}{\sqrt{2}}\left| 0 \right\rangle + \frac{1}{\sqrt{2}}\left| 1 \right\rangle$$

å¯ä»¥ç”¨æ¨¡æ‹Ÿå™¨æ¥éªŒè¯é‡å­æ¯”ç‰¹æ˜¯å¦å¤„äºä¸Šè¿°çš„çŠ¶æ€ï¼š

> state = execute(qc, backend).result().get_statevector()
>
> print(\"Qubit State = \" + str(state))
>
> è¾“å‡ºï¼š
>
> Qubit State = \[0.+0.70710678j 0.70710678+0.j\]

ä»è¾“å‡ºä¸­å¯ä»¥çœ‹åˆ°é‡å­æ¯”ç‰¹åˆå§‹åŒ–çš„çŠ¶æ€\[0.+0.70710678j
0.70710678+0.j\]ï¼Œæ­£æ˜¯æ‰€æœŸæœ›çš„çŠ¶æ€ã€‚

ç°åœ¨å¯¹è¯¥é‡å­æ¯”ç‰¹è¿›è¡Œæµ‹é‡ï¼š

> qc.measure_all()
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image63.png)

å½“æˆ‘ä»¬æ¨¡æ‹Ÿæ•´ä¸ªå›è·¯æ—¶ï¼Œå¯ä»¥çœ‹åˆ°å…¶ä¸­ä¸€ä¸ªå¹…å€¼æ€»ä¸º0ï¼š

> state = execute(qc, backend).result().get_statevector()
>
> print(\"State of Measured Qubit = \" + str(state))
>
> è¾“å‡ºï¼š
>
> State of Measured Qubit = \[0.+1.j 0.+0.j\]

æ‚¨å¯ä»¥é‡æ–°è¿è¡Œè¿™ä¸ªå•å…ƒå‡ æ¬¡ï¼Œä»¥ä¾¿é‡æ–°åˆå§‹åŒ–é‡å­æ¯”ç‰¹å¹¶å†æ¬¡æµ‹é‡ã€‚æ‚¨å¯èƒ½ä¼šæ³¨æ„åˆ°æ‰€æœ‰çš„æµ‹é‡ç»“æœéƒ½æ˜¯ç­‰å¯èƒ½çš„ï¼Œä½†é‡å­æ¯”ç‰¹çš„çŠ¶æ€ä»æ¥å°±ä¸æ˜¯å åŠ äº†\|0âŸ©å’Œ\|1âŸ©ã€‚æ¯”è¾ƒæœ‰è¶£çš„æ˜¯ï¼Œå…¨å±€ç›¸ä½çŠ¶æ€\|0âŸ©å¹¸å­˜äº†ä¸‹æ¥ï¼Œä½†å› ä¸ºè¿™æ˜¯å…¨å±€ç›¸ä½ï¼Œæˆ‘ä»¬æ°¸è¿œæ— æ³•åœ¨ä¸€ä¸ªçœŸæ­£çš„é‡å­è®¡ç®—æœºä¸­å¯¹å…¶æµ‹é‡ã€‚

####### å…³äºé‡å­æ¨¡æ‹Ÿå™¨çš„è¯´æ˜

ä¾æ®ä¸Šè¿°è¿‡ç¨‹å¯ä»¥çœ‹åˆ°è®°å½•ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„çŠ¶æ€éœ€è¦è·Ÿè¸ªä¸¤ä¸ªå¤æ•°ï¼Œä½†æ˜¯å½“ä½¿ç”¨çœŸæ­£çš„é‡å­è®¡ç®—æœºæ—¶ï¼Œæˆ‘ä»¬åªä¼šæ”¶åˆ°æ¯ä¸ªé‡å­æ¯”ç‰¹å¤„äºæ˜¯æˆ–å¦(0æˆ–1)ç­”æ¡ˆã€‚10-qubitçš„é‡å­è®¡ç®—æœºè¾“å‡ºå¦‚ä¸‹æ‰€ç¤ºï¼š

0110111110

åªæœ‰10ä½ï¼Œæ²¡æœ‰å åŠ åŠå¤æ‚çš„å¹…å€¼ã€‚å½“ä½¿ç”¨çœŸæ­£çš„é‡å­è®¡ç®—æœºæ—¶ï¼Œæˆ‘ä»¬æ— æ³•åœ¨è®¡ç®—è¿‡ç¨‹ä¸­çœ‹åˆ°é‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œå› ä¸ºå¯¹å…¶æµ‹é‡æˆ–ç ´åçŠ¶æ€ï¼è¿™ç§è¡Œä¸ºå¯¹äºå­¦ä¹ æ¥è¯´å¹¶ä¸ç†æƒ³ï¼Œå› æ­¤Qiskitæä¾›äº†ä¸åŒçš„é‡å­æ¨¡æ‹Ÿå™¨ï¼šqasm_simulatorçš„è¡Œä¸ºå°±åƒæ‚¨åœ¨ä¸çœŸæ­£çš„é‡å­è®¡ç®—æœºè¿›è¡Œäº¤äº’ä¸€æ ·ï¼Œå¹¶ä¸”ä¸å…è®¸æ‚¨ä½¿ç”¨.get_statevector()ã€‚æˆ–è€…ä½¿ç”¨statevector_simulatorï¼ˆæ€å‘é‡æ¨¡æ‹Ÿå™¨ï¼‰åœ¨æµ‹é‡ä¹‹å‰æŸ¥çœ‹é‡å­æ€ï¼Œæ­£å¦‚ä½¿ç”¨çš„æ–¹å¼ã€‚

### å¸ƒæ´›èµ«çƒï¼ˆBloch Sphereï¼‰

#### 3.1 æè¿°å—é™çš„é‡å­æ¯”ç‰¹çŠ¶æ€

æˆ‘ä»¬åœ¨æœ¬ç« çš„å…ˆå‰éƒ¨åˆ†çœ‹åˆ°é‡å­æ¯”ç‰¹\|qâŸ©çš„ä¸€èˆ¬çŠ¶æ€ï¼š

$$\left| q \right\rangle = \alpha\left| 0 \right\rangle + \beta\left| 1 \right\rangle$$

$$\alpha,\beta\mathbb{\in C}$$

ï¼ˆç¬¬äºŒè¡Œå‘Šè¯‰æˆ‘ä»¬$\alpha$å’Œ$\beta$æ˜¯å¤æ•°ã€‚ï¼‰ç¬¬2èŠ‚çš„å‰ä¸¤ä¸ªå«æ„å‘Šè¯‰æˆ‘ä»¬ï¼Œæˆ‘ä»¬æ— æ³•åŒºåˆ†å…¶ä¸­çš„çŠ¶æ€ï¼Œè¡¨æ˜å¯ä»¥æ›´å…·ä½“åœ°æè¿°é‡å­æ¯”ç‰¹ã€‚

é¦–å…ˆï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½è¡¡é‡å…¨å±€ç›¸ä½ï¼Œåªèƒ½æµ‹é‡æ€\|0âŸ©å’Œ\|1âŸ©ä¹‹é—´çš„ç›¸ä½å·®å¼‚ã€‚åŠ å…¥Î±å’ŒÎ²å°±å˜å¾—æ›´åŠ å¤æ‚äº†ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶é™åˆ¶åœ¨å®æ•°èŒƒå›´å†…ï¼Œç„¶ååŠ ä¸Šä¸€é¡¹ï¼Œä»¥ä¾¿æ‰¾å‡ºä¹‹é—´çš„ç›¸å¯¹ç›¸ä½ï¼š

$$\left| q \right\rangle = \alpha\left| 0 \right\rangle + e^{\text{iÏ•}}\beta\left| 1 \right\rangle\left( æ¬§æ‹‰å…¬å¼ï¼še^{\text{ix}} = cosx + isinx \right)$$

$$\alpha,\beta,\phi \in \mathbb{R}$$

æœ€åï¼Œç”±äºé‡å­æ¯”ç‰¹çš„çŠ¶æ€å¿…é¡»æ­£è§„åŒ–ï¼Œå³ï¼š

$$\sqrt{\alpha^{2} + \beta^{2}} = 1$$

å¯ä»¥ç”¨ä¸‰è§’æ’ç­‰å¼ï¼š

$$\sqrt{\sin^{2}x + \cos^{2}x} = 1$$

ç”¨ä¸€ä¸ªå˜é‡$\theta$åˆ†åˆ«æè¿°å®æ•°$\alpha$å’Œ$\beta$ï¼š

$\alpha = \cos\frac{\theta}{2}\ ,\ \beta = \sin\frac{\theta}{2}$

#### 3.2 ç›´è§‚åœ°å‘ˆç°ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„çŠ¶æ€

æˆ‘ä»¬ä¼šæƒ³è¦ç»˜åˆ¶å‡ºé€šå¸¸çš„é‡å­æ¯”ç‰¹çŠ¶æ€ï¼š

$$\left| q \right\rangle = \cos\frac{\theta}{2}\left| 0 \right\rangle + e^{\text{iÏ•}}\sin\frac{\theta}{2}\left| 1 \right\rangle$$

å¦‚æœæˆ‘ä»¬å°†$\theta$å’Œ$\phi$æ¼”ç»ä¸ºçƒä½“çš„åæ ‡ï¼ˆr=1ï¼Œå› é‡å­æ¯”ç‰¹çŠ¶æ€çš„å¤§å°æ˜¯1ï¼‰ï¼Œå°±å¯ä»¥åœ¨çƒä½“çš„è¡¨é¢ç»˜åˆ¶å‡ºä»»ä¸€é‡å­æ¯”ç‰¹ï¼Œè¯¥çƒä½“ç§°ä¹‹ä¸ºå¸ƒæ´›èµ«çƒï¼ˆBloch
Sphereï¼‰ã€‚

ä¸‹é¢æˆ‘ä»¬ç»˜åˆ¶äº†ä¸€ä¸ªé‡å­æ¯”ç‰¹\|+âŸ©çš„çŠ¶æ€ï¼Œå…¶ä¸­Î¸=Ï€/2ã€Ï•=0ã€‚

ï¼ˆQiskitæœ‰ä¸€ä¸ªç”¨äºç»˜åˆ¶æ´›èµ«çƒçš„å‡½æ•°plot_bloch_vector()ï¼Œä½†æ˜¯åœ¨ç¼–å†™æœ¬æ–‡æ—¶ï¼Œå®ƒåªä½¿ç”¨ç¬›å¡å°”åæ ‡ã€‚æ‰€ä»¥æˆ‘ä»¬æ·»åŠ äº†ä¸€ä¸ªè‡ªåŠ¨è½¬æ¢çš„å‡½æ•°ã€‚ï¼‰

> from qiskit_textbook.widgets import plot_bloch_vector_spherical
>
> coords = \[pi/2,0,1\] \# \[Theta, Phi, Radius\]
>
> plot_bloch_vector_spherical(coords) \# Bloch Vector with spherical
> coordinates
>
> è¾“å‡ºï¼š

![](pics/media/image64.png)

**è­¦å‘Šï¼**

å½“ç¬¬ä¸€æ¬¡å­¦ä¹ é‡å­æ¯”ç‰¹çš„çŠ¶æ€æ—¶ï¼Œå¾ˆå®¹æ˜“æŠŠé‡å­æ¯”ç‰¹çš„æ€å‘é‡ä¸å…¶Blochå‘é‡æ··æ·†ã€‚è¯·è®°ä½ï¼Œåœ¨æœ¬æ•™ç¨‹1.1ä¸­è®¨è®ºçš„æ€å‘é‡æ˜¯å‘é‡ï¼Œå…¶ä¸­ä¿å­˜äº†é‡å­æ¯”ç‰¹å¯å¤„äºä¸¤ç§çŠ¶æ€çš„å¹…å€¼ã€‚Blochå‘é‡æ˜¯ä¸€ç§å¯è§†åŒ–å·¥å…·ï¼Œå¯ä»¥å°†å¤æ‚äºŒç»´æ€å‘é‡æ˜ å°„åˆ°çœŸå®çš„ä¸‰ç»´ç©ºé—´ã€‚

ä»è¿™ä¸€ç‚¹æ¥çœ‹ï¼Œé€šè¿‡å˜é‡$\phi$å’Œ$\theta$å¯ä»¥æè¿°ä»»ä½•é‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼š

$$\left| q \right\rangle = \cos\frac{\theta}{2}\left| 0 \right\rangle + e^{\text{iÏ•}}\sin\frac{\theta}{2}\left| 1 \right\rangle\ ,\ \ \theta,\phi\mathbb{\in R}$$

#### å¿«é€Ÿç»ƒä¹ 

ä½¿ç”¨plot_bloch_vector()æˆ–plot_bloch_sphere_spherical()ä»¥ä¸‹çŠ¶æ€çš„é‡å­æ¯”ç‰¹ï¼š

1.  $\left| 0 \right\rangle$

2.  $\left| 1 \right\rangle$

3.  $\frac{1}{2}\left( \left| 0 \right\rangle + \left| 1 \right\rangle \right)$

4.  $\frac{1}{2}\left( \left| 0 \right\rangle - i\left| 1 \right\rangle \right)$

5.  $\frac{1}{2}\begin{bmatrix}
    i \\
    1 \\
    \end{bmatrix}$

æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„å°éƒ¨ä»¶ä»çƒåæ ‡è½¬æ¢ä¸ºç¬›å¡å°”åæ ‡ï¼Œå¯å°†è½¬æ¢åçš„åæ ‡ç”¨äºplot_bloch_vector()ï¼š

> from qiskit_textbook.widgets import bloch_calc
>
> bloch_calc()
>
> import qiskit
>
> qiskit.\_\_qiskit_version\_\_
>
> è¾“å‡ºï¼š
>
> {\'qiskit-terra\': \'0.14.1\',
>
> \'qiskit-aer\': \'0.5.1\',
>
> \'qiskit-ignis\': \'0.3.0\',
>
> \'qiskit-ibmq-provider\': \'0.7.1\',
>
> \'qiskit-aqua\': \'0.7.1\',
>
> \'qiskit\': \'0.19.2\'}

1.4 å•é‡å­æ¯”ç‰¹é—¨
----------------

åœ¨ä¹‹å‰çš„ç« èŠ‚ä¸­æˆ‘ä»¬æ‰¾å¯»äº†ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„å¯èƒ½çŠ¶æ€ã€‚æˆ‘ä»¬çœ‹åˆ°é‡å­æ¯”ç‰¹å¯ä»¥ç”¨äºŒç»´å‘é‡è¡¨ç¤ºï¼Œå¹¶ä¸”é‡å­æ¯”ç‰¹çš„çŠ¶æ€è¢«é™åˆ¶ä¸ºï¼š

$$\left| q \right\rangle = \cos\frac{\theta}{2}\left| 0 \right\rangle + e^{\text{iÏ•}}\sin\frac{\theta}{2}\left| 1 \right\rangle$$

å…¶ä¸­$\theta$å’Œ$\phi$æ˜¯å®æ•°ã€‚æœ¬éƒ¨åˆ†çš„å†…å®¹å°†è¦†ç›–é—¨ï¼ˆgateï¼‰ï¼šæ”¹å˜é‡å­æ¯”ç‰¹çŠ¶æ€çš„æ“ä½œã€‚ç”±äºé—¨çš„æ•°é‡åŠå…¶ä¹‹é—´çš„ç›¸ä¼¼æ€§ï¼Œæœ¬ç« æœ‰æˆä¸ºä¸€ä¸ªåˆ—è¡¨çš„é£é™©ã€‚ä¸ºäº†è§£å†³è¿™ä¸€é—®é¢˜ï¼Œæˆ‘ä»¬åœ¨æœ¬ç« ä¸­é€‚å½“çš„åœ°æ–¹åŠ å…¥äº†ä¸€äº›é¢˜å¤–è¯æ¥ä»‹ç»é‡è¦çš„æ€æƒ³ã€‚

### å†…å®¹

1.  æ³¡åˆ©é—¨ï¼ˆPauli Gateï¼‰

    1.  æ³¡åˆ©Xé—¨ï¼ˆPauli X-Gateï¼‰

    2.  æ³¡åˆ©Yå’ŒZé—¨ï¼ˆPauli Y-Gate ã€Pauli Z-Gateï¼‰

2.  é¢˜å¤–è¯ï¼šXã€Yå’ŒZ-åŸº

3.  é˜¿è¾¾é©¬é—¨ï¼ˆHadamard Gateï¼‰

4.  é¢˜å¤–è¯ï¼šä»¥ä¸åŒçš„åŸºæµ‹é‡

5.  $R_{\phi}$é—¨ï¼ˆR~Ï•~-gateï¼‰

6.  Iã€Så’ŒT-é—¨ï¼ˆIã€Sã€T-gatesï¼‰

> 6.1 I-Gate
>
> 6.2 S-Gate
>
> 6.3 T-Gate

7.  é€šç”¨U~3~é—¨ï¼ˆU~3~-gateï¼‰

åœ¨åŸºå…ƒçš„è®¡ç®—ä¸­ä¼šé‡åˆ°äº†ä¸€äº›é—¨ï¼Œå¹¶ç”¨å®ƒä»¬æ¥è¿›è¡Œç»å…¸çš„è®¡ç®—ã€‚é‡å­å›è·¯çš„ä¸€ä¸ªé‡è¦ç‰¹å¾æ˜¯åœ¨åˆå§‹åŒ–é‡å­æ¯”ç‰¹å’Œæµ‹é‡é‡å­æ¯”ç‰¹ä¹‹é—´ï¼Œæ“ä½œï¼ˆgateï¼‰æ€»æ˜¯å¯é€†çš„ï¼è¿™äº›å¯é€†çš„é—¨å¯ä»¥è¡¨ç¤ºä¸ºçŸ©é˜µï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºä¸ºç»•å¸ƒæ´›èµ«çƒçš„æ—‹è½¬ã€‚

> from qiskit import \*
>
> from math import pi
>
> from qiskit.visualization import plot_bloch_multivector

### æ³¡åˆ©é—¨ï¼ˆPauli Gateï¼‰

æ‚¨åº”è¯¥ç†Ÿæ‚‰çº¿æ€§ä»£æ•°éƒ¨åˆ†çš„æ³¡åˆ©çŸ©é˜µã€‚å¦‚æœæœ¬éƒ¨åˆ†ä¸­çš„æ•°å­¦çŸ¥è¯†å¯¹äºæ‚¨æ¥è¯´ä»æœªé‡åˆ°ï¼Œé‚£ä¹ˆåº”è¯¥ä½¿ç”¨æœ¬æ•™ç¨‹çš„çº¿æ€§ä»£æ•°éƒ¨åˆ†æ¥åŠ å¿«é˜…è¯»é€Ÿåº¦ã€‚æˆ‘ä»¬å°†åœ¨æœ¬éƒ¨åˆ†ä¸­äº†è§£åˆ°æ³¡åˆ©çŸ©é˜µå¯ä»¥ç”¨äºè¡¨ç¤ºä¸€äº›éå¸¸å¸¸ç”¨çš„é‡å­é—¨ã€‚

#### æ³¡åˆ© X-é—¨ï¼ˆPauli X-Gateï¼‰

Pauli X-é—¨å¯ç”¨Pauli-XçŸ©é˜µè¡¨ç¤ºï¼š

$$X = \left\lbrack \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right\rbrack = |0\rangle\langle 1| + |1\rangle\langle 0|$$

è¦æŸ¥çœ‹ä¸€ä¸ªé—¨å¯¹ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„å½±å“ï¼Œåªéœ€å°†è¿™ä¸ªé‡å­æ¯”ç‰¹çš„æ€å‘é‡ä¹˜ä»¥æ”¹é—¨ã€‚å¯ä»¥çœ‹åˆ°ï¼šX-gateå°†é‡å­æ¯”ç‰¹çŠ¶æ€çš„å¹…å€¼\|0âŸ©è½¬æ¢ä¸º\|1âŸ©ï¼š

$$X\left| 0 \right\rangle = \left\lbrack \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right\rbrack\begin{bmatrix}
1 \\
0 \\
\end{bmatrix} = \begin{bmatrix}
0 \\
1 \\
\end{bmatrix} = \left| 1 \right\rangle$$

**æç¤ºï¼šå‘é‡ä¹˜ä»¥çŸ©é˜µ**

çŸ©é˜µä¹˜æ³•æ˜¯ä¸Šä¸€ç« ä¸­å†…ç§¯çš„ä¸€èˆ¬åŒ–ã€‚åœ¨ç”¨ä¸€ä¸ªå‘é‡ä¹˜ä»¥ä¸€ä¸ªçŸ©é˜µçš„ç‰¹æ®Šæƒ…å†µä¸‹ï¼ˆå¦‚ä¸Šæ‰€ç¤ºï¼‰ï¼Œæ€»æ˜¯ä¼šå¾—åˆ°ä¸€ä¸ªå‘é‡ï¼š

$$M\left| \upsilon \right\rangle = \left\lbrack \begin{matrix}
a \\
c \\
\end{matrix}\ \begin{matrix}
b \\
d \\
\end{matrix} \right\rbrack\begin{bmatrix}
\upsilon_{0} \\
\upsilon_{1} \\
\end{bmatrix} = \begin{bmatrix}
a \bullet \upsilon_{0} + b \bullet \upsilon_{1} \\
c \bullet \upsilon_{0} + d \bullet \upsilon_{1} \\
\end{bmatrix}$$

åœ¨é‡å­è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠçŸ©é˜µå†™æˆåŸºå‘é‡çš„å½¢å¼ï¼š

$$X = |0\rangle\langle 1| + |1\rangle\langle 0|$$

ç”±äºå¯ä»¥çœ‹åˆ°ä¸åŒçš„ä¹˜æ³•æ‰€äº§ç”Ÿçš„ç»“æœï¼Œæœ‰æ—¶æ¯”ä½¿ç”¨æ–¹æ¡†çŸ©é˜µæ›´æ¸…æ™°ï¼š

$$X|1\rangle = (|0\rangle\langle 1| + |1\rangle\langle 0|)|1\rangle = |0\rangle\langle 1|1\rangle + |1\rangle\langle 0|1\rangle = |0\rangle \times 1 + |1\rangle \times 0 = |0\rangle$$

äº‹å®ä¸Šï¼Œå½“å³çŸ¢ï¼ˆketï¼‰å’Œå·¦çŸ¢ï¼ˆbraï¼‰ç›¸ä¹˜æ—¶:

$$|a\rangle\langle b|$$

ç§°ä¹‹ä¸ºå¤–ç§¯ï¼ˆ**outer product**ï¼‰ï¼Œå…¶éµå¾ªä»¥ä¸‹è§„åˆ™ï¼š

$$|a\rangle\langle b| = \begin{bmatrix}
a_{0}b_{0}\text{\ a}_{0}b_{1}\ \cdots\ a_{0}b_{n} \\
a_{1}b_{0}\  \ddots \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \vdots \ \ \ \  \\
 \vdots \ \ \ \ \ \ \ \ \ \ \ \ \  \ddots \ \ \ \ \ \ \ \ \ \  \vdots \  \\
a_{n}b_{0}\ \cdots\ \ \ \ \cdots\ \ a_{n}b_{n} \\
\end{bmatrix}$$

å¯ä»¥çœ‹åˆ°è¯¥è¿ç®—è¿‡ç¨‹ç¡®å®å¯¼å‡ºäº†ä¸Šè¿°çš„æ³¡åˆ©X-çŸ©é˜µï¼š

$$|0\rangle\langle 1| + |1\rangle\langle 0| = \left\lbrack \begin{matrix}
0 \\
0 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right\rbrack + \left\lbrack \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
0 \\
0 \\
\end{matrix} \right\rbrack = \left\lbrack \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right\rbrack = X$$

åœ¨Qiskitä¸­æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå°çš„å›è·¯æ¥å®ç°ï¼š

> \# Let\'s do an X-gate on a \|0\> qubit
>
> qc = QuantumCircuit(1)
>
> qc.x(0)
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image65.png)

è®©æˆ‘ä»¬çœ‹çœ‹ä¸Šé¢å›è·¯çš„è¾“å‡ºã€‚**æ³¨æ„**ï¼šåœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨plot_bloch_multiector()å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„æ€å‘é‡ï¼Œè€ŒéBlochå‘é‡ã€‚

> \# Let\'s see the result
>
> backend = Aer.get_backend(\'statevector_simulator\')
>
> out = execute(qc,backend).result().get_statevector()
>
> plot_bloch_multivector(out)
>
> è¾“å‡ºï¼š

![](pics/media/image66.png)

å¯ä»¥ä»ä¸Šé¢è¾“å‡ºçš„å›¾åƒçœ‹å‡ºè¯¥é‡å­æ¯”ç‰¹çš„é¢„æœŸä¸ºæ€\|1âŸ©ã€‚æˆ‘ä»¬å¯ä»¥è®¤ä¸ºè¿™æ˜¯åœ¨å¸ƒæ´›èµ«çƒä½“ä¸­ç»•xè½´æ—‹è½¬Ï€å¼§åº¦ã€‚X-gateä¹Ÿç»å¸¸è¢«ç§°ä¸º"éé—¨ï¼ˆNOT-gateï¼‰"ï¼Œç”¨äºæŒ‡ç§°ç»å…¸è®¡ç®—ä¸­çš„ç±»ä¼¼æƒ…å†µã€‚

#### 1.2 æ³¡åˆ© Y-é—¨ä¸Z-é—¨

ä¸æ³¡åˆ© X-é—¨ç›¸ç±»ä¼¼ï¼Œåœ¨é‡å­å›è·¯ä¸­æ³¡åˆ©Yå’ŒZçŸ©é˜µä¹Ÿæ‰®æ¼”äº†Y-é—¨ä¸Z-é—¨çš„è§’è‰²ï¼š

$$Y = \left\lbrack \begin{matrix}
0 \\
i \\
\end{matrix}\ \begin{matrix}
 - i \\
0 \\
\end{matrix} \right\rbrack\ \ \ \ Z = \left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
 - 1 \\
\end{matrix} \right\rbrack$$

$$Y = - i\left| 0 \right\rangle\left\langle 1\left| + i \right|1 \right\rangle\left\langle 0 \right|$$

$$Z = |0\rangle\langle 0| - |1\rangle\langle 1|$$

ä¸å‡ºæ„æ–™çš„æ˜¯Y-å’ŒZ-é—¨åˆ†åˆ«åœ¨å¸ƒæ´›èµ«çƒä¸­ä¾æ®yå’Œzè½´æ—‹è½¬Ï€å¼§åº¦ã€‚

ä¸‹é¢çš„ä»£ç æ˜¯ä¸€ä¸ªåœ¨å¸ƒæ´›èµ«çƒä¸­æ˜¾ç¤ºä¸€ä¸ªé‡å­æ¯”ç‰¹çŠ¶æ€çš„å°éƒ¨ä»¶ï¼ŒæŒ‰ä¸‹å…¶ä¸­ä¸€ä¸ªæŒ‰é’®å°†åœ¨é‡å­ä½ä¸Šæ‰§è¡Œé‡å­é—¨çš„æ“ä½œï¼š

> \# Run the code in this cell to see the widget
>
> from qiskit_textbook.widgets import gate_demo
>
> gate_demo(gates=\'pauli\')
>
> è¾“å‡ºï¼š

![](pics/media/image67.png)

åœ¨Qiskitä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä»£ç å°†Y-å’ŒZ-é—¨åº”ç”¨åœ¨é‡å­å›è·¯ä¸­ï¼š

> qc.y(0) \# Do Y-gate on qubit 0
>
> qc.z(0) \# Do Z-gate on qubit 0
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image68.png)

**æç¤ºï¼šçŸ©é˜µçš„æœ¬å¾å‘é‡**

æˆ‘ä»¬å·²ç»çœ‹åˆ°ç”¨ä¸€ä¸ªå‘é‡ä¹˜ä»¥ä¸€ä¸ªçŸ©é˜µä¼šå¾—åˆ°ä¸€ä¸ªå‘é‡ï¼š

$$M\left| \upsilon \right\rangle = \left| \upsilon^{'} \right\rangle \longleftarrow \mathbf{æ–°çš„å‘é‡}$$

å¦‚æœé€‰æ‹©æ­£ç¡®çš„å‘é‡å’ŒçŸ©é˜µï¼Œå¯ä»¥æ‰¾åˆ°ä¸€ç§æƒ…å†µï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒçŸ©é˜µä¹˜æ³•å’Œæ ‡é‡ä¹˜æ³•æ˜¯ç›¸ç­‰çš„ï¼š

$$M|v\rangle\  = \ \lambda|v\rangle$$

ï¼ˆä¸Šå¼ä¸­$M$æ˜¯ä¸€ä¸ªçŸ©é˜µï¼Œ$\lambda$æ˜¯ä¸€æ ‡é‡ï¼‰ã€‚å¯¹äºçŸ©é˜µ$M$ï¼Œä»»ä¸€ç¬¦åˆä¸Šå¼çš„å‘é‡è¢«æˆä¸ºçŸ©é˜µ$M$çš„æœ¬å¾å‘é‡ã€‚ä¾‹å¦‚ï¼ŒZ-çŸ©é˜µçš„æœ¬å¾å‘é‡æ˜¯$|0\rangle$å’Œ$|1\rangle$ï¼š

$${Z\left| 0 \right\rangle = \left| 0 \right\rangle
}{Z\left| 1 \right\rangle = - |1\rangle}$$

å› æ­¤æˆ‘ä»¬ç”¨å‘é‡æ¥æè¿°é‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬é€šå¸¸ç§°è¿™äº›å‘é‡ä¸ºæœ¬å¾æ€ï¼ˆ*eigenstate*ï¼‰ã€‚æœ¬å¾å‘é‡åœ¨é‡å­è®¡ç®—ä¸­éå¸¸é‡è¦ï¼Œæ‰€æ‚¨éœ€è¦å¯¹å…¶æœ‰åšå®çš„æŒæ¡ã€‚

### é¢˜å¤–è¯ï¼šXã€Yå’ŒZ-åŸº

æ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼Œå½“Z-é—¨å¤„äºè¿™ä¸¤ç§çŠ¶æ€ä¸­çš„ä»»ä½•ä¸€ç§æ—¶ï¼Œä¼¼ä¹å¯¹æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹æ²¡æœ‰å½±å“ã€‚è¿™æ˜¯å› ä¸ºæ€\|0âŸ©å’Œ\|1âŸ©æ˜¯Z-é—¨çš„ä¸¤ä¸ªæœ¬å¾æ€ã€‚äº‹å®ä¸Šï¼Œè®¡ç®—åŸºï¼ˆ*computational
basis*ï¼Œ\|0âŸ©å’Œ\|1âŸ©å½¢å¼çš„åŸºçŸ¢ï¼‰é€šå¸¸è¢«ç§°ä¸ºZ-åŸºï¼ˆZ-basisï¼‰ï¼Œä½†ä¸æ˜¯å¯ä½¿ç”¨çš„å”¯ä¸€åŸºï¼Œä¸€ä¸ªæµè¡Œçš„åŸºæ˜¯X-åŸºï¼ˆX-basisï¼‰ï¼Œç”±æ³¡åˆ©X-é—¨çš„æœ¬å¾æ€ç»„æˆã€‚æˆ‘ä»¬ç§°å‘é‡\|+âŸ©å’Œ\|âˆ’âŸ©ï¼š

$$\left| + \right\rangle = \frac{1}{\sqrt{2}}(\left| 0 \right\rangle + |1\rangle) = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 \\
1 \\
\end{bmatrix}$$

$$\left| - \right\rangle = \frac{1}{\sqrt{2}}(\left| 0 \right\rangle - |1\rangle) = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 \\
 - 1 \\
\end{bmatrix}$$

å¦ä¸€ä¸ªä¸å¸¸ç”¨çš„åŸºç”±æ³¡åˆ©Y-é—¨çš„æœ¬å¾æ€ç»„æˆï¼š

$$\left| \circlearrowleft \right\rangle,\left| \circlearrowright \right\rangle$$

æˆ‘ä»¬å°†å…¶ä½œä¸ºä¸€ä¸ªç»ƒä¹ æ¥è®¡ç®—ã€‚äº‹å®ä¸Šæœ‰æ— æ•°çš„åŸºï¼›ä¸ºäº†ç»„æˆå…¶ä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œåªéœ€è¦ä¸¤ä¸ªæ­£äº¤çš„å‘é‡ã€‚

#### å¿«é€Ÿç»ƒä¹ 

1.  éªŒè¯$\left| + \right\rangle$å’Œ$\left| - \right\rangle$æ˜¯æ³¡åˆ©X-é—¨çš„æœ¬å¾æ€ã€‚

2.  ä¸Šè¿°å‘é‡çš„æœ¬å¾å€¼æ˜¯ä»€ä¹ˆï¼Ÿ

3.  ä¸ºä½•åœ¨å¸ƒæ´›èµ«çƒçœ‹ä¸åˆ°è¿™äº›æœ¬å¾å€¼çš„å‡ºç°ï¼Ÿ

4.  æ‰¾å‡ºæ³¡åˆ©Y-é—¨çš„æœ¬å¾æ€åŠå…¶åœ¨å¸ƒæ´›èµ«çƒä¸Šçš„åæ ‡ã€‚

é™¤æ€\|0âŸ©å’Œ\|1âŸ©ä¹‹å¤–ï¼Œåªä½¿ç”¨Paulié—¨ä¸èƒ½åˆå§‹åŒ–ä»»æ„çŠ¶æ€çš„é‡å­æ¯”ç‰¹ï¼Œå› æ­¤ä¸èƒ½å®ç°å åŠ æ€ã€‚è¡¨æ˜æˆ‘ä»¬çœ‹ä¸å‡ºä»»ä½•ä¸ç»å…¸æ¯”ç‰¹ä¸åŒçš„è¡Œä¸ºã€‚ä¸ºäº†åˆ›é€ æ›´å¤šæœ‰è¶£çš„çŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦æ›´å¤šçš„é—¨ï¼

### é˜¿è¾¾é©¬é—¨ï¼ˆHadamard Gateï¼‰

é˜¿è¾¾é©¬é—¨ï¼ˆH-gateï¼‰æ˜¯ä¸€ä¸ªåŸºæœ¬é‡å­é—¨ï¼Œå…¶å¯ä»¥è®©æˆ‘ä»¬è¿œç¦»å¸ƒæ´›èµ«çƒçš„ä¸¤æå¹¶åˆ›å»ºå‡ºä»‹äº\|0âŸ©å’Œ\|1âŸ©ä¹‹é—´çš„å åŠ æ€ã€‚è¯¥é‡å­é—¨çš„çŸ©é˜µå½¢å¦‚ï¼š

$$H = \frac{1}{\sqrt{2}}\left\lbrack \begin{matrix}
1 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
\end{matrix} \right\rbrack$$

æ‰§è¡Œè¯¥çŸ©é˜µè½¬æ¢çš„ç»“æœå¦‚ä¸‹ï¼š

$$H\left| 0 \right\rangle = \left| + \right\rangle$$

$$H\left| 1 \right\rangle = \left| - \right\rangle$$

ä¸Šè¿°è½¬æ¢å¯ä»¥è¢«è®¤ä¸ºæ˜¯å›´ç»•Blochå‘é‡\[1,0,1\]ï¼ˆxå’Œzè½´ä¹‹é—´çš„çº¿ï¼‰çš„æ—‹è½¬ï¼Œæˆ–è€…æ˜¯è½¬æ¢X-å’ŒZ-åŸºä¹‹é—´é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚

æ‚¨å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„å°å·¥å…·æ¥è¯•éªŒï¼š

> \# Run the code in this cell to see the widget
>
> from qiskit_textbook.widgets import gate_demo
>
> gate_demo(gates=\'pauli+h\')
>
> è¾“å‡ºï¼š

![](pics/media/image69.png)

#### å¿«é€Ÿç»ƒä¹ 

1.  å†™å‡ºH-gateä¸å‘é‡\|0âŸ©ã€\|1âŸ©ã€\|+âŸ©å’Œ\|âˆ’âŸ©çš„å¤–ç§¯ã€‚

2.  è¯æ˜å¯¹ä»»æ„é‡å­æ¯”ç‰¹çš„çŠ¶æ€åº”ç”¨é—¨åºåˆ—HZHä¸åº”ç”¨æ³¡åˆ©X-é—¨æ˜¯ç­‰ä»·çš„ã€‚

3.  æ‰¾å‡ºX-ã€Z-å’ŒH-é—¨çš„ç»„åˆï¼Œä½¿å…¶ç­‰ä»·äºY-é—¨ï¼ˆå¿½ç•¥å…¨å±€ç›¸ä½ï¼‰ã€‚

4.  ### é¢˜å¤–è¯ï¼šä½¿ç”¨ä¸åŒçš„åŸºæ¥æµ‹é‡

æˆ‘ä»¬å·²ç»çœ‹åˆ°Zè½´æœ¬è´¨ä¸Šå¹¶ä¸ç‰¹æ®Šï¼Œè¿˜æœ‰æ— ç©·å¤šçš„å…¶ä»–åŸºã€‚ä¸æµ‹é‡ç±»ä¼¼ï¼Œæˆ‘ä»¬ä¸å¿…æ€»æ˜¯åœ¨è®¡ç®—åŸºä¸Šæµ‹é‡ï¼ˆZ-åŸºï¼‰ï¼Œå¯ä»¥åœ¨ä»»ä½•åŸºä¸Šæµ‹é‡é‡å­æ¯”ç‰¹ã€‚

å°è¯•ä½¿ç”¨X-åŸºæµ‹é‡ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—ä¸­æµ‹é‡\|+âŸ©æˆ–\|âˆ’âŸ©çš„æ¦‚ç‡ï¼š

$$p(| + \rangle) = \left| \left\langle + \middle| q \right\rangle \right|^{2},p(| - \rangle) = \left| \left\langle - \middle| q \right\rangle \right|^{2}$$

åœ¨æµ‹é‡ä¹‹åï¼Œå¯ä»¥ä¿è¯åœ¨è¿™ä¸¤ç§çŠ¶æ€ä¹‹ä¸€æœ‰ä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚ç”±äºQiskitåªå…è®¸åœ¨Z-åŸºä¸Šè¿›è¡Œæµ‹é‡ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨H-gateæ¥åˆ›å»ºæˆ‘ä»¬è‡ªå·±çš„åŸºï¼š

> from qiskit.extensions import Initialize \# Import the Inititialize
> function
>
> \# Create the X-measurement function:
>
> def x_measurement(qc,qubit,cbit):
>
> \"\"\"Measure \'qubit\' in the X-basis, and store the result in
> \'cbit\'\"\"\"
>
> qc.h(qubit)
>
> qc.measure(qubit, cbit)
>
> qc.h(qubit)
>
> return qc
>
> \# Initialise our qubit and measure it
>
> qc = QuantumCircuit(1,1)
>
> initial_state = \[0,1\]
>
> initializer = Initialize(initial_state)
>
> initializer.label = \"init\"
>
> qc.append(initializer, \[0\])
>
> x_measurement(qc, 0, 0)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image70.png)

åœ¨ä¹‹å‰çš„å¿«é€Ÿç»ƒä¹ ä¸­ï¼Œæ‚¨å¯ä»¥é€šè¿‡å°†Zé—¨å¤¹åœ¨ä¸¤ä¸ªH-é—¨ä¹‹é—´æ¥åˆ›å»ºä¸€ä¸ªXé—¨ï¼š

$$X = HZH$$

ä»Z-åŸºå¼€å§‹ï¼ŒHé—¨å°†é‡å­æ¯”ç‰¹è½¬æ¢åˆ°X-åŸºï¼ŒZé—¨åœ¨X-åŸºä¸Šè¿›è¡Œä¸€ä¸ªéé—¨ï¼ˆNOTï¼‰æ“ä½œï¼Œæœ€åçš„Hé—¨å°†é‡å­æ¯”ç‰¹è¿”å›åˆ°Z-åŸºã€‚

![](pics/media/image71.png)

æˆ‘ä»¬å¯ä»¥é€šè¿‡çŸ©é˜µç›¸ä¹˜éªŒè¯HZHçš„è¡Œä¸ºå°±æ˜¯Xé—¨ï¼š

$$\text{HZH} = \frac{1}{\sqrt{2}}\left\lbrack \begin{matrix}
1 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
\end{matrix} \right\rbrack\left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
 - 1 \\
\end{matrix} \right\rbrack\frac{1}{\sqrt{2}}\left\lbrack \begin{matrix}
1 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
\end{matrix} \right\rbrack = \left\lbrack \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right\rbrack = X$$

æŒ‰ç…§ç›¸åŒçš„é€»è¾‘ï¼Œè¿™é‡Œé€šè¿‡å°†Z-æµ‹é‡ï¼ˆZ-measurementï¼‰å¤¹åœ¨ä¸¤ä¸ªHé—¨ä¹‹é—´åˆ›å»ºä¸€ä¸ªX-æµ‹é‡ï¼ˆX-measurementï¼‰ã€‚

![](pics/media/image72.png)

ç°åœ¨çœ‹çœ‹ä¸Šé¢é€»è¾‘çš„åœ¨Qiskitä¸­çš„è¾“å‡ºï¼š

> backend = Aer.get_backend(\'statevector_simulator\') \# Tell Qiskit
> how to simulate our circuit
>
> out_state = execute(qc,backend).result().get_statevector() \# Do the
> simulation, returning the state vector
>
> plot_bloch_multivector(out_state) \# Display the output state vector
>
> è¾“å‡ºï¼š

![](pics/media/image73.png)

æˆ‘ä»¬åœ¨æ€\|1âŸ©ä¸­åˆå§‹åŒ–é‡å­æ¯”ç‰¹ï¼Œå¯ä»¥çœ‹åˆ°æµ‹é‡ä¼šåå¡Œé‡å­æ¯”ç‰¹çš„çŠ¶æ€ä¸º\|+âŸ©æˆ–\|âˆ’âŸ©ã€‚å¦‚æœä½ å†æ¬¡è¿è¡Œçš„ä¸Šé¢çš„ä¸¤ç«¯ä»£ç ï¼Œåˆ™ä¼šçœ‹åˆ°ä¸åŒçš„ç»“æœï¼Œä½†é‡å­æ¯”ç‰¹çš„æœ€ç»ˆçŠ¶æ€æ€»æ˜¯\|+âŸ©æˆ–\|âˆ’âŸ©ã€‚

#### å¿«é€Ÿç»ƒä¹ 

1.  å¦‚æœæˆ‘ä»¬åœ¨æ€\|+âŸ©ä¸­åˆå§‹åŒ–é‡å­æ¯”ç‰¹ï¼Œæµ‹å¾—å…¶åœ¨æ€\|âˆ’âŸ©ä¸­çš„æ¦‚ç‡æ˜¯å¤šå°‘?

2.  ä½¿ç”¨Qiskitæ˜¾ç¤ºæµ‹é‡é‡å­æ¯”ç‰¹\|0âŸ©åœ¨æ€\|+âŸ©å’Œ\|âˆ’âŸ©ä¸­çš„æ¦‚ç‡ï¼ˆæç¤ºï¼šæ‚¨å¯èƒ½ä¼šç”¨åˆ°.get_counts()å’Œplot_histogram()ï¼‰ã€‚

3.  å°è¯•åˆ›å»ºä¸€ä¸ªç”¨Y-åŸºæµ‹é‡çš„å‡½æ•°ã€‚

ç”¨ä¸åŒçš„åŸºæµ‹é‡å¯ä»¥è®©æˆ‘ä»¬çœ‹åˆ°æµ·æ£®å ¡è‘—åçš„æµ‹ä¸å‡†åŸç†æ˜¯å¦‚ä½•èµ·ä½œç”¨çš„ã€‚ç¡®å®šä»¥Z-åŸºæµ‹é‡æŸä¸ªçŠ¶æ€ï¼Œå°±æ¶ˆé™¤äº†ä»¥X-åŸºæµ‹é‡æŸä¸ªç‰¹å®šçŠ¶æ€çš„æ‰€æœ‰ç¡®å®šæ€§ï¼Œåä¹‹äº¦ç„¶ã€‚ä¸€ä¸ªå¸¸è§çš„è¯¯è§£æ˜¯ä¸ç¡®å®šæ€§æ˜¯ç”±äºè®¾å¤‡çš„é™åˆ¶ï¼Œä½†åœ¨è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œä¸ç¡®å®šæ€§å®é™…ä¸Šæ˜¯é‡å­æ¯”ç‰¹æœ¬è´¨çš„ä¸€éƒ¨åˆ†ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æŠŠé‡å­æ¯”ç‰¹æ”¾å…¥æ€\|0âŸ©ä¸­ï¼Œä»¥Z-åŸºæµ‹é‡è‚¯å®šä¼šå¾—åˆ°\|0âŸ©ï¼Œä½†ä»¥X-åŸºæµ‹é‡åˆ™ä¼šå¾—åˆ°å®Œå…¨éšæœºçš„ç»“æœï¼ç±»ä¼¼åœ°ï¼Œå¦‚æœæŠŠé‡å­æ¯”ç‰¹æ”¾å…¥æ€\|âˆ’âŸ©ï¼Œä»¥X-åŸºæµ‹é‡è‚¯å®šä¼šå¾—åˆ°\|âˆ’âŸ©ï¼Œä½†ç°åœ¨ä»¥Z-åŸºçš„ä»»æ„æµ‹é‡å°†ä¼šå®Œå…¨éšæœºçš„ç»“æœã€‚

**æ›´ä¸€èˆ¬åœ°ï¼šæ— è®ºæˆ‘ä»¬çš„é‡å­ç³»ç»Ÿå¤„äºä»€ä¹ˆçŠ¶æ€ï¼Œæ€»æœ‰ä¸€ç§æµ‹é‡ä¼šæœ‰ä¸€ä¸ªç¡®å®šçš„ç»“æœã€‚**

Hé—¨çš„å¼•å…¥æ˜¯çš„æˆ‘ä»¬èƒ½å¤Ÿæ¢ç´¢ä¸€äº›æœ‰è¶£çš„ç°è±¡ï¼Œä½†åœ¨é‡å­æ“ä½œæ–¹é¢ä»ç„¶éå¸¸æœ‰é™ã€‚ç°åœ¨ä»‹ç»ä¸€ç§æ–°å‹çš„é‡å­é—¨ï¼š

### 5. $\mathbf{R}_{\mathbf{\phi}}$é—¨ï¼ˆR~Ï•~-gateï¼‰

ç”±äºR~Ï•~æ˜¯å‚æ•°åŒ–çš„ï¼ˆparametrisedï¼‰ï¼Œå› æ­¤å…¶éœ€è¦ä¸€ä¸ªæ•°å­—ï¼ˆ$\phi$ï¼‰æ¥å‘Šè¯‰å®ƒåšä»€ä¹ˆã€‚R~Ï•~-gateæ‰§è¡Œç»•Zè½´æ—‹è½¬$\phi$è§’åº¦ï¼Œå› æ­¤ä¹Ÿè¢«ç§°ä¸ºRz-gateï¼Œå…¶çŸ©é˜µå½¢å¼å¦‚ä¸‹ï¼š

$$R_{\phi} = \left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
e^{i\phi} \\
\end{matrix} \right\rbrack$$

å…¶ä¸­$\phi$æ˜¯ä¸€ä¸ªå®æ•°ã€‚

æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨qiskit_textbookä¸­çš„å°éƒ¨ä»¶å°è¯•R~Ï•~-gateï¼Œå¯ä»¥é€šè¿‡é‡Œé¢çš„æ»‘å—åˆ¶å®š$\phi$ï¼š

> \# Run the code in this cell to see the widget
>
> from qiskit_textbook.widgets import gate_demo
>
> gate_demo(gates=\'pauli+h+rz\')
>
> è¾“å‡ºï¼š

![](pics/media/image74.png)

åœ¨Qiskitä¸­ï¼Œæˆ‘å¯ä»¥é€šè¿‡rz(phi, qubit)æ¥æŒ‡å®šä¸€ä¸ªR~Ï•~-gateï¼š

æ‚¨å¯ä»¥çœ‹åˆ°å½“ğœ™=ğœ‹æ—¶ï¼ŒZé—¨æ˜¯R~Ï•~-gateçš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚å®é™…ä¸Šæœ‰ä¸‰ä¸ªæ›´å¸¸è§çš„å‚è€ƒé‡å­é—¨ä¼šåœ¨æœ¬ç« ä¸­æåŠï¼Œå®ƒä»¬éƒ½æ˜¯R~Ï•~-gateçš„ç‰¹æ®Šæƒ…å†µï¼š

> qc = QuantumCircuit(1)
>
> qc.rz(pi/4, 0)
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image75.png)

### 6. Iã€Så’ŒT-é—¨ï¼ˆIã€Sã€T-gatesï¼‰

#### 6.1 I-gate

ç¬¬ä¸€ä¸ªæ˜¯"I-gate"(åˆå"Id-gate"æˆ–"Identity
gate")ã€‚è¿™æ˜¯ä¸€ä¸ªä¸è¿›è¡Œä»»ä½•æ“ä½œçš„é‡å­é—¨ï¼Œå…¶çŸ©é˜µå½¢å¼ä¸ºå•ä½çŸ©é˜µï¼š

$$I = \left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
1 \\
\end{matrix} \right\rbrack$$

å°†è¯¥å•ä½é‡å­é—¨åº”ç”¨äºé‡å­å›è·¯ä¸­ä¸ä¼šæ”¹å˜é‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œæ‰€ä»¥å°†å…¶è®¤ä½œä¸€ä¸ªé‡å­é—¨å€¼å¾—æ¢å¯»ã€‚æœ‰ä¸¤ä¸ªåŸå› å¯¼è‡´å¦‚æ­¤ï¼šç¬¬ä¸€I-gateè¢«ç»å¸¸ç”¨äºè®¡ç®—ä¸­ï¼Œæ¯”å¦‚è¯æ˜æ³¡åˆ©Xé—¨æ˜¯å…¶è‡ªèº«çš„é€†ã€‚

$$I = XX$$

ç¬¬äºŒè€ƒè™‘å®é™…ç¡¬ä»¶æ¥æŒ‡å®š"do-nothing"æˆ–"none"æ“ä½œé€šå¸¸å¾ˆæœ‰ç”¨ã€‚

##### å¿«é€Ÿç»ƒä¹ 

1.  I-gateçš„æœ¬å¾æ€æ˜¯ä»€ä¹ˆï¼Ÿ

#### 6.2 S-gate

æ¥ä¸‹æ¥å°†è¦æåŠçš„é‡å­é—¨æ˜¯S-gateï¼ˆæœ‰æ—¶è¢«ç§°ä¸º$\sqrt{Z}$-gateï¼‰ï¼Œæ˜¯ğœ™=ğœ‹/2æ—¶çš„R~Ï•~-gateã€‚è¯¥é‡å­é—¨ç»•å¸ƒæ´›èµ«çƒæ—‹è½¬å››åˆ†ä¹‹ä¸€åœˆã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ä¸æœ¬ç« åˆ°ç›®å‰ä¸ºæ­¢ä»‹ç»çš„æ‰€æœ‰é—¨ä¸åŒï¼ŒSé—¨ä¸æ˜¯å…¶è‡ªèº«çš„é€†ï¼åœ¨æ­¤æˆ‘ä»¬å…ˆç»™å‡ºç»“æœï¼Œæ‚¨ä¼šç»å¸¸çœ‹åˆ°S^â€ ^-gateï¼Œä¹Ÿç§°ä¸º"S-dagger"ã€"Sdg"æˆ–${\sqrt{Z}}^{\dagger}$-gateã€‚S^â€ ^-gateæ˜¯å½“ğœ™=âˆ’ğœ‹/2æ—¶çš„R~Ï•~-gateã€‚

$$S = \left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
e^{\frac{\text{iÏ€}}{2}} \\
\end{matrix} \right\rbrack\ \ ,S^{\dagger} = \left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
e^{- \frac{\text{iÏ€}}{2}} \\
\end{matrix} \right\rbrack$$

$\sqrt{Z}$-gateçš„åå­—æ˜¯ç”±äºä¸¤æ¬¡æˆåŠŸåº”ç”¨S-gateçš„æ•ˆæœä¸Z-gateä¸€è‡´ï¼š

$$\text{SS}\left| q \right\rangle = Z\left| q \right\rangle$$

è¿™ä¸€ç¬¦å·åœ¨é‡å­è®¡ç®—ä¸­å¾ˆå¸¸è§ã€‚

åœ¨Qiskitä¸­æ·»åŠ ä¸€ä¸ªS-gateçš„ä»£ç å¦‚ä¸‹ï¼š

> qc = QuantumCircuit(1)
>
> qc.s(0) \# Apply S-gate to qubit 0
>
> qc.sdg(0) \# Apply Sdg-gate to qubit 0
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image76.png)

#### 6.3 T-gate

T-gateæ˜¯é‡å­è®¡ç®—ä¸­æœ€é•¿ä½¿ç”¨çš„ä¸€ä¸ªé‡å­é—¨ï¼Œå…¶ä¸ºåœ¨ğœ™=ğœ‹/4æ—¶çš„R~Ï•~-gateã€‚

$$T = \left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
e^{\frac{\text{iÏ€}}{4}} \\
\end{matrix} \right\rbrack\ \ ,T^{\dagger} = \left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
e^{- \frac{\text{iÏ€}}{4}} \\
\end{matrix} \right\rbrack$$

> qc = QuantumCircuit(1)
>
> qc.t(0) \# Apply T-gate to qubit 0
>
> qc.tdg(0) \# Apply Tdg-gate to qubit 0
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image77.png)

ä¸S-gateä¸€æ ·ï¼ŒT-gateæœ‰æ—¶è¢«ç§°ä¸º$\sqrt[4]{Z}$-gateã€‚åœ¨Qiskitä¸­ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨qiskit_textbookä¸­çš„å°éƒ¨ä»¶æŠŠç©æœ¬ç« ä¸­ä»‹ç»çš„æ‰€æœ‰é‡å­é—¨ï¼š

> \# Run the code in this cell to see the widget
>
> from qiskit_textbook.widgets import gate_demo
>
> gate_demo()
>
> è¾“å‡ºï¼š

![](pics/media/image78.png)

### 7. é€šç”¨U-gate

æ­£å¦‚æˆ‘ä»¬å…ˆå‰æ‰€è®²ï¼ŒIã€Zã€Så’ŒT-gateéƒ½æ˜¯R~Ï•~-gateçš„ç‰¹ä¿—æƒ…å†µã€‚åŒæ ·çš„é“ç†ï¼ŒU~3~-gateæ˜¯æ‰€æœ‰å•é‡å­æ¯”ç‰¹é‡å­é—¨ä¸­æœ€å¸¸ç”¨çš„ä¸€ç§ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªå‚æ•°åŒ–çš„é‡å­é—¨ï¼š

$$U_{3}\left( \theta,\phi,\lambda \right) = \left\lbrack \begin{matrix}
\cos\left( \frac{\theta}{2} \right) \\
e^{\text{iÏ•}}\text{si}n\left( \frac{\theta}{2} \right) \\
\end{matrix}\text{\ \ }\begin{matrix}
{- e}^{\text{iÏ•}}\sin\left( \frac{\theta}{2} \right) \\
e^{i\lambda + i\phi}\text{co}s\left( \frac{\theta}{2} \right) \\
\end{matrix} \right\rbrack$$

æœ¬ç« ä¸­ä»‹ç»çš„æ¯ä¸€ä¸ªé‡å­é—¨éƒ½å¯ä»¥è¢«æŒ‡å®šä¸ºä¸€ä¸ª$U_{3}\left( \theta,\phi,\lambda \right)$ï¼Œä½†è¿™ä¸€æƒ…å†µåœ¨ä¸€ä¸ªå›è·¯çš„å›¾è§£ä¸­ä¸å¸¸è§ï¼Œå…¶å¯èƒ½çš„åŸå› æ˜¯ç›¸å¯¹äºæ¯”è¾ƒéš¾ä»¥é˜…è¯»ã€‚

Qiskitæä¾›äº†U~1~-å’ŒU~2~-gateï¼Œç”¨äºåˆ†åˆ«æŒ‡ä»£ğœƒ = ğœ‹/2å’Œğœƒ = ğœ™
=0æ—¶U~3~-gateçš„ç‰¹æ®Šæƒ…å†µã€‚æ‚¨å°†ä¼šçœ‹åˆ°U~1~-gateç­‰åŒäºR~Ï•~-gateã€‚

$$U_{3}\left( \pi/2,\phi,\lambda \right) = U_{2} = \frac{1}{\sqrt{2}}\left\lbrack \begin{matrix}
1 \\
e^{\text{iÏ•}} \\
\end{matrix}\text{\ \ }\begin{matrix}
{- e}^{\text{iÎ»}} \\
e^{i\lambda + i\phi} \\
\end{matrix} \right\rbrack$$

$$U_{3}\left( 0,0,\lambda \right) = U_{1} = \left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\text{\ \ }\begin{matrix}
0 \\
e^{\text{iÎ»}} \\
\end{matrix} \right\rbrack$$

åœ¨çœŸæ­£çš„IBMé‡å­ç¡¬ä»¶ä¸Šè¿è¡Œä¹‹å‰ï¼Œæ‰€æœ‰å•é‡å­æ¯”ç‰¹æ“ä½œéƒ½è¢«ç¼–è¯‘ä¸ºğ‘ˆ~1~ã€ğ‘ˆ~2~å’Œğ‘ˆ~3~ï¼Œå› æ­¤æœ‰æ—¶è¢«ç§°ä¸ºç‰©ç†é—¨ï¼ˆ*physical
gate*ï¼‰ã€‚

ç”±æ­¤å¯ä»¥æ˜æ˜¾çœ‹å‡ºï¼Œå¯èƒ½å­˜åœ¨æ— ç©·å¤šçš„é—¨ï¼Œå…¶ä¸­ä¹ŸåŒ…æ‹¬Rxå’ŒRy-gateï¼Œå°½ç®¡è¿™é‡Œæ²¡æœ‰æåˆ°ã€‚è¿˜å¿…é¡»æ³¨æ„çš„æ˜¯Z-åŸºæ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«ä¹‹å¤„ï¼Œåªæ˜¯å®ƒè¢«é€‰ä¸ºæ ‡å‡†è®¡ç®—åŸºã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬ç»™äºˆS-å’ŒT-gateåå­—ï¼Œå´æ²¡æœ‰ç»™å…¶Xå’ŒYç­‰ä»·ç‰©å–åå­—çš„åŸå› ã€‚ï¼ˆæ¯”å¦‚ï¼š$\sqrt{X}$å’Œ$\sqrt[4]{Y}$ï¼‰

2. å¤šé‡å­æ¯”ç‰¹å’Œçº ç¼ ï¼ˆEntanglementï¼‰
===================================

2.1 ä»‹ç»
--------

è‹¥ä»…ä»…æœ‰é‡å­æ¯”ç‰¹ä¸è¶³ä»¥å½¢æˆé‡å­å›è·¯ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å¯¹å…¶è¿›è¡Œæ“çºµã€‚æ‰€æœ‰å¯èƒ½çš„æ–¹æ³•éƒ½å¯ä»¥è¢«ç¼–è¯‘æˆä¸€ç»„åŸºæœ¬çš„æ“ä½œï¼Œç§°ä¸ºé‡å­é—¨ã€‚

é€šå¸¸ï¼Œå¯ä»¥ç›´æ¥åœ¨ç¡¬ä»¶ä¸­å®ç°çš„é‡å­é—¨åªä½œç”¨äºä¸€ä¸ªæˆ–ä¸¤ä¸ªé‡å­æ¯”ç‰¹ã€‚åœ¨æˆ‘ä»¬çš„å›è·¯ä¸­ï¼Œå¯èƒ½æƒ³è¦ä½¿ç”¨ä½œç”¨äºå¤§é‡é‡å­æ¯”ç‰¹çš„å¤æ‚é‡å­ä»¬ã€‚å¹¸è¿çš„æ˜¯ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªé—®é¢˜ã€‚æœ‰äº†ç¡¬ä»¶æä¾›çš„1å’Œ2ä¸ªé‡å­é—¨ï¼Œå°±æœ‰å¯èƒ½å»ºé€ ä»»ä½•å…¶ä»–çš„é‡å­é—¨ã€‚

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†é¦–å…ˆä»‹ç»æœ€åŸºæœ¬çš„é—¨ï¼Œä»¥åŠç”¨æ¥æè¿°å’Œåˆ†æçš„æ•°å­¦ã€‚ç„¶åå°†å±•ç¤ºå¦‚ä½•è¯æ˜è¿™äº›é—¨å¯ä»¥ç”¨æ¥åˆ›å»ºä»»ä½•å¯èƒ½çš„é‡å­ç®—æ³•ã€‚

ç„¶åï¼Œæœ¬ç« ä»¥è§‚å¯Ÿé‡å­é—¨çš„å°è§„æ¨¡åº”ç”¨ä½œä¸ºç»“æŸã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬çœ‹åˆ°å¦‚ä½•ä»å•é‡å­æ¯”ç‰¹æ“ä½œå’ŒåŒé‡å­æ¯”ç‰¹æ“ä½œæ„å»ºç±»ä¼¼äºToffoliçš„ä¸‰é‡å­æ¯”ç‰¹é—¨ã€‚

![](pics/media/image79.png)

2.2 å¤šé‡å­æ¯”ç‰¹å’Œçº ç¼ æ€ï¼ˆEntangled Stateï¼‰
-----------------------------------------

å•é‡å­æ¯”ç‰¹æ˜¯å¾ˆæœ‰è¶£ï¼Œä½†å•ä¸ªå¹¶ä¸èƒ½æä¾›è®¡ç®—ä¼˜åŠ¿ã€‚ç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•è¡¨ç¤ºå¤šé‡å­æ¯”ç‰¹ï¼Œä»¥åŠè¿™äº›é‡å­æ¯”ç‰¹å¦‚ä½•ç›¸äº’ä½œç”¨ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½•ç”¨äºŒç»´å‘é‡è¡¨ç¤ºä¸€ä¸ªé‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œç°åœ¨å°†çœ‹åˆ°å¦‚ä½•è¡¨ç¤ºå¤šé‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚

### å†…å®¹

1\. å‘ˆç°å¤šé‡å­æ¯”ç‰¹çš„çŠ¶æ€

1.1 ç»ƒä¹ 

2\. ç”¨å¤šé‡å­æ¯”ç‰¹æ€å‘é‡å‘ˆç°å•é‡å­æ¯”ç‰¹

2.1 ç»ƒä¹ 

3\. å¤šé‡å­æ¯”ç‰¹é—¨

3.1 å—æ§éé—¨

3.2 çº ç¼ æ€

3.3 ç»ƒä¹ 

### 1. å‘ˆç°å¤šé‡å­æ¯”ç‰¹çš„çŠ¶æ€

æˆ‘ä»¬çœ‹åˆ°å•ä¸ªæ¯”ç‰¹æœ‰ä¸¤ç§å¯èƒ½çš„çŠ¶æ€ï¼Œè€Œä¸€ä¸ªé‡å­æ¯”ç‰¹æœ‰ä¸¤ä¸ªå¤æ•°å¹…å€¼ã€‚åŒæ ·ï¼Œä¸¤ä¸ªæ¯”ç‰¹æœ‰å››ç§å¯èƒ½çš„çŠ¶æ€ï¼š

00 01 10 11

è¦æè¿°ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„çŠ¶æ€éœ€è¦å››ä¸ªå¤æ•°å¹…å€¼ã€‚æˆ‘ä»¬å°†è¿™äº›å¹…å€¼å­˜å‚¨åœ¨ä¸€ä¸ªå››ç»´çš„çŸ¢é‡ä¸­ï¼š

$$\left| a \right\rangle = a_{00}\left| 00 \right\rangle + a_{01}\left| 01 \right\rangle + a_{10}\left| 10 \right\rangle + a_{11}\left| 11 \right\rangle = \begin{bmatrix}
a_{00} \\
a_{01} \\
a_{10} \\
a_{11} \\
\end{bmatrix}$$

æµ‹é‡è§„åˆ™ä»ç„¶ä¸Šä¸€ç« ä¸­æ‰€è¯‰çš„ç›¸åŒï¼š

$$p(|00\rangle) = \left| \left\langle 00 \middle| a \right\rangle \right|^{2} = \left| a00 \right|^{2}$$

åŒæ ·çš„å«ä¹‰ä¹Ÿé€‚ç”¨ï¼Œä¾‹å¦‚æ ‡å‡†åŒ–æ¡ä»¶ï¼š

$$\left| a_{00} \right|^{2} + \left| a_{01} \right|^{2} + \left| a_{10} \right|^{2} + \left| a_{11} \right|^{2} = 1$$

å¦‚æœæœ‰ä¸¤ä¸ªåˆ†å¼€çš„é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å¼ é‡ç§¯ï¼ˆ**tensor
product**ï¼‰æ¥æè¿°å®ƒä»¬çš„æ€»ä½“çŠ¶æ€ï¼š

$$\left| a \right\rangle = \begin{bmatrix}
a_{0} \\
a_{1} \\
\end{bmatrix},\ \left| b \right\rangle = \begin{bmatrix}
b_{0} \\
b_{1} \\
\end{bmatrix}$$

$$\left| \text{ab} \right\rangle = \left| a \right\rangle \otimes \left| b \right\rangle = \begin{bmatrix}
a_{0} \times \begin{bmatrix}
b_{0} \\
b_{1} \\
\end{bmatrix} \\
a_{1} \times \begin{bmatrix}
b_{0} \\
b_{1} \\
\end{bmatrix} \\
\end{bmatrix} = \begin{bmatrix}
a_{0}b_{0} \\
a_{0}b_{1} \\
a_{1}b_{0} \\
a_{1}b_{1} \\
\end{bmatrix}$$

éµå¾ªåŒæ ·çš„è§„åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å¼ é‡ç§¯æ¥æè¿°ä»»æ„æ•°é‡çš„é‡å­æ¯”ç‰¹çš„æ€»ä½“çŠ¶æ€ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªåŒ…å«ä¸‰ä¸ªé‡å­æ¯”ç‰¹çš„ä¾‹å­ï¼š

$$\left| \text{abc} \right\rangle = \begin{bmatrix}
a_{0}b_{0}c_{0} \\
a_{0}b_{0}c_{1} \\
\ a_{0}b_{1}c_{0} \\
a_{0}b_{1}c_{1} \\
\ a_{1}b_{0}c_{0} \\
a_{1}b_{0}c_{1} \\
a_{1}b_{1}c_{0} \\
a_{1}b_{1}c_{1} \\
\end{bmatrix}$$

å¦‚æœæˆ‘ä»¬æœ‰nä¸ªé‡å­æ¯”ç‰¹ï¼Œå°±éœ€è¦è¿½è¸ª$2^{n}$ä¸ªå¤æ•°å¹…å€¼ã€‚æ­£å¦‚æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ï¼Œè¿™äº›å‘é‡ä¾æ®é‡å­æ¯”ç‰¹çš„æ•°é‡æŒ‡æ•°çº§åˆ«çš„å¢é•¿ã€‚è¿™å°±ä¸ºä»€ä¹ˆå«æœ‰å¤§æ•°é‡çš„é‡å­æ¯”ç‰¹çš„é‡å­è®¡ç®—æœºå¾ˆéš¾æ¨¡æ‹Ÿçš„åŸå› ã€‚ä¸€å°è¾ƒæ–°çš„ç¬”è®°æœ¬ç”µè„‘å¯ä»¥æ¨¡æ‹Ÿçº¦20ä¸ªé‡å­æ¯”ç‰¹ï¼Œä½†å¦‚æœæœ‰100ä¸ªé‡å­æ¯”ç‰¹å³ä½¿æ˜¯è¶…çº§è®¡ç®—æœºä¹Ÿå¾ˆéš¾æ¨¡æ‹Ÿã€‚

ç°åœ¨è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªé‡å­å›è·¯çš„ç¤ºä¾‹ï¼š

from qiskit import \*

from math import pi

import numpy as np

from qiskit.visualization import plot_bloch_multivector, plot_histogram

> qc = QuantumCircuit(3)
>
> \# Apply H-gate to each qubit:
>
> for qubit in range(3):
>
> qc.h(qubit)
>
> \# See the circuit:
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image80.png)

æ¯ä¸€ä¸ªé‡å­æ¯”ç‰¹éƒ½å¤„äº\|+âŸ©ï¼Œæ‰€ä»¥æˆ‘ä»¬åº”è¯¥çœ‹åˆ°å‘é‡ï¼š

$$\left| + + + \right\rangle = \frac{1}{\sqrt{8}}\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
1 \\
1 \\
1 \\
1 \\
\end{bmatrix}$$

> \# Let\'s see the result
>
> backend = Aer.get_backend(\'statevector_simulator\')
>
> final_state = execute(qc,backend).result().get_statevector()
>
> \# In Jupyter Notebooks we can display this nicely using Latex.
>
> \# If not using Jupyter Notebooks you may need to remove the
>
> \# vector2latex function and use print(final_state) instead.
>
> from qiskit_textbook.tools import array_to_latex
>
> array_to_latex(final_state, pretext=\"\\\\text{Statevector} = \")
>
> è¾“å‡ºï¼š

![](pics/media/image81.png)

ä»¥ä¸Šä»£ç çš„è¾“å‡ºæ­£æ˜¯æˆ‘ä»¬æ‰€æœŸæœ›çš„ç»“æœã€‚

1.1 å¿«é€Ÿç»ƒä¹ 

1\. å†™å‡ºä»¥ä¸‹é‡å­æ¯”ç‰¹çš„å¼ é‡ç§¯ï¼š

> a\) $|0\rangle|1\rangle$
>
> b\) $|0\rangle| + \rangle$
>
> c\) $| + \rangle|1\rangle$
>
> d\) $| - \rangle| + \rangle$

2\.
å°†æ€å‘é‡$\left| \psi \right\rangle = \frac{1}{\sqrt{2}}\left| 00 \right\rangle + \frac{i}{\sqrt{2}}\left| 01 \right\rangle$å†™æˆä¸¤ä¸ªå•ç‹¬çš„é‡å­æ¯”ç‰¹ã€‚

### 2. ç”¨å¤šé‡å­æ¯”ç‰¹æ€å‘é‡å‘ˆç°å•é‡å­æ¯”ç‰¹

æˆ‘ä»¬å·²ç»çœ‹åˆ°ç”¨çŸ©é˜µè¡¨ç¤ºçš„X-gateï¼š

$$X = \left\lbrack \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right\rbrack$$

å½“å…¶ä½œç”¨äºæ€$\left| 0 \right\rangle$æ—¶ï¼š

$$X\left| 0 \right\rangle = \left\lbrack \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right\rbrack\begin{bmatrix}
1 \\
0 \\
\end{bmatrix} = \begin{bmatrix}
0 \\
1 \\
\end{bmatrix}$$

ä½†X-gateåœ¨å¤šé‡å­æ¯”ç‰¹å‘é‡ä¸­å¦‚ä½•ä½œç”¨äºä¸€ä¸ªé‡å­æ¯”ç‰¹å°šä¸æ¸…æ¥šã€‚å¹¸è¿çš„æ˜¯ï¼Œè§„åˆ™ç›¸å½“ç®€å•ï¼›å’Œæˆ‘ä»¬ç”¨å¼ é‡ç§¯è®¡ç®—å¤šé‡å­æ¯”ç‰¹æ€å‘é‡ä¸€æ ·ï¼Œä½¿ç”¨å¼ é‡ç§¯è®¡ç®—çŸ©é˜µçš„è¿‡ç¨‹æ­£æ˜¯ä½œç”¨äºè¿™äº›æ€å‘é‡çš„è¿‡ç¨‹ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸‹é¢çš„å›è·¯ä¸­ï¼š

> qc = QuantumCircuit(2)
>
> qc.h(0)
>
> qc.x(1)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image82.png)

æˆ‘ä»¬å¯ä»¥ç”¨å¼ é‡ç§¯æ¨¡æ‹Ÿè¿™ä¸€æ“ä½œï¼ˆH&Xï¼‰ï¼š

$$X\left| q_{1} \right\rangle \otimes H\left| q_{0} \right\rangle = \left( X \otimes H \right)\left| q_{1}q_{0} \right\rangle$$

è¿™ä¸€æ“ä½œçš„è¿‡ç¨‹ä¸ºï¼š

$$X \otimes H = \left\lbrack \begin{matrix}
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
\end{matrix} \right\rbrack \otimes \frac{1}{\sqrt{2}}\left\lbrack \begin{matrix}
1 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
\end{matrix} \right\rbrack = \frac{1}{\sqrt{2}}\left\lbrack \begin{matrix}
0 \times \left\lbrack \begin{matrix}
1 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
\end{matrix} \right\rbrack \\
1 \times \left\lbrack \begin{matrix}
1 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
\end{matrix} \right\rbrack \\
\end{matrix}\ \begin{matrix}
1 \times \left\lbrack \begin{matrix}
1 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
\end{matrix} \right\rbrack \\
0 \times \left\lbrack \begin{matrix}
1 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
\end{matrix} \right\rbrack \\
\end{matrix} \right\rbrack = \frac{1}{\sqrt{2}}\left\lbrack \begin{matrix}
0 \\
0 \\
1 \\
1 \\
\end{matrix}\ \begin{matrix}
0 \\
0 \\
1 \\
 - 1 \\
\end{matrix}\ \begin{matrix}
1 \\
1 \\
0 \\
0 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
0 \\
0 \\
\end{matrix} \right\rbrack$$

æˆ‘ä»¬å¯ä»¥å°†ä¸Šå¼åº”ç”¨å››ç»´æ€å‘é‡$\left| q_{1}q_{0} \right\rangle$ã€‚ä½¿å…¶å˜å¾—éå¸¸å®¹æ˜“ï¼Œæ‚¨å°†ä¼šç»å¸¸çœ‹åˆ°ä¸‹é¢çš„æ¸…æ™°ç¬¦å·ï¼š

$$X \otimes H = \left\lbrack \begin{matrix}
0 \\
H \\
\end{matrix}\ \begin{matrix}
H \\
0 \\
\end{matrix} \right\rbrack$$

ä¸å…¶æ‰‹ç®—ä¹‹ä¸€è¿‡ç¨‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Qiskitä¸­çš„unitary_simulatoræ¥è®¡ç®—ã€‚å¹ºæ­£æ¨¡æ‹Ÿå™¨å°†å›è·¯ä¸­æ‰€æœ‰çš„é‡å­é—¨ç›¸ä¹˜ï¼Œå¾—å‡ºä¸€ä¸ªè¿è¡Œæ•´ä¸ªé‡å­å›è·¯çš„å¹ºæ­£çŸ©é˜µï¼š

> backend = Aer.get_backend(\'unitary_simulator\')
>
> unitary = execute(qc,backend).result().get_unitary()
>
> \# In Jupyter Notebooks we can display this nicely using Latex.
>
> \# If not using Jupyter Notebooks you may need to remove the
>
> \# unitary2latex function and use print(unitary) instead.
>
> from qiskit_textbook.tools import array_to_latex
>
> array_to_latex(unitary, pretext=\"\\\\text{Circuit = }\\n\")
>
> è¾“å‡ºï¼š

![](pics/media/image83.png)

å¦‚æœæˆ‘ä»¬ä»…æƒ³è¦æ¯æ¬¡åªåœ¨ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨ä¸€ä¸ªé‡å­é—¨ï¼ˆå¦‚ä¸‹æ‰€ç¤ºï¼‰ï¼Œä½¿ç”¨å•ä½çŸ©é˜µè¿›è¡Œå¼ é‡ç§¯ï¼š

$$X \otimes I$$

å¯ä»¥çœ‹åˆ°ï¼Œåœ¨Qiskitä¸­è¿›è¡Œå¼ é‡ç§¯çš„ç»“æœï¼š

$$X \otimes I = \left\lbrack \begin{matrix}
0 \\
I \\
\end{matrix}\ \begin{matrix}
I \\
0 \\
\end{matrix} \right\rbrack = \left\lbrack \begin{matrix}
0 \\
0 \\
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
0 \\
0 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
0 \\
0 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
1 \\
0 \\
0 \\
\end{matrix} \right\rbrack$$

#### 2.1 å¿«é€Ÿç»ƒä¹ 

1\. è®¡ç®—ç”±ä¸€ç³»åˆ—é‡å­é—¨åˆ›å»ºçš„å•ä¸€é‡å­æ¯”ç‰¹$U = XZH$çš„å¹ºæ­£å˜æ¢unitary
(ğ‘ˆ)ã€‚ä½¿ç”¨Qiskitä¸­çš„å¹ºæ­£æ¨¡æ‹Ÿå™¨æ¥éªŒè¯æ‚¨çš„ç­”æ¡ˆã€‚

2\.
å°è¯•æ”¹å˜ä¸Šè¿°äº§é‡å­å›è·¯ä¸­çš„é‡å­é—¨ã€‚è®¡ç®—å…¶å¼ é‡ç§¯ï¼Œå¹¶ç”¨å¹ºæ­£æ¨¡æ‹Ÿå™¨æ£€æŸ¥ç­”æ¡ˆã€‚

**æ³¨ï¼š**ä¸åŒä¹¦ç±ã€è½¯ä»¶å’Œç½‘ç«™ä¸­é‡å­æ¯”ç‰¹çš„é¡ºåºä¹Ÿä¸åŒï¼Œè¡¨æ˜åŒä¸€é‡å­å›è·¯çš„å¼ é‡ç§¯å¯èƒ½çœ‹ä¸Šå»æä¸ºä¸åŒã€‚å½“æŸ¥é˜…å…¶ä»–èµ„æ–™æ—¶ï¼Œè¯·å°†è¿™ä¸€ç‚¹é“­è®°åœ¨å¿ƒã€‚

> qc = QuantumCircuit(2)
>
> qc.x(1)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image84.png)

> \# Simulate the unitary
>
> backend = Aer.get_backend(\'unitary_simulator\')
>
> unitary = execute(qc,backend).result().get_unitary()
>
> \# Display the results:
>
> array_to_latex(unitary, pretext=\"\\\\text{Circuit = } \")
>
> è¾“å‡ºï¼š

![](pics/media/image85.png)

### 3. å¤šé‡å­æ¯”ç‰¹é—¨

è‡³æ­¤æˆ‘ä»¬çŸ¥é“äº†å¦‚ä½•è¡¨ç¤ºå¤šé‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œä¸ºå­¦ä¹ é‡å­æ¯”ç‰¹ä¹‹é—´å¦‚ä½•äº¤äº’åšå¥½äº†å‡†å¤‡ã€‚å…¶ä¸­ä¸€ä¸ªéå¸¸é‡è¦çš„åŒé‡å­æ¯”ç‰¹é—¨ï¼ˆtwo-qubit
gateï¼‰æ˜¯å—æ§éé—¨ï¼ˆCNOT-gateï¼‰ã€‚

#### 3.1 å—æ§éé—¨ï¼ˆCNOT-gateï¼‰

æ‚¨åœ¨å…ˆå‰çš„"è®¡ç®—çš„åŸºå…ƒ"ä¸­å·²ç»é‡åˆ°è¿‡è¯¥é‡å­é—¨ã€‚å¦‚æœç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼ˆæ§åˆ¶ï¼‰æ˜¯$|1\rangle$ï¼Œå—æ§éé—¨æ˜¯ä¸€ä¸ªåœ¨ç¬¬äºŒä¸ªé‡å­æ¯”ç‰¹ï¼ˆç›®æ ‡ï¼‰ä¸Šæ‰§è¡ŒX-gateçš„æ¡ä»¶é—¨ï¼ˆconditional
gateï¼‰ã€‚è¯¥é‡å­é—¨ç»˜åˆ¶åœ¨å›è·¯ä¸­çš„æ ·å­å¦‚ä¸‹ï¼Œå…¶ä¸­q0ä½œä¸ºæ§åˆ¶ï¼Œq1ä½œä¸ºç›®æ ‡ï¼š

> qc = QuantumCircuit(2)
>
> \# Apply CNOT
>
> qc.cx(0,1)
>
> \# See the circuit:
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image86.png)

å½“é‡å­æ¯”ç‰¹ä¸å¤„äº$|0\rangle$å’Œ$|1\rangle$ï¼ˆç±»ä¼¼ç»å…¸æ¯”ç‰¹çš„è¡Œä¸ºï¼‰ä¹‹é—´çš„å åŠ æ€æ—¶ï¼Œå—æ§éé—¨éå¸¸ç®€å•ä¸”èƒ½å¤Ÿè¢«ç›´è§‚çš„ç†è§£ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç»å…¸çœŸå€¼è¡¨æ¥æè¿°ï¼š

  **è¾“å…¥(t,c)**   **è¾“å‡º(t,c)**
--------------- ---------------
  00              00
  01              11
  10              10
  11              01

å°†å…¶è½¬æ¢ä¸ºå››ä½æ€å‘é‡ï¼Œå…¶ä¸ºä»¥ä¸‹ä¸¤ä¸ªçŸ©é˜µä¸­çš„ä¸€ä¸ªï¼š

$$ {CNOT = \left\lbrack \begin{matrix}
1 \\
0 \\
0 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
0 \\
0 \\
1 \\
\end{matrix}\ \begin{matrix}
0 \\
0 \\
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
1 \\
0 \\
0 \\
\end{matrix} \right\rbrack,\ 
}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CNOT = \left\lbrack \begin{matrix}
1 \\
0 \\
0 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
1 \\
0 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
0 \\
0 \\
1 \\
\end{matrix}\ \begin{matrix}
0 \\
0 \\
1 \\
0 \\
\end{matrix} \right\rbrack}$$

ä¾æ®å“ªä¸€é‡å­æ¯”ç‰¹æ˜¯æ§åˆ¶ç«¯æˆ–ç›®æ ‡ç«¯ã€‚ä¸åŒä¹¦ç±ã€æ¨¡æ‹Ÿå™¨å’Œè®ºæ–‡å¯¹é‡å­æ¯”ç‰¹çš„æ’åºä¹Ÿä¸ä¸€æ ·ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œå·¦ä¾§çš„çŸ©é˜µå¯¹åº”äºä¸Šè¿°æ‰€æœ‰é‡å­å›è·¯ä¸­çš„å—æ§éé—¨ã€‚è¯¥çŸ©é˜µäº¤æ¢æ€å‘é‡ä¸­\|01âŸ©å’Œ\|11âŸ©ä¹‹é—´çš„å¹…å€¼ã€‚

$$\left| a \right\rangle = \begin{bmatrix}
a_{00} \\
a_{01} \\
a_{10} \\
a_{11} \\
\end{bmatrix},\ \ CNOT\left| a \right\rangle = \begin{bmatrix}
a_{00} \\
a_{11} \\
a_{10} \\
a_{01} \\
\end{bmatrix}$$

æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å—æ§éé—¨å¦‚ä½•ä½œç”¨äºç»å…¸çŠ¶æ€çš„æ–¹å¼ï¼Œç°åœ¨çœ‹çœ‹è¯¥é‡å­é—¨å¦‚ä½•ä½œç”¨äºå¤„äºå åŠ æ€çš„é‡å­æ¯”ç‰¹ã€‚æˆ‘ä»¬å°†å…¶ä½œç”¨äºæ€\|+âŸ©ï¼š

> qc = QuantumCircuit(2)
>
> \# Apply H-gate to the first:
>
> qc.h(0)
>
> qc.draw()
>
> è¾“å‡ºï¼š
>
> ![](pics/media/image87.png)
>
> \# Let\'s see the result:
>
> backend = Aer.get_backend(\'statevector_simulator\')
>
> final_state = execute(qc,backend).result().get_statevector()
>
> \# Print the statevector neatly:
>
> array_to_latex(final_state, pretext=\"\\\\text{Statevector = }\")
>
> è¾“å‡ºï¼š

![](pics/media/image88.png)

æ­£å¦‚æ‰€æœŸæœ›çš„é‚£æ ·ï¼Œè¿™ä¸€æ“ä½œäº§ç”Ÿäº†$\left| 0 \right\rangle \otimes \left| + \right\rangle = \left| 0 + \right\rangle$ï¼š

$$\left| 0 + \right\rangle = \frac{1}{\sqrt{2}}\left( \left| 00 \right\rangle + \left| 01 \right\rangle \right)$$

æ¥ç€çœ‹çœ‹åº”ç”¨å—æ§éé—¨ä¹‹åçš„æƒ…å†µï¼š

> qc = QuantumCircuit(2)
>
> \# Apply H-gate to the first:
>
> qc.h(0)
>
> \# Apply a CNOT:
>
> qc.cx(0,1)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image89.png)

> \# Let\'s see the result:
>
> backend = Aer.get_backend(\'statevector_simulator\')
>
> final_state = execute(qc,backend).result().get_statevector()
>
> \# Print the statevector neatly:
>
> array_to_latex(final_state, pretext=\"\\\\text{Statevector = }\")
>
> è¾“å‡ºï¼š

![](pics/media/image90.png)

å¯ä»¥çœ‹åˆ°æˆ‘ä»¬è·å¾—äº†æ€ï¼š

$$\text{CNOT}\left| 0 + \right\rangle = \frac{1}{\sqrt{2}}\left( \left| 00 \right\rangle + \left| 11 \right\rangle \right)$$

è¿™ä¸€é‡å­æ€éå¸¸æœ‰è¶£ï¼Œå› ä¸ºå…¶æ˜¯çº ç¼ çš„ï¼ˆ***entangled***ï¼‰ã€‚è¿™ä¸€å‘ç°å°†æˆ‘ä»¬å¼•å‘ä¸‹ä¸€èŠ‚çš„å†…å®¹ã€‚

#### 3.2 çº ç¼ æ€ï¼ˆEntangled Stateï¼‰

åœ¨å‰ä¸€èŠ‚ä¸­æˆ‘ä»¬åˆ›å»ºäº†æ€ï¼š

$$\frac{1}{\sqrt{2}}\left( \left| 00 \right\rangle + \left| 11 \right\rangle \right)$$

è¿™ä¸€é‡å­æ€è¢«ç§°ä¸ºè´å°”åŸºæ€ï¼ˆ*Bell*
stateï¼‰ã€‚å¯ä»¥çœ‹å‡ºè¯¥é‡å­æ€æœ‰50%çš„æ¦‚ç‡æµ‹é‡å‡ºæ€$\left| 00 \right\rangle$ï¼Œä»¥åŠ50%çš„æœºç‡æµ‹é‡æ€$\left| 11 \right\rangle$ã€‚éå¸¸æœ‰è¶£çš„æ˜¯ï¼šè¯¥é‡å­æ€æµ‹é‡å‡ºæ€$\left| 01 \right\rangle$å’Œ$\left| 10 \right\rangle$çš„æœºç‡ä¸º0ã€‚æˆ‘ä»¬å‘¢å¯ä»¥åœ¨Qiskitä¸­ä½¿ç”¨å¦‚ä¸‹ä»£ç æ¥éªŒè¯ï¼š

> results = execute(qc,backend).result().get_counts()
>
> plot_histogram(results)
>
> è¾“å‡ºï¼š

![](pics/media/image91.png)

è¿™ä¸€å¤åˆçŠ¶æ€æ— æ³•å†™ä¸ºä¸¤ä¸ªå•ç‹¬é‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œå…¶è•´å«çš„æ„ä¹‰è®©äººç€è¿·ã€‚è™½ç„¶æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹å¤„äºå åŠ æ€ï¼Œæµ‹é‡å…¶ä¸­ä¸€ä¸ªä¼šå‘Šè¯‰æˆ‘ä»¬å¦ä¸€ä¸ªçš„çŠ¶æ€å¹¶ä½¿å…¶å åŠ æ€åç¼©ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æµ‹é‡åä¸Šé¢çš„é‡å­å·´æ¯”ç‰¹å¹¶è·çŸ¥å…¶çŠ¶æ€ä¸º$\left| 1 \right\rangle$ï¼Œæ‰€æœ‰é‡å­æ¯”ç‰¹çš„æ•´ä½“çŠ¶æ€å˜åŒ–å¦‚ä¸‹ï¼š

$$\frac{1}{\sqrt{2}}\left( \left| 00 \right\rangle + \left| 11 \right\rangle \right)\overset{\text{measure}}{\rightarrow}\left| 11 \right\rangle$$

å³ä½¿å°†è¿™äº›é‡å­æ¯”ç‰¹æ”¾ç½®åœ¨äº’ç›¸ç›¸éš”å…‰å¹´ä»¥å¤–çš„ä½ç½®ï¼Œæµ‹é‡å…¶ä¸­ä¸€ä¸ªé‡å­æ¯”ç‰¹å°±ä¼šä½¿å åŠ æ€åç¼©ï¼Œå¹¶åœ¨å…¶ä»–é‡å­æ¯”ç‰¹ä¸Šå³åˆ»äº§ç”Ÿå½±å“ã€‚è¿™å°±æ˜¯é¬¼é­…èˆ¬çš„è¶…è·ä½œç”¨ï¼ˆ[spooky
action at a
distance](https://en.wikipedia.org/wiki/Quantum_nonlocality)ï¼‰ï¼Œè¯¥ä½œç”¨ä½¿å¾—20ä¸–çºªçš„å¤§éƒ¨åˆ†ç‰©ç†å­¦å®¶æ„Ÿåˆ°æ²®ä¸§ã€‚

#### 3.3 å¿«é€Ÿç»ƒä¹ 

1\.
åˆ›å»ºä¸€ä¸ªå¯ä»¥äº§ç”Ÿè´å°”åŸºæ€$\frac{1}{\sqrt{2}}\left( \left| 01 \right\rangle + \left| 10 \right\rangle \right)$çš„é‡å­å›è·¯ã€‚ä½¿ç”¨Qiskitä¸­çš„æ€å‘é‡æ¨¡æ‹Ÿå™¨éªŒè¯ç»“æœã€‚

2\.
åœ¨ä¸Šé¢ç»ƒä¹ ä¸­åˆ›å»ºçš„é‡å­å›è·¯å°†æ€$\left| 00 \right\rangle$è½¬æ¢ä¸º$\frac{1}{\sqrt{2}}\left( \left| 01 \right\rangle + \left| 10 \right\rangle \right)$ï¼Œä½¿ç”¨Qiskitä¸­çš„æ¨¡æ‹Ÿå™¨è®¡ç®—è¿™ä¸€å›è·¯çš„å¹ºæ­£çŸ©é˜µã€‚éªŒè¯è¿™ä¸€å¹ºæ­£çŸ©é˜µæ‰§è¡Œäº†å‡†ç¡®çš„å˜æ¢ã€‚

### 4. å‚è€ƒæ–‡çŒ®

\[1\] Asher Peres, Daniel R. Terno, Quantum Information and Relativity
Theory, 2004, https://arxiv.org/abs/quant-ph/0212023

2.3 ç›¸ä½åå†²ï¼ˆPhase Kickbackï¼‰
------------------------------

### å†…å®¹

1\. æ¢ç´¢å—æ§éé—¨

2\. ç›¸ä½åå†²

2.1 è§£é‡Šå—æ§éé—¨å›è·¯æ’ç­‰å¼

2.2 ä½¿ç”¨T-gateåå†²

### 1. æ¢ç´¢å—æ§éé—¨

åœ¨ä¹‹å‰çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°å—æ§éé—¨çš„ä¸€äº›éå¸¸åŸºç¡€ç»“æœã€‚åœ¨æœ¬èŠ‚ä¸­æˆ‘ä»¬å°†ä¼šæ¢ç´¢æ›´æœ‰è¶£çš„ç»“æœã€‚

æˆ‘ä»¬åœ¨ä¸Šä¸€èŠ‚ä¸­çœ‹åˆ°å¯ä»¥é€šè¿‡è®¾ç½®å—æ§é‡å­æ¯”ç‰¹ä¸ºæ€$| + \rangle$ä½¿å¾—ä¸¤ä¸ªé‡å­æ¯”ç‰¹çº ç¼ ï¼š

$$\text{CNOT}\left| 0 + \right\rangle = \frac{1}{\sqrt{2}}\left( \left| 00 \right\rangle + \left| 11 \right\rangle \right)$$

ä½†æ˜¯å¦‚æœæ”¾å…¥å¤„äºå åŠ æ€çš„ç¬¬äºŒä¸ªä¸¤ä¸ªæ¯”ç‰¹ä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ

> from qiskit import QuantumCircuit, Aer, execute
>
> from math import pi
>
> import numpy as np
>
> from qiskit.visualization import plot_bloch_multivector,
> plot_histogram
>
> \# In Jupyter Notebooks we can display this nicely using Latex.
>
> \# If not using Jupyter Notebooks you may need to remove the
>
> \# array_to_latex function and use print() instead.
>
> from qiskit_textbook.tools import array_to_latex
>
> qc = QuantumCircuit(2)
>
> qc.h(0)
>
> qc.h(1)
>
> qc.cx(0,1)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image92.png)

åœ¨ä¸Šé¢çš„é‡å­å›è·¯ä¸­ï¼Œæˆ‘ä»¬å°†å—æ§éé—¨ä½œç”¨äºæ€ï¼š

$$| + + \rangle = \frac{1}{\sqrt{2}}(|00\rangle + |01\rangle + |10\rangle + |11\rangle)$$

ç”±äºå—æ§éé—¨CNOTäº¤æ¢æ€$\left| 01 \right\rangle$å’Œ$\left| 11 \right\rangle$çš„å¹…å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šçœ‹åˆ°å˜åŒ–ï¼š

> qc = QuantumCircuit(2)
>
> qc.h(0)
>
> qc.h(1)
>
> qc.cx(0,1)
>
> display(qc.draw())
>
> \# Let\'s see the result
>
> statevector_backend = Aer.get_backend(\'statevector_simulator\')
>
> final_state =
> execute(qc,statevector_backend).result().get_statevector()
>
> array_to_latex(final_state, pretext=\"\\\\text{Statevector} = \",
> precision=1)
>
> plot_bloch_multivector(final_state)
>
> è¾“å‡ºï¼š

![](pics/media/image93.png)

![](pics/media/image94.png)

ç°åœ¨è®¾ç½®ç›®æ ‡é‡å­æ¯”ç‰¹ä¸ºæ€$| - \rangle$ï¼Œæ‰€ä»¥å…¶æˆä¸ºä¸€ä¸ªè´Ÿç›¸ä½ï¼š

> qc = QuantumCircuit(2)
>
> qc.h(0)
>
> qc.x(1)
>
> qc.h(1)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image95.png)

å°†ä¼šç”Ÿæˆå¦‚ä¸‹çŠ¶æ€ï¼š

$$| \mp \rangle = \frac{1}{\sqrt{2}}(|00\rangle + |01\rangle - |10\rangle - |11\rangle)$$

> qc = QuantumCircuit(2)
>
> qc.h(0)
>
> qc.x(1)
>
> qc.h(1)
>
> display(qc.draw())
>
> \# See the result
>
> final_state =
> execute(qc,statevector_backend).result().get_statevector()
>
> array_to_latex(final_state, pretext=\"\\\\text{Statevector} = \",
> precision=1)
>
> plot_bloch_multivector(final_state)
>
> è¾“å‡ºï¼š

![](pics/media/image96.png)![](pics/media/image97.png)

![](pics/media/image98.png)

å¦‚æœå—æ§éé—¨ä½œç”¨äºè¿™ä¸€çŠ¶æ€ï¼Œå°†ä¼šäº¤æ¢æ€$\left| 01 \right\rangle$å’Œ$\left| 11 \right\rangle$çš„å¹…å€¼ï¼Œç»“æœä¼šæ˜¯å¦‚ä¸‹çš„çŠ¶æ€ï¼š

$$CNOT| \mp \rangle = \frac{1}{\sqrt{2}}(|00\rangle - |01\rangle - |10\rangle + |11\rangle)$$

$$\text{CNOT}\left| \mp \right\rangle = \left| - - \right\rangle$$

è¿™ä¸€ç‚¹éå¸¸æœ‰è¶£ï¼Œå› ä¸ºå…¶åœ¨ä¸æ”¹å˜ç›®æ ‡é‡å­æ¯”ç‰¹çŠ¶æ€çš„æƒ…å†µä¸‹å½±å“äº†æ§åˆ¶é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚

> qc.cx(0,1)
>
> display(qc.draw())
>
> final_state =
> execute(qc,statevector_backend).result().get_statevector()
>
> array_to_latex(final_state, pretext=\"\\\\text{Statevector} = \",
> precision=1)
>
> plot_bloch_multivector(final_state)
>
> è¾“å‡ºï¼š

![](pics/media/image99.png)![](pics/media/image100.png)

![](pics/media/image101.png)

å¦‚æœæ‚¨è¿˜è®°å¾—H-gateï¼ˆé˜¿è¾¾é©¬é—¨ï¼‰å°†$\left| + \right\rangle \rightarrow \left| 0 \right\rangle$ä»¥åŠ$\left| - \right\rangle \rightarrow \left| 1 \right\rangle$ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å¤šä¸ªH-gateä¸­è£…å…¥ä¸€ä¸ªå—æ§éé—¨ï¼Œç­‰åŒäºä¸€ä¸ªç›¸åæ–¹å‘å—æ§éé—¨çš„è¡Œä¸ºï¼š

![](pics/media/image102.png)

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨Qiskitä¸­çš„å¹ºæ­£æ¨¡æ‹Ÿå™¨æ¥éªŒè¯è¿™ä¸€æƒ³æ³•ï¼š

> qc = QuantumCircuit(2)
>
> qc.h(0)
>
> qc.h(1)
>
> qc.cx(0,1)
>
> qc.h(0)
>
> qc.h(1)
>
> display(qc.draw())
>
> \# \`display\` is an IPython tool, remove if it cases an error
>
> unitary_backend = Aer.get_backend(\'unitary_simulator\')
>
> unitary = execute(qc,unitary_backend).result().get_unitary()
>
> array_to_latex(unitary, pretext=\"\\\\text{Circuit = }\\n\")
>
> è¾“å‡ºï¼š

![](pics/media/image103.png)

> qc = QuantumCircuit(2)
>
> qc.cx(1,0)
>
> display(qc.draw())
>
> unitary_backend = Aer.get_backend(\'unitary_simulator\')
>
> unitary = execute(qc,unitary_backend).result().get_unitary()
>
> array_to_latex(unitary, pretext=\"\\\\text{Circuit = }\\n\")
>
> è¾“å‡ºï¼š

![](pics/media/image104.png)

è¿™ä¸€ç­‰å¼å°±æ˜¯ç›¸ä½åå†²ï¼ˆ*phase
kickback*ï¼‰çš„ç¤ºä¾‹ï¼Œå¹¶å°†æˆ‘ä»¬å¼•å‘ä¸‹ä¸€èŠ‚çš„å†…å®¹ã€‚

### 2. ç›¸ä½åå†²

2.1 è§£é‡Šå—æ§éé—¨å›è·¯æ’ç­‰å¼

åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°å¦‚ä¸‹æ’ç­‰å¼ï¼š

![](pics/media/image105.png)

è¿™ä¸€åå†²ï¼ˆç›¸ä½åå†²ï¼‰çš„ç¤ºä¾‹éå¸¸é‡è¦ï¼Œå…¶å¯ç”¨åœ¨å‡ ä¹æ‰€æœ‰çš„é‡å­ç®—æ³•ä¸­ã€‚åå†²å³ç”±ä¸€ä¸ªé‡å­é—¨åŠ åˆ°é‡å­æ¯”ç‰¹ä¸Šçš„æœ¬å¾å€¼ï¼Œç»ç”±ä¸€ä¸ªå—æ§æ“ä½œ"å›å¼¹ï¼ˆkicked
backï¼‰"è‡³ä¸€ä¸ªä¸åŒçš„é‡å­æ¯”ç‰¹ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬çœ‹åˆ°è¿‡åœ¨ä¸€ä¸ª$\left| - \right\rangle$æ€çš„é‡å­æ¯”ç‰¹æ‰§è¡ŒX-gateä¼šç»™å‡ºè¯¥é‡å­æ¯”ç‰¹çš„ç›¸ä½-1ï¼š

$$X\left| - \right\rangle = - \left| - \right\rangle$$

å½“æˆ‘ä»¬çš„æ§åˆ¶ç«¯é‡å­æ¯”ç‰¹å¤„äºæ€$\left| 0 \right\rangle$æˆ–$\left| 1 \right\rangle$æ—¶ï¼Œè¯¥ç›¸ä½ä¼šå½±å“æ•´ä¸ªçŠ¶æ€ï¼Œç„¶è€Œå…¨å±€ç›¸ä½æ²¡æœ‰å—åˆ°æ˜æ˜¾çš„å½±å“ï¼š

$${\text{CNOT}\left| - 0 \right\rangle = \left| - \right\rangle \otimes \left| 0 \right\rangle
}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  = \left| - 0 \right\rangle
}{\text{CNOT}\left| - 1 \right\rangle = X\left| - \right\rangle \otimes \left| 1 \right\rangle
}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  = - \left| - \right\rangle \otimes \left| 1 \right\rangle
}{= - \left| - 1 \right\rangle}$$

è¿™ä¸€æœ‰è¶£çš„å½±å“å½“æ§åˆ¶ç«¯é‡å­æ¯”ç‰¹å¤„äºå åŠ æ€æ—¶æ‰ä¼šå‘ç”Ÿï¼Œä»…å½“ç›®æ ‡ç«¯é‡å­æ¯”ç‰¹å¤„äºæ€$\left| 1 \right\rangle$æ—¶è¿™ä¸€ç›¸ä½å› å­æ‰ä¼šåº”ç”¨äºç›®æ ‡ç«¯é‡å­æ¯”ç‰¹ï¼Œå°±æ˜¯åœ¨æ§åˆ¶ç«¯é‡å­æ¯”ç‰¹ä¸Šæ·»åŠ ä¸€ä¸ªç›¸å¯¹ç›¸ä½ï¼š

$$CNOT| \mp \rangle = \frac{1}{\sqrt{2}}(CNOT| - 0\rangle + CNOT| - 1\rangle)$$

$$CNOT| \mp \rangle = \frac{1}{\sqrt{2}}(| - 0\rangle + X| - 1\rangle)$$

$$CNOT| \mp \rangle = \frac{1}{\sqrt{2}}(| - 0\rangle - | - 1\rangle)$$

ä¸Šè¿°ä¹Ÿå¯å†™æˆä¸¤ä¸ªå•ç‹¬çš„é‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼š

$$CNOT| \mp \rangle = | - \rangle \otimes \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$$

$$\text{CNOT}\left| \mp \right\rangle = \left| - - \right\rangle$$

è£…å…¥å¤šä¸ªH-gateçš„å—æ§éé—¨å°†é‡å­æ¯”ç‰¹ä»è®¡ç®—åŸºè½¬æ¢ä¸ºåŸº\|+âŸ©å’Œ\|âˆ’âŸ©ï¼Œæ­£å¦‚æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ä¸€æ ·ã€‚è¿™ä¸€æ’ç­‰å¼åœ¨ç¡¬ä»¶ä¸­éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºæŸäº›é‡å­ç¡¬ä»¶ä»…å…è®¸å—æ§éé—¨ä½œç”¨äºä¸¤ä¸ªç‰¹å®šé‡å­æ¯”ç‰¹ä¸­çš„ä¸€ä¸ªæ–¹å‘ä¸Šã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸€æ’ç­‰å¼å…‹æœè¿™ä¸€é—®é¢˜ï¼Œè®©å—æ§éé—¨èƒ½å¤Ÿåœ¨ä¸¤ä¸ªæ–¹å‘ä¸Šå‘ç”Ÿä½œç”¨ã€‚

2.2 ä½¿ç”¨T-gateå®ç°åå†²

ç°åœ¨æˆ‘ä»¬çœ‹ä¸€çœ‹ä¸¤ä¸€ä¸ªå—æ§çš„æ“ä½œï¼Œå—æ§Té—¨ï¼š

> qc = QuantumCircuit(2)
>
> qc.cu1(pi/4, 0, 1)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image106.png)

T-gateçš„çŸ©é˜µå½¢å¼å¦‚ä¸‹ï¼š

$$T = \left\lbrack \begin{matrix}
1 \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
e^{\frac{\text{iÏ€}}{4}} \\
\end{matrix} \right\rbrack$$

å—æ§Té—¨çš„çŸ©é˜µå½¢å¼å¦‚ä¸‹ï¼š

$$\text{Controlled} - T = \left\lbrack \begin{matrix}
\begin{matrix}
1 \\
0 \\
\end{matrix} \\
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\end{matrix}\ \begin{matrix}
\begin{matrix}
0 \\
1 \\
\end{matrix} \\
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\end{matrix}\ \begin{matrix}
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\begin{matrix}
1 \\
0 \\
\end{matrix} \\
\end{matrix}\ \begin{matrix}
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\begin{matrix}
0 \\
e^{\frac{\text{iÏ€}}{4}} \\
\end{matrix} \\
\end{matrix} \right\rbrack$$

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨Qiskitä¸­çš„å¹ºæ­£æ¨¡æ‹Ÿå™¨æ¥éªŒè¯ï¼š

> qc = QuantumCircuit(2)
>
> qc.cu1(pi/4, 0, 1)
>
> display(qc.draw())
>
> \# See Results:
>
> unitary_backend = Aer.get_backend(\'unitary_simulator\')
>
> unitary = execute(qc,unitary_backend).result().get_unitary()
>
> array_to_latex(unitary, pretext=\"\\\\text{Controlled-T} = \\n\")
>
> è¾“å‡ºï¼š

![](pics/media/image107.png)

æ›´ä¸€èˆ¬åœ°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä»¥ä¸‹è§„åˆ™æ‰¾åˆ°ä»»ä¸€å—æ§Uæ“ä½œçš„çŸ©é˜µï¼š

$$U = \left\lbrack \begin{matrix}
u_{00} \\
u_{10} \\
\end{matrix}\ \begin{matrix}
u_{01} \\
u_{11} \\
\end{matrix} \right\rbrack$$

$$\text{Controlled} - U = \left\lbrack \begin{matrix}
I \\
0 \\
\end{matrix}\ \begin{matrix}
0 \\
U \\
\end{matrix} \right\rbrack = \left\lbrack \begin{matrix}
\begin{matrix}
1 \\
0 \\
\end{matrix} \\
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\end{matrix}\ \begin{matrix}
\begin{matrix}
0 \\
1 \\
\end{matrix} \\
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\end{matrix}\ \begin{matrix}
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\begin{matrix}
u_{00} \\
u_{10} \\
\end{matrix} \\
\end{matrix}\ \begin{matrix}
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\begin{matrix}
u_{01} \\
u_{11} \\
\end{matrix} \\
\end{matrix} \right\rbrack$$

æˆ–è€…ä½¿ç”¨Qiskitçš„é‡å­æ¯”ç‰¹æ’åˆ—ï¼š

$$\text{Controlled} - U = \left\lbrack \begin{matrix}
\begin{matrix}
1 \\
0 \\
\end{matrix} \\
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\end{matrix}\ \begin{matrix}
\begin{matrix}
0 \\
u_{00} \\
\end{matrix} \\
\begin{matrix}
0 \\
u_{10} \\
\end{matrix} \\
\end{matrix}\ \begin{matrix}
\begin{matrix}
0 \\
0 \\
\end{matrix} \\
\begin{matrix}
1 \\
0 \\
\end{matrix} \\
\end{matrix}\ \begin{matrix}
\begin{matrix}
0 \\
u_{01} \\
\end{matrix} \\
\begin{matrix}
0 \\
u_{11} \\
\end{matrix} \\
\end{matrix} \right\rbrack$$

å¦‚æœåº”ç”¨T-gateäºä¸€ä¸ªå¤„äºæ€\|1âŸ©çš„é‡å­æ¯”ç‰¹ï¼Œå°±ä¼šåœ¨è¯¥é‡å­æ¯”ç‰¹ä¸Šæ·»åŠ äº†$e^{\frac{\text{iÏ€}}{4}}$çš„ç›¸ä½ï¼š

$$T\left| 1 \right\rangle = e^{\frac{\text{iÏ€}}{4}}\left| 1 \right\rangle$$

æ­¤ä¸ºå…¨å±€ç›¸ä½ï¼ˆ*global
phase*ï¼‰ä¸”ä¸å—æ§ã€‚ä½†å¦‚æœæˆ‘ä»¬ä½¿ç”¨å¤„äºæ€\|+âŸ©çš„å¦ä¸€ä¸ªé‡å­æ¯”ç‰¹æ¥æ§åˆ¶è¿™ä¸€æ“ä½œï¼Œå…¨å±€ç›¸ä½å°±ä¼šå˜ä¸ºç›¸å¯¹ç›¸ä½ï¼š

$${|1 + \rangle = |1\rangle \otimes \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) = \frac{1}{\sqrt{2}}(|10\rangle + |11\rangle)
}{Controlled - T|1 + \rangle = \frac{1}{\sqrt{2}}(|10\rangle + e^{\frac{\text{iÏ€}}{4}}|11\rangle)
}{Controlled - T|1 + \rangle = |1\rangle \otimes \frac{1}{\sqrt{2}}(|0\rangle + e^{\frac{\text{iÏ€}}{4}}|1\rangle)}$$

ä½¿å¾—æ§åˆ¶ç«¯é‡å­æ¯”ç‰¹ç»•ç€å¸ƒæ´›èµ«çƒçš„zè½´æ—‹è½¬ï¼ŒåŒæ—¶ä¿æŒç›®æ ‡ç«¯é‡å­æ¯”ç‰¹ä¸å˜ï¼š

> qc = QuantumCircuit(2)
>
> qc.h(0)
>
> qc.x(1)
>
> display(qc.draw())
>
> \# See Results:
>
> final_state =
> execute(qc,statevector_backend).result().get_statevector()
>
> plot_bloch_multivector(final_state)
>
> è¾“å‡ºï¼š

![](pics/media/image108.png)

> qc = QuantumCircuit(2)
>
> qc.h(0)
>
> qc.x(1)
>
> \# Add Controlled-T
>
> qc.cu1(pi/4, 0, 1)
>
> display(qc.draw())
>
> \# See Results:
>
> final_state =
> execute(qc,statevector_backend).result().get_statevector()
>
> plot_bloch_multivector(final_state)
>
> è¾“å‡ºï¼š

![](pics/media/image109.png)

å¯ä»¥çœ‹åˆ°æœ€å³è¾¹çš„é‡å­æ¯”ç‰¹æ­£å¦‚æˆ‘ä»¬æ‰€å¸Œæœ›åœ°ç»•å¸ƒæ´›èµ«çƒçš„zè½´æ—‹è½¬äº†Ï€/4ã€‚åœ¨æ¢ç´¢äº†è¿™ç§è¡Œä¸ºä¹‹åï¼Œä¸ºä½•Qiskitä»¥è¿™ç§å¯¹ç§°æ–¹å¼ï¼ˆä¸¤ä¸ªæ§åˆ¶ç«¯è€Œä¸æ˜¯ä¸€ä¸ªæ§åˆ¶ç«¯å’Œä¸€ä¸ªç›®æ ‡ç«¯ï¼‰ç»˜åˆ¶å—æ§Zæ—‹è½¬é‡å­é—¨çš„åŸå› å°±å˜å¾—å¾ˆæ¸…æ¥šäº†ã€‚åœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼Œé‡å­æ¯”ç‰¹æ²¡æœ‰æ˜ç¡®çš„æ§åˆ¶ç«¯æˆ–ç›®æ ‡ç«¯ã€‚

![](pics/media/image110.png)

#### å¿«é€Ÿç»ƒä¹ 

1\.
å¦‚æœç›®æ ‡ç«¯é‡å­æ¯”ç‰¹ï¼ˆq1ï¼‰å¤„äºæ€\|0âŸ©æ—¶ï¼Œæ§åˆ¶ç«¯é‡å­æ¯”ç‰¹\|1âŸ©ï¼ˆq0ï¼‰çš„æœ€ç»ˆçŠ¶æ€å°†æ˜¯å¦‚ä½•ï¼Ÿï¼ˆæ˜¯ä¸æ˜¯äºä¸‹é¢å›¾ä¸­çš„çš„å›è·¯ä¸€æ ·ï¼‰ï¼Ÿä½¿ç”¨Qiskitæ£€æŸ¥ç­”æ¡ˆã€‚

![](pics/media/image111.png)

2\.
å¦‚æœç›®æ ‡ç«¯é‡å­æ¯”ç‰¹ï¼ˆq1ï¼‰å¤„äºæ€\|1âŸ©ä¸”åœ¨å›è·¯ä¸­ä½¿ç”¨å—æ§Sdgé—¨ä»£æ›¿å—æ§Té—¨æ—¶ï¼Œæ§åˆ¶ç«¯é‡å­æ¯”ç‰¹\|1âŸ©ï¼ˆq0ï¼‰çš„æœ€ç»ˆçŠ¶æ€å°†æ˜¯å¦‚ä½•ï¼Ÿï¼ˆå¦‚ä¸‹æ‰€ç¤ºçš„é‡å­å›è·¯ï¼‰

![](pics/media/image112.png)

3\.
å¦‚æœåœ¨åº”ç”¨å—æ§Té—¨ä¹‹å‰å°†æ§åˆ¶ç«¯é‡å­æ¯”ç‰¹ï¼ˆq0ï¼‰çš„çŠ¶æ€\|1âŸ©æ›¿æ¢ä¸º\|+âŸ©ï¼Œå…¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿï¼ˆå¦‚ä¸‹æ‰€ç¤ºçš„é‡å­å›è·¯ï¼‰

![](pics/media/image113.png)

2.4 è¯æ˜æ™®é€‚æ€§
--------------

### å†…å®¹

1\. å‰è¨€

2\. å®šä¹‰æ™®é€‚æ€§

3\. è¯æ˜æ™®é€‚æ€§

4\. é€šç”¨é‡å­é—¨é›†

5\. å‚è€ƒæ–‡çŒ®

### 1. å‰è¨€

å¯¹ä¸€å°è®¡ç®—æœºæ¥è¯´åšæ‰€æœ‰å¯èƒ½åšçš„äº‹æƒ…æ„å‘³ç€ä»€ä¹ˆï¼Ÿè¿™å°±æ˜¯åœ¨æˆ‘ä»¬å¯¹è®¡ç®—æœºæœ‰ä¸€ä¸ªå¾ˆå¥½çš„æ¦‚å¿µä¹‹å‰ï¼Œè‰¾ä¼¦Â·å›¾çµï¼ˆAlan
Turingï¼‰è§£å†³çš„é—®é¢˜ã€‚

è‹¥è¦å‘ç»å…¸è®¡ç®—æœºé—®è¿™ä¸ªé—®é¢˜ï¼Œç‰¹åˆ«æ˜¯æ ‡å‡†æ•°å­—è®¡ç®—æœºï¼Œæˆ‘ä»¬éœ€è¦å»æ‰æ‰€æœ‰çš„å±å¹•ã€æ‰¬å£°å™¨å’ŒèŠ±å“¨çš„è¾“å…¥è®¾å¤‡ã€‚æ‰€å‰©ä¸‹çš„åªæ˜¯ä¸€å°å°†è¾“å…¥æ¯”ç‰¹ä¸²è½¬æ¢æˆè¾“å‡ºæ¯”ç‰¹ä¸²çš„æœºå™¨ã€‚å¦‚æœä¸€ä¸ªè®¾å¤‡å¯ä»¥è¿›è¡Œä»»ä½•è¿™æ ·çš„è½¬æ¢ï¼Œå–ä»»æ„ä¸€ç»„è¾“å…¥å¹¶å°†å…¶è½¬æ¢ä¸ºä»»æ„é€‰æ‹©çš„ä¸€ç»„è¾“å‡ºï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ™®é€‚ï¼ˆ*universal*ï¼‰ã€‚

è¿™äº›è®¾å¤‡çš„æ™®é€‚æ€§è¦æ±‚çœ‹ä¸Šå»éå¸¸åˆç†ã€‚æˆ‘ä»¬åœ¨"è®¡ç®—çš„åŸºå…ƒ"ä¸­æ‰§è¡ŒåŠ æ³•æ‰€éœ€çš„é‡å­é—¨ä¹Ÿè¶³ä»¥å®ç°ä»»ä½•å¯èƒ½çš„è®¡ç®—ã€‚äº‹å®ä¸Šï¼Œåªè¦æœ‰è¶³å¤Ÿæ•°é‡çš„ä¸éé—¨å°±è¶³å¤Ÿäº†ã€‚

è™½ç„¶ç›®å‰çš„è®¡ç®—æœºåœ¨ç†è®ºä¸Šå¯ä»¥åšä»»ä½•äº‹æƒ…ï¼Œä½†æœ‰äº›ä»»åŠ¡åœ¨å®è·µä¸­è¿‡äºè€—è´¹èµ„æºã€‚åœ¨å¦‚ä½•è¿›è¡ŒåŠ æ³•è¿ç®—çš„ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°æ‰€éœ€çš„èµ„æºä¸é—®é¢˜çš„å¤§å°æˆçº¿æ€§å…³ç³»ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå°†æ•°å­—ä¸­çš„ä½æ•°ç¿»å€ï¼Œéœ€è¦è¿›è¡ŒåŠ æ³•çš„è§„æ¨¡æ•°é‡ä¹Ÿç¿»å€ã€‚

å¯¹äºè®¸å¤šå…¶ä»–é—®é¢˜ï¼Œæ‰€éœ€çš„èµ„æºéšç€è¾“å…¥çš„å¤§å°å‘ˆæŒ‡æ•°çº§å¢é•¿ï¼Œå› å¼åˆ†è§£å°±æ˜¯å…¶ä¸­ä¸€ä¸ªæ˜æ˜¾çš„ä¾‹å­ã€‚åœ¨æœ€è¿‘çš„ä¸€é¡¹ç ”ç©¶ä¸­\[1\]ï¼Œä¸€ä¸ª320ä½æ•°å­—ä¼šè®©CPUèŠ±è´¹å‡ å¹´çš„æ—¶é—´æ¥è¿›è¡Œå› å¼åˆ†è§£ã€‚å¯¹äºé‚£äº›å¹¶ä¸å¾ˆå¤§çš„æ•°å­—ï¼Œåœ¨è¿™ä¸ªä¸–ç•Œä¸Šä¹Ÿæ²¡æœ‰è¶³å¤Ÿçš„è®¡ç®—èµ„æºæ¥å¤„ç†------å°½ç®¡ç›¸åŒçš„æ•°å­—å¯ä»¥åœ¨ä¸€ä¸ªæ›´åˆç†çš„æ—¶é—´å†…ä»…ç”¨æ™ºèƒ½æ‰‹æœºè¿›è¡Œç›¸åŠ æˆ–ç›¸ä¹˜ã€‚

é‡å­è®¡ç®—æœºå°†é€šè¿‡ä¸€ç§å®Œå…¨ä¸åŒçš„æ–¹å¼å®ç°æ™®é€‚æ€§æ¥ç¼“è§£è¿™äº›é—®é¢˜ã€‚æ­£å¦‚æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ï¼Œé‡å­è®¡ç®—çš„å˜é‡å¹¶ä¸ç­‰åŒäºæ ‡å‡†è®¡ç®—æœºçš„å˜é‡ã€‚æˆ‘ä»¬æ‰€ä½¿ç”¨çš„é‡å­é—¨ï¼Œä¾‹å¦‚åœ¨æœ€åä¸€èŠ‚ä¸­ä½¿ç”¨çš„é‡å­é—¨ï¼Œè¶…å‡ºäº†æ ‡å‡†è®¡ç®—æœºçš„é€»è¾‘é—¨çš„èŒƒå›´ã€‚æ­£å› å¦‚æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°å…¶ä»–æ–¹æ³•æ¥å®ç°ä¸å¯èƒ½å®ç°çš„ç»“æœã€‚

### 2. å®šä¹‰æ™®é€‚æ€§

é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•å®šä¹‰é‡å­è®¡ç®—æœºçš„æ™®é€‚æ€§å‘¢ï¼Ÿå¯ä»¥ç”¨ç±»ä¼¼äºä¸Šé¢è®¨è®ºçš„å®šä¹‰æ–¹å¼æ¥å®ç°ã€‚æ­£å¦‚æ•°å­—è®¡ç®—æœºå°†ä¸€ç»„è¾“å…¥æ¯”ç‰¹ä¸²è½¬æ¢æˆä¸€ç»„è¾“å‡ºæ¯”ç‰¹ä¸²ï¼Œå¹ºæ­£æ“ä½œå°†ä¸€ç»„æ­£äº¤è¾“å…¥çŠ¶æ€è½¬æ¢æˆæ­£äº¤è¾“å‡ºçŠ¶æ€ã€‚

ä½œä¸ºä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œè¿™äº›çŠ¶æ€å¯ä»¥ç”¨é‡å­å½¢å¼æè¿°æ¯”ç‰¹ä¸²ã€‚å¦‚æœæˆ‘ä»¬èƒ½å®ç°ä»»ä¸€å¹ºæ­£ï¼Œå°±èƒ½å› æ­¤å®ç°æ™®éæ€§ã€‚

å¦ä¸€ç§ç‰¹æ®Šæƒ…å†µæ˜¯è¾“å…¥å’Œè¾“å‡ºçŠ¶æ€å¯ä»¥æè¿°çœŸå®çš„ç‰©ç†ç³»ç»Ÿã€‚ç„¶åï¼Œå¹ºæ­£å‡½æ•°å¯¹åº”äºæ—¶é—´æ¼”åŒ–ã€‚å½“ç”¨åˆé€‚çš„å„ç±³çŸ©é˜µè¡¨ç¤ºæˆæŒ‡æ•°å½¢å¼æ—¶ï¼Œè¯¥çŸ©é˜µå°†å¯¹åº”äºHamiltonianã€‚å› æ­¤ï¼Œå®ç°ä»»ä¸€å¹ºæ­£å‡½æ•°éƒ½å¯¹åº”äºæ¨¡æ‹Ÿä»»ä¸€æ—¶é—´æ¼”åŒ–ï¼Œå¹¶å®ç°ä»»ä¸€Hamiltoniançš„å½±å“ã€‚è¿™ä¹Ÿæ˜¯ä¸€ä¸ªé‡è¦çš„é—®é¢˜ï¼Œå¯¹ç»å…¸è®¡ç®—æœºæ¥è¯´æ˜¯ä¸åˆ‡å®é™…çš„ï¼Œä½†å´æ˜¯é‡å­è®¡ç®—æœºçš„åŸç”Ÿåº”ç”¨ã€‚

é‡å­è®¡ç®—æœºçš„æ™®é€‚æ€§æ˜¯å¦‚æ­¤ç®€å•ï¼šåœ¨ä»»æ„æ•°é‡çš„é‡å­æ¯”ç‰¹ä¸Šå®ç°ä»»ä½•æ‰€æœŸæœ›å¹ºæ­£çš„èƒ½åŠ›ã€‚

### 3. è¯æ˜æ™®é€‚æ€§

å¯¹äºç»å…¸è®¡ç®—æœºï¼Œæˆ‘ä»¬éœ€è¦å°†ä¸€ä¸ªå¤§çš„å·¥ä½œåˆ†å‰²æˆå¯ç®¡ç†çš„å—ã€‚æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ç»„åŸºç¡€çš„é‡å­é—¨æ¥å®ç°è¿™ä¸€ç›®æ ‡ã€‚æ­£å¦‚å°†ä¼šçœ‹åˆ°çš„ï¼Œä¸Šä¸€èŠ‚æ‰€æåŠçš„å•é‡å­æ¯”ç‰¹å’ŒåŒé‡å­æ¯”ç‰¹é—¨è¶³ä»¥å®Œæˆè¿™é¡¹ä»»åŠ¡ã€‚

å‡è®¾æˆ‘ä»¬æƒ³è¦å®ç°å¹ºæ­£å˜æ¢ï¼š

$$U = e^{i\left( aX + bZ \right)}$$

ä½†æˆ‘ä»¬ä»…æœ‰é‡å­é—¨$R_{x}\left( \theta \right) = e^{i\frac{\theta}{2}X}$å’Œ$R_{z}\left( \theta \right) = e^{i\frac{\theta}{2}Z}$ã€‚å¤„ç†è¿™ä¸€é—®é¢˜çš„æœ€ä½³æ–¹å¼ä¸ºä½¿ç”¨æ¬§æ‹‰è§’ï¼ˆEuler
angleï¼‰ã€‚ä½†å…ˆè®©æˆ‘ä»¬è€ƒè™‘å¦ä¸€ç§ä¸åŒçš„æ–¹æ³•ã€‚

åœ¨$U$æŒ‡æ•°ä¸­çš„å„ç±³çŸ©é˜µä»…æ˜¯$R_{x}\left( \theta \right)$å’Œ$R_{z}\left( \theta \right)$æ—‹è½¬çš„å’Œã€‚è¿™å°±ç»™å‡ºäº†è§£å†³ä¸Šè¿°é—®é¢˜çš„å¤©ç”Ÿæ–¹æ³•ï¼šæˆ‘ä»¬å¯ä»¥åœ¨åº”ç”¨$R_{x}\left( 2a \right) = e^{\text{iaX}}$ä¹‹åç´§è·Ÿ$R_{z}\left( 2b \right) = e^{\text{ibZ}}$ã€‚ä½†ä¸å¹¸çš„æ˜¯ï¼Œç”±äºå¹‚ä¸­çš„çŸ©é˜µæ— æ³•å¯¹æ˜“ï¼Œè¿™ä¸€æ–¹æ³•å°±æ— æ³•å®ç°ã€‚

$$e^{\text{iaX}}e^{\text{ibZ}} \neq e^{i\left( aX + bZ \right)}$$

ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¿®æ­£çš„ç‰ˆæœ¬ï¼š

$$U = \lim_{n \rightarrow \infty}\left( e^{iaX/n}e^{ibZ/n} \right)^{n}$$

åœ¨è¿™é‡Œæˆ‘ä»¬æŠŠ$U$åˆ†æˆnä¸ªç‰‡æ®µã€‚å¯¹äºå…¶ä¸­çš„æ¯ä¸ªç‰‡æ®µï¼Œå°±ä¼šæœ‰ä¸€ä¸ªå¾ˆå¥½çš„è¿‘ä¼¼ï¼š

$$e^{iaX/n}e^{ibZ/n} = e^{i\left( aX + bZ \right)\text{/n}}$$

è¿™ä¸€è¿‘ä¼¼è¯¯å·®å¤§å°ä¸º$1/n^{2}$ã€‚å½“æˆ‘ä»¬å°†nä¸ªç‰‡æ®µç»„åˆèµ·æ¥åï¼Œæ‰€å¾—åˆ°çš„ç›®æ ‡å¹ºæ­£çŸ©é˜µçš„è¯¯å·®å¤§å°ä¸º$1/n$ã€‚æ•…åªéœ€ç®€å•çš„å¢åŠ ç‰‡æ®µçš„æ•°é‡ï¼Œå°±èƒ½æ— é™æ¥è¿‘$U$ã€‚åˆ›å»ºåºåˆ—çš„å…¶ä»–æ–¹æ³•ä¹Ÿå¯èƒ½è·å¾—ç›®æ ‡å¹ºæ­£æ›´ç²¾ç¡®çš„ç‰ˆæœ¬ã€‚

è¿™ä¸€æ–¹æ³•çš„å¼ºå¤§ä¹‹å¤„åœ¨äºå®ƒå¯ä»¥åº”ç”¨äºå¤æ‚çš„æƒ…å†µï¼Œè€Œéä»…æ˜¯å•ä¸ªé‡å­æ¯”ç‰¹ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘å¹ºæ­£å‡½æ•°ï¼š

$$U = e^{i\left( aX \otimes X \otimes X + bZ \otimes Z \otimes Z \right)}$$

æˆ‘ä»¬çŸ¥é“å¦‚ä½•ä»ä½†é‡å­æ¯”ç‰¹$R_{x}\left( \theta \right)$ä»¥åŠä¸¤ä¸ªå—æ§éé—¨åˆ›å»ºå¹ºæ­£$e^{i\frac{\theta}{2}X \otimes X \otimes X}$ã€‚

> theta = \'Î¸\'
>
> qc = QuantumCircuit(3)
>
> qc.cx(0,2)
>
> qc.cx(0,1)
>
> qc.rx(theta,0)
>
> qc.cx(0,1)
>
> qc.cx(0,1)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image114.png)

é€šè¿‡ä¸€äº›é˜¿è¾¾é©¬é—¨ï¼Œå¯ä»¥å¯¹$e^{i\frac{\theta}{2}Z \otimes Z \otimes Z}$è¿›è¡ŒåŒæ ·çš„æ“ä½œï¼š

> qc.h(0)
>
> qc.h(1)
>
> qc.h(2)
>
> qc.cx(0,2)
>
> qc.cx(0,1)
>
> qc.rx(theta,0)
>
> qc.cx(0,1)
>
> qc.cx(0,1)
>
> qc.h(2)
>
> qc.h(1)
>
> qc.h(0)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image115.png)

è¿™ä½¿æˆ‘ä»¬æœ‰èƒ½åŠ›å¤åˆ¶çš„ç‰‡æ®µï¼Œä¸‰é‡å­æ¯”ç‰¹Uï¼š

$$e^{i\frac{\theta}{2}X \otimes X \otimes X/n}e^{i\frac{\theta}{2}Z \otimes Z \otimes Z/n} = e^{i\left( aX \otimes X \otimes X + bZ \otimes Z \otimes Z \right)\text{/n}}$$

æ­£å¦‚ä¹‹å‰æ‰€è¯´ï¼Œæ¥ç€æˆ‘ä»¬å°†æ‰€æœ‰ç‰‡æ®µç»„åˆèµ·æ¥å°±èƒ½è·å¾—$U$çš„ä»»æ„ç²¾ç¡®è¿‘ä¼¼ã€‚

å½“æˆ‘ä»¬å¢åŠ é‡å­æ¯”ç‰¹çš„æ•°é‡ä»¥åŠéœ€è¦æ¨¡æ‹Ÿé¡¹çš„æ•°é‡æ—¶ï¼Œè¿™ä¸€æ–¹æ³•ä»ç„¶æœ‰æ•ˆã€‚å¿…é¡»å°å¿ƒç¡®ä¿è¿‘ä¼¼ä»ç„¶ç²¾ç¡®ï¼Œä½†è¿™å¯ä»¥é€šè¿‡è¯·æ±‚åˆç†èµ„æºçš„æ–¹å¼æ¥å®ç°ã€‚è‹¥è¦å¢åŠ é¢å¤–çš„é¡¹æ¥æ¨¡æ‹Ÿæˆ–è€…å¢åŠ æœŸæœ›çš„ç²¾åº¦ï¼Œè¯¥æ–¹æ³•çš„å¤æ‚åº¦åªè¦æ±‚å¢åŠ å¤šé¡¹å¼ã€‚

è¿™ä¸€å½¢å¼çš„æ–¹æ³•å¯ä»¥å¤åˆ¶ä»»ä¸€$U\  = \ e^{\text{iH}}$ï¼Œå› æ­¤$H$å¯ä»¥è¡¨ç¤ºä¸ºæ³¡åˆ©é‡å­é—¨çš„å¼ é‡ç§¯ã€‚ç”±äºæˆ‘ä»¬åœ¨ä¹‹å‰å·²ç»å±•ç¤ºäº†æ‰€æœ‰çŸ©é˜µéƒ½å¯ä»¥ç”¨è¿™ä¸€æ–¹æ³•è¡¨ç¤ºï¼Œè¿™è¶³ä»¥è¯´æ˜æˆ‘ä»¬å¯ä»¥å¤åˆ¶æ‰€æœ‰çš„å¹ºæ­£å˜æ¢ã€‚è™½ç„¶å…¶ä»–æ–¹æ³•åœ¨å®è·µä¸­å¯èƒ½æ›´å¥½ï¼Œä½†æœ¬ç« çš„ä¸»æ—¨æ˜¯ç¡®å®æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥ä»…ä½¿ç”¨Qiskitä¸­çš„åŸºæœ¬æ“ä½œæ¥é‡ç°æ‰€æœ‰çš„å¤šé‡å­æ¯”ç‰¹ã€‚é‡å­æ™®é€‚æ€§å¯ä»¥è¢«å®ç°äº†ï¼

### 4. é€šç”¨é‡å­é—¨é›†

åœ¨ä¸Šé¢çš„å†…å®¹ä¸­å›½å‘¢æˆ‘ä»¬çœ‹åˆ°é€šè¿‡$R_{x}$ã€$H$å’ŒCNOTï¼ˆå—æ§éé—¨ï¼‰å®ç°æ™®éæ€§ï¼Œå•è¿˜æœ‰è®¸å¤šä¸é€šçš„é€šç”¨é‡å­é—¨ã€‚ä¾‹å¦‚ï¼ŒIBMQX2å¤„ç†å™¨ç»™å‡ºçš„ä¸€äº›åŸºç¡€é‡å­é—¨ï¼š

> from qiskit import IBMQ
>
> IBMQ.load_account()
>
> ibmqx2 = IBMQ.get_provider(\'ibm-q\').get_backend(\'ibmqx2\')
>
> ibmqx2.configuration().basis_gates
>
> è¾“å‡ºï¼š
>
> \[\'u1\', \'u2\', \'u3\', \'cx\', \'id\'\]

ä»ä¸Šé¢çš„è¾“å‡ºå¯ä»¥çœ‹åˆ°IBMQX2å¤„ç†å™¨ç»™å‡ºäº†$U_{1}$ã€$U_{2}$ã€$U_{3}$ã€$\text{CX}$å’Œ$\text{Id}$ï¼Œè¶³ä»¥å¤åˆ¶ä»»ä½•å¹ºæ­£å˜æ¢ã€‚å…¶ä»–ç±»å‹çš„é‡å­è®¡ç®—æœºæœ‰ä¸åŒçš„åŸå£°é‡å­é—¨ï¼Œæ¯”å¦‚åŒé‡å­æ¯”ç‰¹çš„Ising-gate\[2\]ï¼Œè¿™äº›é‡å­é—¨å°†ä¸åœ¨æ­¤å¤„è®¨è®ºã€‚æ‚¨ç°åœ¨éœ€è¦çŸ¥é“çš„æ˜¯ï¼šä½¿ç”¨ä¸€ç»„é€šç”¨é‡å­é—¨åˆ›å»ºçš„ä»»ä½•ç®—æ³•éƒ½å¯ä»¥åœ¨ä»»ä½•é€šç”¨é‡å­è®¡ç®—æœºä¸Šè¿è¡Œã€‚

### 5. å‚è€ƒæ–‡çŒ®

\[1\] "[Factorization of a 1061-bit number by the Special Number Field
Sieve](https://eprint.iacr.org/2012/444.pdf)"by Greg Childers.

\[2\] "[Demonstration of a small programmable quantum computer with
atomic
qubits](http://iontrap.umd.edu/wp-content/uploads/2012/12/nature18648.pdf)"
by S.Debnath1, N.M.Linke1, C.Figgatt1, K.A.Landsman1, K.Wright1 &
C.Monroe

2.5 æ›´å¤šå›è·¯æ’ç­‰å¼
------------------

> from qiskit import QuantumCircuit
>
> from qiskit.circuit import Gate
>
> from math import pi
>
> qc = QuantumCircuit(2)
>
> c = 0
>
> t = 1

å½“æˆ‘ä»¬åœ¨é‡å­è®¡ç®—æœºä¸Šç¼–ç¨‹æ—¶ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å§‹ç»ˆæ˜¯ä»åŸºç¡€æ„å»ºæ¨¡å—ï¼ˆthe basic
building
blocksï¼‰æ„å»ºæœ‰ç”¨çš„é‡å­å›è·¯ã€‚ä½†æœ‰æ—¶æˆ‘ä»¬å¯èƒ½ä¸èƒ½è·å–æƒ³è¦çš„å…¨éƒ¨åŸºç¡€æ„å»ºæ¨¡å—ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•åœ¨åŸºç¡€çš„é‡å­é—¨ä¹‹é—´è¿›è¡Œè½¬æ¢ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨è¿™äº›åŸºç¡€é‡å­é—¨æ„å»ºç¨å¾®å¤æ‚çš„é‡å­é—¨ã€‚

æˆ‘ä»¬åœ¨æœ¬ç« ä¸­æ‰€è®¨è®ºçš„æŠ€æœ¯ç”±BarencoåŠå…¶åˆä½œè€…åœ¨1995å¹´çš„è®ºæ–‡ä¸­ç¬¬ä¸€æ¬¡è¢«æå‡º\[1\]ã€‚

### å†…å®¹

1\. ä»ä¸€ä¸ªCNOTåˆ›å»ºä¸€ä¸ªå—æ§Zé—¨

2\. äº¤æ¢é‡å­æ¯”ç‰¹

3\. å—æ§æ—‹è½¬

4\. Toffolié—¨

5\. Hå’ŒTçš„ä»»æ„æ—‹è½¬

6\. å‚è€ƒæ–‡çŒ®

### 1. ä»ä¸€ä¸ªCNOTåˆ›å»ºä¸€ä¸ªå—æ§Zé—¨

å—æ§Zé—¨ï¼ˆczï¼‰æ˜¯å¦ä¸€ä¸ªç»å¸¸ä½¿ç”¨çš„åŒé‡å­æ¯”ç‰¹é—¨ã€‚å¦‚åŒæ— è®ºæ§åˆ¶ç«¯çš„é‡å­æ¯”ç‰¹æ˜¯å¦å¤„äºæ€$\left| 1 \right\rangle$ï¼Œä½œç”¨äº$X$ï¼ˆæ³¡åˆ©-Xï¼‰ç›®æ ‡ç«¯é‡å­æ¯”ç‰¹çš„CNOTä¸€æ ·ï¼Œå—æ§Zé—¨åŒæ ·åº”ç”¨ä¸€ä¸ª$Z$å˜æ¢ã€‚åœ¨Qiskitä¸­å¯ä»¥ç›´æ¥è°ƒç”¨ï¼š

> \# a controlled-Z
>
> qc.cz(c,t)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image116.png)

ä»£ç ä¸­çš„cå’Œtæ˜¯æ§åˆ¶ç«¯å’Œç›®æ ‡ç«¯é‡å­æ¯”ç‰¹ã€‚ç„¶è€Œåœ¨IBMçš„Qè®¾å¤‡ä¸Šï¼Œå”¯ä¸€ä¸€ç±»å¯ä»¥ç›´æ¥åº”ç”¨çš„åŒé‡å­æ¯”ç‰¹é—¨æ˜¯CNOTï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰¾åˆ°å°†å…¶è½¬æ¢ä¸ºå…¶ä»–ç±»å‹çš„æ–¹æ³•ã€‚

è¿™ä¸€è¿‡ç¨‹ç›¸å½“ç®€å•ã€‚æˆ‘ä»¬çŸ¥é“å°†æ€$\left| 0 \right\rangle$å’Œ$\left| 1 \right\rangle$è½¬æ¢ä¸ºæ€$\left| + \right\rangle$å’Œ$\left| - \right\rangle$çš„é˜¿è¾¾é©¬é—¨ï¼ˆHadamardï¼‰ï¼Œè¿˜çŸ¥é“Z-gateåœ¨æ€$\left| + \right\rangle$å’Œ$\left| - \right\rangle$ä¸Šæ‰€å¯¼è‡´çš„å½±å“ä¸$X$åœ¨æ€$\left| 0 \right\rangle$å’Œ$\left| 1 \right\rangle$ä¸Šæ‰€å¯¼è‡´çš„ç›¸åŒã€‚ä¾æ®è¿™äº›åŸå› ä»¥åŠç®€å•çš„çŸ©é˜µç›¸ä¹˜ï¼Œæˆ‘ä»¬å‘ç°ï¼š

$$HXH = Z,HZH = X$$

åŒæ ·çš„æŠ€å·§å¯ä»¥å°†CNOTè½¬æ¢ä¸ºå—æ§Zé—¨æ—¶ä½¿ç”¨ã€‚æ‰€è¦åšçš„ä»…æ˜¯åœ¨ç›®æ ‡é‡å­æ¯”ç‰¹çš„CNOTå‰åæ”¾ç½®é˜¿è¾¾é©¬é—¨ã€‚è¿™ä¸€æ“ä½œå°†åº”ç”¨äºé‡å­æ¯”ç‰¹çš„ä»»ä¸€$X$è½¬æ¢ä¸ºä¸€ä¸ª$Z$ã€‚

> qc = QuantumCircuit(2)
>
> \# also a controlled-Z
>
> qc.h(t)
>
> qc.cx(c,t)
>
> qc.h(t)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image117.png)

ç”¨æ›´åŠ é€šä¿—çš„æ–¹å¼æ¥è®²ï¼Œæˆ‘ä»¬å¯ä»¥å°†å•ä¸ªCNOTè½¬æ¢ä¸ºä»»ä¸€å¸ƒæ´›èµ«çƒä¸­æ—‹è½¬è§’åº¦$\pi$çš„å—æ§ç‰ˆæœ¬ï¼Œä»…é€šè¿‡åœ¨å…¶å‰åæ”¾ç½®æ­£ç¡®çš„æ—‹è½¬è§’åº¦ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå—æ§Yé—¨ï¼š

> qc = QuantumCircuit(2)
>
> \# a controlled-Y
>
> qc.sdg(t)
>
> qc.cx(c,t)
>
> qc.s(t)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image118.png)

ä»¥åŠä¸€ä¸ªå—æ§Hé—¨ï¼š

> qc = QuantumCircuit(2)
>
> \# a controlled-H
>
> qc.ry(pi/4,t)
>
> qc.cx(c,t)
>
> qc.ry(-pi/4,t)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image119.png)

### 2. äº¤æ¢é‡å­æ¯”ç‰¹

æœ‰æ—¶æˆ‘ä»¬éœ€è¦ç§»åŠ¨ä¸€ä¸ªé‡å­è®¡ç®—æœºä¸­çš„ä¿¡æ¯ã€‚å¯¹äºæŸäº›é‡å­æ¯”ç‰¹çš„å®ç°ï¼Œå¯ä»¥é€šè¿‡ç‰©ç†ç§»åŠ¨æ¥å®ç°ã€‚å¦ä¸€ç§æ–¹å¼æ˜¯ç®€å•åœ°åœ¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¹‹é—´ç§»åŠ¨å…¶çŠ¶æ€ã€‚è¿™å°±æ˜¯ç”±äº¤æ¢é—¨ï¼ˆSWAP
gateï¼‰å®Œæˆã€‚

> a = 0
>
> b = 1
>
> qc = QuantumCircuit(2)
>
> \# swaps states of qubits a and b
>
> qc.swap(a,b)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image120.png)

ä¸Šé¢çš„ä»£ç ä¸­ç›´æ¥è°ƒç”¨äº†è¿™ä¸€é‡å­é—¨ï¼Œç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•ä½¿ç”¨æ ‡å‡†é‡å­é—¨é›†æ¥å®ç°SWAP
gateã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹å¤„äºæ€\|1âŸ©çš„é‡å­æ¯”ç‰¹aå’Œå¤„äºæ€\|0âŸ©çš„é‡å­æ¯”ç‰¹bï¼Œä¸ºæ­¤å°†åº”ç”¨ä»¥ä¸‹çš„é‡å­é—¨ï¼š

> qc = QuantumCircuit(2)
>
> \# swap a 1 from a to b
>
> qc.cx(a,b) \# copies 1 from a to b
>
> qc.cx(b,a) \# uses the 1 on b to rotate the state of a to 0
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image121.png)

è¿™å°±äº§ç”Ÿè®©é‡å­æ¯”ç‰¹aå¤„äºæ€\|0âŸ©ä»¥åŠé‡å­æ¯”ç‰¹bå¤„äºæ€\|1âŸ©çš„æ•ˆæœã€‚è‡³å°‘åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œå®Œæˆäº†äº¤æ¢ï¼ˆSWAPï¼‰æ“ä½œã€‚

ç°åœ¨è®©æˆ‘ä»¬ä¸Šé¢çš„çŠ¶æ€äº¤æ¢è‡³æœ€åˆçŠ¶æ€ã€‚æ‚¨å¯èƒ½æ—©å°±çŒœåˆ°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åè½¬ä¸Šè¿°çš„è¿‡ç¨‹æ¥å®ç°ï¼š

> \# swap a q from b to a
>
> qc.cx(b,a) \# copies 1 from b to a
>
> qc.cx(a,b) \# uses the 1 on a to rotate the state of b to 0
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image122.png)

åœ¨è¿™ä¸¤ä¸ªè¿‡ç¨‹ä¸­å¯ä»¥çœ‹åˆ°ï¼Œç¬¬ä¸€ä¸ªæ­¥éª¤çš„é‡å­é—¨ä¸ä¼šæ”¹å˜å¦ä¸€ä¸ªçš„åˆå§‹çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œæœ€åçš„cx(b,a)è¦æ±‚å½“æˆ‘ä»¬ä»aè‡³bäº¤æ¢\|1âŸ©æ—¶ï¼Œä¸ä¼šå¯¹\|1âŸ©æ˜¯å¦åœ¨bä¸Šäº§ç”Ÿå½±å“ã€‚

é€šè¿‡è¿™äº›è§‚å¯Ÿï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å…¶ä¸­æ·»åŠ ä¸€ä¸ªæ— æ•ˆçš„é‡å­é—¨æ¥ç»“åˆè¿™ä¸¤ä¸ªè¿‡ç¨‹ã€‚ä¾‹å¦‚ï¼š

> qc = QuantumCircuit(2)
>
> qc.cx(b,a)
>
> qc.cx(a,b)
>
> qc.cx(b,a)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image123.png)

æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸€è¿‡ç¨‹å½“ä½œå¼€å¤´åŒ…å«æ— ç”¨qc.cx(b,a)çš„ä»aè‡³bäº¤æ¢\|1âŸ©çš„è¿‡ç¨‹ã€‚ä¹Ÿå¯ä»¥å°†è¿™ä¸€è¿‡ç¨‹å½“ä½œç»“å°¾åŒ…å«æ— ç”¨qc.cx(b,a)çš„ä»bè‡³aäº¤æ¢\|1âŸ©çš„è¿‡ç¨‹ã€‚æ— è®ºå“ªç§æ–¹å¼ï¼Œå…¶ç»“æœæ˜¯åŒæ—¶è¿›è¡Œä¸¤ç§äº¤æ¢çš„è¿‡ç¨‹ã€‚

ä¸Šè¿°è¿‡ç¨‹å¯¹\|00âŸ©æ€ä¹Ÿæœ‰æ­£ç¡®çš„å½±å“ã€‚ç”±äº\|00âŸ©æ€çš„å¯¹ç§°æ€§ï¼Œäº¤æ¢é‡å­æ¯”ç‰¹çš„çŠ¶æ€ä¸ä¼šé€ æˆå½±å“ã€‚å› æ­¤åœ¨æ§åˆ¶ç«¯é‡å­æ¯”ç‰¹ä¸º\|0âŸ©æ—¶ï¼Œå—æ§éé—¨ä¸ä¼šäº§ç”Ÿå½±å“ï¼Œè¿™ä¸€è¿‡ç¨‹æ­£ç¡®åœ°å®Œæˆä»€ä¹ˆéƒ½ä¸åšçš„æ“ä½œã€‚

\|11âŸ©æ€ä¹Ÿæ˜¯å¯¹ç§°çš„ï¼Œæ‰€ä»¥ä¼šä»äº¤æ¢è¿‡ç¨‹ä¸­è·å¾—ä¸€äº›å¾®ä¸è¶³é“çš„å½±å“ã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œä¸Šè¿°è¿‡ç¨‹ä¸­ç¬¬ä¸€ä¸ªå—æ§éé—¨å°†ä¼šå¯¼è‡´ç¬¬äºŒä¸ªæ— æ•ˆï¼Œç¬¬ä¸‰ä¸ªä¼šæ’¤é”€ç¬¬ä¸€ä¸ªçš„æ“ä½œã€‚å› æ­¤ï¼Œå¯¹äºæ•´ä½“çš„å½±å“ç¡®å®æ˜¯å¾®ä¸è¶³é“ã€‚

å¦‚æ­¤ï¼Œæˆ‘ä»¬æ‰¾åˆ°äº†å°†SWAP
gateåˆ†è§£ä¸ºå•é‡å­æ¯”ç‰¹æ—‹è½¬å’Œå—æ§éé—¨çš„æ ‡å‡†é‡å­é—¨é›†çš„æ–¹æ³•ã€‚

> qc = QuantumCircuit(2)
>
> qc.cx(b,a)
>
> qc.cx(a,b)
>
> qc.cx(b,a)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image123.png)

è¿™ä¸€æ–¹æ³•å¯¹æ€\|00âŸ©ã€\|01âŸ©ã€\|10âŸ©å’Œ\|11âŸ©èµ·ä½œç”¨ï¼Œå¦‚æœè¿™ä¸€æ–¹æ³•å¯¹è®¡ç®—åŸºçš„æ‰€æœ‰çŠ¶æ€èµ·ä½œç”¨ï¼Œé‚£ä¹ˆå…¶å¿…ç„¶å¯¹æ‰€æœ‰é‡å­çš„è£…æ€æ™®éèµ·ä½œç”¨ã€‚å› æ­¤è¿™ä¸€é‡å­å›è·¯èƒ½å¤Ÿäº¤æ¢æ‰€æœ‰å¯èƒ½çš„åŒé‡å­æ¯”ç‰¹çŠ¶æ€ã€‚

å¦‚æœæˆ‘ä»¬æ”¹å˜CNOTçš„é¡ºåºï¼Œä¼šäº§ç”Ÿç›¸åŒç»“æœçš„å½±å“ï¼š

> qc = QuantumCircuit(2)
>
> \# swaps states of qubits a and b
>
> qc.cx(a,b)
>
> qc.cx(b,a)
>
> qc.cx(a,b)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image124.png)

ä¸Šé¢çš„ä»£ç æ˜¯è·å¾—SWAP gateçš„åŒç­‰æœ‰æ•ˆæ–¹æ³•ã€‚

è¿™é‡Œçš„æ¨å¯¼è¿‡ç¨‹åŸºäºZåŸºæ€ï¼Œä½†ä¹Ÿå¯ä»¥é€šè¿‡æ€è€ƒäº¤æ¢å¤„äºæ€\|+âŸ©å’Œ\|âˆ’âŸ©çš„é‡å­æ¯”ç‰¹éœ€è¦ä»€ä¹ˆæ¥å®ç°ã€‚å®ç°SWAP
gateçš„æ–¹æ³•ä¸ä¸Šè¿°çš„æ–¹æ³•å®Œå…¨ç›¸åŒã€‚

#### å¿«é€Ÿç»ƒä¹ 

-   æ‰¾å‡ºèƒ½å¤Ÿäº¤æ¢å¤„äºæ€\|+âŸ©å’Œ\|âˆ’âŸ©çš„é‡å­æ¯”ç‰¹çš„ä¸åŒå›è·¯ï¼Œå¹¶ç»™å‡ºå‡ºç­‰åŒäºä¸Šæ–‡æ‰€ç¤ºå›è·¯çš„å›¾ç‰‡ã€‚

### 3. å—æ§æ—‹è½¬

æˆ‘ä»¬å·²ç»çŸ¥é“å¦‚ä½•ä»å•ä¸ªå—æ§éé—¨æ„å»ºå—æ§çš„$\pi$æ—‹è½¬ã€‚æ­¤æ—¶æˆ‘ä»¬å°†è¦çœ‹çœ‹å¦‚ä½•æ„å»ºä»»ä½•å—æ§æ—‹è½¬ã€‚

é¦–å…ˆï¼Œè®©æˆ‘ä»¬æ€è€ƒä¸€ä¸‹ç»•yè½´çš„ä»»æ„æ—‹è½¬ï¼Œç‰¹åˆ«æ˜¯æ€è€ƒä»¥ä¸‹é‡å­é—¨åºåˆ—ï¼š

> qc = QuantumCircuit(2)
>
> theta = pi \# theta can be anything (pi chosen arbitrarily)
>
> qc.ry(theta/2,t)
>
> qc.cx(c,t)
>
> qc.ry(-theta/2,t)
>
> qc.cx(c,t)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image125.png)

å¦‚æœæ§åˆ¶ç«¯é‡å­æ¯”ç‰¹å¤„äºæ€\|0âŸ©ï¼Œæˆ‘ä»¬å°†è·å¾—ç´§éš$R_{y}\left( \theta/2 \right)$åçš„é€†$R_{y}\left( - \theta/2 \right)$ã€‚æœ€ç»ˆå½±å“è¿˜æ˜¯æ— å…³ç´§è¦ã€‚å¦‚æœæ§åˆ¶ç«¯é‡å­æ¯”ç‰¹å¤„äºæ€\|1âŸ©ï¼Œåœ¨X-gateå‰åçš„ry(-theta/2)ä¼šç”Ÿæ•ˆã€‚è¿™ä¼šäº§ç”Ÿæ”¹å˜yæ—‹è½¬æ–¹å‘çš„å½±å“ï¼Œå¹¶ä¸”ç”Ÿæˆç¬¬äºŒä¸ª$R_{y}\left( \theta/2 \right)$ã€‚å› æ­¤åœ¨è¿™ä¸€æƒ…å†µä¸‹çš„å‡€å½±å“ä¸ºä½¿å¾—$R_{y}\left( \theta/2 \right)$è¿›è¡Œäº†å—æ§çš„æ—‹è½¬ã€‚

å› ä¸ºxå’Œyè½´æ­£äº¤ï¼Œæ‰€ä»¥è¿™ä¸€æ–¹æ³•æœ‰æ•ˆï¼Œå› è€Œå¯¼è‡´xé—¨ç¿»è½¬äº†æ—‹è½¬æ–¹å‘ã€‚æ•…ç›¸ç±»ä¼¼çš„è¿‡ç¨‹åˆ›å»ºäº†ä¸€ä¸ªå—æ§çš„$R_{z}\left( \theta \right)$ã€‚å—æ§çš„$R_{x}\left( \theta \right)$ä¹Ÿå¯ä»¥é€šè¿‡å—æ§éé—¨ä½¿ç”¨ç±»ä¼¼çš„æ–¹æ³•åˆ›å»ºã€‚

æˆ‘ä»¬è¿˜å¯ä»¥åˆ›å»ºä»»ä¸€ä½†é‡å­æ¯”ç‰¹$U$æ—‹è½¬çš„å—æ§ç‰ˆæœ¬ã€‚æ­¤æ—¶æˆ‘ä»¬è¿›éœ€è¦æ‰¾å‡ºç¬¦åˆä¸‹è¿°æ¡ä»¶çš„æ—‹è½¬Aã€Bã€Cå’Œç›¸ä½$\alpha$ï¼š

$$ABC = I,\ \ \ e^{\text{iÎ±}}AZBZC = U$$

æ— è®ºæ§åˆ¶ç«¯æ˜¯å¦å¤„äºæ€\|0âŸ©ï¼Œä½¿ç”¨å—æ§Zé—¨å¼•å‘è¿™äº›å…³ç³»çš„ç¬¬ä¸€ä¸ªå‘ç”Ÿï¼Œç„¶åå½“æ§åˆ¶ç«¯å¤„äºæ€\|1âŸ©æ—¶å¼•å‘ç¬¬äºŒä¸ªå…³ç³»å‘ç”Ÿã€‚$R_{z}\left( 2\alpha \right)$æ—‹è½¬ä¹Ÿåœ¨æ§åˆ¶ç«¯ä¸Šè·å–æ­£ç¡®çš„ç›¸ä½ï¼Œæ¯å½“å¤„äºå åŠ çŠ¶æ€æ—¶è¿™ä¸€ç‚¹å°±å˜å¾—å¾ˆé‡è¦ã€‚

> A = Gate(\'A\', 1, \[\])
>
> B = Gate(\'B\', 1, \[\])
>
> C = Gate(\'C\', 1, \[\])
>
> alpha = 1 \# arbitrarily define alpha to allow drawing of circuit
>
> qc = QuantumCircuit(2)
>
> qc.append(C, \[t\])
>
> qc.cz(c,t)
>
> qc.append(B, \[t\])
>
> qc.cz(c,t)
>
> qc.append(A, \[t\])
>
> qc.u1(alpha,c)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image126.png)

![](pics/media/image127.png)

æ­¤å¤„çš„Aã€Bå’ŒCåˆ†åˆ«æ˜¯$A$ã€$B$å’Œ$C$é‡å­é—¨çš„å®ç°ã€‚

### 4. Toffolié—¨ï¼ˆåˆè¢«ç§°ä½œ "æ§-æ§-é"é—¨ï¼Œ\"controlled-controlled-not ï¼ˆCCNOTï¼‰\" gateï¼‰

Toffolié—¨æ˜¯ä¸€ä¸ªä¸‰é‡å­æ¯”ç‰¹é—¨ï¼Œå…¶åŒ…å«ä¸¤ä¸ªæ§åˆ¶ç«¯ä»¥åŠä¸€ä¸ªç›®æ ‡ç«¯ã€‚å…¶ä»…åœ¨ä¸¤ä¸ªæ§åˆ¶ç«¯çš†å¤„äºæ€\|1âŸ©æ—¶ï¼Œæ‰ä¼šåœ¨ç›®æ ‡ç«¯ä¸Šæ‰§è¡Œ$X$ï¼ˆæ³¡åˆ©-Xï¼‰ã€‚

> qc = QuantumCircuit(3)
>
> a = 0
>
> b = 1
>
> t = 2
>
> \# Toffoli with control qubits a and b and target t
>
> qc.ccx(a,b,t)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image128.png)

é¦–å…ˆé€šè¿‡è§‚å¯Ÿå¦‚ä½•ä»å•å’ŒåŒé‡å­æ¯”ç‰¹é—¨æ¥æ„å»ºToffolié—¨å¯¹äºå±•ç¤ºå¦‚ä½•æ„å»ºæ›´é€šç”¨çš„é‡å­é—¨éå¸¸æœ‰å¸®åŠ©ï¼šä»»ä½•å•é‡å­æ¯”ç‰¹ç»Uæ—‹è½¬çš„ä»»æ„æ§-æ§-Ué—¨ï¼ˆcontrolled-controlled-Uï¼‰ã€‚è‹¥è¦åˆ›å»ºæ§-æ§-Ué—¨ï¼Œè¦å®šä¹‰å—æ§ç‰ˆæœ¬çš„$V = \sqrt{U}$å’Œ$V^{\dagger}$ã€‚åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨cu1(theta,c,t)å’Œcu1(-theta,c,t)åˆ†åˆ«æ›¿æ¢æœªå®šä¹‰çš„å­ç¨‹åºcvå’Œcvdgï¼Œå…¶ä¸­æ§åˆ¶ç«¯ä¸º$a$å’Œ$b$,ç›®æ ‡ç«¯ä¸º$t$ã€‚

> qc = QuantumCircuit(3)
>
> qc.cu1(theta,b,t)
>
> qc.cx(a,b)
>
> qc.cu1(-theta,b,t)
>
> qc.cx(a,b)
>
> qc.cu1(theta,a,t)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image129.png)

![](pics/media/image130.png)

é€šè¿‡è·Ÿè¸ªä¸¤ä¸ªæ§åˆ¶ç«¯é‡å­æ¯”ç‰¹çš„å€¼ï¼Œæ‚¨èƒ½å¤Ÿè¯´æœè‡ªå·±ï¼šå¦‚æœä»…å½“ä¸¤ä¸ªæ§åˆ¶ç«¯éƒ½ä¸º1æ—¶ï¼ŒU-gateæ‰è¢«åº”ç”¨äºç›®æ ‡ç«¯é‡å­æ¯”ç‰¹ã€‚ä¾æ®æˆ‘ä»¬æ—©å°±æè¿°çš„æƒ³æ³•ï¼Œæ‚¨ç°åœ¨èƒ½å¤Ÿé€šè¿‡å—æ§Vé—¨ï¼ˆcontrolled-V
gateï¼‰å®ç°æŸäº›å›è·¯ä¸­çš„åŒæ§Ué—¨ï¼ˆdoubly-controlled-U
gateï¼‰ã€‚äº‹å®è¯æ˜å®ç°Toffolié—¨æ‰€éœ€å—æ§éé—¨çš„æœ€å°æ•°é‡ä¸º6 \[2\]ã€‚

![](pics/media/image131.png)

Toffolié—¨å¹¶éæ˜¯åœ¨é‡å­è®¡ç®—ä¸­å®ç°ä¸é—¨ï¼ˆAND
gateï¼‰çš„å”¯ä¸€æ–¹å¼ã€‚æˆ‘ä»¬è¿˜å¯ä»¥å®šä¹‰å…¶ä»–çš„é‡å­é—¨æ¥å®ç°ç›¸åŒçš„æ•ˆæœï¼Œä½†éœ€è¦å¼•å…¥ç›¸å¯¹ç›¸ä½ã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œèƒ½å¤Ÿé€šè¿‡ä¸€äº›å—æ§éé—¨æ¥å®ç°ä¸é—¨ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬åŒæ—¶ä½¿ç”¨å¯ä»¥ç”±å•ä¸ªå—æ§éé—¨å®ç°çš„å—æ§é˜¿è¾¾é©¬é—¨å’Œå—æ§Zé—¨æ„å»ºä»¥ä¸‹å›è·¯ï¼š

> qc = QuantumCircuit(3)
>
> qc.ch(a,t)
>
> qc.cz(b,t)
>
> qc.ch(a,t)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image132.png)

å¯¹äºä¸¤ä¸ªå¤„äºæ€\|00âŸ©çš„æ§åˆ¶ç«¯ï¼Œè¯¥å›è·¯ä¸ä¼šåœ¨ç›®æ ‡ç«¯åšå‡ºä»»ä½•æ”¹å˜ã€‚ä½†å¯¹äºæ€\|11âŸ©ï¼Œç›®æ ‡ç«¯ç»å†åœ¨ä¸€ä¸ªZ-gateå‰åæ”¾ç½®çš„$H$ï¼ˆ$\text{HZH}$ï¼‰ã€‚è¯¥è¿‡ç¨‹çš„å‡€å½±å“æ˜¯åœ¨ç›®æ ‡ç«¯çš„$X$ã€‚è‹¥å—æ§ç«¯å¤„äº\|01âŸ©å’Œ\|10âŸ©ï¼Œç›®æ ‡ç«¯ä»…ç»å†ä¸¤ä¸ª$H$ï¼ˆäº’ç›¸æŠµæ¶ˆï¼‰æˆ–ä¸€ä¸ª$Z$ï¼ˆä»…å¼•å…¥ä¸€ä¸ªç›¸å¯¹ç›¸ä½ï¼‰ã€‚ç”±äºç›®æ ‡ç«¯çš„å€¼ä»…å½“æ§åˆ¶ç«¯å¤„äº\|11âŸ©æ€æ‰ä¼šè¢«æ”¹å˜ï¼Œå› æ­¤è¯¥å›è·¯å¹…é‡å¤äº†ä¸é—¨çš„æ•ˆæœï¼Œä½†å…¶åªç”¨ç›¸å½“äºä¸‰ä¸ªCNOTé—¨å°±å®ç°äº†åŠŸèƒ½ã€‚

### 5. è‡ª$\mathbf{H}$å’Œ$\mathbf{T}$çš„ä»»æ„æ—‹è½¬

ç°æœ‰è®¾å¤‡ä¸­çš„é‡å­æ¯”ç‰¹ä¼šå—åˆ°å™ªå£°çš„å½±å“ï¼Œå› æ­¤åŸºæœ¬ä¸Šç»„æˆé‡å­é—¨çš„æ˜¯é”™è¯¯ï¼ˆmistakeï¼‰ã€‚ç±»ä¼¼æ¸©åº¦ç­‰ç®€å•æƒ…å†µä¼šå¹²æ‰°ç£åœºæˆ–æ¿€æ´»ç›¸é‚»çš„é‡å­æ¯”ç‰¹ï¼Œä½¿å¾—ä¼šå‘ç”Ÿæ‰€ä¸æœŸæœ›çš„äº‹æƒ…ã€‚

å¯¹äºé‡å­è®¡ç®—æœºä¸­çš„å¤§å‹åº”ç”¨ç¨‹åºï¼Œéå¸¸æœ‰å¿…è¦ä»¥ä¸å—å™ªå£°å½±å“çš„æ–¹å¼ç¼–ç é‡å­æ¯”ç‰¹ã€‚å› è€Œä½¿å¾—ä¾æ®é”™è¯¯æˆ–æå¸¦é”™è¯¯çš„é‡å­æ¯”ç‰¹å®ç°é‡å­é—¨æå…¶å›°éš¾ã€‚

è¿™ä¸€ä¸å¹¸çš„æƒ…å†µåœ¨å•é‡å­æ¯”ç‰¹æ—‹è½¬$R_{x}\left( \theta \right)$ã€$R_{y}\left( \theta \right)$å’Œ$R_{z}\left( \theta \right)$éƒ½å­˜åœ¨ã€‚å› æ­¤æ˜¯ä¸å¯èƒ½ä»¥å®Œå…¨çš„ç²¾åº¦å®ç°è§’åº¦$\theta$çš„æ—‹è½¬ï¼Œå› è€Œå¯ä»¥ç¡®ä¿¡å®ç°$\theta + 0.0000001$ç»éå¶ç„¶ã€‚æˆ‘ä»¬æ‰€èƒ½è¾¾åˆ°çš„ç²¾åº¦æ€»æœ‰ä¸€ä¸ªæé™ï¼Œè€Œä¸”å½“è€ƒè™‘åˆ°å¤§å‹ç”µè·¯çš„ç´¯ç§¯ä¸å®Œå…¨æ—¶ï¼Œè¿™ä¸€æé™æ€»æ˜¯å¤§äºå¯å®¹å¿çš„èŒƒå›´ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†æ— æ³•åœ¨å®¹é”™ï¼ˆfault-tolerantï¼‰é‡å­è®¡ç®—æœºä¸­ç›´æ¥å®ç°è¿™äº›æ—‹è½¬ï¼Œè€Œæ˜¯éœ€è¦ä»¥ä¸€ç§æ›´ä¸ºæ…é‡çš„æ–¹å¼æ¥æ„å»ºã€‚

å®¹é”™æ–¹æ¡ˆé€šå¸¸ä½¿ç”¨ä¸¤ä¸ªé‡å­é—¨ï¼ˆHå’ŒTï¼‰çš„å¤šä¸ªåº”ç”¨æ¥æ‰§è¡Œè¿™äº›æ—‹è½¬ã€‚

åœ¨Qiskitä¸­T-gateä½¿ç”¨.t()è¡¨ç¤ºï¼š

> qc = QuantumCircuit(1)
>
> qc.t(0) \# T gate on qubit 0
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image133.png)

è¿™æ˜¯ä¸€ä¸ªç»•Zè½´è¿›è¡Œ$\theta = \pi/4$çš„æ—‹è½¬ï¼Œå…¶æ•°å­¦ä¸Šçš„è¡¨ç¤ºä¸º$R_{z}\left( \pi/4 \right) = e^{i\pi/8\ Z}$ã€‚

åœ¨ä¸‹æ–‡ä¸­æˆ‘ä»¬å‡è®¾$H$é—¨å’Œ$T$é—¨ä»¥æœ‰æ•ˆçš„å®Œç¾æ–¹å¼è¿è¡Œã€‚è¿™ä¸€ç‚¹å¯ä»¥é€šè¿‡é€‚å½“çš„çº é”™å’Œå®¹é”™æ–¹æ³•æ¥å®ç°ã€‚

é€šè¿‡Hadamardä»¥åŠåœ¨æœ€åä¸€ç« ä¸­è®¨è®ºçš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨T-gateåˆ›å»ºä¸€ä¸ªç»•xè½´çš„ç±»ä¼¼æ—‹è½¬ã€‚

qc = QuantumCircuit(1)

> qc.h(0)
>
> qc.t(0)
>
> qc.h(0)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image134.png)

ç°åœ¨å°†ä¸Šé¢ä¸¤ä¸ªå›è·¯æ”¾åœ¨ä¸€èµ·æ¥åˆ›å»º$R_{x}\left( \pi/4 \right)R_{z}\left( \pi/4 \right)$é—¨ã€‚

> qc = QuantumCircuit(1)
>
> qc.h(0)
>
> qc.t(0)
>
> qc.h(0)
>
> qc.t(0)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image135.png)

ç”±äºè¿™æ˜¯ä¸€ä¸ªå•é‡å­æ¯”ç‰¹é—¨ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³è±¡å…¶åœ¨å¸ƒæ´›èµ«çƒä¸­æ—‹è½¬çš„æƒ…å½¢ã€‚è¿™è¡¨æ˜$R_{x}\left( \pi/4 \right)R_{z}\left( \pi/4 \right)$é—¨æ˜¯ç»•æŸä¸€åæ ‡è½´æŒ‰ç…§æŸä¸€è§’åº¦çš„æ—‹è½¬ã€‚æˆ‘ä»¬åœ¨æ­¤å¤„ä¸éœ€è¦æƒ³è±¡å¤ªå¤šçš„åæ ‡è½´ï¼Œä»…ç”¨xã€yå’Œzè½´å°±èƒ½å¤Ÿè¯´æ˜é—®é¢˜ã€‚æ›´åŠ é‡è¦çš„æ˜¯è§’åº¦é—®é¢˜ã€‚

è¿™ä¸€æ—‹è½¬ä¸­è§’åº¦çš„å…³é”®ç‰¹æ€§ä¸ºå…¶ä¸ºæ— ç†æ•°ã€‚æ‚¨å¯ä»¥ç”¨ä¸€å¤§å †æ•°å­¦æ¥è¯æ˜ï¼Œä½†ä¹Ÿå¯ä»¥é€šè¿‡åº”ç”¨è¯¥é‡å­é—¨åè§‚å¯Ÿå…¶ä¸åˆç†çš„åŠ¨ä½œæ¥éªŒè¯ã€‚é‡å¤è¯¥é‡å­é—¨næ¬¡ä¼šå¯¼è‡´ç»•åŒä¸€è½´æŒ‰ç…§ä¸åŒçš„è§’åº¦æ—‹è½¬ã€‚ç”±äºæ— ç†æ€§ï¼Œä¸åŒçš„é‡å¤æ‰€äº§ç”Ÿçš„è§’åº¦æ°¸è¿œä¸ä¼šç›¸åŒã€‚

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸€ç‚¹ã€‚æ¯ä¸€ä¸ªè§’åº¦éƒ½åœ¨$0$å’Œ$2\pi$ä¹‹é—´ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸€é—´éš”åˆ†å‰²æˆå®½åº¦ä¸º$2\pi/n$çš„$n$ä¸ªåˆ‡ç‰‡ã€‚å¯¹äºæ¯æ¬¡é‡å¤ï¼Œç»“æœè§’åº¦éƒ½ä¼šè½åœ¨è¿™äº›åˆ‡ç‰‡çš„ä¸€ä¸ªä¸­ã€‚å¦‚æœæˆ‘ä»¬æŸ¥çœ‹ç¬¬ä¸€æ¬¡$n + 1$é‡å¤çš„è§’åº¦ï¼Œä¼šå‘ç°è‡³å°‘æœ‰ä¸€ä¸ªåˆ‡ç‰‡åŒ…å«è¿™äº›è§’åº¦ä¸­çš„ä¸¤ä¸ªã€‚æ­¤å¤„æˆ‘ä»¬ä½¿ç”¨$n_{1}$è¡¨ç¤ºç¬¬ä¸€æ¬¡éœ€è¦é‡å¤çš„æ¬¡æ•°ï¼Œ$n_{2}$è¡¨ç¤ºç¬¬äºŒæ¬¡éœ€è¦é‡å¤çš„æ¬¡æ•°ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è¯æ˜å…³äº$n_{2} - n_{1}$æ¬¡é‡å¤ä¸­è§’åº¦çš„ä¸€äº›é—®é¢˜ã€‚è¿™å’Œ$n_{2}$æ¬¡é‡å¤ç„¶ååå‘$n_{1}$æ¬¡é‡å¤ä¸€æ ·ã€‚ç”±äºè¿™äº›é‡å¤ä¸­çš„è§’åº¦ä¸ç›¸ç­‰ï¼ˆç”±äºæ— ç†æ€§ï¼‰ï¼Œä½†ä¹Ÿä¸ä¼šå¤§äº$2\pi/n$ï¼ˆå› ä¸ºè§’åº¦å¯¹åº”äºåŒä¸€åˆ‡ç‰‡ï¼‰ï¼Œå› æ­¤$n_{2} - n_{1}$æ¬¡é‡å¤çš„è§’åº¦æ»¡è¶³ï¼š

$$\theta_{n_{2} - n_{1}} \neq 0,\  - \frac{2\pi}{n} \leq \theta_{n_{2} - n_{1}} \leq \frac{2\pi}{n}$$

æ‰€ä»¥æˆ‘ä»¬æœ‰èƒ½åŠ›åšå°è§’åº¦çš„æ—‹è½¬ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™ä¸€åŸç†æ—‹è½¬æƒ³è¦çš„ä»»ä½•è§’åº¦ï¼Œåªéœ€å¢åŠ é‡å¤è¿™ä¸€é‡å­é—¨çš„æ¬¡æ•°ã€‚

é€šè¿‡ä½¿ç”¨å¤§é‡å°è§’åº¦æ—‹è½¬ï¼Œæˆ‘ä»¬è¿˜èƒ½å¤Ÿå®ç°ä»»ä½•æƒ³è¦çš„æ—‹è½¬ã€‚è™½ç„¶å¹¶éæ€»æ˜¯ç²¾ç¡®ï¼Œä½†å¯ä¿è¯$2\pi/n$çš„ç²¾åº¦ï¼Œå¹¶ä¸”å¯åšåˆ°å°½å¯èƒ½çš„å°ã€‚è‡³æ­¤æˆ‘ä»¬å¯ä»¥æ§åˆ¶æ—‹è½¬ä¸­çš„ä¸ç²¾ç¡®æ€§äº†ã€‚

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªèƒ½ç»•ä¸€ä¸ªè½´åšä»»æ„çš„æ—‹è½¬ã€‚å¯¹äºç¬¬äºŒä¸ªè½´ï¼Œæˆ‘ä»¬ç®€å•åœ°ä»¥ç›¸åçš„é¡ºåºè¿›è¡Œ$R_{x}\left( \pi/4 \right)$å’Œ$R_{z}\left( \pi/4 \right)$çš„æ—‹è½¬ã€‚

> qc = QuantumCircuit(1)
>
> qc.h(0)
>
> qc.t(0)
>
> qc.h(0)
>
> qc.t(0)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image136.png)

è¿™ä¸€æ—‹è½¬æ‰€å¯¹ç”¨çš„è½´ä¸å…ˆå‰æ€è€ƒçš„é‡å­é—¨ç›¸åŒã€‚æˆ‘ä»¬ç°åœ¨æœ‰äº†ç»•ä¸¤ä¸ªè½´çš„ä»»æ„æ—‹è½¬ï¼Œå› æ­¤ä¸‡å¯ä»¥å®ç°ç»•å¸ƒæ´›èµ«çƒçš„ä»»æ„æ—‹è½¬ã€‚æˆ‘ä»¬åˆå¯ä»¥åšä»»ä½•äº‹æƒ…äº†ï¼Œå°½ç®¡éœ€è¦å¾ˆå¤šT-gateã€‚

æ­£å› ä¸ºè¿™æ ·çš„åº”ç”¨ï¼ŒT-gateæ‰åœ¨é‡å­è®¡ç®—ä¸­å¦‚æ­¤çªå‡ºã€‚äº‹å®ä¸Šï¼Œå®¹é”™é‡å­è®¡ç®—æœºç®—æ³•çš„å¤æ‚æ€§ç»å¸¸è¢«å¼•åˆ°éœ€è¦å¤šå°‘T-gateä¸Šã€‚è¿™ä¿ƒä½¿äººä»¬è¿½æ±‚ç”¨å°½å¯èƒ½å°‘çš„T-gateæ¥å®ç°ç›®æ ‡ã€‚å¯ä»¥çœ‹å‡ºä¸Šé¢çš„è®¨è®ºåªæ˜¯ä¸ºäº†è¯æ˜T-gateå¯ä»¥ç”¨è¿™ä¸€ç§æ–¹å¼æ¥ä½¿ç”¨ï¼Œå…¶å¹¶ä¸æ˜¯æˆ‘ä»¬æ‰€çŸ¥é“çš„æœ€æœ‰æ•ˆæ–¹æ³•ã€‚

### 6. å‚è€ƒæ–‡çŒ®

\[1\] [Barenco, et al.
1995](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.3457?cm_mc_uid=43781767191014577577895&cm_mc_sid_50200000=1460741020)

\[2\] [Shende and Markov,
2009](http://dl.acm.org/citation.cfm?id=2011799)

3. é‡å­åè®®å’Œé‡å­ç®—æ³•
=====================

å…³äºæœ¬èŠ‚
--------

è‡³æ­¤æˆ‘ä»¬å·²ç»è®²è¿°äº†é‡å­è®¡ç®—çš„åŸºç¡€ï¼Œç°åœ¨å‡†å¤‡ä»‹ç»ä¸€äº›é‡å­åè®®ï¼ˆQuantum
Protocolï¼‰å’Œç®—æ³•ï¼ˆQuantum
Algorithmï¼‰ã€‚é€šè¿‡è¿™äº›ç®—æ³•ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°ä¸Šä¸€ç« ä¸­çš„æ¦‚å¿µï¼Œå¹¶å°†å¼•å…¥æ–°çš„æ€æƒ³å’ŒæŠ€æœ¯ã€‚æ‚¨å°†é¦–å…ˆå­¦ä¹ çš„ç®—æ³•æ˜¯æ¦‚å¿µéªŒè¯ç®—æ³•ï¼ˆ**proof-of-concept
algorithm**ï¼‰ï¼Œè¿™äº›ç®—æ³•å¼€å‘ç›®çš„æ˜¯å±•ç¤ºé‡å­è®¡ç®—æœºçš„ä¼˜åŠ¿ã€‚è¿™äº›ç®—æ³•æ˜¯å­¦ä¹ é‡å­ç¼–ç¨‹å¾ˆå¥½çš„èµ·ç‚¹ï¼›å› å…¶å±•ç¤ºäº†ä¸€äº›æŠ€æœ¯å¹¶åœ¨åæ¥è¢«åº”ç”¨åˆ°"æœ‰ç”¨çš„"ç®—æ³•ä¸­ï¼Œä»è€Œå¼•å‘äº†äººä»¬å¯¹é‡å­è®¡ç®—çš„å…´å¥‹ã€‚è¿™äº›ç®—æ³•å¯ä»¥è®©æˆ‘ä»¬ä»¥å…¶æœ€ç®€å•çš„å½¢å¼ç†è§£å…¶ä¸­çš„æ ¸å¿ƒæ€æƒ³ã€‚æ¦‚å¿µéªŒè¯ç®—æ³•åœ¨æµ‹è¯•ç¡¬ä»¶æ—¶ä¹Ÿå¯ä»¥ä½œä¸ºåŸºå‡†ã€‚

å³å°†åˆ°æ¥
--------

ä»¥ä¸‹ä¸»é¢˜ç›®å‰æ­£åœ¨å¼€å‘ä¸­ï¼Œå°†è¢«æ·»åŠ åˆ°æœ¬æ•™ç¨‹ä¸­ï¼š

-   NISQç¡¬ä»¶ä¸­çš„é‡å­ç®—æ³•æ¦‚è§ˆ

3.1 å®šä¹‰é‡å­å›è·¯
----------------

### å†…å®¹

1\. å¼•è¨€

2\. ä»€ä¹ˆæ˜¯é‡å­å›è·¯ï¼Ÿ

3\. ç¤ºä¾‹ï¼šé‡å­éšå½¢ä¼ æ€ï¼ˆQuantum Teleportationï¼‰

4\. ç¤ºä¾‹ï¼šå˜åˆ†é‡å­æœ¬å¾å€¼æ±‚è§£å™¨ï¼ˆVariational Quantum Eigensolverï¼‰

5\. ä¸ºä½•æœ‰ç»å…¸éƒ¨åˆ†ï¼Ÿ

### 1. å¼•è¨€

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°è¿‡ä¸åŒé¢å•é‡å­æ¯”ç‰¹å’Œå¤šé‡å­æ¯”ç‰¹çš„é‡å­é—¨ï¼Œè¿˜çœ‹åˆ°å¦‚ä½•ç»„åˆè¿™ä¸¤é‡å­é—¨å’Œå…¶ä»–ç»„ä»¶æ¥æ„å»ºé‡å­å›è·¯ã€‚

åœ¨çœŸå®çš„é‡å­è®¡ç®—æœºä¸Šå®ç°é‡å­ç®—æ³•ä¹‹å‰ï¼Œå…·ä½“çš„å¼ºè°ƒä¸€ä¸‹é‡å­å›è·¯çš„å®šä¹‰éå¸¸é‡è¦ï¼Œå¦‚åŒæˆ‘ä»¬å°†ä¼šåˆ›å»ºé‡å­å›è·¯æ¥å®ç°è¿™äº›ç®—æ³•ä¸€æ ·ã€‚

### 2. ä»€ä¹ˆæ˜¯é‡å­å›è·¯ï¼Ÿ

é‡å­å›è·¯æ˜¯ç”±é‡å­æ•°æ®ï¼ˆå¦‚é‡å­æ¯”ç‰¹ï¼‰ä¸Šçš„ç›¸å…³é‡å­æ“ä½œå’Œå¹¶è¡Œå®æ—¶ç»å…¸è®¡ç®—ç»„æˆçš„è®¡ç®—ç¨‹åºï¼Œä¸ºé‡å­é—¨ã€æµ‹é‡å’Œé‡ç½®çš„æœ‰åºåºåˆ—ï¼Œæ‰€æœ‰è¿™äº›éƒ½å¯ä»¥æœ‰æ¡ä»¶åœ°ä½¿ç”¨æ¥è‡ªå®æ—¶ç»å…¸è®¡ç®—çš„æ•°æ®ã€‚

å¦‚æœé‡å­æ•°æ®çš„ä»»ä½•å¹ºæ­£å˜æ¢éƒ½å¯ä»¥æœ‰æ•ˆåœ°ä»»æ„è¿‘ä¼¼æˆé‡å­é—¨çš„åºåˆ—ï¼Œé‚£ä¹ˆä¸€ç»„é‡å­é—¨å°±ç§°ä¸ºæ™®é€‚ï¼ˆuniversalï¼‰ã€‚ä»»ä½•é‡å­ç¨‹åºéƒ½è¡¨ç¤ºä¸ºä¸€ç»„é‡å­ç”µè·¯å’Œéå¹¶è¡Œç»å…¸è®¡ç®—ã€‚

### 3. ç¤ºä¾‹ï¼šé‡å­éšå½¢ä¼ æ€

çœ‹ä¸€çœ‹ä¸‹é¢çš„é‡å­å›è·¯ï¼Œæ‚¨å°†äº†è§£å°†è¦å®ç°çš„é‡å­éšå½¢ä¼ æ€ç®—æ³•ï¼ˆthe quantum
teleportation algorithmï¼‰ã€‚ç°åœ¨ï¼Œçœ‹ä¸€ä¸‹è¿™ä¸€é‡å­ç”µè·¯çš„ç»„æˆå°±è¶³å¤Ÿäº†ã€‚

![Quantum Teleportation
Labeled](pics/media/image137.png)

è¯¥é‡å­å›è·¯ä½¿ç”¨ä¸‰ä¸ªé‡å­æ¯”ç‰¹å’Œä¸¤ä¸ªç»å…¸æ¯”ç‰¹ã€‚åœ¨è¿™ä¸ªé‡å­å›è·¯ä¸­æœ‰å››ä¸ªä¸»è¦å…ƒä»¶ã€‚

#### åˆå§‹åŒ–å’Œé‡ç½®

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰è‰¯å¥½çš„é‡å­æ€æ¥å¼€å§‹é‡å­è®¡ç®—ï¼Œå¯ä»¥ä½¿ç”¨åˆå§‹åŒ–å’Œé‡ç½®æ“ä½œæ¥å®ç°ã€‚

é‡ç½®æ“ä½œå¯ç”±ç»“åˆå•é‡å­æ¯”ç‰¹é—¨å’Œå¹¶å‘å®æ—¶ç»å…¸è®¡ç®—æ¥å®ç°ï¼Œç„¶åé€šè¿‡æµ‹é‡æ¥ç›‘æ§æ˜¯å¦æˆåŠŸåœ°åˆ›å»ºäº†æ‰€éœ€çš„çŠ¶æ€ã€‚ç„¶åé€šè¿‡åº”ç”¨å•é‡å­æ¯”ç‰¹é—¨åˆå§‹åŒ–$q_{0}$è‡³ç†æƒ³æ€$\left| \psi \right\rangle$ã€‚

#### é‡å­é—¨

ç¬¬äºŒï¼Œæˆ‘ä»¬åº”ç”¨ä¸€ä¸ªé‡å­é—¨åºåˆ—æ¥æ“çºµä¸‰ä¸ªé‡å­æ¯”ç‰¹ï¼Œä»¥æ»¡è¶³é‡å­éšå½¢ä¼ æ€ç®—æ³•çš„è¦æ±‚ã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œä»…éœ€ä½¿ç”¨å•é‡å­æ¯”ç‰¹é˜¿è¾¾é©¬é—¨ï¼ˆ$H$ï¼‰ä»¥åŠåŒé‡å­æ¯”ç‰¹å—æ§Xé—¨ï¼ˆ$\oplus$ï¼‰ã€‚

#### æµ‹é‡

ç¬¬ä¸‰ï¼Œå¯¹ä¸‰ä¸ªé‡å­æ¯”ç‰¹ä¸­çš„ä¸¤ä¸ªè¿›è¡Œæµ‹é‡ã€‚ç»å…¸è®¡ç®—æœºå°†æ¯ä¸ªé‡å­æ¯”ç‰¹çš„æµ‹é‡ç»“æœè§£é‡Šä¸ºç»å…¸ç»“æœï¼ˆ0å’Œ1ï¼‰ï¼Œå¹¶å°†å…¶å­˜å‚¨äºä¸¤ä¸ªç»å…¸æ¯”ç‰¹ä¸­ã€‚

#### ç»å…¸æ¡ä»¶é‡å­é—¨

ç¬¬å››ï¼Œåœ¨ç¬¬ä¸‰ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨å•é‡å­æ¯”ç‰¹$Z$å’Œ$X$é‡å­é—¨ã€‚è¿™äº›é‡å­é—¨æ˜¯å¦è¿è¡Œç”±å­˜å‚¨åœ¨ä¸¤ä¸ªç»å…¸æ¯”ç‰¹çš„æµ‹é‡ç»“æœå†³å®šã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬åœ¨åŒä¸€é‡å­å›è·¯ä¸­åŒæ—¶å®æ—¶åœ°ä½¿ç”¨äº†ç»å…¸è®¡ç®—çš„ç»“æœã€‚

### 4. ç¤ºä¾‹ï¼šå˜åˆ†é‡å­æœ¬å¾å€¼æ±‚è§£å™¨

ä»¥ä¸‹æ˜¯ä¸€ä¸ªé‡å­ç¨‹åºçš„ç¤ºä¾‹ã€‚æ‚¨å°†åœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­å­¦ä¹ ï¼Œè¯¥ç¨‹åºå®ç°äº†ä¸€ä¸ªå˜åˆ†é‡å­ç‰¹å¾å€¼æ±‚è§£å™¨ã€‚åœ¨è¿™ä¸ªç¨‹åºä¸­ï¼Œç»å…¸è®¡ç®—æœºä¸é‡å­è®¡ç®—æœºéå¹¶å‘åœ°ååŒå·¥ä½œã€‚

![Variational Quantum Eigensolver
Labeled](pics/media/image138.png)

#### é‡å­å—ï¼ˆQuantum Blockï¼‰

åœ¨ä¸Šé¢çš„ç¤ºä¾‹1ä¸­ï¼Œé‡å­æ€$\left| \Psi\left( \theta \right) \right\rangle$æ˜¯ç”±å•å’Œå¤šé‡å­æ¯”ç‰¹é‡å­é—¨å½¢æˆçš„é‡ç½®ç»„åˆã€‚åœ¨è¿™é‡Œï¼ŒçŠ¶æ€çš„å‚æ•°è¢«é‡$\theta$å‚æ•°åŒ–ã€‚ä¸€æ—¦å…¶å‡†å¤‡å¥½ï¼Œé‡å­æ€å°±å¯ä»¥ç”¨é‡å­é—¨æ“çºµå¹¶æµ‹é‡ã€‚é‡å­å—å†…çš„æ‰€æœ‰æ“ä½œéƒ½ç”±é‡å­å›è·¯ç»„æˆã€‚

#### ç»å…¸å—ï¼ˆClassical Blockï¼‰

ä¸€æ—¦é‡å­æ€è¢«æµ‹é‡ï¼Œä¸€ä¸ªç»å…¸è®¡ç®—å™¨å¯¹æµ‹é‡ç»“æœè¿›è¡Œè§£é‡Šï¼Œå¹¶ä½¿ç”¨é’ˆå¯¹ç‰¹å®šåº”ç”¨é€‰æ‹©çš„ä»£ä»·ï¼ˆcostï¼‰å‡½æ•°æ¥è®¡ç®—å…¶ä»£ä»·ã€‚åœ¨æ­¤ä»£ä»·çš„åŸºç¡€ä¸Šï¼Œç»å…¸è®¡ç®—å™¨ç¡®å®šå‚æ•°$\theta$çš„å¦ä¸€ä¸ªå€¼ã€‚

#### è”åˆè¿è¡Œï¼ˆCombined operationï¼‰

ä¸€æ—¦ç»å…¸è®¡ç®—å™¨ç¡®å®šäº†é‡ç½®åºåˆ—çš„ä¸‹ä¸€ä¸ªå‚æ•°$\theta$ï¼Œé‡å­å›è·¯ä¸­çš„å•å’Œå¤šé‡å­æ¯”ç‰¹é‡å­é—¨å°±ä¼šå‡†å¤‡$\left| \Psi\left( \theta \right) \right\rangle$ï¼Œè¿™ä¸€è¿‡ç¨‹ä¼šä¸€ç›´è¿è¡Œç›´åˆ°è¢«æµ‹é‡å­æ€çš„ä»£ä»·ç¨³å®šï¼Œæˆ–è€…ç›´åˆ°å¦ä¸€ä¸ªé¢„å…ˆç¡®å®šçš„ç»“æœå¾—åˆ°æ»¡è¶³ã€‚

### 5. ä¸ºä½•æœ‰ç»å…¸éƒ¨åˆ†ï¼Ÿ

è™½ç„¶é€šç”¨é‡å­è®¡ç®—æœºå¯ä»¥åšä»»ä½•ç»å…¸è®¡ç®—æœºèƒ½åšçš„äº‹æƒ…ï¼Œä½†æˆ‘ä»¬ç»å¸¸åœ¨é‡å­ç”µè·¯ä¸­æ·»åŠ ç»å…¸éƒ¨åˆ†ï¼Œå› ä¸ºé‡å­æ€å¾ˆè„†å¼±ã€‚

å½“æˆ‘ä»¬æµ‹é‡é‡å­æ¯”ç‰¹æ—¶å°±æ¢ç´¢äº†å…¶çš„çŠ¶æ€ï¼Œç ´åäº†å…¶ä¸­çš„è®¸å¤šä¿¡æ¯ã€‚ç”±äºæ‰€æœ‰æµ‹é‡éƒ½ä¼šç ´åä¿¡æ¯ï¼Œæ‰€ä»¥ç†è®ºä¸Šæˆ‘ä»¬æ€»æ˜¯å¯ä»¥æœ€åæµ‹é‡å¹¶ä¸”ä¸ä¼šå¤±å»è®¡ç®—ä¸Šçš„ä¼˜åŠ¿ã€‚ä½†ç°å®ä¸­ï¼Œæ—©å…ˆæµ‹é‡æä¾›äº†è®¸å¤šå®é™…çš„ä¼˜åŠ¿ã€‚

ä¾‹å¦‚ï¼Œåœ¨éšå½¢ä¼ æ€å›è·¯ä¸­ï¼Œé€šè¿‡æµ‹é‡é‡å­æ¯”ç‰¹å°±å¯ä»¥é€šè¿‡ç»å…¸ä¿¡é“è€Œéé‡å­ä¿¡é“å‘é€ä¿¡æ¯ã€‚å…¶ä¼˜ç‚¹æ˜¯ç»å…¸ä¿¡é“éå¸¸ç¨³å®šï¼Œè€Œä¸”æˆ‘ä»¬å¹¶æ²¡æœ‰å¯è¡Œçš„æ–¹æ³•å°†é‡å­ä¿¡æ¯å‘é€ç»™å…¶ä»–äººï¼Œå› ä¸ºè¿™ç§ä¿¡é“å¾ˆéš¾åˆ›å»ºã€‚

åœ¨å˜åˆ†é‡å­æœ¬å¾å€¼æ±‚è§£å™¨çš„ä¾‹å­ä¸­ï¼ŒæŠŠè®¡ç®—åˆ†è§£æˆæ›´å°çš„é‡å­è®¡ç®—å®é™…ä¸Šå¤±å»äº†ä¸€äº›è®¡ç®—ä¼˜åŠ¿ï¼Œä½†é€šè¿‡å‡å°‘é‡å­æ¯”ç‰¹çš„å åŠ æ—¶é—´å¼¥è¡¥äº†è¿™ä¸€ç‚¹ã€‚è¿™æ„å‘³ç€å¹²æ‰°å¯¼è‡´ç»“æœä¸å‡†ç¡®çš„æœºä¼šå‡å°‘ã€‚

æœ€åï¼Œè‹¥è¦åœ¨æ—¥å¸¸ä¸­ä½¿ç”¨é‡å­è®¡ç®—çš„ç»“æœï¼Œéœ€è¦åœ¨è®¡ç®—ç»“æŸæ—¶æµ‹é‡å’Œè§£é‡Šè¿™äº›çŠ¶æ€ã€‚

3.2 é‡å­éšå½¢ä¼ æ€
----------------

### å†…å®¹

1\. æ¦‚è¿°

2\. é‡å­éšå½¢ä¼ æ€åè®®

3\. æ¨¡æ‹Ÿéšå½¢ä¼ æ€åè®®

3.1
æˆ‘ä»¬å¦‚ä½•åœ¨çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸Šæµ‹è¯•è¯¥åè®®ï¼Ÿï¼ˆåŸæ–‡é”™è¯¯ï¼ŒåŸæ–‡ä¸­æ˜¯ç»“æœResultï¼‰

3.2 ä½¿ç”¨æ€å‘é‡æ¨¡æ‹Ÿå™¨

3.3 ä½¿ç”¨QASMæ¨¡æ‹Ÿå™¨

4\. ç†è§£éšå½¢ä¼ æ€

5\. åœ¨çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸Šéšå½¢ä¼ æ€

5.1 IBMç¡¬ä»¶ä¸é€’å»¶æµ‹é‡

5.2 æ‰§è¡Œ

6\. å‚è€ƒæ–‡çŒ®

### 1. æ¦‚è¿°

Aliceæƒ³è¦ä¼ é€é‡å­ä¿¡æ¯ç»™Bobã€‚å…·ä½“æ¥è¯´ï¼Œå‡è®¾å¥¹æƒ³å‘é€é‡å­æ¯”ç‰¹çŠ¶æ€$\left| \psi \right\rangle = \alpha\left| 0 \right\rangle + \beta\left| 1 \right\rangle$ï¼Œå°±éœ€è¦å‘Bobä¼ é€’å…³äº$\alpha$å’Œ$\beta$çš„ä¿¡æ¯ã€‚

åœ¨é‡å­åŠ›å­¦ä¸­å­˜åœ¨ä¸€ä¸ªå®šç†ï¼šæ‚¨ä¸èƒ½ç®€å•åœ°å¤åˆ¶ä¸€ä¸ªæœªçŸ¥çš„é‡å­çŠ¶æ€ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„éå…‹éš†å®šç†ï¼ˆno-cloning
theoremï¼‰ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥çœ‹åˆ°Aliceä¸èƒ½ç®€å•åœ°ç”Ÿæˆ$\left| \psi \right\rangle$çš„å‰¯æœ¬å¹¶å‘ç”Ÿç»™Bobï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½å¤åˆ¶ç»å…¸æ€ï¼ˆä¸èƒ½å¤åˆ¶å åŠ æ€ï¼‰ã€‚

ç„¶è€Œï¼Œåˆ©ç”¨ä¸¤ä¸ªç»å…¸æ¯”ç‰¹å’Œä¸€å¯¹çº ç¼ é‡å­æ¯”ç‰¹ï¼ŒAliceå¯ä»¥è½¬ç§»çŠ¶æ€$\left| \psi \right\rangle$ç»™Bobã€‚æˆ‘ä»¬å°†åœ¨Bobæ”¶åˆ°$\left| \psi \right\rangle$åAliceå°±æ²¡æœ‰è¯¥$\left| \psi \right\rangle$çš„æƒ…å†µç§°ä¹‹ä¸ºéšå½¢ä¼ æ€ï¼ˆ**teleportation**ï¼‰ã€‚

### 2. é‡å­éšå½¢ä¼ æ€åè®®

ä¸ºäº†è½¬ç§»ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼ŒAliceå’ŒBobå¿…é¡»è®©ç¬¬ä¸‰æ–¹ï¼ˆEveï¼‰å‘ä»–ä»¬å‘é€ä¸€ä¸ªçº ç¼ çš„é‡å­æ¯”ç‰¹å¯¹ã€‚ç„¶åAliceä»–ä»¬å¯¹å‘é€ç»™å¥¹çš„é‡å­æ¯”ç‰¹è¿›è¡Œä¸€äº›æ“ä½œï¼Œå¹¶é€šè¿‡ä¸€ä¸ªç»å…¸çš„é€šä¿¡ä¿¡é“å°†ç»“æœå‘é€ç»™Bobï¼Œç„¶åBobåœ¨ä»–çš„é‡å­æ¯”ç‰¹ä¸Šè¿›è¡Œä¸€äº›æ“ä½œæ¥æ¥æ”¶Aliceçš„é‡å­æ¯”ç‰¹ã€‚

![](pics/media/image139.png)

æˆ‘ä»¬å°†åœ¨ä¸‹é¢é‡å­å›è·¯ä¸­æè¿°è¯¥æ­¥éª¤ã€‚åœ¨è¿™é‡Œï¼Œæ²¡æœ‰é‡å­æ¯”ç‰¹å®é™…ä¸Šè¢«"å‘é€"ï¼Œæ‚¨åªéœ€è¦æƒ³è±¡è¯¥æƒ…å†µï¼

é¦–å…ˆè®¾ç½®ä¼šè¯ï¼š

> \# Do the necessary imports
>
> import numpy as np
>
> from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister,
> execute, BasicAer, IBMQ
>
> from qiskit.visualization import plot_histogram,
> plot_bloch_multivector
>
> from qiskit.extensions import Initialize
>
> from qiskit_textbook.tools import random_state, array_to_latex

ç„¶ååˆ›å»ºé‡å­å›è·¯ï¼š

> qr = QuantumRegister(3) \# Protocol uses 3 qubits
>
> crz = ClassicalRegister(1) \# and 2 classical bits
>
> crx = ClassicalRegister(1) \# in 2 different registers
>
> teleportation_circuit = QuantumCircuit(qr, crz, crx)

#### æ­¥éª¤1

ç¬¬ä¸‰æ–¹Eveåˆ›å»ºä¸€çº ç¼ çš„é‡å­æ¯”ç‰¹å¯¹ï¼Œå¹¶å°†å…¶åˆ†åˆ«ç»™Aliceå’ŒBobã€‚

Eveåˆ›å»ºçš„çº ç¼ å¯¹æ˜¯ä¸€ä¸ªç§°ä¹‹ä¸ºè´å°”å¯¹ï¼ˆBell
pairï¼‰çš„ç‰¹å®šé‡å­æ¯”ç‰¹å¯¹ã€‚ç”¨é‡å­å›è·¯çš„è¯­è¨€æè¿°ï¼Œåˆ›å»ºä¸¤ä¸ªä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„è´å°”å¯¹æ˜¯ä½¿ç”¨é˜¿è¾¾é©¬é—¨å…ˆå°†å…¶ä¸­ä¸€ä¸ªè½¬ç§»è‡³X-åŸºï¼ˆ$\left| + \right\rangle$å’Œ$\left| - \right\rangle$ï¼‰ï¼Œç„¶åä¾æ®åœ¨X-åŸºä¸Šçš„é‡å­æ¯”ç‰¹åœ¨å¦ä¸€ä¸ªä¸Šåº”ç”¨ä¸€ä¸ªå—æ§éé—¨ã€‚

> def create_bell_pair(qc, a, b):
>
> \"\"\"Creates a bell pair in qc using qubits a & b\"\"\"
>
> qc.h(a) \# Put qubit a into state \|+\>
>
> qc.cx(a,b) \# CNOT with a as control and b as target
>
> \#\# SETUP
>
> \# Protocol uses 3 qubits and 2 classical bits in 2 different
> registers
>
> qr = QuantumRegister(3)
>
> crz, crx = ClassicalRegister(1), ClassicalRegister(1)
>
> teleportation_circuit = QuantumCircuit(qr, crz, crx)
>
> \#\# STEP 1
>
> \# In our case, Eve entangles qubits q1 and q2
>
> \# Let\'s apply this to our circuit:
>
> create_bell_pair(teleportation_circuit, 1, 2)
>
> \# And view the circuit so far:
>
> teleportation_circuit.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image140.png)

åœ¨å°†è¯¥è´å°”å¯¹åˆ†å¼€åï¼Œæˆ‘ä»¬å¯ä»¥è¯´Aliceæ‹¥æœ‰$q_{1}$è€ŒBobæ‹¥æœ‰$q_{2}$ã€‚

#### æ­¥éª¤2

Aliceåœ¨$q_{1}$ä¸Šåº”ç”¨ä¸€ä¸ªç”±$\left| \psi \right\rangle$æ§åˆ¶çš„å—æ§éé—¨ï¼Œ$\left| \psi \right\rangle$æ˜¯å°†è¦ä¼ é€ç»™Bobçš„é‡å­æ¯”ç‰¹ã€‚ç„¶åAliceåœ¨$\left| \psi \right\rangle$åº”ç”¨ä¸€ä¸ªé˜¿è¾¾é©¬é—¨ã€‚åœ¨æˆ‘ä»¬æ‰€åˆ›å»ºçš„é‡å­å›è·¯ä¸­ï¼ŒAliceæƒ³è¦ä¼ é€çš„é‡å­æ¯”ç‰¹$\left| \psi \right\rangle$æ˜¯$q_{0}$ï¼š

> def alice_gates(qc, psi, a):
>
> qc.cx(psi, a)
>
> qc.h(psi)
>
> \#\# SETUP
>
> \# Protocol uses 3 qubits and 2 classical bits in 2 different
> registers
>
> qr = QuantumRegister(3)
>
> crz, crx = ClassicalRegister(1), ClassicalRegister(1)
>
> teleportation_circuit = QuantumCircuit(qr, crz, crx)
>
> \#\# STEP 1
>
> create_bell_pair(teleportation_circuit, 1, 2)
>
> \#\# STEP 2
>
> teleportation_circuit.barrier() \# Use barrier to separate steps
>
> alice_gates(teleportation_circuit, 0, 1)
>
> teleportation_circuit.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image141.png)

#### æ­¥éª¤3

æ¥ç€ï¼ŒAliceåœ¨å…¶æ‰€æœ‰çš„é‡å­æ¯”ç‰¹$q_{1}$å’Œ$\left| \psi \right\rangle$ä¸Šåº”ç”¨ä¸€ä¸ªæµ‹é‡ï¼Œå¹¶å°†ç»“æœå‚¨å­˜åœ¨ä¸¤ä¸ªç»å…¸æ¯”ç‰¹ä¸­ã€‚ç„¶åå°†è¿™ä¸¤ä¸ªç»å…¸æ¯”ç‰¹ä¼ é€ç»™Bobã€‚

> def measure_and_send(qc, a, b):
>
> \"\"\"Measures qubits a & b and \'sends\' the results to Bob\"\"\"
>
> qc.barrier()
>
> qc.measure(a,0)
>
> qc.measure(b,1)
>
> \#\# SETUP
>
> \# Protocol uses 3 qubits and 2 classical bits in 2 different
> registers
>
> qr = QuantumRegister(3)
>
> crz, crx = ClassicalRegister(1), ClassicalRegister(1)
>
> teleportation_circuit = QuantumCircuit(qr, crz, crx)
>
> \#\# STEP 1
>
> create_bell_pair(teleportation_circuit, 1, 2)
>
> \#\# STEP 2
>
> teleportation_circuit.barrier() \# Use barrier to separate steps
>
> alice_gates(teleportation_circuit, 0, 1)
>
> \#\# STEP 3
>
> measure_and_send(teleportation_circuit, 0 ,1)
>
> teleportation_circuit.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image142.png)

#### æ­¥éª¤4

å·²æœ‰é‡å­æ¯”ç‰¹$q_{2}$çš„Bobä¼šåœ¨æ¥æ”¶ç»å…¸æ¯”ç‰¹åï¼Œä¾æ®æ‰€æ¥æ”¶ç»å…¸æ¯”ç‰¹æ‰€ä»£è¡¨çš„çŠ¶æ€åº”ç”¨ä»¥ä¸‹é‡å­é—¨ï¼š

00$\rightarrow$ä»€ä¹ˆä¹Ÿä¸åš

01$\rightarrow$åº”ç”¨$X$-gate

10$\rightarrow$åº”ç”¨$Z$-gate

11$\rightarrow$åº”ç”¨$\text{ZX}$-gate

> \# This function takes a QuantumCircuit (qc), integer (qubit)
>
> \# and ClassicalRegisters (crz & crx) to decide which gates to apply
>
> def bob_gates(qc, qubit, crz, crx):
>
> \# Here we use c_if to control our gates with a classical
>
> \# bit instead of a qubit
>
> qc.x(qubit).c_if(crx, 1) \# Apply gates if the registers
>
> qc.z(qubit).c_if(crz, 1) \# are in the state \'1\'
>
> \#\# SETUP
>
> \# Protocol uses 3 qubits and 2 classical bits in 2 different
> registers
>
> qr = QuantumRegister(3)
>
> crz, crx = ClassicalRegister(1), ClassicalRegister(1)
>
> teleportation_circuit = QuantumCircuit(qr, crz, crx)
>
> \#\# STEP 1
>
> create_bell_pair(teleportation_circuit, 1, 2)
>
> \#\# STEP 2
>
> teleportation_circuit.barrier() \# Use barrier to separate steps
>
> alice_gates(teleportation_circuit, 0, 1)
>
> \#\# STEP 3
>
> measure_and_send(teleportation_circuit, 0 ,1)
>
> \#\# STEP 4
>
> teleportation_circuit.barrier() \# Use barrier to separate steps
>
> bob_gates(teleportation_circuit, 2, crz, crx)
>
> teleportation_circuit.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image143.png)

ï¼ˆæ³¨ï¼šæ­¤å¤„æ˜¯çº¯ç»å…¸çš„ä¿¡æ¯è½¬ç§»ã€‚ï¼‰

åœ¨è¿™ä¸ªåè®®çš„æœ€åï¼ŒAliceçš„é‡å­æ¯”ç‰¹å·²ç»ä¼ é€ç»™Bobäº†ã€‚

### 3. æ¨¡æ‹Ÿéšå½¢ä¼ æ€åè®®

#### 3.1 æˆ‘ä»¬å¦‚ä½•åœ¨çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸Šæµ‹è¯•è¯¥åè®®ï¼Ÿ

åœ¨æœ¬notebookä¸­ï¼Œæˆ‘ä»¬å°†åˆå§‹åŒ–Aliceçš„é‡å­æ¯”ç‰¹ä¸ºéšæœºæ€$\left| \psi \right\rangle$ï¼ˆpsiï¼Œæ™®è¥¿ï¼‰ã€‚è¿™ä¸€çŠ¶æ€å°†é€šè¿‡åœ¨$\left| q_{0} \right\rangle$ä¸Šåˆå§‹ä¸€ä¸ªé‡å­é—¨æ¥åˆ›å»ºã€‚æˆ‘ä»¬åœ¨æœ¬ç« ä¸­ä½¿ç”¨random_stateå‡½æ•°ä¸ºæˆ‘ä»¬é€‰æ‹©psiï¼Œä½†æ˜¯æ‚¨å¯ä»¥å°†psiè®¾ç½®ä¸ºä»»æ„æƒ³è¦çš„é‡å­æ¯”ç‰¹ã€‚

> \# Create random 1-qubit state
>
> psi = random_state(1)
>
> \# Display it nicely
>
> array_to_latex(psi, pretext=\"\|\\\\psi\\\\rangle =\")
>
> \# Show it on a Bloch sphere
>
> plot_bloch_multivector(psi)
>
> è¾“å‡ºï¼š

![](pics/media/image144.png)

ç°åœ¨è®©æˆ‘ä»¬ä»æ€$\left| 0 \right\rangle$åˆ›å»ºåˆå§‹çš„é‡å­é—¨ï¼š

> init_gate = Initialize(psi)
>
> init_gate.label = \"init\"

å¦‚æœé‡å­éšå½¢ä¼ æ€å·¥ä½œï¼Œé‚£ä¹ˆåœ¨é‡å­å›è·¯æœ«ç«¯çš„$\left| q_{2} \right\rangle$å°±ä¼šå¤„äºè¿™ä¸€çŠ¶æ€ï¼ˆpsiï¼‰ã€‚æˆ‘ä»¬å°†ä¼šä½¿ç”¨æ€å‘é‡æ¨¡æ‹Ÿå™¨æ¥æ£€æŸ¥ã€‚

#### 3.2 ä½¿ç”¨æ€å‘é‡æ¨¡æ‹Ÿå™¨

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ€å‘é‡æ¨¡æ‹Ÿå™¨æ¥éªŒè¯é‡å­æ¯”ç‰¹æ˜¯å¦è¢«ä¼ é€ã€‚

> \#\# SETUP
>
> qr = QuantumRegister(3) \# Protocol uses 3 qubits
>
> crz = ClassicalRegister(1) \# and 2 classical registers
>
> crx = ClassicalRegister(1)
>
> qc = QuantumCircuit(qr, crz, crx)
>
> \#\# STEP 0
>
> \# First, let\'s initialise Alice\'s q0
>
> qc.append(init_gate, \[0\])
>
> qc.barrier()
>
> \#\# STEP 1
>
> \# Now begins the teleportation protocol
>
> create_bell_pair(qc, 1, 2)
>
> qc.barrier()
>
> \#\# STEP 2
>
> \# Send q1 to Alice and q2 to Bob
>
> alice_gates(qc, 0, 1)
>
> \#\# STEP 3
>
> \# Alice then sends her classical bits to Bob
>
> measure_and_send(qc, 0, 1)
>
> \#\# STEP 4
>
> \# Bob decodes qubits
>
> bob_gates(qc, 2, crz, crx)
>
> \# Display the circuit
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image145.png)

æˆ‘ä»¬å¯ä»¥ä»ä¸‹é¢çœ‹åˆ°ï¼Œé€šè¿‡ä½¿ç”¨æ€å‘é‡æ¨¡æ‹Ÿå™¨$\left| q_{2} \right\rangle$çš„çŠ¶æ€ä¸æ‰€åˆ›å»ºçš„$\left| \psi \right\rangle$å®Œå…¨ä¸€æ ·ï¼ŒåŒæ—¶$\left| q_{0} \right\rangle$å’Œ$\left| q_{1} \right\rangle$çš„çŠ¶æ€åç¼©ä¸º$\left| 0 \right\rangle$å’Œ$\left| 1 \right\rangle$ã€‚æ€$\left| \psi \right\rangle$è¢«ä»é‡å­æ¯”ç‰¹0ä¼ æ€è‡³é‡å­æ¯”ç‰¹2ã€‚

> backend = BasicAer.get_backend(\'statevector_simulator\')
>
> out_vector = execute(qc, backend).result().get_statevector()
>
> plot_bloch_multivector(out_vector)
>
> è¾“å‡ºï¼š

![](pics/media/image146.png)

æ‚¨å¯ä»¥é€šè¿‡å¤šæ¬¡ä¸Šé¢çš„ä»£ç æ¥ç¡®è®¤ã€‚æ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼šé‡å­æ¯”ç‰¹0å’Œ1æ”¹å˜äº†å…¶çŠ¶æ€ï¼Œä½†æ˜¯é‡å­æ¯”ç‰¹2å§‹ç»ˆå¤„äºæ€$\left| \psi \right\rangle$ã€‚

#### 3.3 ä½¿ç”¨QASMæ¨¡æ‹Ÿå™¨

é‡å­éšå½¢ä¼ æ€è¢«è®¾è®¡ä¸ºåœ¨ä¸¤æ–¹ä¹‹é—´å‘é€é‡å­æ¯”ç‰¹ã€‚æˆ‘ä»¬æ²¡æœ‰ç¡¬ä»¶æ¥æ¼”ç¤ºï¼Œä½†æˆ‘ä»¬å¯ä»¥è¯æ˜é‡å­é—¨åœ¨å•ä¸€é‡å­èŠ¯ç‰‡ä¸Šæ‰§è¡Œæ­£ç¡®çš„è½¬æ¢ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨QASMæ¨¡æ‹Ÿå™¨æ¥æ¨¡æ‹Ÿå¦‚ä½•æµ‹è¯•è¯¥åè®®ã€‚

åœ¨ä¸€å°çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸Šæˆ‘ä»¬æ— æ³•å¯¹æ€å‘é‡è¿›è¡Œé‡‡æ ·ï¼Œæ‰€ä»¥å¦‚æœæƒ³æ£€æŸ¥éšå½¢ä¼ æ€å›è·¯æ˜¯å¦æ­£å¸¸ï¼Œéœ€è¦åšä¸€äº›ç¨å¾®ä¸åŒçš„äº‹æƒ…ã€‚æ˜¯å¦è¿˜è®°å¾—æˆ‘ä»¬ä½¿ç”¨åˆå§‹åŒ–ï¼ˆInitializeï¼‰å°†æ€$\left| 0 \right\rangle$çš„é‡å­æ¯”ç‰¹è½¬æ¢ä¸º$\left| \psi \right\rangle$ã€‚

$$\left| 0 \right\rangle\overset{\text{Initiali}se}{\rightarrow}\left| \psi \right\rangle$$

ç”±äºæ‰€æœ‰é‡å­æ¯”ç‰¹éƒ½æ˜¯å¯åè½¬çš„ï¼ˆreversibleï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°åˆå§‹åŒ–çš„é€†ï¼š

inverse_init_gate = init_gate.gates_to_uncompute()

è¯¥æ“ä½œæœ‰æ€§è´¨ä¸ºï¼š

$$\left| \psi \right\rangle\overset{\text{Inverse\ Initiali}se}{\rightarrow}\left| 0 \right\rangle$$

ä¸ºäº†éªŒè¯é‡å­æ¯”ç‰¹$\left| q_{0} \right\rangle$è¢«ä¼ æ€è‡³$\left| q_{2} \right\rangle$ï¼Œå¦‚æœåœ¨$\left| q_{2} \right\rangle$ä¸Šæ‰§è¡Œé€†åˆå§‹åŒ–æ“ä½œï¼Œæˆ‘ä»¬æœŸæœ›ç¡®å®šæ— ç–‘åœ°æµ‹é‡ä¸º$\left| 0 \right\rangle$ã€‚å®ç°è¿™ä¸€è¿‡ç¨‹çš„å›è·¯å¦‚ä¸‹ä»£ç ï¼š

> \#\# SETUP
>
> qr = QuantumRegister(3) \# Protocol uses 3 qubits
>
> crz = ClassicalRegister(1) \# and 2 classical registers
>
> crx = ClassicalRegister(1)
>
> qc = QuantumCircuit(qr, crz, crx)
>
> \#\# STEP 0
>
> \# First, let\'s initialise Alice\'s q0
>
> qc.append(init_gate, \[0\])
>
> qc.barrier()
>
> \#\# STEP 1
>
> \# Now begins the teleportation protocol
>
> create_bell_pair(qc, 1, 2)
>
> qc.barrier()
>
> \#\# STEP 2
>
> \# Send q1 to Alice and q2 to Bob
>
> alice_gates(qc, 0, 1)
>
> \#\# STEP 3
>
> \# Alice then sends her classical bits to Bob
>
> measure_and_send(qc, 0, 1)
>
> \#\# STEP 4
>
> \# Bob decodes qubits
>
> bob_gates(qc, 2, crz, crx)
>
> \#\# STEP 5
>
> \# reverse the initialisation process
>
> qc.append(inverse_init_gate, \[2\])
>
> \# Display the circuit
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image147.png)

æœ€åï¼Œæˆ‘ä»¬æµ‹é‡ç¬¬ä¸‰ä¸ªé‡å­æ¯”ç‰¹ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨ç¬¬ä¸‰ä¸ªç»å…¸æ¯”ç‰¹ä¸­ï¼š

> \# Need to add a new ClassicalRegister
>
> \# to see the result
>
> cr_result = ClassicalRegister(1)
>
> qc.add_register(cr_result)
>
> qc.measure(2,2)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image148.png)

æ¥ç€è¿›è¡Œå®éªŒï¼š

> backend = BasicAer.get_backend(\'qasm_simulator\')
>
> counts = execute(qc, backend, shots=1024).result().get_counts()
>
> plot_histogram(counts)
>
> è¾“å‡ºï¼š

![](pics/media/image149.png)

å¯ä»¥çœ‹åˆ°æµ‹é‡$q_{2}$çš„ç»“æœ100%å¤„äºæ€$\left| 0 \right\rangle$ã€‚è¿™æ­£æ˜¯æ‰€æœŸæœ›çš„ç»“æœï¼Œè¡¨æ˜ä¼ æ€åè®®å·¥ä½œæ­£å¸¸ã€‚

### 4. ç†è§£é‡å­éšå½¢ä¼ æ€

åœ¨æ‚¨å®ç°å¯è¿è¡Œçš„é‡å­éšå½¢ä¼ æ€çš„å®ä¾‹ä¹‹å‰ï¼Œå› å½“ç†è§£è¯¥åè®®èƒŒåçš„æ•°å­¦åŸç†ã€‚

#### æ­¥éª¤1

é‡å­éšå½¢ä¼ æ€å¼€å§‹äºAliceä¼ é€ä¸€ä¸ªéšæœºé‡å­æ¯”ç‰¹ï¼ˆ$|q\rangle = a|0\rangle + b|1\rangle$ï¼‰ç»™Bobã€‚Aliceå¹¶ä¸æ¸…æ¥šè¯¥é‡å­æ¯”ç‰¹å¤„äºå“ªç§çŠ¶æ€ã€‚å› æ­¤ï¼ŒAliceå’ŒBobå‘ç¬¬ä¸‰æ–¹Evaæ±‚åŠ©ã€‚Evaä¸ºAliceå’ŒBobå‡†å¤‡ä¸€å¯¹å¤„äºçº ç¼ æ€çš„é‡å­æ¯”ç‰¹å¯¹ï¼Œè¿™ä¸€çº ç¼ é‡å­æ¯”ç‰¹å¯¹å¯ä»¥å†™ä¸ºå¦‚ä¸‹ç‹„æ‹‰å…‹ç¬¦å·ï¼š

$$|\psi \rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)$$

Aliceå’ŒBobåˆ†åˆ«å¤„ç†è¯¥çº ç¼ é‡å­æ¯”ç‰¹å¯¹ä¸­ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼ˆåˆ†åˆ«æ ‡è®°ä¸ºAå’ŒBï¼‰ï¼š

$$|\psi\rangle = \frac{1}{\sqrt{2}} (|0\rangle_A |0\rangle_B + |1\rangle_A |1\rangle_B)$$

ç»è¿‡å¤„ç†åä¼šç”Ÿæˆä¸€ä¸ªä¸‰é‡å­æ¯”ç‰¹ç³»ç»Ÿï¼Œå…¶ä¸­Aliceæ‹¥æœ‰å‰ä¸¤ä¸ªï¼Œè€ŒBobæ‹¥æœ‰æœ€åä¸€ä¸ªã€‚

$$
|q\rangle \otimes |\psi\rangle = \frac{1}{\sqrt{2}} (a |0\rangle \otimes (|00\rangle + |11\rangle) + b |1\rangle \otimes (|00\rangle + |11\rangle))\\
= \frac{1}{\sqrt{2}} (a|000\rangle + a|011\rangle + b|100\rangle + b|111\rangle)$$

#### æ­¥éª¤2

ç°åœ¨ä¾æ®åè®®ï¼ŒAliceåœ¨å…¶æ‰€æœ‰ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨CNOTé‡å­é—¨ï¼Œç„¶åå¯¹ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹åº”ç”¨ä¸€ä¸ªé˜¿è¾¾ç›é—¨ï¼ˆH-gateï¼‰ã€‚è¿™ä¸€è¿‡ç¨‹ä¼šç”Ÿæˆå¦‚ä¸‹çŠ¶æ€ï¼š

$$
(H \otimes I \otimes I) (CNOT \otimes I) (|q\rangle \otimes |\psi\rangle)\\
=(H \otimes I \otimes I) (CNOT \otimes I) \frac{1}{\sqrt{2}} (a|000\rangle + a|011\rangle + b|100\rangle + b|111\rangle) \\
= (H \otimes I \otimes I) \frac{1}{\sqrt{2}} (a|000\rangle + a|011\rangle + b|110\rangle + b|101\rangle) \\
= \frac{1}{2}  (a(|000\rangle + |011\rangle + |100\rangle + |111\rangle) + b(|010\rangle + |001\rangle - |110\rangle - |101\rangle))
$$

ç„¶åå¯ä»¥å°†å…¶åˆ†å¼€å†™æˆï¼š

$$
= \frac{1}{2}(\phantom{+} |00\rangle (a|0\rangle + b|1\rangle) \hphantom{\quad )} \\
  + |01\rangle (a|1\rangle + b|0\rangle) \hphantom{\quad )}\\[4pt]
  + |10\rangle (a|0\rangle - b|1\rangle) \hphantom{\quad )}\\[4pt]
  + |11\rangle (a|1\rangle - b|0\rangle) \quad )
$$

#### æ­¥éª¤3

Aliceå¯¹æ‰€æœ‰çš„å‰ä¸¤ä¸ªé‡å­æ¯”ç‰¹è¿›è¡Œæµ‹é‡åå°†æµ‹é‡ç»“æœä½œä¸ºä¸¤ä¸ªç»å…¸æ¯”ç‰¹å‘é€ç»™Bobã€‚Aliceæµ‹é‡æ‰€è·å¾—çš„ç»“æœå§‹ç»ˆä»¥ç­‰æ¦‚ç‡çš„æƒ…å†µè½äºæ ‡å‡†åŸºæ€$|00\rangleï¼Œ|01\rangleï¼Œ|10\rangleï¼Œ|11\rangle$ä¹‹ä¸€ã€‚

ä¾æ®Aliceçš„æµ‹é‡ç»“æœï¼ŒBobå°†å…¶æ˜ å°„è‡³ï¼š

$$|00\rangle \rightarrow (a|0\rangle + b|1\rangle)\\
|01\rangle \rightarrow (a|1\rangle + b|0\rangle)\\
|10\rangle \rightarrow (a|0\rangle - b|1\rangle)\\
|11\rangle \rightarrow (a|1\rangle - b|0\rangle)$$

#### æ­¥éª¤4

Bobåœ¨æ”¶åˆ°æ¥è‡ªAliceçš„ç»å…¸æ¯”ç‰¹åå°±çŸ¥é“å¯ä»¥é€šè¿‡åœ¨çº ç¼ é‡å­æ¯”ç‰¹å¯¹ä¸­å±äºä»–çš„é‡å­æ¯”ç‰¹ä¸Šåº”ç”¨ç›¸åº”çš„å˜æ¢æ¥è·å–åŸå§‹æ€$|q\rangle$ã€‚

Bobæ‰€éœ€è¦çš„å˜æ¢æ­¥éª¤å¦‚ä¸‹ï¼š

![](pics/media/teleportation-transformation.png)

ç»è¿‡ä¸Šè¿°æ­¥éª¤ä¹‹åBobå°±æˆåŠŸçš„é‡æ„Aliceæ‰€æ‹¥æœ‰é‡å­æ¯”ç‰¹çš„çŠ¶æ€äº†ã€‚

### 5. åœ¨çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸Šéšå½¢ä¼ æ€

#### 5.1 IBMç¡¬ä»¶ä¸é€’å»¶æµ‹é‡

IBMé‡å­è®¡ç®—æœºç›®å‰ä¸æ”¯æŒåæµ‹é‡çš„æŒ‡ä»¤ï¼Œè¡¨æ˜æˆ‘ä»¬ä¸èƒ½åœ¨çœŸå®çš„ç¡¬ä»¶ä¸Šè¿è¡Œå½“å‰å½¢å¼çš„é‡å­éšå½¢ä¼ æ€ã€‚å¹¸è¿çš„æ˜¯ï¼Œç”±äºé€’å»¶æµ‹é‡åŸç†\[1\]ï¼Œè¿™ä¸€ç‚¹å¹¶æ²¡æœ‰é™åˆ¶æˆ‘ä»¬æ‰§è¡Œä»»ä½•è®¡ç®—çš„èƒ½åŠ›ã€‚è¯¥åŸç†è¡¨æ˜ï¼Œä»»ä½•æµ‹é‡éƒ½å¯ä»¥æ¨è¿Ÿåˆ°å›è·¯çš„æœ«ç«¯ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä¹ˆå¯ä»¥å°†æ‰€æœ‰çš„æµ‹é‡ç§»åˆ°æœ«ç«¯ï¼Œå°±ä¼šçœ‹åˆ°ç›¸åŒçš„ç»“æœã€‚

![](pics/media/image150.png)

æ—©æœŸæµ‹é‡çš„ä»»ä½•ç›Šå¤„éƒ½ä¸ç¡¬ä»¶ç›¸å…³è”ï¼šå¦‚æœèƒ½å¤Ÿæå‰æµ‹é‡ï¼Œæˆ‘ä»¬å°±èƒ½å¤Ÿé‡ç”¨é‡å­æ¯”ç‰¹ï¼Œæˆ–è€…å‡å°‘é‡å­æ¯”ç‰¹å¤„äºè„†å¼±å åŠ æ€çš„æ—¶é—´ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé‡å­éšå½¢ä¼ æ€çš„æ—©æœŸæµ‹é‡å…è®¸æˆ‘ä»¬åœ¨æ²¡æœ‰ç›´æ¥é‡å­é€šä¿¡ä¿¡é“çš„æƒ…å†µä¸‹ä¼ è¾“ä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚

è™½ç„¶ç§»åŠ¨é‡å­é—¨å¯ä»¥è®©æˆ‘ä»¬åœ¨çœŸå®çš„ç¡¬ä»¶ä¸Šæ¼”ç¤º"éšå½¢ä¼ æ€"å›è·¯ï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œéšå½¢ä¼ æ€è¿‡ç¨‹ï¼ˆé€šè¿‡ç»å…¸é€šé“ä¼ è¾“é‡å­æ€ï¼‰çš„ç›Šå¤„å·²ç»ä¸§å¤±äº†ã€‚

ä¸‹è½½æ”¹å†™bob_gateså‡½æ•°ä¸ºnew_bob_gatesï¼š

> def new_bob_gates(qc, a, b, c):
>
> qc.cz(a, c)
>
> qc.cx(b, c)
>
> qc = QuantumCircuit(3,1)
>
> \# First, let\'s initialise Alice\'s q0
>
> qc.append(init_gate, \[0\])
>
> qc.barrier()
>
> \# Now begins the teleportation protocol
>
> create_bell_pair(qc, 1, 2)
>
> qc.barrier()
>
> \# Send q1 to Alice and q2 to Bob
>
> alice_gates(qc, 0, 1)
>
> qc.barrier()
>
> \# Alice sends classical bits to Bob
>
> new_bob_gates(qc, 0, 1, 2)
>
> \# We undo the initialisation process
>
> qc.append(inverse_init_gate, \[2\])
>
> \# See the results, we only care about the state of qubit 2
>
> qc.measure(2,0)
>
> \# View the results:
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image151.png)

ç„¶ååˆ›å»ºä¸€ä¸ªæ–°çš„é‡å­å›è·¯ï¼š

> \# First, see what devices we are allowed to use by loading our saved
> accountsï¼Œæ­¤æ­¥éª¤éœ€è¦æ³¨å†ŒIBMçš„è´¦å·
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> provider.backends()
>
> è¾“å‡ºï¼š
>
> ç•¥...

#### 5.2 æ‰§è¡Œ

> \# get the least-busy backend at IBM and run the quantum circuit there
>
> from qiskit.providers.ibmq import least_busy
>
> backend = least_busy(provider.backends(filters=lambda b:
> b.configuration().n_qubits \>= 3 and
>
> not b.configuration().simulator and b.status().operational==True))
>
> job_exp = execute(qc, backend=backend, shots=8192)
>
> \# Get the results and display them
>
> exp_result = job_exp.result()
>
> exp_measurement_result = exp_result.get_counts(qc)
>
> print(exp_measurement_result)
>
> plot_histogram(exp_measurement_result)
>
> è¾“å‡ºï¼š

![](pics/media/image152.png)

æ­£å¦‚æ‰€çœ‹åˆ°çš„ï¼Œæœ‰ä¸€äº›æˆ‘ä»¬æµ‹é‡å‡ºä¸ºæ€$\left| 1 \right\rangle$çš„ç»“æœã€‚è¿™äº›ç»“æœçš„å‡ºç°æ˜¯ç”±äºé‡å­é—¨å’Œé‡å­æ¯”ç‰¹ä¸­çš„è¯¯å·®ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œæœ¬ç« ä¸­åœ¨å…ˆå‰çš„æ¨¡æ‹Ÿå™¨è¿è¡Œè¯¥é‡å­é—¨æ²¡æœ‰å‘ç”Ÿé”™è¯¯ï¼Œå¹¶ä¸”å…è®¸æ— å·®é”™çš„ä¼ æ€ã€‚

> error_rate_percent = sum(\[exp_measurement_result\[result\] for result
> in exp_measurement_result.keys() if result\[0\]==\'1\'\]) \\
>
> \* 100./ sum(list(exp_measurement_result.values()))
>
> print(\"The experimental error rate : \", error_rate_percent, \"%\")
>
> è¾“å‡ºï¼š
>
> The experimental error rate : 7.6171875 %

### 6. å‚è€ƒæ–‡çŒ®

\[1\] M. Nielsen and I. Chuang, Quantum Computation and Quantum
Information, Cambridge Series on Information and the Natural Sciences
(Cambridge University Press, Cambridge, 2000).

3.3 è¶…å¯†ç¼–ç ï¼ˆSuperdense Codingï¼‰
---------------------------------

æœ¬èŠ‚è¯æ˜äº†è¶…å¯†ç¼–ç ï¼ˆSuperdense
Codingï¼ŒSDCï¼‰åè®®ã€‚æˆ‘ä»¬é¦–å…ˆä½¿ç”¨Qiskitçš„æ¨¡æ‹Ÿå™¨æ¥æµ‹è¯•é‡å­å›è·¯ï¼Œç„¶ååœ¨ä¸€å°çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸Šè¿›è¡Œæµ‹è¯•ã€‚

### å†…å®¹

1\. è¶…å¯†ç¼–ç å’Œé‡å­éšå½¢ä¼ æ€

2\. è¿‡ç¨‹

2.1 æ­¥éª¤1

2.2 æ­¥éª¤2

2.3 æ­¥éª¤3

3\. æ¨¡æ‹Ÿè¶…å¯†ç¼–ç åè®®

3.1 å¯è§†åŒ–æµ‹é‡

4\. åœ¨çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸Šè¶…å¯†ç¼–ç 

### 1. è¶…å¯†ç¼–ç å’Œé‡å­éšå½¢ä¼ æ€ä¹‹é—´çš„ä¸åŒ

é‡å­éšå½¢ä¼ æ€å’Œè¶…å¯†ç¼–ç æ˜¯å¯†åˆ‡ç›¸å…³çš„ï¼Œä¸ºäº†é¿å…æ··æ·†ï¼Œéœ€è¦æ¾„æ¸…ä¹‹é—´çš„åŒºåˆ«ã€‚

é‡å­éšå½¢ä¼ æ€æ˜¯é€šè¿‡ä¸¤ä¸ªç»å…¸é€šä¿¡å’Œä¸€ä¸ªè´å°”å¯¹å°†ä¸€ä¸ªå¤„äºæ€$\left| \psi \right\rangle$çš„é‡å­æ¯”ç‰¹ä»ä¸€ä¸ªåœ°æ–¹ä¼ é€åˆ°å¦ä¸€ä¸ªåœ°æ–¹çš„è¿‡ç¨‹ã€‚ä¹Ÿå°±è¯´æˆ‘ä¹ˆå¯ä»¥å°†è¿™ä¸€è¿‡ç¨‹è®¤å¯ä¸ºä¸€ä¸ªåè®®ï¼Œå…¶å¯ä»¥åœ¨å…±äº«çº ç¼ æ€å¸®åŠ©ä¸‹ï¼Œåœ¨ä¸€ä¸ªä½ç½®æ‘§æ¯ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„é‡å­æ€ï¼Œç„¶ååœ¨å¦ä¸€ä¸ªé¥è¿œçš„ä½ç½®é‡å»ºã€‚è¶…å¯†ç¼–ç æ˜¯ä¸€ç§ç¨‹åºï¼Œå…è®¸æŸäººä»…ä½¿ç”¨å•ä¸ªé‡å­æ¯”ç‰¹é€šä¿¡å°±å¯ä»¥å‘å¦ä¸€æ–¹å‘é€ä¸¤ä¸ªç»å…¸æ¯”ç‰¹ã€‚

  **Teleportation**   **Superdense Coding**
  ------------------- -----------------------
  Transmit one        Transmit two
  qubit using two     classical bits
  classical bits      using one qubit

è¿œç¨‹ä¼ æ€åè®®å¯ä»¥çœ‹ä½œæ˜¯è¶…å¯†ç¼–ç åè®®çš„ç¿»ç‰ˆï¼Œå°±å…¶æ„ä¹‰è€Œè¨€Aliceå’ŒBobåªæ˜¯"äº¤æ¢äº†å½¼æ­¤çš„è®¾å¤‡"ã€‚

### 2. è¿‡ç¨‹

![](pics/media/image153.png)

#### 2.1 æ­¥éª¤1

è¶…å¯†ç¼–ç çš„è¿‡ç¨‹ä»ä¸€ä¸ªç¬¬ä¸‰æ–¹å¼€å§‹ï¼Œæˆ‘ä»¬å°†å…¶ç§°ä¸ºCharlieã€‚ä¸¤ä¸ªå¤„äºçº ç¼ æ€çš„é‡å­æ¯”ç‰¹ç”±Charlieç»™å‡ºã€‚ä»–å°†è¿™ä¸¤ä¸ªé‡å­æ¯”ç‰¹åˆå§‹åŒ–ä¸ºåŸºæ€$\left| 0 \right\rangle$ã€‚æ¥ç€å°†ä¸€ä¸ªé˜¿è¾¾é©¬é—¨ï¼ˆ$H$ï¼‰åº”ç”¨äºç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹ä½¿å…¶å¤„äºå åŠ æ€ï¼Œç„¶ååº”ç”¨ä¸€ä¸ªå—æ§éé—¨ï¼ˆ$\text{CX}$ï¼‰æ˜¯ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸ºæ§åˆ¶ç«¯ï¼Œå¦ä¸€ä¸ªä¸ºç›®æ ‡ç«¯ã€‚è¿™å°±ç”Ÿæˆäº†æˆ‘ä»¬åœ¨ä¹‹å‰æåˆ°çš„çº ç¼ æ€ï¼ˆBell
pairï¼‰ã€‚

##### ç»“æœçŠ¶æ€

Charlieå…ˆåº”ç”¨äº†ä¸€ä¸ªé˜¿è¾¾é©¬é—¨ã€‚

å½“H-gateåº”ç”¨äºç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹åï¼Œåˆ›å»ºäº†å¦‚ä¸‹çŠ¶æ€çš„å åŠ æ€ï¼š

$$|0 + \rangle = \frac{1}{\sqrt{2}}(|00\rangle + |01\rangle)$$

ç„¶åå†åº”ç”¨ä¸€ä¸ªå—æ§éé—¨ã€‚è¯¥å—æ§éé—¨å°†ä¸¤ä¸ªé‡å­æ¯”ç‰¹å°±é¤åœ¨ä¸€èµ·ï¼Œè‹¥æ§åˆ¶ç«¯çš„æ€ä¸º$\left| 1 \right\rangle$åˆ™ç¿»è½¬ç›®æ ‡ç«¯ã€‚è¯·æ³¨æ„æ§åˆ¶ç«¯çš„é‡å­æ¯”ç‰¹æ—¶ä¸Šå¼ä¸­æœ€å³ä¾§çš„ä¸€ä¸ªã€‚

$$\text{CNOT}\frac{1}{\sqrt{2}}(|00\rangle + |01\rangle) = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$$

#### 2.2 æ­¥éª¤2

Charlieå°†ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹å‘é€ç»™äº†Aliceï¼Œå¹¶å°†ç¬¬äºŒä¸ªå‘ç»™äº†Bobã€‚è¿™ä¸€åè®®çš„ç›®çš„ä¸ºAliceé€šè¿‡å‘ç»™å¥¹çš„é‡å­æ¯”ç‰¹å‘é€ä¸¤ä¸ªç»å…¸æ¯”ç‰¹çš„ä¿¡æ¯ç»™Bobã€‚åœ¨å¥¹åšå‡ºè¿™äº›æ“ä½œå‰ï¼Œ

Aliceéœ€è¦ä¾æ®æ‰€è¦å‘å‡ºçš„2ä¸ªæ¯”ç‰¹ä¿¡æ¯åœ¨å¥¹çš„é‡å­æ¯”ç‰¹ä¸Šåº”ç”¨ä¸€ç»„é‡å­é—¨ã€‚

##### è¶…å¯†ç¼–ç çš„ç¼–ç è§„åˆ™ï¼ˆAlice åè®®ï¼‰

![image2](pics/media/image154.png)

å› æ­¤ï¼Œå¦‚æœå¥¹æƒ³å‘é€ä¸€ä¸ª00ï¼Œåˆ™å¯¹å…¶é‡å­æ¯”ç‰¹ä¸åšä»»ä½•æ“ä½œï¼ˆåº”ç”¨I-gateï¼ˆIï¼‰ï¼‰ã€‚å¦‚æœéœ€è¦å‘é€ä¸€ä¸ª10ï¼Œé‚£ä¹ˆåº”ç”¨Xé—¨ã€‚æ ¹æ®æƒ³è¦å‘é€çš„å†…å®¹åº”ç”¨é€‚å½“çš„é—¨ï¼Œç„¶åå°†å¥¹çš„é‡å­æ¯”ç‰¹å‘é€ç»™Bobè¿›è¡Œæœ€åä¸€æ­¥ã€‚

#### 2.3 æ­¥éª¤3

Bobæ”¶åˆ°Aliceå‘è¿‡æ¥çš„é‡å­æ¯”ç‰¹åä½¿ç”¨ä»–çš„é‡å­æ¯”ç‰¹è§£ç Aliceçš„ä¿¡æ¯ã€‚æ³¨æ„ï¼šBobä¸éœ€è¦çŸ¥é“è§£ç é‡å­æ€ä¿¡æ¯çš„çŸ¥è¯†ï¼Œåªéœ€ç®€å•çš„è¿˜åŸåŠ å¯†æ“ä½œï¼ˆåå‘ï¼‰ã€‚

Bobåº”ç”¨ä¸€ä¸ªå—æ§éé—¨ï¼Œå°†æœ€å³ä¾§çš„é‡å­æ¯”ç‰¹ä½œä¸ºæ§åˆ¶ç«¯ï¼Œæœ€å·¦ä¾§çš„ä¸ºç›®æ ‡ç«¯ã€‚ç„¶ååº”ç”¨é˜¿è¾¾é©¬é—¨ï¼Œå¹¶åœ¨æœ€åå¯¹ä¸¤ä¸ªé‡å­æ¯”ç‰¹æ‰§è¡Œæµ‹é‡æ¥æå–Aliceçš„ä¿¡æ¯ã€‚

![image3](pics/media/image155.png)

å½“Bobæ‰§è¡Œæµ‹é‡æ—¶ï¼Œå°±ç¡®è®¤æ”¶åˆ°äº†æ¥è‡ªAliceçš„ä¿¡æ¯ã€‚æ³¨æ„ï¼è§£ç ä¿¡æ¯æ‰€å¾—çš„æœ€åç»“æœå¸¦æœ‰è´Ÿå·ï¼ˆ$- \left| 11 \right\rangle$ï¼‰ï¼Œå°†å…¶å†™ä¸º$\left| 11 \right\rangle$ä¹Ÿæ­£ç¡®ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªæ— æ³•æµ‹é‡çš„å…¨å±€ç›¸ä½ã€‚

### 3. æ¨¡æ‹Ÿè¶…å¯†ç¼–ç åè®®

> \# Importing everything
>
> from qiskit import \*
>
> from qiskit.visualization import plot_histogram
>
> \# For Jupyter Notebooks, change the settings to get nicer images
>
> %config InlineBackend.figure_format = \'svg\'

åœ¨ä¹‹å‰çš„ä»‹ç»ä¸­æˆ‘ä»¬çœ‹åˆ°éœ€è¦åˆ›å»ºä¸€ä¸ªçº ç¼ çš„é‡å­å¯¹ï¼Œå…ˆåº”ç”¨ä¸€ä¸ªH-hateï¼Œæ¥ç€åº”ç”¨ä¸€ä¸ªCNOTã€‚æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå‡½æ•°æ¥å®Œæˆè¿™ä¸€è¿‡ç¨‹ï¼Œè¯¥å‡½æ•°åˆ†åˆ«æ¥æ”¶å‚æ•°ä¸ºé‡å­å›è·¯ä¸çº ç¼ çš„é‡å­å¯¹ï¼ˆåˆ†åˆ«ä¸ºaå’Œbï¼‰ï¼š

> \# Define a function that takes a QuantumCircuit (qc)
>
> \# and two integers (a & b)
>
> def create_bell_pair(qc, a, b):
>
> qc.h(a) \# Apply a h-gate to the first qubit
>
> qc.cx(a,b) \# Apply a CNOT, using the first qubit as the control

æ¥ç€å°±éœ€è¦å¯¹ä¿¡æ¯è¿›è¡Œç¼–ç ã€‚åœ¨è¿™ä¹‹å‰æˆ‘ä»¬çœ‹åˆ°ç”±å››ç§å¯èƒ½çš„ä¿¡æ¯å¯ä»¥è¢«å‘é€ï¼š00ã€01ã€10å’Œ11ã€‚æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå‡½æ•°æ¥æ¥æ”¶è¿™ä¸ªä¿¡æ¯å¹¶åº”ç”¨ç›¸åº”çš„é‡å­é—¨ï¼š

> \# Define a function that takes a QuantumCircuit (qc)
>
> \# a qubit index (qubit) and a message string (msg)
>
> def encode_message(qc, qubit, msg):
>
> if msg == \"00\":
>
> pass \# To send 00 we do nothing
>
> elif msg == \"10\":
>
> qc.x(qubit) \# To send 10 we apply an X-gate
>
> elif msg == \"01\":
>
> qc.z(qubit) \# To send 01 we apply a Z-gate
>
> elif msg == \"11\":
>
> qc.z(qubit) \# To send 11, we apply a Z-gate
>
> qc.x(qubit) \# followed by an X-gate
>
> else:
>
> print(\"Invalid Message: Sending \'00\'\")

æœ€åï¼Œéœ€è¦å¯¹ä¿¡æ¯è¿›è¡Œè§£ç ï¼Œå¦‚åŒåœ¨ä¹‹å‰æ‰€è§ï¼Œå…ˆåº”ç”¨ä¸€ä¸ªCNOTï¼Œç„¶åæ˜¯H-gateã€‚æˆ‘ä»¬ä¹Ÿåˆ›å»ºä¸€ä¸ªå‡½æ•°æ¥å¤„ç†ï¼š

> def decode_message(qc, a, b):
>
> qc.cx(a,b)
>
> qc.h(a)

æœ€ç»ˆï¼Œæˆ‘ä»¬å°†æ‰€æœ‰ä¸€åˆ‡ç»„åˆèµ·æ¥å°±å®Œæˆäº†åè®®ã€‚

> \# Create the quantum circuit with 2 qubits
>
> qc = QuantumCircuit(2)
>
> \# First, Charlie creates the entangled pair between Alice and Bob
>
> create_bell_pair(qc, 0, 1)
>
> qc.barrier() \# This adds a barrier to our circuit. A barrier
>
> \# separates the gates in our diagram and makes it
>
> \# clear which part of the circuit is which
>
> \# At this point, qubit 0 goes to Alice and qubit 1 goes to Bob
>
> \# Next, Alice encodes her message onto qubit 0. In this case,
>
> \# we want to send the message \'10\'. You can try changing this
>
> \# value and see how it affects the circuit
>
> message = \"10\"
>
> encode_message(qc, 0, message)
>
> qc.barrier()
>
> \# Alice then sends her qubit to Bob.
>
> \# After recieving qubit 0, Bob applies the recovery protocol:
>
> decode_message(qc, 0, 1)
>
> \# Finally, Bob measures his qubits to read Alice\'s message
>
> qc.measure_all()
>
> \# Draw our output
>
> qc.draw(output = \"mpl\")
>
> è¾“å‡ºï¼š

![](pics/media/image156.png)

#### 3.1 å¯è§†åŒ–æµ‹é‡

> backend = Aer.get_backend(\'qasm_simulator\')
>
> job_sim = execute(qc, backend, shots=1024)
>
> sim_result = job_sim.result()
>
> measurement_result = sim_result.get_counts(qc)
>
> print(measurement_result)
>
> plot_histogram(measurement_result)
>
> è¾“å‡ºï¼š
>
> {\'10\': 1024}

![](pics/media/image157.png)

æ¨¡æ‹Ÿå™¨æ¨¡æ‹Ÿå‡ºäº†ä¸€å°*å®Œç¾*çš„é‡å­è®¡ç®—æœºã€‚å¯ä»¥çœ‹åˆ°æ²¡æœ‰ä»»ä½•é”™è¯¯å‘ç”Ÿï¼Œæµ‹é‡å‡º100%å‡†ç¡®çš„ä¿¡æ¯ã€‚

### 4. åœ¨çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸Šè¶…å¯†ç¼–ç 

è‡³æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸€å°çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸ŠæŸ¥çœ‹ä¸Šè¿°å·¥ä½œçš„è¿‡ç¨‹ã€‚æœå…ˆï¼Œæˆ‘ä»¬æƒ³è¦åŠ è½½çš„å¸æˆ·è·å–è´Ÿè½½æœ€å°çš„é‡å­ç³»ç»Ÿï¼š

> from qiskit import IBMQ
>
> \#IBMQ.save_account(\'MY_API_TOKEN\')
>
> from qiskit.providers.ibmq import least_busy
>
> shots = 256
>
> \# Load local account information
>
> IBMQ.load_account()
>
> \# Get the least busy backend
>
> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> backend = least_busy(provider.backends(filters=lambda x:
> x.configuration().n_qubits \>= 2
>
> and not x.configuration().simulator
>
> and x.status().operational==True))
>
> print(\"least busy backend: \", backend)
>
> \# Run our circuit
>
> job = execute(qc, backend=backend, shots=shots)
>
> è¾“å‡ºï¼š
>
> least busy backend: ibmq_burlington
>
> \# Monitoring our job
>
> from qiskit.tools.monitor import job_monitor
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> \# Plotting our result
>
> result = job.result()
>
> plot_histogram(result.get_counts(qc))
>
> è¾“å‡ºï¼š

![](pics/media/image158.png)

æ­£å¦‚ä¸Šé¢çš„è¾“å‡ºæ‰€ç¤ºï¼Œå½“åœ¨çœŸæ­£çš„é‡å­è®¡ç®—æœºä¸Šè¿è¡Œæ—¶æœ‰ä¸€äº›è‡ªå…¶ä»–ä¸‰ä¸ªçŠ¶æ€çš„ç»“æœã€‚å¯¼è‡´è¿™äº›é”™è¯¯çš„åŸå› æ˜¯é‡å­é—¨å’Œé‡å­æ¯”ç‰¹å‘ç”Ÿäº†é€€ç›¸å¹²ï¼ˆ**decoherence**ï¼‰ã€‚æˆ‘ä»¬å°†åœ¨æœ€åçš„ç« èŠ‚ä¸­äº†è§£è¿™äº›é”™è¯¯çš„æ›´å¤šä¿¡æ¯ã€‚

> correct_results = result.get_counts(qc)\[message\]
>
> accuracy = (correct_results/shots)\*100
>
> print(\"Accuracy = %.2f%%\" % accuracy)
>
> è¾“å‡ºï¼š
>
> Accuracy = 62.50% \#æ¯æ¬¡è¿è¡Œéƒ½ä¸åŒ

3.4 Deutsch-Joszaç®—æ³•
---------------------

åœ¨è¿™æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆä»‹ç»Deutsch-Joszaé—®é¢˜ï¼Œä»¥åŠè§£å†³çš„ç»å…¸å’Œé‡å­ç®—æ³•ã€‚ç„¶åä½¿ç”¨Qiskitå®ç°è¯¥é‡å­ç®—æ³•ï¼Œå¹¶åœ¨æ¨¡æ‹Ÿå™¨å’Œè®¾å¤‡ä¸Šè¿è¡Œã€‚

### 1. å¼•è¨€

Deutsch-Joszaç®—æ³•åœ¨åœ¨å‚è€ƒæ–‡çŒ®\[1\]ä¸­ç¬¬ä¸€æ¬¡è¢«å¼•å…¥ï¼Œæ˜¯ç¬¬ä¸€ä¸ªæ¯”æœ€å¥½çš„ç»å…¸ç®—æ³•è¿è¡Œæ›´åŠ çš„é‡å­ç®—æ³•ã€‚å…¶å±•ç¤ºäº†å¯ä»¥åˆ©ç”¨é‡å­è®¡ç®—æœºå½“ä½œå¤„ç†ç‰¹å®šé—®é¢˜çš„è®¡ç®—å·¥å…·ã€‚

#### 1.1 Deutsch-Joszaé—®é¢˜

æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªéšè—çš„å¸ƒå°”å‡½æ•°$f$ï¼Œè¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ªç»å…¸æ¯”ç‰¹å­—ä¸²ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¿”å›$0$æˆ–$1$ã€‚

$$f\left( x_{0},x_{1},x_{2},\ldots \right) \rightarrow 0or1,wherex_{n}is0or1$$

æ‰€ç»™å¸ƒå°”å‡½æ•°çš„æ€§è´¨æ˜¯ä¿è¯å‡è¡¡æˆ–å¸¸å€¼ã€‚ä¸€ä¸ªå¸¸å€¼å‡½æ•°å¯¹ä»»ä½•è¾“å…¥éƒ½è¿”å›å…¨$0$æˆ–å…¨$1$ï¼Œä¸€ä¸ªå‡è¡¡å‡½æ•°å¯¹è¾“å…¥ä¸­çš„ä¸€åŠè¿”å›$0$å¹¶å¯¹è¾“å…¥çš„å¦ä¸€åŠè¿”å›$1$ã€‚æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯ç¡®å®šç»™å®šå‡½æ•°æ˜¯å‡è¡¡è¿˜æ˜¯å¸¸å€¼ã€‚

æ³¨æ„ï¼Deutsch-Joszaé—®é¢˜æ˜¯å•æ¯”ç‰¹Deutsché—®é¢˜çš„$n$æ¯”ç‰¹çš„æ‰©å±•ã€‚

#### 1.2 ç»å…¸è§£æ³•

é€šå¸¸ï¼Œåœ¨æœ€å¥½çš„æƒ…å†µä¸‹ä¸¤ä¸ªæŸ¥è¯¢çš„é¢„è¨€ï¼ˆoracleï¼‰å°±å¯ä»¥ç¡®å®šéšè—çš„å¸ƒå°”å‡½æ•°$f\left( x \right)$æ˜¯å¦æ˜¯å‡è¡¡å‡½æ•°ï¼šå¦‚æˆ‘ä»¬å¾—åˆ°$f\left( 0,0,0,\ldots \right) \rightarrow 0$å’Œ$f\left( 1,0,0,\ldots \right) \rightarrow 1$ï¼Œç”±äºè·å¾—äº†ä¸¤ä¸ªä¸åŒçš„è¾“å‡ºï¼Œå°±çŸ¥é“è¯¥å‡½æ•°æ˜¯å‡è¡¡å‡½æ•°ã€‚

åœ¨æœ€ç³Ÿç³•çš„æƒ…å†µä¸‹ï¼Œå¦‚æœå‡½æ•°å¯¹äºæ‰€å°è¯•çš„è¾“å…¥æŒç»­ç»™å‡ºåŒä¸€è¾“å‡ºï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥æ‰€æœ‰å¯èƒ½è¾“å…¥çš„ä¸€åŠåŠ ä¸Š1æ¥ç¡®å®š$f\left( x \right)$æ˜¯å¸¸å€¼å‡½æ•°ã€‚ç”±äºæ‰€æœ‰å¯èƒ½è¾“å…¥çš„æ•°é‡ä¸º$2^{n}$ï¼Œæ„å‘³åœ¨æœ€ç³Ÿç³•çš„æƒ…å†µä¸‹éœ€è¦$2^{n + 1} + 1$æ¬¡å°è¯•è¾“å…¥æ¥ç¡®å®š$f\left( x \right)$æ˜¯å¸¸å€¼å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¯¹äº4æ¯”ç‰¹çš„å­—ä¸²ï¼Œå¦‚æœæˆ‘ä»¬æ£€æŸ¥äº†16ç§å¯èƒ½ç»„åˆä¸­çš„8ç§ï¼Œæ‰€æœ‰çš„ç»“æœéƒ½æ˜¯$0$ï¼Œä»ç„¶æœ‰å¯èƒ½åœ¨ç¬¬9æ¬¡è¾“å…¥åè¿”å›1ï¼Œåˆ™$f\left( x \right)$æ˜¯å‡è¡¡å‡½æ•°ã€‚ä»æ¦‚ç‡ä¸Šè®²ï¼Œè¿™æ˜¯ä¸€ä¸ªæå…¶ä¸å¯èƒ½å‘ç”Ÿçš„äº‹ä»¶ã€‚äº‹å®ä¸Šï¼Œå¦‚æœè¿ç»­åœ°å¾—åˆ°ç›¸åŒçš„ç»“æœï¼Œå½“ä¸€ä¸ªå‡½æ•°çš„$k$æ¬¡è¾“å…¥åç¡®å®šå…¶ä¸ºå¸¸å€¼å‡½æ•°çš„æ¦‚ç‡å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$P_{\text{constant}}\left( k \right) = 1 - \frac{1}{2^{k - 1}}\ for\ k \leq 2^{n - 1}$$

å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©æå‰æˆªæ–­ç»å…¸ç®—æ³•ï¼Œå‡è®¾æˆ‘ä»¬æœ‰è¶…è¿‡x%çš„ç¡®ä¿¡ã€‚ä½†å¦‚æœæˆ‘ä»¬æƒ³è¦100%çš„ç¡®ä¿¡ï¼Œæ®éœ€è¦æ£€æŸ¥$2^{n + 1}$æ¬¡è¾“å…¥ã€‚

#### 1.3 é‡å­è§£æ³•

ä½¿ç”¨é‡å­è®¡ç®—æœºï¼Œåªéœ€è°ƒç”¨å‡½æ•°$f\left( x \right)$ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°±å¯ä»¥100%ç¡®ä¿¡åœ°è§£å†³è¿™ä¸€é—®é¢˜ï¼Œå‡è®¾å‡½æ•°$f$è¢«å®ç°ä¸ºé‡å­é¢„è¨€ï¼Œå°†æ€$\left| x \right\rangle\left| y \right\rangle$æ˜ å°„ä¸º$\left| x \right\rangle\left| y \oplus f\left( x \right) \right\rangle$ï¼Œå…¶ä¸­ç¬¦å·$\oplus$è¡¨ç¤ºä»¥2ä¸ºæ¨¡ã€‚ä¸‹å›¾ä¸ºDeutsch-Joszaç®—æ³•çš„é€šç”¨å›è·¯ã€‚

![image1](pics/media/image159.png)

ç°åœ¨ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ç®—æ³•çš„æ­¥éª¤ï¼š

1.  å‡†å¤‡ä¸¤ä¸ªé‡å­å¯„å­˜å™¨ã€‚ç¬¬ä¸€ä¸ªæ˜¯ä¸€ä¸ªn-é‡å­æ¯”ç‰¹å¯„å­˜å™¨åˆå§‹åŒ–ä¸º$\left| 0 \right\rangle$ï¼Œç¬¬äºŒä¸ªæ˜¯ä¸€ä¸ªå•é‡æ¯”ç‰¹å¯„å­˜å™¨åˆå§‹åŒ–$\left| 1 \right\rangle$ï¼š

$$\left| \psi_{0} \right\rangle = \left| 0 \right\rangle^{\otimes n}\left| 1 \right\rangle$$

2.  åœ¨æ¯ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨ä¸€ä¸ªé˜¿è¾¾é©¬é—¨ï¼š

$$\left| \psi_{1} \right\rangle = \frac{1}{\sqrt{2^{n + 1}}}\sum_{x = 0}^{2^{n} - 1}\left| x \right\rangle(|0\rangle - |1\rangle)$$

3.  åº”ç”¨é‡å­è¯­è¨€ï¼Œä½¿$\left| x \right\rangle\left| y \right\rangle$å˜ä¸º$\left| x \right\rangle\left| y \oplus f\left( x \right) \right\rangle$ï¼Œ

$${\left| \psi_{2} \right\rangle = \frac{1}{\sqrt{2^{n + 1}}}\sum_{x = 0}^{2^{n} - 1}\left| x \right\rangle(|f(x)\rangle - |1 \oplus f(x)\rangle)
}{\ \ \ \ \ \ \ \ \ \  = \frac{1}{\sqrt{2^{n + 1}}}\sum_{x = 0}^{2^{n} - 1}{\left( - 1 \right)^{f\left( x \right)}\left| x \right\rangle}(|0\rangle - |1\rangle)}$$

å¯¹äºæ¯ä¸ª$x$ï¼Œ$f\left( x \right)$ä¸æ˜¯$0$å°±æ˜¯$1$ã€‚

4.  æ­¤æ—¶ï¼Œç¬¬äºŒä¸ªå•é‡å­æ¯”ç‰¹å¯„å­˜å™¨å¯èƒ½è¢«å¿½ç•¥ã€‚å¯¹ç¬¬ä¸€ä¸ªå¯„å­˜å™¨çš„æ¯ä¸ªé‡å­æ¯”ç‰¹åº”ç”¨é˜¿è¾¾é©¬é—¨ï¼š
$$ {\left| \psi_{3} \right\rangle = \frac{1}{2^{n}}\sum_{x = 0}^{2^{n} - 1}{\left( - 1 \right)^{f\left( x \right)}\left\lbrack \sum_{x = 0}^{2^{n} - 1}{\left( - 1 \right)^{x \bullet y}\left| y \right\rangle} \right\rbrack}
}{\ \ \ \ \ \ \ \ \ \  = \frac{1}{2^{n}}\sum_{x = 0}^{2^{n} - 1}\left\lbrack \sum_{x = 0}^{2^{n} - 1}{\left( - 1 \right)^{f\left( x \right)}\left( - 1 \right)}^{x \bullet y} \right\rbrack\left| y \right\rangle
}$$

5.  æµ‹é‡ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ã€‚å¯ä»¥çœ‹å‡ºæµ‹é‡çš„æ¦‚ç‡ä¸º$\left| 0 \right\rangle^{\otimes n} = \left| \frac{1}{2^{n}}\sum_{x = 0}^{2^{n} - 1}\left( - 1 \right)^{f\left( x \right)} \right|^{2}$ï¼Œå½“$f\left( x \right)$ä¸ºæ˜¯å¸¸å€¼å‡½æ•°æ—¶ä¸º$1$ï¼Œ$f\left( x \right)$ä¸ºæ˜¯å‡è¡¡å‡½æ•°æ—¶ä¸º$0$ã€‚

#### 1.4 ä¸ºä½•è¦è¿›è¡Œè¿™ä¸€å·¥ä½œï¼Ÿ

##### å¸¸å€¼é¢„è¨€

å½“é¢„è¨€ä¸ºå¸¸å€¼ï¼ˆ*constant*ï¼‰æ—¶ï¼Œä¸ä¼šåœ¨è¾“å…¥é‡å­æ¯”ç‰¹ä¸Šé€ æˆå½±å“ï¼ˆä¸€ç›´åˆ°ä¸€ä¸ªå…¨å±€ç›¸ä½ï¼‰ï¼Œä¸”æ— è®ºåœ¨æŸ¥è¯¢é¢„è¨€çš„å‰åé‡å­æ€éƒ½ç›¸åŒã€‚ç”±äºH-gateæ˜¯å…¶è‡ªèº«çš„é€†ï¼Œåœ¨æ­¥éª¤4ä¸­æˆ‘ä»¬é€šè¿‡åè½¬æ­¥éª¤2æ¥è·å–ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸­$\left| 00\ldots 0 \right\rangle$çš„åˆå§‹é‡å­æ€ã€‚

$$H^{\otimes n}\begin{bmatrix}
1 \\
0 \\
0 \\
 \vdots \\
0 \\
\end{bmatrix} = \frac{1}{\sqrt{2^{n}}}\begin{bmatrix}
1 \\
1 \\
1 \\
 \vdots \\
1 \\
\end{bmatrix}\overset{\text{after\ \ \ }U_{f}}{\rightarrow}H^{\otimes n}\frac{1}{\sqrt{2^{n}}}\begin{bmatrix}
1 \\
1 \\
1 \\
 \vdots \\
1 \\
\end{bmatrix} = \begin{bmatrix}
1 \\
0 \\
0 \\
 \vdots \\
0 \\
\end{bmatrix}$$

##### å‡è¡¡é¢„è¨€

åœ¨æ­¥éª¤2ä¹‹åï¼Œæˆ‘ä»¬çš„è¾“å…¥å¯„å­˜å™¨æ˜¯è®¡ç®—åŸºä¸Šæ‰€æœ‰çŠ¶æ€çš„ç›¸ç­‰å åŠ ã€‚å½“é¢„è¨€ä¸ºå‡è¡¡ï¼ˆ*balanced*ï¼‰æ—¶ï¼Œç›¸ä½åå†²ä¼šåœ¨è¿™äº›çŠ¶æ€ä¸­åŠä¸Šæ·»åŠ ä¸€ä¸ªè´Ÿç›¸ä½ã€‚

$$U_{f}\frac{1}{\sqrt{2^{n}}}\begin{bmatrix}
1 \\
1 \\
1 \\
 \vdots \\
1 \\
\end{bmatrix} = \frac{1}{\sqrt{2^{n}}}\begin{bmatrix}
 - 1 \\
1 \\
 - 1 \\
 \vdots \\
1 \\
\end{bmatrix}$$

æŸ¥è¯¢é¢„è¨€ä¹‹åçš„é‡å­æ€ä¸æŸ¥è¯¢é¢„è¨€ä¹‹å‰çš„é‡å­æ€æ­£äº¤ã€‚å› æ­¤åœ¨æ­¥éª¤4ä¸­ï¼Œå½“åº”ç”¨H-gateåï¼Œå¿…ä»¥æ­£äº¤äº$\left| 00\cdots 0 \right\rangle$çš„é‡å­æ€ç»“æŸã€‚è¿™è¡¨æ˜æˆ‘ä»¬ç»ä¸ä¼šæµ‹é‡åˆ°å…¨é›¶çš„çŠ¶æ€ã€‚

### 2. æœ‰æ•ˆç¤ºä¾‹

ç°åœ¨è®©æˆ‘ä»¬äº†è§£ä¸€ä¸ªåŒæ¯”ç‰¹å‡è¡¡å‡½æ•°çš„ç‰¹å®šç¤ºä¾‹ï¼Œå…¶ä¸­å°†ä¼šåœ¨ä¸¤ä¸ªæ¯”ç‰¹ä¸Šå‡åº”ç”¨X-gateã€‚

1.  åœ¨ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸­çš„ä¸¤ä¸ªé‡å­æ¯”ç‰¹å‡åˆå§‹åŒ–ä¸º$\left| 00 \right\rangle$ï¼Œç¬¬äºŒä¸ªå¯„å­˜å™¨ä¸­çš„å¦ä¸€ä¸ªé‡å­æ¯”ç‰¹åˆå§‹åŒ–ä¸º$\left| 1 \right\rangle$

$$\left| \psi_{0} \right\rangle = \left| 00 \right\rangle_{1}\left| 1 \right\rangle_{2}$$

2.  å¯¹æ‰€æœ‰é‡å­æ¯”ç‰¹åº”ç”¨é˜¿è¾¾é©¬é—¨

$$\left| \psi_{1} \right\rangle = \frac{1}{2}\left( \left| 00 \right\rangle_{1} + \left| 01 \right\rangle_{1} + \left| 10 \right\rangle_{1} + \left| 11 \right\rangle_{1} \right)\frac{1}{\sqrt{2}}\left( \left| 0 \right\rangle_{2} - \left| 1 \right\rangle_{2} \right)$$

3.  é¢„è¨€æ–¹ç¨‹å¯å®ç°ä¸º$Q_{f} = \text{CX}_{1a}\text{CX}_{2a}$

$${|\psi_{2}\rangle = \frac{1}{2\sqrt{2}}\lbrack\left| 00 \right\rangle_{1}\left( \left| 0\bigoplus_{}^{}{0\bigoplus_{}^{}0} \right\rangle_{2} - \left| 1\bigoplus_{}^{}{0\bigoplus_{}^{}0} \right\rangle_{2} \right)
}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  + \left| 01 \right\rangle_{1}\left( \left| 0\bigoplus 0\bigoplus 1 \right\rangle_{2} - \left| 1\bigoplus 0\bigoplus 1 \right\rangle_{2} \right)}$$

$$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  + \left| 10 \right\rangle_{1}\left( \left| 0\bigoplus_{}^{}{1\bigoplus_{}^{}0} \right\rangle_{2} - \left| 1\bigoplus_{}^{}{1\bigoplus_{}^{}0} \right\rangle_{2} \right)$$

$$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  + \left| 11 \right\rangle_{1}\left( \left| 0\bigoplus_{}^{}{1\bigoplus_{}^{}1} \right\rangle_{2} - \left| 1\bigoplus_{}^{}{1\bigoplus_{}^{}1} \right\rangle_{2} \right)\rbrack$$

4.  å› æ­¤

$$\left| \psi_{2} \right\rangle = \frac{1}{2\sqrt{2}}\left\lbrack \left| 00 \right\rangle_{1}\left( \left| 0 \right\rangle_{2} - \left| 1 \right\rangle_{2} \right) - \left| 01 \right\rangle_{1}\left( \left| 0 \right\rangle_{2} - \left| 1 \right\rangle_{2} \right) - \left| 10 \right\rangle_{1}\left( \left| 0 \right\rangle_{2} - \left| 1 \right\rangle_{2} \right) + \left| 11 \right\rangle_{1}\left( \left| 0 \right\rangle_{2} - \left| 1 \right\rangle_{2} \right) \right\rbrack$$

$$= \frac{1}{2}\left( \left| 00 \right\rangle_{1} - \left| 01 \right\rangle_{1} - \left| 10 \right\rangle_{1} + \left| 11 \right\rangle_{1} \right)\frac{1}{\sqrt{2}}\left( \left| 0 \right\rangle_{2} - \left| 1 \right\rangle_{2} \right)$$

$$= \frac{1}{\sqrt{2}}\left( \left| 0 \right\rangle_{10} - \left| 1 \right\rangle_{10} \right)\frac{1}{\sqrt{2}}\left( \left| 0 \right\rangle_{11} - \left| 1 \right\rangle_{11} \right)\frac{1}{\sqrt{2}}\left( \left| 0 \right\rangle_{2} - \left| 1 \right\rangle_{2} \right)$$

5.  åœ¨ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸Šåº”ç”¨é˜¿è¾¾é©¬é—¨

$$\left| \psi_{3} \right\rangle = \left| 1 \right\rangle_{10}\left| 1 \right\rangle_{11}\left( \left| 0 \right\rangle_{2} - \left| 1 \right\rangle_{2} \right)$$

6.  å¯¹å¼€å§‹çš„ä¸¤ä¸ªé‡å­æ¯”ç‰¹æµ‹é‡ä¼šç»™å‡ºéé›¶$11$ï¼Œè¡¨æ˜æ˜¯ä¸€ä¸ªå‡è¡¡å‡½æ•°ã€‚

æ‚¨å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„å°éƒ¨ä»¶å°è¯•ç±»ä¼¼çš„ç¤ºä¾‹ã€‚ç‚¹å‡»æŒ‰é’®æ·»åŠ H-gateå’Œé¢„è¨€ï¼Œé‡æ–°è¿è¡Œå•å…ƒå’Œæˆ–è®¾ç½®case=\"constant\"æ¥å°è¯•ä¸åŒçš„é¢„è¨€ã€‚

> from qiskit_textbook.widgets import dj_widget
>
> dj_widget(size=\"small\", case=\"balanced\")

è¾“å‡ºï¼š

![](pics/media/image160.png)

### 3. åˆ›å»ºé‡å­é¢„è¨€

è®©æˆ‘ä»¬çœ‹ä¸€çœ‹åˆ›å»ºé‡å­é¢„è¨€çš„å‡ ç§ä¸åŒæ–¹æ³•ã€‚

å¯¹äºå¸¸å€¼å‡½æ•°ï¼Œå¾ˆç®€å•ï¼š

1.  å¦‚æœf(x)=0ï¼Œåˆ™åœ¨å¯„å­˜å™¨2ä¸­å¯¹é‡å­æ¯”ç‰¹åº”ç”¨I-gateã€‚

2.  å¦‚æœf(x)=1ï¼Œåˆ™åœ¨å¯„å­˜å™¨2ä¸­å¯¹é‡å­æ¯”ç‰¹åº”ç”¨H-gateã€‚

å¯¹äºå‡è¡¡å‡½æ•°ï¼Œå¯ä»¥åˆ›å»ºè®¸å¤šä¸åŒçš„å›è·¯ã€‚å¯ä»¥ä¿è¯å‡è¡¡å›è·¯çš„ä¸€ç§æ–¹å¼æ˜¯å¯¹å¯„å­˜å™¨1ä¸­çš„æ¯ä¸ªé‡å­æ¯”ç‰¹æ‰§è¡ŒCNOTï¼Œå¹¶æŠŠå¯„å­˜å™¨2ä¸­çš„é‡å­æ¯”ç‰¹ä½œä¸ºç›®æ ‡ç«¯ã€‚

![](pics/media/image161.png)

åœ¨ä¸Šé¢çš„å›¾ç‰‡ä¸­ï¼Œä¸Šä¸‰ä¸ªé‡å­æ¯”ç‰¹å½¢æˆè¾“å…¥å¯„å­˜å™¨ï¼Œæœ€åº•ä¸‹çš„ä¸€ä¸ªé‡å­æ¯”ç‰¹æ˜¯è¾“å‡ºå¯„å­˜å™¨ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ä¸‹è¡¨ä¸­æŸ¥çœ‹æ¯ä¸€çŠ¶æ€æ‰€ç»™å‡ºçš„ç›¸åº”è¾“å‡ºï¼š

  **States that output 0**   **States that output 1**
-------------------------- --------------------------
  000                        001
  011                        100
  101                        010
  110                        111

æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†é€‰å®šçš„æ§åˆ¶ç«¯åŒ…å…¥ä¸€ä¸ªX-gateä¸­æ¥æ›´æ”¹ç»“æœï¼ŒåŒæ—¶ä¿æŒç»“æœå¹³è¡¡ã€‚ä¾‹å¦‚ï¼Œè¯·å‚è§ä¸‹é¢çš„ç”µè·¯åŠå…¶ç»“æœè¡¨ï¼š

![](pics/media/image162.png)

  **States that output 0**   **States that output 1**
-------------------------- --------------------------
  001                        000
  010                        011
  100                        101
  111                        110

### 4. åœ¨Qiskitä¸­å®ç°

ç°åœ¨ï¼Œæˆ‘ä»¬ç”¨å¸¸å€¼å’Œå‡è¡¡é¢„è¨€çš„ä¸‰æ¯”ç‰¹å‡½æ•°ä¸ºç¤ºä¾‹å®ç°Deutsch-Joszaç®—æ³•ã€‚é¦–å…ˆåœ¨Pythonä¸­å¯¼å…¥ç›¸åº”çš„åº“ï¼š

> \# initialization
>
> import numpy as np
>
> \# importing Qiskit
>
> from qiskit import IBMQ, BasicAer
>
> from qiskit.providers.ibmq import least_busy
>
> from qiskit import QuantumCircuit, execute
>
> \# import basic plot tools
>
> from qiskit.visualization import plot_histogram

æ¥ç€ä¸ºé¢„è¨€è®¾ç½®è¾“å…¥å¯„å­˜å™¨çš„å¤§å°ï¼š

> \# set the length of the n-bit input string.
>
> n = 3

#### 4.1 å¸¸å€¼é¢„è¨€

æˆ‘ä»¬ä»åˆ›å»ºä¸€ä¸ªå¸¸å€¼é¢„è¨€å¼€å§‹ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹è¾“å…¥å¯¹è¾“å‡ºæ²¡æœ‰å½±å“ï¼Œå› æ­¤åªæ˜¯å°†è¾“å‡ºé‡å­æ¯”ç‰¹éšæœºè®¾ç½®ä¸º0æˆ–1ï¼š

> \# set the length of the n-bit input string.
>
> n = 3
>
> const_oracle = QuantumCircuit(n+1)
>
> output = np.random.randint(2)
>
> if output == 1:
>
> const_oracle.x(n)
>
> const_oracle.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image163.png)

#### 4.2 å‡è¡¡é¢„è¨€

balanced_oracle = QuantumCircuit(n+1)

æ¥ç€åˆ›å»ºä¸€ä¸ªå‡è¡¡é¢„è¨€ã€‚æ­£å¦‚åœ¨æœ¬ç« çš„1bèŠ‚ä¸­æ‰€è§ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ‰§è¡Œå¤šä¸ªCNOTæ¥åˆ›å»ºå‡è¡¡é¢„è¨€ï¼Œå…¶ä¸­æ¯ä¸€ä¸ªè¾“å…¥ç«¯é‡å­æ¯”ç‰¹ä¸ºæ§åˆ¶ç«¯ï¼Œè€Œè¾“å‡ºç«¯é‡å­æ¯”ç‰¹ä¸ºç›®æ ‡ç«¯ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æŸäº›æ§åˆ¶ç«¯è£…å…¥X-gateæ¥ç»™äºˆè¾“å…¥çŠ¶æ€0æˆ–1ã€‚é¦–å…ˆé€‰æ‹©ä¸€ä¸ªé•¿åº¦ä¸ºnçš„äºŒè¿›åˆ¶å­—ä¸²ï¼Œè¯¥å­—ä¸²ç”¨äºæŒ‡æ˜è¦åŒ…å…¥çš„æ§ä»¶ï¼š

b_str = \"101\"

è‡³æ­¤æˆ‘ä»¬æœ‰äº†è¿™æ ·çš„ä¸€ä¸ªå­—ä¸²ï¼Œå°±å¯ä»¥å°†è¯¥å­—ä¸²å½“ä½œæ”¾ç½®X-gateçš„é’¥åŒ™ã€‚å¯¹äºåœ¨å›è·¯ä¸­çš„æ¯ä¸ªé‡å­æ¯”ç‰¹ï¼Œå¦‚æœb_strä¸­ç›¸å¯¹åº”çš„æ•°ä½ï¼ˆdigitï¼‰æ˜¯1ï¼Œåˆ™åœ¨è¯¥æ•°ä½å¯¹åº”çš„é‡å­æ¯”ç‰¹å¤„æ”¾ç½®ä¸€ä¸ªX-gateã€‚

æ¥ç€æˆ‘ä»¬ä½¿ç”¨è¾“å…¥ç«¯çš„æ¯ä¸ªé‡å­æ¯”ç‰¹ä½œä¸ºæ§åˆ¶ç«¯ï¼Œä¾æ¬¡åº”ç”¨å—æ§éé—¨ï¼Œæ‰€æœ‰CNOTçš„ç›®æ ‡ç«¯æ˜¯è¾“å‡ºç«¯çš„é‡å­æ¯”ç‰¹ï¼š

> balanced_oracle = QuantumCircuit(n+1)
>
> b_str = \"101\"
>
> \# Place X-gates
>
> for qubit in range(len(b_str)):
>
> if b_str\[qubit\] == \'1\':
>
> balanced_oracle.x(qubit)
>
> balanced_oracle.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image164.png)

> balanced_oracle = QuantumCircuit(n+1)
>
> b_str = \"101\"
>
> \# Place X-gates
>
> for qubit in range(len(b_str)):
>
> if b_str\[qubit\] == \'1\':
>
> balanced_oracle.x(qubit)
>
> \# Use barrier as divider
>
> balanced_oracle.barrier()
>
> \# Controlled-NOT gates
>
> for qubit in range(n):
>
> balanced_oracle.cx(qubit, n)
>
> balanced_oracle.barrier()
>
> balanced_oracle.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image165.png)

æœ€åï¼Œé‡å¤ä¸¤ä¸ªå•å…ƒä¸­çš„ä»£ç å®Œæˆåœ¨æ§åˆ¶ç«¯è£…å…¥X-gateï¼š

> balanced_oracle = QuantumCircuit(n+1)
>
> b_str = \"101\"
>
> \# Place X-gates
>
> for qubit in range(len(b_str)):
>
> if b_str\[qubit\] == \'1\':
>
> balanced_oracle.x(qubit)
>
> \# Use barrier as divider
>
> balanced_oracle.barrier()
>
> \# Controlled-NOT gates
>
> for qubit in range(n):
>
> balanced_oracle.cx(qubit, n)
>
> balanced_oracle.barrier()
>
> \# Place X-gates
>
> for qubit in range(len(b_str)):
>
> if b_str\[qubit\] == \'1\':
>
> balanced_oracle.x(qubit)
>
> \# Show oracle
>
> balanced_oracle.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image166.png)

æˆ‘ä»¬åˆšåˆšåˆ›å»ºäº†ä¸€ä¸ªå‡è¡¡é¢„è¨€ï¼å‰©ä¸‹è¦åšçš„äº‹æƒ…å°±æ˜¯çœ‹Deutsch-Jozaç®—æ³•æ˜¯å¦å¯ä»¥å°†å…¶è§£å‡ºã€‚

#### 4.3 å®Œæ•´çš„ç®—æ³•

ç°åœ¨æˆ‘ä»¬å°†æ‰€æœ‰çš„ä¸œè¥¿æ”¾åœ¨ä¸€èµ·ã€‚ç®—æ³•ä¸­çš„ç¬¬ä¸€éƒ¨å°†å›è·¯çš„è¾“å…¥ç«¯å’Œè¾“å‡ºç«¯é‡å­æ¯”ç‰¹åˆ†åˆ«åˆå§‹åŒ–ä¸ºæ€$\left| + \right\rangle$å’Œæ€$\left| - \right\rangle$ã€‚

> dj_circuit = QuantumCircuit(n+1, n)
>
> \# Apply H-gates
>
> for qubit in range(n):
>
> dj_circuit.h(qubit)
>
> \# Put qubit in state \|-\>
>
> dj_circuit.x(n)
>
> dj_circuit.h(n)
>
> dj_circuit.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image167.png)

ä¸‹ä¸€æ­¥å°±æ˜¯åº”ç”¨é¢„è¨€ï¼Œæ­¤å¤„æˆ‘ä»¬åº”ç”¨ä¹‹å‰åˆ›å»ºçš„balanced_oracleï¼š

> dj_circuit = QuantumCircuit(n+1, n)
>
> \# Apply H-gates
>
> for qubit in range(n):
>
> dj_circuit.h(qubit)
>
> \# Put qubit in state \|-\>
>
> dj_circuit.x(n)
>
> dj_circuit.h(n)
>
> \# Add oracle
>
> dj_circuit += balanced_oracle
>
> dj_circuit.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image168.png)

æœ€åï¼Œåœ¨né‡å­æ¯”ç‰¹çš„è¾“å…¥ç«¯æ‰§è¡ŒH-gateï¼Œç„¶åæµ‹é‡è¾“å…¥å¯„å­˜å™¨ï¼š

> dj_circuit = QuantumCircuit(n+1, n)
>
> \# Apply H-gates
>
> for qubit in range(n):
>
> dj_circuit.h(qubit)
>
> \# Put qubit in state \|-\>
>
> dj_circuit.x(n)
>
> dj_circuit.h(n)
>
> \# Add oracle
>
> dj_circuit += balanced_oracle
>
> \# Repeat H-gates
>
> for qubit in range(n):
>
> dj_circuit.h(qubit)
>
> dj_circuit.barrier()
>
> \# Measure
>
> for i in range(n):
>
> dj_circuit.measure(i, i)
>
> \# Display circuit
>
> dj_circuit.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image169.png)

çœ‹ä¸€çœ‹è¾“å…¥å¦‚ä½•ï¼š

> \# use local simulator
>
> backend = BasicAer.get_backend(\'qasm_simulator\')
>
> shots = 1024
>
> results = execute(dj_circuit, backend=backend, shots=shots).result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image170.png)

ä»ä¸Šé¢çš„ç»“æœå¯ä»¥çœ‹å‡ºï¼Œæµ‹é‡å‡º$000$çš„æ¦‚ç‡æ˜¯0ï¼…ï¼Œæ­£ç¡®åœ°é¢„æµ‹äº†å‡½æ•°æ˜¯å‡è¡¡å‡½æ•°ã€‚

#### 4.4 é€šç”¨é‡å­å›è·¯

åœ¨ä¸‹é¢çš„ä»£ç ä¸­ç»™å‡ºäº†ä¸€ä¸ªé€šç”¨å‡½æ•°ï¼Œè¯¥å‡½æ•°ç”¨äºåˆ›å»ºDeutsch-Jozaé¢„è¨€å¹¶å°†å…¶è½¬æ¢ä¸ºé‡å­é—¨ã€‚å…¶æ¥æ”¶"balanced"æˆ–"constant"ä»¥åŠè¾“å…¥å¯„å­˜å™¨çš„å¤§å°nä½œä¸ºå‚æ•°ï¼š

> def dj_oracle(case, n):
>
> \# We need to make a QuantumCircuit object to return
>
> \# This circuit has n+1 qubits: the size of the input,
>
> \# plus one output qubit
>
> oracle_qc = QuantumCircuit(n+1)
>
> \# First, let\'s deal with the case in which oracle is balanced
>
> if case == \"balanced\":
>
> \# First generate a random number that tells us which CNOTs to
>
> \# wrap in X-gates:
>
> b = np.random.randint(1,2\*\*n)
>
> \# Next, format \'b\' as a binary string of length \'n\', padded with
> zeros:
>
> b_str = format(b, \'0\'+str(n)+\'b\')
>
> \# Next, we place the first X-gates. Each digit in our binary string
>
> \# corresponds to a qubit, if the digit is 0, we do nothing, if it\'s
> 1
>
> \# we apply an X-gate to that qubit:
>
> for qubit in range(len(b_str)):
>
> if b_str\[qubit\] == \'1\':
>
> oracle_qc.x(qubit)
>
> \# Do the controlled-NOT gates for each qubit, using the output qubit
>
> \# as the target:
>
> for qubit in range(n):
>
> oracle_qc.cx(qubit, n)
>
> \# Next, place the final X-gates
>
> for qubit in range(len(b_str)):
>
> if b_str\[qubit\] == \'1\':
>
> oracle_qc.x(qubit)
>
> \# Case in which oracle is constant
>
> if case == \"constant\":
>
> \# First decide what the fixed output of the oracle will be
>
> \# (either always 0 or always 1)
>
> output = np.random.randint(2)
>
> if output == 1:
>
> oracle_qc.x(n)
>
> oracle_gate = oracle_qc.to_gate()
>
> oracle_gate.name = \"Oracle\" \# To show when we display the circuit
>
> return oracle_gate

æˆ‘ä»¬è¿˜å¯ä»¥åˆ›å»ºä¸€ä¸ªå‡½æ•°æ¥æ”¶è¯¥é¢„è¨€é‡å­é—¨å¹¶åœ¨å…¶ä¸Šæ‰§è¡ŒDeutsch-Jozaç®—æ³•ï¼š

> def dj_algorithm(oracle, n):
>
> dj_circuit = QuantumCircuit(n+1, n)
>
> \# Set up the output qubit:
>
> dj_circuit.x(n)
>
> dj_circuit.h(n)
>
> \# And set up the input register:
>
> for qubit in range(n):
>
> dj_circuit.h(qubit)
>
> \# Let\'s append the oracle gate to our circuit:
>
> dj_circuit.append(oracle, range(n+1))
>
> \# Finally, perform the H-gates again and measure:
>
> for qubit in range(n):
>
> dj_circuit.h(qubit)
>
> for i in range(n):
>
> dj_circuit.measure(i, i)
>
> return dj_circuit

æœ€åé€šè¿‡è¿™äº›å‡½æ•°æŠŠç©ä»¥ä¸‹Deutsch-Jozaç®—æ³•ï¼š

> n = 4
>
> oracle_gate = dj_oracle(\'balanced\', n)
>
> dj_circuit = dj_algorithm(oracle_gate, n)
>
> dj_circuit.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image171.png)

çœ‹ä¸€ä¸‹è¿™ä¸€å›è·¯çš„è¿è¡Œç»“æœï¼š

> results = execute(dj_circuit, backend=backend, shots=1024).result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image172.png)

### 5. ä½“ç°çœŸå®çš„è®¾å¤‡

æˆ‘ä»¬å¯ä»¥åœ¨çœŸå®è®¾å¤‡ä¸Šè¿è¡Œè¿™ä¸ªå›è·¯ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚å½“ç„¶ï¼Œé¦–å…ˆå¯»æ‰¾å¯ä»¥å¤„ç†è¯¥å›è·¯è´Ÿè½½æœ€è½»çš„è®¾å¤‡ã€‚

> \# Load our saved IBMQ accounts and get the least busy backend device
> with greater than or equal to (n+1) qubits
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> backend = least_busy(provider.backends(filters=lambda x:
> x.configuration().n_qubits \>= (n+1) and
>
> not x.configuration().simulator and x.status().operational==True))
>
> print(\"least busy backend: \", backend)
>
> è¾“å‡ºï¼š
>
> least busy backend: ibmq_london
>
> \# Run our circuit on the least busy backend. Monitor the execution of
> the job in the queue
>
> from qiskit.tools.monitor import job_monitor
>
> shots = 1024
>
> job = execute(dj_circuit, backend=backend, shots=shots,
> optimization_level=3)
>
> job_monitor(job, interval = 2)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> \# Get the results of the computation
>
> results = job.result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image173.png)

æ­£å¦‚è¾“å‡ºçš„æŸ±çŠ¶å›¾æ‰€ç¤ºï¼Œæœ€æœ‰å¯èƒ½ç»“æœæ˜¯0111å’Œ1111ã€‚å…¶ä»–ç»“æœæ˜¯ç”±é‡å­è®¡ç®—ä¸­çš„è¯¯å·®é€ æˆçš„ã€‚

### 6. é—®é¢˜

1\. æ‚¨æ˜¯å¦èƒ½å¤Ÿåˆ›é€ ä¸€ä¸ªå‡è¡¡æˆ–å¸¸å€¼çš„ä¸åŒå½¢å¼é¢„è¨€ï¼Ÿ

> from qiskit_textbook.problems import dj_problem_oracle
>
> oracle = dj_problem_oracle(1)

å‡½æ•°dj_problem_oracleï¼ˆå¦‚ä¸Šæ‰€ç¤ºï¼‰ä»¥é‡å­é—¨çš„å½¢å¼è¿”å›ä¸€ä¸ªDeutsch-Jozaé¢„è¨€ï¼Œå…¶ä¸­æœ€ç»ˆçš„é‡å­æ¯”ç‰¹æ˜¯è¾“å‡ºç«¯é‡å­æ¯”ç‰¹ï¼ˆä¸ä¸Šé¢çš„ä¾‹å­ä¸€æ ·ï¼‰ã€‚æ‚¨å¯ä»¥é€šè¿‡ç»™å‡½æ•°dj_problem_oracle
1åˆ°5ä¹‹é—´ä¸åŒçš„æ•´æ•°æ¥å¾—åˆ°ä¸åŒé¢„è¨€ã€‚ä½¿ç”¨Deutsch-Jozaç®—æ³•æ¥å†³å®šæ¯ä¸ªé¢„è¨€æ˜¯å‡è¡¡è¿˜æ˜¯å¸¸å€¼ï¼ˆ**æ³¨æ„**ï¼šå¼ºçƒˆå»ºè®®æ‚¨ä½¿ç”¨qasm_simulatorè€Œä¸æ˜¯çœŸæ­£çš„è®¾å¤‡æ¥å°è¯•è¿™ä¸€ç¤ºä¾‹ï¼‰ã€‚

### 7. å‚è€ƒæ–‡çŒ®

1\. David Deutsch and Richard Jozsa (1992). \"Rapid solutions of
problems by quantum computation\". Proceedings of the Royal Society of
London A. 439: 553--558.
[doi:10.1098/rspa.1992.0167](https://doi.org/10.1098%2Frspa.1992.0167).

2\. R. Cleve; A. Ekert; C. Macchiavello; M. Mosca (1998). \"Quantum
algorithms revisited\". Proceedings of the Royal Society of London A.
454: 339--354.
[doi:10.1098/rspa.1998.0164](https://doi.org/10.1098%2Frspa.1998.0164).

3.5 Bernstein-Vazirani ç®—æ³•
---------------------------

æœ¬èŠ‚ä¸­é¦–å…ˆä»‹ç»Bernstein-Vaziranié—®é¢˜ï¼ŒåŠå…¶ç»å…¸è§£å’Œç”¨äºå¤„ç†çš„é‡å­ç®—æ³•ã€‚ç„¶åä½¿ç”¨Qiskitå®ç°é‡å­ç®—æ³•ï¼Œå¹¶åœ¨æ¨¡æ‹Ÿå™¨å’Œè®¾å¤‡ä¸Šè¿è¡Œã€‚

### å†…å®¹

1\. Bernstein-Vaziraniç®—æ³•

1.1 Bernstein-Vaziranié—®é¢˜

1.2 ç»å…¸è§£æ³•

1.3 é‡å­è§£æ³•

2\. ç¤ºä¾‹

3\. Qiskitå®ç°

3.1 æ¨¡æ‹Ÿå™¨

3.2 çœŸå®è®¾å¤‡

4\. ç»ƒä¹ 

5\. å‚è€ƒæ–‡çŒ®

### 1. Bernstein-Vaziraniç®—æ³•

Bernstein-Vaziraniåœ¨å‚è€ƒæ–‡çŒ®\[1\]ä¸­ç¬¬ä¸€æ¬¡è¢«å¼•å…¥ï¼Œå¯è¢«çœ‹ä½œæ˜¯ä¸Šä¸€èŠ‚ä¸­Deutsch-Joszaçš„æ‰©å±•ã€‚è¯¥ç®—æ³•æ­ç¤ºäº†é€šè¿‡å°†é‡å­è®¡ç®—æœºä½œä¸ºä¸€ä¸ªè®¡ç®—å·¥å…·èƒ½å¤Ÿå¤„ç†æ¯”Deutsch-Joszawené—®é¢˜æ›´åŠ å¤æ‚çš„é—®é¢˜ã€‚

#### 1.1 Bernstein-Vaziranié—®é¢˜

æˆ‘ä»¬è¿˜æ˜¯ç»™å‡ºä¸€ä¸ªé»‘ç®±å‡½æ•°$f$ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸²æ¯”ç‰¹ï¼ˆ$x$ï¼‰ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¿”å›$0$æˆ–$1$ï¼š

$$f\left( x0,x1,x2,\ldots \right) \rightarrow 0\ or\ 1\ where\ x_{n}\ is\ 0\ or\ 1$$

ä¸Deutsch-Joszaé—®é¢˜ä¸­çš„å‡è¡¡æˆ–å¸¸å€¼å‡½æ•°ä¸åŒï¼Œä¸Šè¿°å‡½æ•°è¿”å›è¾“å…¥ä¸å­—ä¸²$s$çš„ä½ç§¯ã€‚æ¢å¥è¯è¯´ï¼Œç»™å®šä¸€ä¸ªè¾“å…¥$x$ï¼Œ$f\left( x \right) = s \cdot x\left( mod2 \right)$ã€‚æˆ‘ä»¬æƒ³è¦æ‰¾å‡ºå­—ä¸²$s$ã€‚ä½œä¸ºç»å…¸å¯é€†ç”µè·¯ï¼ŒBernstein-Vaziranié¢„è¨€çœ‹èµ·æ¥åƒï¼š

![](pics/media/image174.png)

#### 1.2 ç»å…¸è§£æ³•

é€šå¸¸æ¥è®²ï¼Œè¿™ä¸€é¢„è¨€åœ¨ç»™å®šè¾“å…¥$x$æ—¶åº”è¿”å›ï¼š

$$f_{s}\left( x \right) = s \cdot x\ mod\ 2$$

å› æ­¤ï¼Œé€šè¿‡ä¸€ç³»åˆ—çš„è¾“å…¥æŸ¥è¯¢é¢„è¨€ï¼Œå¯ä»¥æ‰¾å‡ºéšè—çš„æ¯”ç‰¹ä¸²$s$ï¼š

  **Input(x)**
  --------------
  100\...0
  010\...0
  001\...0
  000\...1

å½“ç„¶ä¸åŒçš„æŸ¥è¯¢æ­ç¤ºä¸åŒçš„$s$ï¼ˆ$s_{i}$ï¼‰ã€‚æ¯”å¦‚ï¼Œç”¨x =
1000...0å¯ä»¥è·å–$s$çš„æœ€ä½æœ‰æ•ˆä½ï¼Œç”¨x =
0100...0å¯ä»¥è·å–ä¸‹ä¸€ä¸ªæœ€ä½æœ‰æ•ˆä½ï¼Œç­‰ç­‰ã€‚è¿™ä¸€è¿‡ç¨‹è¡¨æ˜æˆ‘ä»¬éœ€è¦è°ƒç”¨å‡½æ•°$f_{s}\left( x \right)$
$n$æ¬¡ã€‚

#### 1.3 é‡å­è§£æ³•

é€šè¿‡é˜¿å“¥é‡å­è®¡ç®—æœºï¼Œæˆ‘ä»¬å¯ä»¥ä»…è°ƒç”¨å‡½æ•°$f_{s}\left( x \right)$ä¸€æ¬¡å°±èƒ½åœ¨100%ç¡®ä¿¡çš„æƒ…å†µè§£å†³è¯¥é—®é¢˜ã€‚é‡å­Bernstein-Vaziraniç®—æ³•æ‰¾å‡ºéšè—æ¯”ç‰¹å­—ä¸²çš„æ–¹å¼éå¸¸ç®€å•ï¼š

1.  åˆå§‹åŒ–è¾“å…¥ç«¯é‡å­æ¯”ç‰¹ä¸ºæ€$\left| 0 \right\rangle^{\otimes n}$ï¼Œè¾“å‡ºç«¯é‡å­æ¯”ç‰¹ä¸ºæ€$\left| - \right\rangle$ã€‚

2.  åœ¨è¾“å…¥å¯„å­˜å™¨ä¸Šåº”ç”¨é˜¿è¾¾é©¬é—¨ã€‚

3.  æŸ¥è¯¢é¢„è¨€ã€‚

4.  åœ¨è¾“å…¥å¯„å­˜å™¨ä¸Šåº”ç”¨é˜¿è¾¾é©¬é—¨ã€‚

5.  æµ‹é‡

![](pics/media/image175.png)

ä¸ºäº†è§£é‡Šè¯¥ç®—æ³•ï¼Œè®©æˆ‘ä»¬æ›´ä»”ç»†åœ°çœ‹çœ‹å½“å¯¹æ¯ä¸ªé‡å­æ¯”ç‰¹åº”ç”¨H-gateæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚å¦‚æœæœ‰ä¸€ä¸ª$n$-é‡å­æ¯”ç‰¹å¤„äºæ€$\left| a \right\rangle$å¹¶åº”ç”¨H-gateï¼Œå°†ä¼šçœ‹åˆ°å¦‚ä¸‹å˜åŒ–å¼ï¼š

$$\left| a \right\rangle\overset{H^{\otimes n}}{\rightarrow}\frac{1}{\sqrt{2^{n}}}\sum_{x \in {0,1}^{n}}^{}{\left( - 1 \right)^{a \bullet x}\left| x \right\rangle}$$

**ç­‰å¼æ³¨è§£**

å›æƒ³ä¸€ä¸‹é˜¿è¾¾é©¬é—¨åœ¨ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸Šæ‰§è¡Œä»¥ä¸‹è½¬æ¢ï¼š

$$H\left| b \right\rangle = \frac{1}{\sqrt{2}}(\left| 0 \right\rangle + \left| 1 \right\rangle)$$

$$H\left| 1 \right\rangle = \frac{1}{\sqrt{2}}(\left| 0 \right\rangle - \left| 1 \right\rangle)$$

ä½¿ç”¨æ±‚å’Œç¬¦å·ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æ”¹å†™ä¸ºï¼š

$$H\left| a \right\rangle = \sum_{a \in \{ 0,1\}}^{}{{(-1)}^{a \bullet x}|x\rangle}$$

å¯¹äºä¸¤ä¸ªé‡å­æ¯”ç‰¹ï¼Œå¯¹æ¯ä¸ªé‡å­æ¯”åº”ç”¨é˜¿è¾¾é©¬é—¨æ‰§è¡Œä¸€ä¸‹è½¬æ¢ï¼š

$$H^{\otimes 2}\left| 00 \right\rangle = \left| 00 \right\rangle + \left| 01 \right\rangle + \left| 10 \right\rangle + \left| 11 \right\rangle$$

$$H^{\otimes 2}\left| 01 \right\rangle = \left| 00 \right\rangle - \left| 01 \right\rangle + \left| 10 \right\rangle - \left| 11 \right\rangle$$

$$H^{\otimes 2}\left| 10 \right\rangle = \left| 00 \right\rangle + \left| 01 \right\rangle - \left| 10 \right\rangle - \left| 11 \right\rangle$$

$$H^{\otimes 2}\left| 11 \right\rangle = \left| 00 \right\rangle - \left| 01 \right\rangle - \left| 10 \right\rangle + \left| 11 \right\rangle$$

æˆ‘ä»¬å¯ä»¥ç”¨å’Œæ¥è¡¨ç¤º:

$$H^{\otimes 2}\left| 11 \right\rangle = \sum_{x \in {\{ 0,1\}}^{2}}^{}{( - 1)}^{a \bullet x}|x\rangle$$

å¸Œæœ›æ‚¨ç°åœ¨èƒ½çœ‹åˆ°å¾—åˆ°ä¸Šé¢ç­‰å¼çš„è¿‡ç¨‹ã€‚

ç‰¹åˆ«æ˜¯ï¼Œå½“æˆ‘ä»¬ä»¥é‡å­å¯„å­˜å™¨ä¸ºæ€$\left| 00\ldots 0 \right\rangle$å¼€å§‹å¹¶åº”ç”¨$n$ä¸ªé˜¿è¾¾é©¬é—¨åï¼Œå°±è·å¾—äº†ç†Ÿæ‚‰çš„é‡å­å åŠ æ€ï¼š

$$\left| 00\ldots 0 \right\rangle\overset{H^{\otimes n}}{\rightarrow}\frac{1}{\sqrt{2^{n}}}\sum_{x \in {0,1}^{n}}^{}\left| x \right\rangle$$

åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œç›¸ä½é¡¹$\left( - 1 \right)^{a \bullet x}$æ¶ˆå¤±äº†ï¼Œå› ä¸º$a = 0$æ‰€ä»¥$\left( - 1 \right)^{a \bullet x} = 1$ã€‚

ç»å…¸é¢„è¨€$f_{s}$å¯¹äºä»»æ„è¾“å…¥$x$éƒ½è¿”å›$1$ï¼Œä½¿å¾—$s \bullet x\ mod\ 2 = 1$ï¼Œå…¶ä»–æƒ…å†µåˆ™è¿”å›$0$ã€‚å¦‚æœä½¿ç”¨Deutsch-Jozaç®—æ³•ä¸­åŒæ ·çš„ç›¸ä½åå†²æŠ€å·§å¹¶å°†å…¶ä½œç”¨åœ¨å¤„äºæ€$\left| - \right\rangle$çš„ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬ä¼šè·å¾—ä¸‹è¿°å˜åŒ–å¼ï¼š

$$\left| x \right\rangle\overset{f_{s}}{\rightarrow}\left( - 1 \right)^{s \bullet x}\left| x \right\rangle$$

ç”¨äºæ­éœ²éšè—æ¯”ç‰¹å­—ä¸²çš„ç®—æ³•é‡‡ç”¨é€šè¿‡æŸ¥è¯¢é‡å­é¢„è¨€$f_{s}$çš„é‡å­å åŠ æ€ä»é˜¿è¾¾é©¬å˜æ¢è·å¾—$\left| 00\ldots 0 \right\rangle$ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ

$$\left| 00\ldots 0 \right\rangle\overset{H^{\otimes n}}{\rightarrow}\frac{1}{\sqrt{2^{n}}}\sum_{x \in {0,1}^{n}}^{}\left| x \right\rangle\overset{f_{n}}{\rightarrow}\frac{1}{\sqrt{2^{n}}}\sum_{x \in {0,1}^{n}}^{}\left( - 1 \right)^{a \bullet x}\left| x \right\rangle$$

å› ä¸º$n$ä¸ªH-gateçš„é€†ä»æ˜¯$n$ä¸ªH-gateï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸‹å¼è·å–$a$ï¼š

$$\frac{1}{\sqrt{2^{n}}}\sum_{x \in {0,1}^{n}}^{}\left( - 1 \right)^{a \bullet x}\left| a \right\rangle\overset{H^{\otimes n}}{\rightarrow}\left| a \right\rangle$$

### 2. ç¤ºä¾‹

ç°åœ¨è®©æˆ‘ä»¬ä»”ç»†æ£€æŸ¥$n = 2$ä¸ªé‡å­æ¯”ç‰¹ä¸ç§˜å¯†å­—ä¸²$s = 11$çš„ç‰¹å®šç¤ºä¾‹ã€‚æ³¨æ„æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨å‚è€ƒæ–‡çŒ®\[2\]çš„å…¬å¼åœ¨ç”ŸæˆBernstein-Vaziranié‡å­é¢„è¨€å›è·¯æ—¶åªä½¿ç”¨ä¸€ä¸ªå¯„å­˜å™¨ã€‚

1\. ä¸¤ä¸ªé‡å­æ¯”ç‰¹å¯„å­˜å™¨åˆå§‹åŒ–ä¸º0ï¼š

$$\left| \psi_{0} \right\rangle = \left| 00 \right\rangle$$

2\. åœ¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¸Šåˆ†åˆ«åº”ç”¨H-gateï¼š

$$\left| \psi_{1} \right\rangle = \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle)$$

3\. å¯¹äºå­—ä¸²$s = 11$ï¼Œé‡å­é¢„è¨€æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

$${\left| x \right\rangle\overset{f_{s}}{\rightarrow}\left( - 1 \right)^{x \bullet 11}\left| x \right\rangle
}{\left| \psi_{2} \right\rangle = \frac{1}{2}(\left( - 1 \right)^{00 \bullet 11}|00\rangle + \left( - 1 \right)^{01 \bullet 11}|01\rangle + \left( - 1 \right)^{10 \bullet 11}|10\rangle + \left( - 1 \right)^{11 \bullet 11}|11\rangle)
}{\left| \psi_{2} \right\rangle = \frac{1}{2}(|00\rangle - |01\rangle - |10\rangle + |11\rangle)}$$

4\. åœ¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¸Šåˆ†åˆ«åº”ç”¨H-gateï¼š

$$\left| \psi_{3} \right\rangle = \left| 11 \right\rangle$$

5\. æµ‹é‡å¹¶æ‰¾å‡ºç§˜å¯†å­—ä¸²$s = 11$ï¼š

ä½¿ç”¨ä¸‹é¢çš„å°éƒ¨ä»¶bv_widgetã€‚ç‚¹å‡»æŒ‰é’®åº”ç”¨ä¸åŒçš„æ­¥éª¤ï¼Œå¹¶å°è¯•è·Ÿéšç®—æ³•æ­¥éª¤ã€‚æ‚¨å¯ä»¥é€šè¿‡å‰ä¸¤ä¸ªä½ç½®å‚æ•°æ›´æ”¹è¾“å…¥é‡å­æ¯”ç‰¹çš„æ•°é‡å’Œç§˜å¯†å­—ä¸²çš„å€¼ã€‚

> from qiskit_textbook.widgets import bv_widget
>
> bv_widget(2, \"11\")

### 3. Qiskitå®ç°

ç°åœ¨æˆ‘ä»¬å°†é€šè¿‡ä¸€ä¸ªä¸‰æ¯”ç‰¹çš„å‡½æ•°$s = 011$åœ¨Qiskitä¸­éå†Bernstein-Vaziraniç®—æ³•çš„å®ç°è¿‡ç¨‹ã€‚

> \# initialization
>
> import matplotlib.pyplot as plt
>
> import numpy as np
>
> \# importing Qiskit
>
> from qiskit import IBMQ, BasicAer
>
> from qiskit.providers.ibmq import least_busy
>
> from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister,
> execute
>
> \# import basic plot tools
>
> from qiskit.visualization import plot_histogram

é¦–å…ˆï¼Œæˆ‘ä»¬è®¾ç½®å®éªŒä¸­ä½¿ç”¨çš„é‡å­æ¯”ç‰¹æ•°é‡ï¼Œä»¥åŠå°†è¦é€šè¿‡ç®—æ³•æ‰¾å‡ºçš„éšè—æ¯”ç‰¹å­—ä¸²ã€‚è¯¥éšè—æ¯”ç‰¹å­—ä¸²$s$ç”¨äºç¡®å®šé‡å­é¢„è¨€çš„å›è·¯ã€‚

> n = 3 \# number of qubits used to represent s
>
> s = \'011\' \# the hidden binary string

ç„¶ååœ¨Qiskitä¸­ç¼–å†™Bernstein-Vaziraniç®—æ³•ã€‚

> \# We need a circuit with n qubits, plus one ancilla qubit
>
> \# Also need n classical bits to write the output to
>
> bv_circuit = QuantumCircuit(n+1, n)
>
> \# put ancilla in state \|-\>
>
> bv_circuit.h(n)
>
> bv_circuit.z(n)
>
> \# Apply Hadamard gates before querying the oracle
>
> for i in range(n):
>
> bv_circuit.h(i)
>
> \# Apply barrier
>
> bv_circuit.barrier()
>
> \# Apply the inner-product oracle
>
> s = s\[::-1\] \# reverse s to fit qiskit\'s qubit ordering
>
> for q in range(n):
>
> if s\[q\] == \'0\':
>
> bv_circuit.i(q)
>
> else:
>
> bv_circuit.cx(q, n)
>
> \# Apply barrier
>
> bv_circuit.barrier()
>
> \#Apply Hadamard gates after querying the oracle
>
> for i in range(n):
>
> bv_circuit.h(i)
>
> \# Measurement
>
> for i in range(n):
>
> bv_circuit.measure(i, i)
>
> bv_circuit.draw()

![](pics/media/image176.png)

#### 3.1 ä½¿ç”¨æ¨¡æ‹Ÿå™¨è¿›è¡Œè¯•éªŒ

æˆ‘ä»¬å¯ä»¥åœ¨æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡Œä¸Šé¢çš„å›è·¯ï¼š

> \# use local simulator
>
> backend = BasicAer.get_backend(\'qasm_simulator\')
>
> shots = 1024
>
> results = execute(bv_circuit, backend=backend, shots=shots).result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image177.png)

ä»è¾“å‡ºä¸­å¯ä»¥çœ‹åˆ°æµ‹é‡ç»“æœå°±æ˜¯éšè—å­—ä¸²$011$ã€‚

#### 3.2 åœ¨çœŸå®çš„é‡å­è®¾å¤‡ä¸Šè¿›è¡Œå®éªŒ

æˆ‘ä»¬å¯ä»¥åœ¨çœŸå®çš„é‡å­è®¾å¤‡ä¸Šè¿è¡Œä¸Šé¢çš„å›è·¯ï¼š

> \# Load our saved IBMQ accounts and get the least busy backend device
> with less than or equal to 5 qubits
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> provider.backends()
>
> backend = least_busy(provider.backends(filters=lambda x:
> x.configuration().n_qubits \<= 5 and x.configuration().n_qubits \>= 2
> and not x.configuration().simulator and x.status().operational==True))
>
> print(\"least busy backend: \", backend)
>
> è¾“å‡ºï¼š
>
> least busy backend: ibmqx2
>
> \# Run our circuit on the least busy backend. Monitor the execution of
> the job in the queue
>
> from qiskit.tools.monitor import job_monitor
>
> shots = 1024
>
> job = execute(bv_circuit, backend=backend, shots=shots)
>
> job_monitor(job, interval = 2)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> \# Get the results from the computation
>
> results = job.result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image178.png)

æ­£å¦‚è¾“å‡ºæ‰€ç¤ºï¼Œç»“æœä¸­æœ€æœ‰å¯èƒ½çš„æ˜¯$011$ã€‚å…¶ä»–ç»“æœæ˜¯å› é‡å­è®¡ç®—ä¸­çš„é”™è¯¯äº§ç”Ÿã€‚

### 4. ç»ƒä¹ 

> from qiskit_textbook.widgets import bv_widget
>
> bv_widget(3, \"011\", hide_oracle=False)

ä½¿ç”¨ä¸‹é¢çš„å°éƒ¨ä»¶æŸ¥çœ‹Bernstein-Vaziraniç®—æ³•åœ¨ä¸åŒé¢„è¨€ä¸Šçš„ä½œç”¨æƒ…å†µï¼š

1\.
åœ¨ä¸Šè¿°[Bernstein-Vaziraniçš„å®ç°](https://qiskit.org/textbook/ch-algorithms/bernstein-vazirani.html#implementation)ä¸­ç§˜å¯†æ¯”ç‰¹å­—ä¸²ä¸º$s = 11$ï¼Œå°†å…¶ä¿®æ”¹ä¸º$s = 1011$ã€‚è¿è¡Œç»“æœä¸æ‰€æœŸæœ›çš„ç›¸åŒå—ï¼Ÿè§£é‡Šä¸€ä¸‹ã€‚

2\.
åœ¨ä¸Šè¿°[Bernstein-Vaziraniçš„å®ç°](https://qiskit.org/textbook/ch-algorithms/bernstein-vazirani.html#implementation)ä¸­ç§˜å¯†æ¯”ç‰¹å­—ä¸²ä¸º$s = 11$ï¼Œå°†å…¶ä¿®æ”¹ä¸º$s = 11101101$ã€‚è¿è¡Œç»“æœä¸æ‰€æœŸæœ›çš„ç›¸åŒå—ï¼Ÿè§£é‡Šä¸€ä¸‹ã€‚

### 5. å‚è€ƒæ–‡çŒ®

1\. Ethan Bernstein and Umesh Vazirani (1997) \"Quantum Complexity
Theory\" SIAM Journal on Computing, Vol. 26, No. 5: 1411-1473,
[doi:10.1137/S0097539796300921](https://doi.org/10.1137/S0097539796300921).

2\. Jiangfeng Du, Mingjun Shi, Jihui Wu, Xianyi Zhou, Yangmei Fan,
BangJiao Ye, Rongdian Han (2001) \"Implementation of a quantum algorithm
to solve the Bernstein-Vazirani parity problem without entanglement on
an ensemble quantum computer\", Phys. Rev. A 64, 042306,
[10.1103/PhysRevA.64.042306](https://doi.org/10.1103/PhysRevA.64.042306),
[arXiv:quant-ph/0012114](https://arxiv.org/abs/quant-ph/0012114).

> import qiskit
>
> qiskit.\_\_qiskit_version\_\_
>
> {\'qiskit-terra\': \'0.14.2\',
>
> \'qiskit-aer\': \'0.5.2\',
>
> \'qiskit-ignis\': \'0.3.3\',
>
> \'qiskit-ibmq-provider\': \'0.7.2\',
>
> \'qiskit-aqua\': \'0.7.3\',
>
> \'qiskit\': \'0.19.6\'}

3.6 Simonç®—æ³•ï¼ˆSimon\'s Algorithmï¼‰
-----------------------------------

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆä»‹ç»Simoné—®é¢˜ï¼ŒåŠå…¶ç»å…¸ä¸é‡å­ç®—æ³•è§£ã€‚ç„¶ååœ¨Qiskitä¸­å®ç°è¯¥é‡å­ç®—æ³•ï¼Œå¹¶åœ¨æ¨¡æ‹Ÿå™¨å’ŒçœŸå®è®¾å¤‡ä¸Šè¿è¡Œã€‚

### å†…å®¹

1\. ç®€ä»‹

1.1 Simoné—®é¢˜

1.2 Simonç®—æ³•

2\. ç¤ºä¾‹

3\. Qiskitå®ç°

3.1 æ¨¡æ‹Ÿå™¨

3.2 çœŸå®è®¾å¤‡

4\. é¢„è¨€

5\. ç»ƒä¹ 

6\. å‚è€ƒæ–‡çŒ®

### 1. ç®€ä»‹

Simonç®—æ³•åœ¨å‚è€ƒæ–‡çŒ®\[1\]ä¸­ç¬¬ä¸€æ¬¡è¢«å¼•å…¥ï¼Œå…¶ä¸ºç›¸å¯¹äºæœ€å¥½çš„ç»å…¸ç®—æ³•åœ¨è§£å†³ç‰¹å®šé—®é¢˜æ—¶é‡‡ç”¨æŒ‡æ•°å€åŠ é€Ÿçš„ç¬¬ä¸€ä¸ªé‡å­ç®—æ³•ã€‚è¿™ä¸€ç®—æ³•å¯å‘äº†ç¦»æ•£å‚…é‡Œå¶å˜æ¢çš„é‡å­ç®—æ³•ï¼ˆä¹Ÿè¢«ç§°ä¸ºé‡å­å‚…é‡Œå¶å˜æ¢ï¼‰ï¼Œå…¶è¢«ç”¨äºæœ€è‘—åçš„é‡å­ç®—æ³•ï¼šShor\'s
factoring algorithmã€‚

#### 1.1 Simoné—®é¢˜

ç»™å‡ºä¸€ä¸ªæœªçŸ¥é»‘ç®±å‡½æ•°$f$ï¼Œè¯¥å‡½æ•°ä¿è¯ä¸€å¯¹ä¸€æˆ–äºŒå¯¹ä¸€ï¼Œå…¶ä¸­ä¸€å¯¹ä¸€å’ŒäºŒå¯¹ä¸€å…·å¤‡ä»¥ä¸‹å±æ€§ï¼š

-   ä¸€å¯¹ä¸€ï¼šä¸ºæ¯ä¸ªè¾“å…¥æ˜ å°„å”¯ä¸€è¾“å‡ºï¼Œå¦‚$f\left( 1 \right) \rightarrow 1$ã€$f\left( 2 \right) \rightarrow 2$ã€$f\left( 3 \right) \rightarrow 3$å’Œ$f\left( 4 \right) \rightarrow 4$ã€‚

-   äºŒå¯¹ä¸€ï¼šå°†ä¸¤ä¸ªè¾“å…¥æ˜ å°„å”¯ä¸€è¾“å‡ºï¼Œå¦‚ä¾æ®éšè—æ¯”ç‰¹å­—ä¸²$s$ï¼Œ$f\left( 1 \right) \rightarrow 1$ã€$f\left( 2 \right) \rightarrow 2$ã€$f\left( 3 \right) \rightarrow 1$å’Œ$f\left( 4 \right) \rightarrow 2$ã€‚å…¶ä¸­ï¼š

$${\text{given\ }x_{1},x_{2}:f\left( x_{1} \right) = f\left( x_{2} \right)
}{it\ is\ guaranteed\ :x_{1} \oplus x_{2} = b}$$

å› æ­¤æ‰€ç»™å‡ºçš„å‡½æ•°$f$æ˜¯é»‘ç®±å‡½æ•°ï¼Œæˆ‘ä»¬å¦‚ä½•å¿«é€Ÿç¡®å®šå‡½æ•°$f$æ˜¯ä¸€å¯¹ä¸€è¿˜æ˜¯äºŒå¯¹ä¸€ï¼Ÿå¦‚æœå‡½æ•°$f$æ˜¯è€ŒäºŒå¯¹ä¸€ï¼Œåˆ™å¦‚ä½•å¿«é€Ÿç¡®å®šéšè—æ¯”ç‰¹å­—ä¸²$b$ï¼Ÿäº‹å®è¯æ˜ï¼Œè¿™ä¸¤ç§æƒ…å†µå¯å½’ç»“ä¸ºåŒæ ·çš„é—®é¢˜------æ‰¾å‡º$s$ï¼Œå…¶ä¸­æ¯”ç‰¹å­—ä¸²$b = 000\ldots$è¡¨ç¤ºä¸€å¯¹ä¸€$f$ã€‚

#### 1.2 Simonç®—æ³•

##### ç»å…¸è§£æ³•

é€šå¸¸ï¼Œå¦‚æœæƒ³è¦100%ç¡®å®šç»™å®šå‡½æ•°$f$çš„å­—ä¸²$b$ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥$2^{N + 1} + 1$ä¸ªè¾“å…¥ï¼Œå…¶ä¸­$N$æ˜¯è¾“å…¥ä¸­æ¯”ç‰¹çš„æ•°é‡ï¼Œè¡¨æ˜éœ€è¦æ£€æŸ¥æ‰€æœ‰å¯èƒ½è¾“å…¥çš„ä¸€åŠä»¥ä¸Šç›´åˆ°æ‰¾å‡ºä¸¤ä¸ªè¾“å…¥äº§ç”ŸåŒä¸€è¾“å‡ºã€‚è¿™ä¸€ç‚¹ä¸Deutsch-Jozsaé—®é¢˜éå¸¸åƒï¼Œå¦‚æœå¹¸è¿çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å°è¯•çš„å‰ä¸¤æ¬¡å°±èƒ½è§£å†³è¿™ä»¥é—®é¢˜ã€‚ä½†æ˜¯å¦‚æœæ­£å¥½å‡½æ•°$f$æ˜¯ä¸€å¯¹ä¸€ï¼Œæˆ–è€…éå¸¸ä¸å¹¸çš„è·å¾—äº†äºŒå¯¹ä¸€çš„$f$ï¼Œé‚£ä¹ˆå°±åªèƒ½å¯¹å…¶$2^{N + 1} + 1$æ¬¡çš„è¾“å…¥æ£€æŸ¥ã€‚æœ‰ä¸€äº›å·²çŸ¥çš„ç®—æ³•æ‹¥æœ‰$\Omega\left( 2^{N\text{/2}} \right)$çš„ä¸‹ç•Œï¼ˆè§å‚è€ƒæ–‡çŒ®\[2\]ï¼‰ï¼Œä½†ä¸€èˆ¬æ¥è¯´å¤æ‚åº¦éšç€Nå‘ˆæŒ‡æ•°å¢é•¿ã€‚

##### é‡å­è§£æ³•

å¦‚ä¸‹æ˜¯ç”¨é‡å­å›è·¯å®ç°Simonç®—æ³•ï¼š

![image1](pics/media/image179.jpeg)

å…¶ä¸­æŸ¥è¯¢å‡½æ•°$Q_{f}$ä½œç”¨äºä¸¤ä¸ªé‡å­å¯„å­˜å™¨ï¼š

$$\left| x \right\rangle\left| a \right\rangle \rightarrow \left| x \right\rangle\left| a \oplus f\left( x \right) \right\rangle$$

åœ¨ç‰¹å®šçš„æƒ…å†µä¸‹,å¦‚ç¬¬äºŒå¯„å­˜å™¨å¤„äºæ€$|0\rangle = |00\ldots 0\rangle$ï¼š

$$\left| x \right\rangle\left| 0 \right\rangle \rightarrow \left| x \right\rangle\left| f\left( x \right) \right\rangle$$

è¯¥ç®—æ³•æ¶‰åŠä»¥ä¸‹æ­¥éª¤ï¼š

1\. ä¸¤ä¸ª$n$-é‡å­æ¯”ç‰¹å¯„å­˜å™¨åˆå§‹åŒ–ä¸º0çŠ¶æ€ï¼š

$$\left| \psi_{1} \right\rangle = \left| 0 \right\rangle^{\otimes n}\left| 0 \right\rangle^{\otimes n}$$

2\. å¯¹ç¬¬ä¸€å¯„å­˜å™¨åº”ç”¨é˜¿è¾¾é©¬å˜æ¢ï¼š

$$\left| \psi_{2} \right\rangle = \frac{1}{\sqrt{2^{n}}}\sum_{x \in {0,1}^{n}}^{}{\left| x \right\rangle\left| 0 \right\rangle^{\otimes n}}$$

3\. åº”ç”¨æŸ¥è¯¢å‡½æ•°$Q_{f}$ï¼š

$$\left| \psi_{3} \right\rangle = \frac{1}{\sqrt{2^{n}}}\sum_{x \in {0,1}^{n}}^{}{\left| x \right\rangle\left| f\left( x \right) \right\rangle}$$

4\.
å¯¹ç¬¬äºŒä¸ªå¯„å­˜å™¨è¿›è¡Œæµ‹é‡ï¼Œ$f\left( x \right)$çš„ç¡®å®šå€¼å°†ä¼šè¢«è§‚å¯Ÿåˆ°ã€‚ç”±äºè¿™ä¸€é—®é¢˜çš„è®¾ç½®ï¼Œ$f\left( x \right)$çš„è§‚æµ‹å€¼ä¸ä¸¤ä¸ªå¯èƒ½çš„è¾“å…¥ç›¸å¯¹åº”ï¼š$x$å’Œ$y = x\bigoplus_{}^{}b$ã€‚å› æ­¤ç¬¬ä¸€ä¸ªå¯„å­˜å™¨å˜ä¸ºï¼š

$$\left| \psi_{4} \right\rangle = \frac{1}{\sqrt{2}}(|x\rangle + |y\rangle)$$

ç”±äºå·²ç»å¯¹ç¬¬äºŒä¸ªå¯„å­˜å™¨è¿›è¡Œäº†æµ‹é‡ï¼Œæ‰€ä»¥å°†å…¶å¿½ç•¥ã€‚

5\. åœ¨ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸Šåº”ç”¨H-gateï¼š

$$\left| \psi_{5} \right\rangle = \frac{1}{\sqrt{2^{n + 1}}}\sum_{z \in {0,1}^{n}}^{}\left\lbrack \left( - 1 \right)^{x \bullet z} + \left( - 1 \right)^{y \bullet z} \right\rbrack\left| z \right\rangle$$

6\. æµ‹é‡ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¼šç»™å‡ºä¸€ä¸ªè¾“å‡ºï¼Œä»…å½“ï¼š

$$\left( - 1 \right)^{x \bullet z} = \left( - 1 \right)^{y \bullet z}$$

è¡¨æ˜ï¼š

$${x \bullet z = y \bullet z
}{x \bullet z = \left( x \oplus b \right) \bullet z
}{x \bullet z = x \bullet z \oplus b \bullet z
}{b \bullet z = 0\left( mod2 \right)}$$

ï¼ˆæ³¨ï¼š$x \equiv 0\left( mod2 \right)$è¡¨ç¤º$x$ä¸$0$åœ¨æ¨¡$2$ä¸‹æ˜¯åŒä½™çš„ï¼Œè¡¨æ˜$x$é™¤ä»¥$2$ä¸$0$é™¤ä»¥$2$ä½™æ•°ç›¸åŒï¼Œä¹Ÿå°±æ˜¯è¯´$x$æ˜¯ä¸ªå¶æ•°ã€‚ï¼‰

å­—ä¸²$z$ä¸$b$çš„å†…ç§¯å°†ä¼šè¢«æµ‹é‡åˆ°ã€‚å› æ­¤é‡å¤å¤§çº¦$n$æ¬¡ï¼Œæˆ‘ä»¬ä¼šè·å¾—$n$ä¸ªä¸åŒçš„$z$å€¼ï¼Œå¯ä»¥å†™å‡ºä»¥ä¸‹æ–¹ç¨‹ç»„ï¼š

$$\left\{ \begin{matrix}
b \cdot z_{1} = 0 \\
b \cdot z_{2} = 0 \\
 \vdots \\
b \cdot z_{n} = 0 \\
\end{matrix} \right.\ $$

å› æ­¤$b$å¯ä»¥è¢«ç¡®å®šï¼Œæ¯”å¦‚é€šè¿‡é«˜æ–¯æ¶ˆå…ƒæ³•ã€‚

æ‰€ä»¥åœ¨è¿™ä»¥ç‰¹æ®Šçš„é—®é¢˜ä¸­é‡å­ç®—æ³•ç›¸å¯¹äºç»å…¸ç®—æ³•æ‰€æ‰§è¡Œçš„æ­¥æ•°æŒ‡æ•°çº§å‡å°‘ã€‚å†ä¸€æ¬¡å¼ºè°ƒï¼Œæ‚¨å¯èƒ½å¾ˆéš¾æƒ³è±¡è¿™ä¸€ç®—æ³•çš„åº”ç”¨ï¼ˆå°½ç®¡å…¶å¯å‘äº†æœ€è‘—åçš„Shorç®—æ³•ï¼‰ï¼Œä½†å…¶æ„ä¹‰ä¸ºç¬¬ä¸€ä¸ªè¯æ˜é€šè¿‡ä½¿ç”¨é‡å­è®¡ç®—æœºè€Œéç»å…¸è®¡ç®—æœºåœ¨è§£å†³å…·ä½“é—®é¢˜æ—¶èƒ½å¤ŸæŒ‡æ•°å€åŠ é€Ÿã€‚

### 2. ç¤ºä¾‹

è®©æˆ‘ä»¬è§‚å¯Ÿä¸€ä¸ªå…·æœ‰åŒé‡å­æ¯”ç‰¹ä¸”ç§˜å¯†å­—ä¸²$b = 11$çš„ç¤ºä¾‹ï¼Œå› è€Œå¦‚æœ$y = x \oplus b$åˆ™$f\left( x \right) = f\left( y \right)$ã€‚è¿™ä¸€é‡å­å›è·¯è§£å†³å¦‚ä¸‹é—®é¢˜ï¼š

![](pics/media/image180.png)

1\. ä¸¤ä¸ªåŒé‡å­æ¯”ç‰¹è¾“å…¥å¯„å­˜å™¨æ—¶åˆå§‹åŒ–ä¸ºï¼š

$$\left| \psi_{1} \right\rangle = \left| 00 \right\rangle_{1}\left| 00 \right\rangle_{2}$$

2\. å¯¹ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸­çš„é‡å­æ¯”ç‰¹åº”ç”¨H-gateï¼š

$$\left| \psi_{2} \right\rangle = \frac{1}{2}(\left| 00 \right\rangle_{1} + \left| 01 \right\rangle_{1}{+ \left| 10 \right\rangle}_{1} + \left| 11 \right\rangle_{1})\left| 00 \right\rangle_{2}$$

3\.
å¯¹äºå­—ä¸²$b = 11$ï¼ŒæŸ¥è¯¢å‡½æ•°å®ç°ä¸º$Q_{f} = CX_{1_{a}2_{a}}CX_{1_{a}2_{b}}CX_{1_{b}2_{a}}CX_{1_{b}2_{b}}$ï¼š

$$ {\left| \psi_{3} \right\rangle = \frac{1}{2}(\left| 00 \right\rangle_{1}\left| 0 \oplus 0 \oplus 0,0 \oplus 0 \oplus 0 \right\rangle_{2}
}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  + \left| 01 \right\rangle_{1}\left| 0 \oplus 0 \oplus 1,0 \oplus 0 \oplus 1 \right\rangle_{2}
}{\text{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }{+ \left| 10 \right\rangle}_{1}\left| 0 \oplus 1 \oplus 0,0 \oplus 1 \oplus 0 \right\rangle_{2}
}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  + {|11\rangle}_{1}\left| 0 \oplus 1 \oplus 1,0 \oplus 1 \oplus 1 \right\rangle_{2})}$$

å› æ­¤

$$\left| \psi_{3} \right\rangle = \frac{1}{2}\left( \left| 00 \right\rangle_{1}\left| 00 \right\rangle_{2} + \left| 01 \right\rangle_{1}\left| 11 \right\rangle_{2} + \left| 10 \right\rangle_{1}\left| 11 \right\rangle_{2} + \left| 11 \right\rangle_{1}\left| 00 \right\rangle_{2} \right)$$

4\.
å¯¹ç¬¬äºŒå¯„å­˜å™¨è¿›è¡Œæµ‹é‡ï¼Œæµ‹å¾—ç»“æœä¸º$\left| 00 \right\rangle_{2}$å’Œ$\left| 11 \right\rangle_{2}$çš„æ¦‚ç‡å„ä½50%ã€‚ä¸ºäº†å®Œæˆè¿™ä¸€ç¤ºä¾‹ï¼Œæˆ‘ä»¬å‡è®¾ä¼šçœ‹åˆ°$\left| 11 \right\rangle_{2}$ï¼Œé‚£ä¹ˆç³»ç»Ÿçš„çŠ¶æ€å°†ä¸ºï¼š

$$\left| \psi_{4} \right\rangle = \frac{1}{\sqrt{2}}\left( \left| 01 \right\rangle_{1} + \left| 10 \right\rangle_{1} \right)$$

æ­¤æ—¶ç”±äºç¬¬äºŒå¯„å­˜å™¨å·²ç»è¢«æµ‹é‡ï¼Œæ‰€ä»¥å°†å…¶å¿½ç•¥ã€‚

5\. å¯¹ç¬¬ä¸€ä¸ªå¯„å­˜å™¨åº”ç”¨H-gateï¼š

$${\left| \psi_{5} \right\rangle = \frac{1}{2\sqrt{2}}\left\lbrack \left( \left| 0 \right\rangle + \left| 1 \right\rangle \right)\bigotimes\left( \left| 0 \right\rangle - \left| 1 \right\rangle \right) + \left( \left| 0 \right\rangle - \left| 1 \right\rangle \right)\bigotimes\left( \left| 0 \right\rangle + \left| 1 \right\rangle \right) \right\rbrack
}{\ \ \ \ \ \ \ \ \ \  = \frac{1}{2\sqrt{2}}\lbrack|00\rangle - |01\rangle + |10\rangle - |11\rangle + |00\rangle + |01\rangle - |10\rangle - |11\rangle\rbrack
}{\ \ \ \ \ \ \ \ \ \  = \frac{1}{2\sqrt{2}}(|00\rangle - |01\rangle)}$$

6\.
å¯¹ç¬¬ä¸€å¯„å­˜å™¨è¿›è¡Œæµ‹é‡ä¼šä»¥ç­‰æ¦‚ç‡å¾—åˆ°$\left| 00 \right\rangle$æˆ–$\left| 11 \right\rangle$ã€‚

7\. å¦‚æœæµ‹å¾—çš„ç»“æœä¸º$\left| 11 \right\rangle$ï¼Œåˆ™ï¼š

$$b \cdot 11 = 0$$

è¿™å°±è¯´æ˜$b \neq 01$æˆ–$10$ï¼Œåˆ™å‰©ä¸‹çš„ä¸¤ä¸ªå¯èƒ½è§£ä¸º$b = 00$æˆ–$b = 11$ã€‚æ³¨æ„ï¼Œ$b = 00$æ°¸è¿œæ˜¯è”ç«‹æ–¹ç¨‹çš„ä¸€ä¸ªå¹³å‡¡è§£ã€‚å¦‚æœå¤šæ¬¡é‡å¤æ­¥éª¤1-6ï¼Œæˆ‘ä»¬å°†ä»…ä¼šæµ‹é‡$|00\rangle$æˆ–$|11\rangle$ä¸ºï¼š

$$b \cdot 11 = 0$$

$$b \cdot 00 = 0$$

æ˜¯å”¯ä¸€æ»¡è¶³$b = 11$çš„æ–¹ç¨‹ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡é€‰å–ä¸€ä¸ªéšæœºè¾“å…¥$\left( x_{i} \right)$å¹¶æ£€æŸ¥$f\left( x_{i} \right) = f\left( x_{i} \oplus b \right)$æ¥éªŒè¯$b = 11$ã€‚ä¾‹å¦‚ï¼š

$$01 \oplus b = 10$$

$$f\left( 01 \right) = f\left( 10 \right) = 11$$

### 3. Qiskitå®ç°

ç°åœ¨æˆ‘ä»¬åœ¨å°†åœ¨Qiskitä¸­é€šè¿‡ä¸€ä¸ª3-é‡å­æ¯”ç‰¹ä¸”$b = 110$çš„ç¤ºä¾‹æ¥å®ç°Simonç®—æ³•ã€‚

\# importing Qiskit

from qiskit import IBMQ, BasicAer

from qiskit.providers.ibmq import least_busy

from qiskit import QuantumCircuit, execute

\# import basic plot tools

from qiskit.visualization import plot_histogram

from qiskit_textbook.tools import simon_oracle

ä¸Šé¢å¯¼å…¥çš„å‡½æ•°simon_oracleä¸ºä½å­—ä¸²båˆ›å»ºäº†Simonè¯­è¨€ã€‚æ­¤å¤„æ²¡æœ‰ç»™å‡ºè§£é‡Šï¼Œä½†æ˜¯æˆ‘ä»¬å°†åœ¨ç¬¬4èŠ‚ä¸­è®¨è®ºè¿™ä¸ªæ–¹æ³•ã€‚

åœ¨Qiskitä¸­ä»…åœ¨é‡å­å›è·¯çš„æœ«ç«¯æ‰èƒ½æµ‹é‡ã€‚å®é™…ä¸Šï¼Œåœ¨Simonç®—æ³•ä¸­æˆ‘ä»¬å¹¶ä¸å…³å¿ƒç¬¬äºŒå¯„å­˜å™¨é¢è¾“å‡ºï¼Œæ•…ä»…æµ‹é‡ç¬¬ä¸€å¯„å­˜å™¨ã€‚

> The function simon_oracle (imported above) creates a Simon oracle for
> the bitstring b. This is given without explanation, but we will
> discuss the method in section 4.b = \'110\'
>
> n = len(b)
>
> simon_circuit = QuantumCircuit(n\*2, n)
>
> \# Apply Hadamard gates before querying the oracle
>
> simon_circuit.h(range(n))
>
> \# Apply barrier for visual separation
>
> simon_circuit.barrier()
>
> simon_circuit += simon_oracle(b)
>
> \# Apply barrier for visual separation
>
> simon_circuit.barrier()
>
> \# Apply Hadamard gates to the input register
>
> simon_circuit.h(range(n))
>
> \# Measure qubits
>
> simon_circuit.measure(range(n), range(n))
>
> simon_circuit.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image181.png)

#### 3.1 é€šè¿‡æ¨¡æ‹Ÿå™¨å®éªŒ

åœ¨æ¨¡æ‹Ÿå™¨ä¸­è¿è¡Œä¸Šé¢çš„é‡å­å›è·¯ï¼š

> \# use local simulator
>
> backend = BasicAer.get_backend(\'qasm_simulator\')
>
> shots = 1024
>
> results = execute(simon_circuit, backend=backend,
> shots=shots).result()
>
> counts = results.get_counts()
>
> plot_histogram(counts)
>
> è¾“å‡ºï¼š

![](pics/media/image182.png)

ç”±äºæˆ‘ä»¬å·²ç»çŸ¥é“$b$çš„å€¼ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç»“æœæ˜¯å¦æ»¡è¶³$b \cdot z = 0(mod2)$æ¥éªŒè¯ï¼š

> \# Calculate the dot product of the results
>
> def bdotz(b, z):
>
> accum = 0
>
> for i in range(len(b)):
>
> accum += int(b\[i\]) \* int(z\[i\])
>
> return (accum % 2)
>
> for z in counts:
>
> print( \'{}.{} = {} (mod 2)\'.format(b, z, bdotz(b,z)) )
>
> è¾“å‡ºï¼š
>
> 110.000 = 0 (mod 2)
>
> 110.001 = 0 (mod 2)
>
> 110.111 = 0 (mod 2)
>
> 110.110 = 0 (mod 2)

åˆ©ç”¨è¿™äº›ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ±‚è§£è¿™ç»„è”ç«‹æ–¹ç¨‹æ¥æ­ç¤º$b = 110$çš„å€¼ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬ç¬¬ä¸€æ¬¡æµ‹å¾—001ï¼š

$$\begin{matrix}
b \cdot 001 & = 0 \\
(b_{2} \cdot 0) + (b_{1} \cdot 0) + (b_{0} \cdot 0) & = 0 \\
(\boxed{b_{2} \cdot 0}) + (\boxed{b_{1} \cdot 0}) + (b_{0} \cdot 1) & = 0 \\
b_{0} & = 0 \\
\end{matrix}$$

å¦‚æœæ¥ç€æµ‹å¾—111ï¼š

$$\begin{matrix}
b \cdot 111 & = 0 \\
(b_{2} \cdot 1) + (b_{1} \cdot 1) + (\boxed{0 \cdot 1}) & = 0 \\
(b_{2} \cdot 1) + (b_{1} \cdot 1) & = 0 \\
\end{matrix}$$

åˆ™å‘Šè¯‰æˆ‘ä»¬ï¼š

$$b_{2} = b_{1} = 0,b = 000$$

æˆ–ï¼š

$$b_{2} = b_{1} = 1,b = 110$$

å…¶ä¸­$b = 110$æ˜¯è”ç«‹æ–¹ç¨‹çš„éå¹³å‡¡è§£ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨é«˜æ–¯æ¶ˆå…ƒæ³•æ¥è§£å†³è¿™äº›é—®é¢˜ï¼Œä½†é«˜æ–¯æ¶ˆå…ƒæ³•çš„è¿è¡Œæ—¶é—´ä¸º$O(n_{3})$ã€‚

#### 3.2 åœ¨çœŸå®çš„è®¾å¤‡ä¸Šå®éªŒ

åœ¨ä¸Šä¸€èŠ‚ä¸­çš„é‡å­å›è·¯ç”¨åˆ°äº†$2n = 6$ä¸ªé‡å­æ¯”ç‰¹ï¼Œä½†åœ¨ç¼–å†™æœ¬ç« å†…å®¹æ—¶å¤šæ•°IBMé‡å­è®¾å¤‡ä»…æœ‰5ä¸ªé‡å­æ¯”ç‰¹ã€‚æˆ‘ä»¬å°†ä¼šè¿è¡Œä¸ä¸ŠèŠ‚ä¸­ç›¸åŒçš„ä»£ç ï¼Œä½†å°†ä½¿ç”¨ç¬¬äºŒèŠ‚ä¸­çš„$b = 11$ä»£æ›¿$b = 110$ï¼Œå› æ­¤ä»…éœ€è¦4ä¸ªé‡å­æ¯”ç‰¹ã€‚

> b = \'11\'
>
> n = len(b)
>
> simon_circuit_2 = QuantumCircuit(n\*2, n)
>
> \# Apply Hadamard gates before querying the oracle
>
> simon_circuit_2.h(range(n))
>
> \# Query oracle
>
> simon_circuit_2 += simon_oracle(b)
>
> \# Apply Hadamard gates to the input register
>
> simon_circuit_2.h(range(n))
>
> \# Measure qubits
>
> simon_circuit_2.measure(range(n), range(n))
>
> simon_circuit_2.draw()

![](pics/media/image183.png)

æ­¤å›è·¯ä¸ç¬¬2èŠ‚æ‰€ç¤ºçš„å›è·¯ç•¥æœ‰ä¸åŒã€‚è¾“å‡ºæ˜¯ä¸åŒçš„ï¼Œä½†è¾“å…¥é æ¥ç›¸åŒï¼Œå³ä¸¤è€…éƒ½å…·æœ‰$f(x) = f(x \oplus 11)$çš„æ€§è´¨ã€‚

> \# Load our saved IBMQ accounts and get the least busy backend device
> with less than or equal to 5 qubits
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> backend = least_busy(provider.backends(filters=lambda x:
> x.configuration().n_qubits \>= n and
>
> not x.configuration().simulator and x.status().operational==True))
>
> print(\"least busy backend: \", backend)
>
> \# Execute and monitor the job
>
> from qiskit.tools.monitor import job_monitor
>
> shots = 1024
>
> job = execute(simon_circuit_2, backend=backend, shots=shots,
> optimization_level=3)
>
> job_monitor(job, interval = 2)
>
> \# Get results and plot counts
>
> device_counts = job.result().get_counts()
>
> plot_histogram(device_counts)
>
> è¾“å‡ºï¼š
>
> least busy backend: ibmq_burlington
>
> Job Status: job has successfully run

![](pics/media/image184.png)

> \# Calculate the dot product of the results
>
> def bdotz(b, z):
>
> accum = 0
>
> for i in range(len(b)):
>
> accum += int(b\[i\]) \* int(z\[i\])
>
> return (accum % 2)
>
> print(\'b = \' + b)
>
> for z in device_counts:
>
> print( \'{}.{} = {} (mod 2) ({:.1f}%)\'.format(b, z, bdotz(b,z),
> device_counts\[z\]\*100/shots))
>
> è¾“å‡ºï¼š
>
> b = 11
>
> 11.00 = 0 (mod 2) (49.2%)
>
> 11.11 = 0 (mod 2) (32.0%)
>
> 11.10 = 1 (mod 2) (9.1%)
>
> 11.01 = 1 (mod 2) (9.7%)

æ­£å¦‚è¾“å‡ºæ‰€ç¤ºï¼Œæœ€æ˜¾è‘—çš„ç»“æœæ˜¯$b \cdot z = 0\left( mod2 \right)$ã€‚å…¶ä»–ç»“æœæ˜¯é”™è¯¯çš„ï¼Œä½†å‘ç”Ÿçš„æ¦‚ç‡è¾ƒä½ã€‚å‡è®¾æˆ‘ä»¬ä¸å¤ªå¯èƒ½æµ‹å¾—é”™è¯¯çš„ç»“æœï¼Œç„¶åæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç»å…¸è®¡ç®—æœºé€šè¿‡æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„æ¥æ­ç¤ºbçš„å€¼ã€‚å¯¹äºè¿™ä¸€$n = 2$çš„æƒ…å†µï¼Œ$b = 11$ã€‚

### 4. é¢„è¨€

ä¸Šè¿°Simonç®—æ³•çš„ç¤ºä¾‹å’Œå®ç°éƒ½ç‰¹å®šäº$b$çš„å€¼ã€‚ä¸ºèƒ½å¤Ÿå°†è¿™ä¸€é—®é¢˜æ‰©å±•è‡³å…¶ä»–ç§˜å¯†æ¯”ç‰¹å­—ä¸²ï¼Œæˆ‘ä»¬éœ€è¦è®¨è®ºSimonæŸ¥è¯¢å‡½æ•°æˆ–é¢„è¨€çš„æ›´å¤šç»†èŠ‚ã€‚

Simonç®—æ³•ç”¨äºå¤„ç†æ‰¾å‡ºé¢„è¨€$f_{s}$çš„éšè—å­—ä¸²$b \in {0,1}^{n}$ï¼Œé¢„è¨€$f_{b}$å¯¹äºæ‰€æœ‰$x \in {0,1}^{n}$æ»¡è¶³$f_{b}\left( x \right) = f_{b}\left( y \right)$ï¼Œå½“ä¸”ä»…å½“$y = x \oplus b$ã€‚æ­¤å¤„çš„$\oplus$æ˜¯é€ä½çš„å¼‚æˆ–è¿ç®—ï¼ˆXOR
operationï¼‰ã€‚å› æ­¤ï¼Œå¦‚æœ$b = 0\ldots 0$ï¼ˆå¦‚å…¨é›¶æ¯”ç‰¹å­—ä¸²ï¼‰ï¼Œé‚£ä¹ˆ$f_{b}$æ˜¯ä¸€ä¸ªä¸€å¯¹ä¸€ï¼ˆæ’åˆ—ï¼Œpermutationï¼‰å‡½æ•°ã€‚å¦åˆ™ï¼Œå¦‚æœ$b \neq 0\ldots 0$åˆ™$f_{b}$æ˜¯ä¸€ä¸ªäºŒå¯¹ä¸€å‡½æ•°ã€‚

åœ¨è¿™ä¸€ç®—æ³•ä¸­ï¼Œè¯¥é¢„è¨€æ¥æ”¶$\left| x \right\rangle\left| 0 \right\rangle$ä½œä¸ºè¾“å…¥ã€‚å¯¹äºé¢„å®šçš„$b$ï¼Œé¢„è¨€å°†å…¶è¾“å‡ºå†™å…¥ç¬¬äºŒä¸ªå¯„å­˜å™¨ï¼Œæ•…è¯¥é¢„è¨€å°†è¾“å…¥è½¬æ¢ä¸º$\left| x \right\rangle\left| f_{b}\left( x \right) \right\rangle$ï¼Œå¯¹äºæ‰€æœ‰$x \in {0,1}^{n}$ä½¿å¾—$f\left( x \right) = f\left( x \oplus b \right)$ã€‚

æ­¤ç±»çš„é»‘ç®±å‡½æ•°å¯ä»¥é€šè¿‡ä»¥ä¸‹ç¨‹åºå®ç°ã€‚

-   å°†ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸­çš„å†…å®¹å¤åˆ¶è‡³ç¬¬äºŒå¯„å­˜å™¨ã€‚

$$\left| x \right\rangle\left| 0 \right\rangle \rightarrow \left| x \right\rangle\left| x \right\rangle$$

-   ï¼ˆ**åˆ›å»º1-to-1æˆ–2-to-2æ˜ å°„**ï¼‰å¦‚æœ$s$å¹¶éå…¨é›¶ï¼Œé‚£ä¹ˆè‡³å°‘æœ‰ä¸€ä¸ªç´¢å¼•$j$ä½¿å¾—$s_{j} = 1$ã€‚å¦‚æœ$x_{j} = 1$,ç„¶åä½¿ç”¨$s$å¯¹ç¬¬äºŒå¯„å­˜å™¨æ‰§è¡Œå¼‚æˆ–æ“ä½œï¼Œå¦åˆ™ä¸æ”¹å˜ç¬¬äºŒå¯„å­˜å™¨ã€‚

$$\left| x \right\rangle\left| x \right\rangle \rightarrow \left| x \right\rangle\left| x \oplus s \right\rangle\text{\ \ if\ \ }x_{j} = 0\ \ for\ the\ least\ index\ j$$

-   ï¼ˆ**åˆ›å»ºéšæœºæ’åˆ—**ï¼‰éšæœºæ’åˆ—å’Œç¿»è½¬ç¬¬äºŒä¸ªå¯„å­˜å™¨çš„é‡å­æ¯”ç‰¹ã€‚

$$\left| x \right\rangle\left| y \right\rangle \rightarrow \left| x \right\rangle\left| f_{b}\left( y \right) \right\rangle$$

### 5. ç»ƒä¹ 

1\. å®ç°ä¸€ä¸ªé€šç”¨Simoné¢„è¨€ã€‚

2\.
åœ¨æ¨¡æ‹Ÿå™¨å’ŒçœŸå®è®¾å¤‡ä¸Šç”¨ç§˜å¯†æ¯”ç‰¹å­—ä¸²$s = 1001$æµ‹è¯•æ‰€å»ºçš„é€šç”¨é¢„è¨€ã€‚ç»“æœæ˜¯å¦å¦‚æœŸæœ›çš„ä¸€æ ·ï¼Ÿä¸ºä½•ï¼Ÿ

### 6. å‚è€ƒæ–‡çŒ®

1\. Daniel R. Simon (1997) \"On the Power of Quantum Computation\" SIAM
Journal on Computing, 26(5), 1474--1483,
[doi:10.1137/S0097539796298637](https://doi.org/10.1137/S0097539796298637)

2\. Guangya Cai and Daowen Qiu. Optimal separation in exact query
complexities for Simon\'s problem. Journal of Computer and System
Sciences 97: 83-93, 2018, <https://doi.org/10.1016/j.jcss.2018.05.001>

3.7 é‡å­å‚…é‡Œå¶å˜æ¢
------------------

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šä»‹ç»é‡å­å‚…é‡Œå¶å˜æ¢ï¼ˆquantum fourier transform
QFTï¼‰ï¼Œå¯¼å‡ºå…¶é‡å­å›è·¯ï¼Œå¹¶åœ¨Qiskitä¸­å®ç°ã€‚æœ¬èŠ‚ä¸­çš„å†…å®¹è¿˜å°†å±•ç¤ºå¦‚ä½•åœ¨æ¨¡æ‹Ÿå™¨å’Œ5ä¸ªé‡å­æ¯”ç‰¹çš„è®¾å¤‡ä¸Šè¿è¡ŒQFTã€‚

### å†…å®¹

1\. ç®€ä»‹

2\. ç›´è§‰ï¼ˆIntuitionï¼‰

2.1 ä»¥å‚…é‡Œå¶åŸºï¼ˆFourier Basisï¼‰è®¡æ•°

3\. ç¤ºä¾‹1ï¼šå•é‡å­æ¯”ç‰¹QFT

4\. é‡å­å‚…é‡Œå¶å˜æ¢

5\. å®ç°QFTçš„é‡å­å›è·¯

6\. ç¤ºä¾‹2ï¼š3-é‡å­æ¯”ç‰¹QFT

7\. QFTå›è·¯å½¢å¼çš„æ³¨æ„äº‹é¡¹

8\. Qiskitå®ç°

8.1 3-é‡å­æ¯”ç‰¹ç¤ºä¾‹

8.2 é€šç”¨QFTå‡½æ•°

8.3 åœ¨çœŸå®çš„è®¾å¤‡ä¸Šè¿è¡ŒQFT

9\. ç»ƒä¹ 

10\. å‚è€ƒæ–‡çŒ®

### 1. ç®€ä»‹

å‚…é‡Œå¶å˜æ¢åœ¨ç»å…¸è®¡ç®—ä¸­æœ‰è®¸å¤šä¸åŒçš„ç‰ˆæœ¬ï¼Œæ‰€æ¶‰åŠçš„é¢†åŸŸä»ä¿¡å·å¤„ç†åˆ°æ•°æ®å‹ç¼©ä»¥åŠå¤æ‚æ€§ç†è®ºã€‚

é‡å­å‚…é‡Œå¶å˜æ¢ï¼ˆQFTï¼‰æ˜¯å¯¹æ³¢å‡½æ•°çš„å¹…å€¼è¿›è¡Œç¦»æ•£å‚…é‡Œå¶å˜æ¢çš„é‡å­å®ç°ã€‚QFTæ˜¯è®¸å¤šé‡å­ç®—æ³•çš„ä¸€éƒ¨åˆ†ï¼Œå…¶ä¸­æœ€è‘—åçš„æ˜¯Shorå› å¼ç®—æ³•ï¼ˆSFAï¼‰å’Œé‡å­ç›¸ä½ä¼°è®¡ã€‚

ç¦»æ•£å‚…é‡Œå¶å˜æ¢ä¾æ®å¦‚ä¸‹ç­‰å¼å°†å‘é‡$\left( x_{0},\ldots,x_{N - 1} \right)$æ˜ å°„ä¸ºå‘é‡$\left( y_{0},\ldots,y_{N - 1} \right)$ï¼š

$$y_{k} = \frac{1}{\sqrt{N}}\sum_{j = 0}^{N - 1}{x_{j}\omega_{N}^{\text{jk}}}$$

å…¶ä¸­$\omega_{N}^{\text{jk}} = e^{2\pi i\frac{\text{jk}}{N}}$ã€‚

åŒæ ·çš„ï¼Œé‡å­å‚…é‡Œå¶å˜æ¢ä¾æ®å¦‚ä¸‹ç­‰å¼å°†é‡å­æ€$\sum_{i = 0}^{N - 1}{x_{i}\left| i \right\rangle}$æ˜ å°„ä¸ºé‡å­æ€$\sum_{i = 0}^{N - 1}{y_{i}\left| i \right\rangle}$ï¼š

$$y_{k} = \frac{1}{\sqrt{N}}\sum_{j = 0}^{N - 1}{x_{j}\omega_{N}^{\text{jk}}}$$

å…¶ä¸­$\omega_{N}^{\text{jk}} = e^{2\pi i\frac{\text{jk}}{N}}$ã€‚å¯ä»¥æ³¨æ„åˆ°è¿™ä¸€å˜æ¢ä»…å¯¹é‡å­æ€çš„å¹…å€¼æœ‰æ•ˆã€‚

è¿™ä¸€å˜æ¢è¿˜å¯ä»¥è¡¨ç¤ºä¸ºæ˜ å°„ï¼š

$$\left| x \right\rangle \longmapsto \frac{1}{\sqrt{N}}\sum_{y = 0}^{N - 1}{\omega_{N}^{\text{xy}}\left| y \right\rangle}$$

æˆ–è¡¨ç¤ºä¸ºå¹ºæ­£çŸ©é˜µï¼š

$$U_{\text{QFT}} = \frac{1}{\sqrt{N}}\sum_{x = 0}^{N - 1}{\sum_{y = 0}^{N - 1}{\omega_{N}^{\text{xy}}\left| y \right\rangle\left\langle x \right|}}$$

### 2. ç›´è§‰

é‡å­å‚…é‡Œå¶å˜æ¢æ˜¯åœ¨ä¸¤ä¸ªåŸºä¹‹é—´è¿›è¡Œï¼šè®¡ç®—åŸºï¼ˆZï¼‰ä¸å‚…é‡Œå¶åŸºï¼ˆFourier
basisï¼‰ã€‚H-gateå°±æ˜¯å•é‡å­æ¯”ç‰¹QFTï¼Œå…¶å°†å¤„äºæ€$\left| 0 \right\rangle$å’Œ$\left| 1 \right\rangle$çš„Z-åŸºå˜æ¢ä¸ºå¤„äºæ€$\left| + \right\rangle$å’Œ$\left| 1 \right\rangle$çš„X-åŸºã€‚è¿ç”¨åŒæ ·çš„æ–¹æ³•ï¼Œæ‰€æœ‰è®¡ç®—åŸºï¼ˆcomputational
basisï¼‰ä¸­å¤šé‡å­æ¯”ç‰¹çš„çŠ¶æ€éƒ½åœ¨å‚…é‡Œå¶åŸºä¸­æœ‰å¯¹åº”çš„çŠ¶æ€ã€‚QFTä»…æ˜¯åœ¨è¿™äº›åŸºä¸­è¿›è¡Œå˜æ¢çš„ç®€å•å‡½æ•°ï¼š

$$\left| \text{StateinComputationalBasis} \right\rangle\overset{\text{QFT}}{\rightarrow}\left| \text{StateinFourierBasis} \right\rangle$$

$$\text{QFT}\left| x \right\rangle = \left| \widetilde{x} \right\rangle$$

ï¼ˆæˆ‘ä»¬ç»å¸¸ç”¨æ³¢æµªå·ï¼ˆ\~ï¼‰è¡¨ç¤ºå‚…é‡Œå¶åŸºä¸­çš„çŠ¶æ€ã€‚ï¼‰

#### 2.1 ä»¥å‚…é‡Œå¶åŸºï¼ˆFourier Basisï¼‰è®¡æ•°

åœ¨è®¡ç®—åŸºä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨æ€$\left| 0 \right\rangle$å’Œ$\left| 1 \right\rangle$ä»¥äºŒè¿›åˆ¶çš„å½¢å¼å­˜å‚¨æ•°å­—ã€‚

![](pics/media/image185.gif)

æ³¨æ„ä¸åŒé‡å­æ¯”ç‰¹çš„å˜åŒ–é¢‘ç‡ï¼›æœ€å·¦è¾¹çš„é‡å­æ¯”ç‰¹æ¯å¢åŠ ä¸€æ¬¡å°±ç¿»è½¬ä¸€æ¬¡ï¼Œä¸‹ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸ºæ¯å¢åŠ 2æ¬¡ï¼Œç¬¬ä¸‰ä¸ªé‡å­æ¯”ç‰¹ä¸ºæ¯å¢åŠ 4æ¬¡ï¼Œä»¥æ­¤ç±»æ¨ã€‚åœ¨å‚…é‡Œå¶åŸºä¸Šï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸åŒç»•Zè½´çš„æ—‹è½¬æ¥å­˜å‚¨æ•°å­—ï¼š

![](pics/media/image186.gif)

æˆ‘ä»¬æƒ³è¦å­˜å‚¨çš„æ•°å­—å†³å®šäº†æ¯ä¸ªé‡å­æ¯”ç‰¹ç»•Zè½´æ—‹è½¬çš„è§’åº¦ã€‚ä»¥æ€$\left| \widetilde{0} \right\rangle$ä¸ºä¾‹ï¼Œæ‰€æœ‰é‡å­æ¯”ç‰¹éƒ½å¤„äºæ€$\left| + \right\rangle$ã€‚å¦‚ä¸Šé¢çš„å›¾ç‰‡æ‰€ç¤ºï¼Œè¦åœ¨3ä¸ªé‡å­æ¯”ç‰¹ä¸­ç¼–ç æ€$\left| \widetilde{5} \right\rangle$ï¼Œéœ€è¦å°†æœ€å·¦è¾¹çš„é‡å­æ¯”ç‰¹æ—‹è½¬$\frac{5}{2^{n}} = \frac{5}{8} \times 2\pi$ã€‚ä¸‹ä¸€ä¸ªé‡å­æ¯”ç‰¹æ—‹è½¬ä¸¤å€çš„è§’åº¦ï¼ˆ$\frac{10}{8} \times 2\pi$ï¼‰ï¼Œå†ä¸‹ä¸€ä¸ªæ—‹è½¬è§’åº¦å†åŠ å€ï¼Œä»¥æ­¤ç±»æ¨ã€‚

å†æ¬¡å¼ºè°ƒï¼Œæ³¨æ„ä¸åŒé‡å­æ¯”ç‰¹çš„å˜åŒ–é¢‘ç‡ã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œå¤„äºæœ€å·¦è¾¹çš„é‡å­æ¯”ç‰¹çš„æ—‹è½¬é¢‘ç‡æœ€å°ï¼Œæœ€å³è¾¹çš„æœ€å¤§ã€‚

### 3. ç¤ºä¾‹1ï¼š1-é‡å­æ¯”ç‰¹ QFT

æ€è€ƒå¦‚ä½•å°†ä¸Šè¿°çš„QFTæ“ä½œä½œç”¨äºå¤„äºæ€$\left| \psi \right\rangle = \alpha\left| 0 \right\rangle + \beta\left| 1 \right\rangle$çš„å•ä¸ªé‡å­æ¯”ç‰¹ä¸Šã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œ$x_{0} = \alpha$ã€$x_{1} = \beta$ä»¥åŠ$N = 2$ï¼Œåˆ™ï¼š

$$y_{0} = \frac{1}{\sqrt{2}}\left( \alpha\exp\left( 2\pi i\frac{0 \times 0}{2} \right) + \beta\exp\left( 2\pi i\frac{1 \times 0}{2} \right) \right) = \frac{1}{\sqrt{2}}\left( \alpha + \beta \right)$$

ä»¥åŠ

$$y_{1} = \frac{1}{\sqrt{2}}\left( \alpha\exp\left( 2\pi i\frac{0 \times 1}{2} \right) + \beta\exp\left( 2\pi i\frac{1 \times 1}{2} \right) \right) = \frac{1}{\sqrt{2}}\left( \alpha - \beta \right)$$

å› æ­¤æœ€ç»ˆç»“æœä¸ºæ€ï¼š

$U_{\text{QFT}}\left| \psi \right\rangle = \frac{1}{\sqrt{2}}\left( \alpha + \beta \right)\left| 0 \right\rangle - \frac{1}{\sqrt{2}}\left( \alpha - \beta \right)\left| 1 \right\rangle$

è¿™ä¸€æ“ä½œæ­£æ˜¯åœ¨ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨é˜¿è¾¾é©¬ç®—å­ï¼ˆ$H$ï¼‰çš„ç»“æœï¼š

$$H = \frac{1}{\sqrt{2}}\left\lbrack \begin{matrix}
1 \\
1 \\
\end{matrix}\ \begin{matrix}
1 \\
 - 1 \\
\end{matrix} \right\rbrack$$

å¦‚æœæˆ‘ä»¬å°†$H$ç®—å­åº”ç”¨äºæ€$\left| \psi \right\rangle = \alpha\left| 0 \right\rangle + \beta\left| 1 \right\rangle$ï¼Œå°†ä¼šè·å¾—ä¸€ä¸ªæ–°çš„çŠ¶æ€ï¼š

$$\frac{1}{\sqrt{2}}\left( \alpha + \beta \right)\left| 0 \right\rangle - \frac{1}{\sqrt{2}}\left( \alpha - \beta \right)\left| 1 \right\rangle \equiv \widetilde{\alpha}\left| 0 \right\rangle + \widetilde{\beta}\left| 1 \right\rangle$$

å¯ä»¥æ³¨æ„åˆ°é˜¿è¾¾é©¬é—¨å¦‚ä½•åœ¨é‡å­æ€çš„å¹…å€¼ä¸Šæ‰§è¡Œ$N = 2$çš„ç¦»æ•£å‚…é‡Œå¶å˜æ¢ã€‚

### 4. é‡å­å‚…é‡Œå¶å˜æ¢

å¾ˆå¤§æ•°é‡$N$çš„QFTä¼šæ˜¯ä»€ä¹ˆæ ·å­å‘¢ï¼Ÿè®©æˆ‘ä»¬æ¨å¯¼ä¸€ä¸‹ä½œç”¨äºæ€$\left| x \right\rangle = \left| x_{1}\ldots x_{n} \right\rangle$çš„$N = 2^{n}$çš„$\text{QFT}_{N}$çš„å˜åŒ–å¼ï¼Œå…¶ä¸­$x_{1}$æ˜¯æœ€é«˜æœ‰æ•ˆä½ï¼ˆ*most
significant
bitï¼ŒMSBï¼šæŒ‡å¤šå­—èŠ‚åºåˆ—ä¸­å…·æœ‰æœ€å¤§æƒé‡çš„å­—èŠ‚*ï¼‰ã€‚è¿™é‡Œçš„æ•°å­¦æ˜¯ä¸ºé‚£äº›å‘ç°å…¶æœ‰ç”¨çš„äººå‡†å¤‡çš„ï¼Œå¦‚æœæ‚¨æ„¿æ„åŒå…¶æ–—äº‰ï¼Œé‚£ä¹ˆå°±ä¸å¿…æ‹…å¿ƒï¼›åªè¦æ‚¨èƒ½å¤Ÿç†è§£ä¸Šæ–‡ä¸­ç›´è§‰éƒ¨åˆ†çš„å†…å®¹ï¼Œå°±å¯ä»¥ç›´æ¥è¿›å…¥ä¸‹ä¸€éƒ¨åˆ†å†…å®¹çš„å­¦ä¹ ã€‚
$$ {U_{\text{QFT}}\left| x \right\rangle = \frac{1}{\sqrt{N}}\sum_{y = 0}^{N - 1}{\omega_{N}^{\text{xy}}\left| y \right\rangle}
}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  = \frac{1}{\sqrt{N}}\sum_{y = 0}^{N - 1}{e^{2\pi ix\frac{y}{2^{n}}}\left| y \right\rangle}\ å› \ \omega_{N}^{\text{xy}} = e^{2\pi i\frac{\text{xy}}{N}}\ ä»¥åŠ\ N = 2^{n}
}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  = \frac{1}{\sqrt{N}}\sum_{y = 0}^{N - 1}{e^{2\pi i\left( \sum_{k = 1}^{n}\frac{y_{k}}{2^{k}} \right)x}\left| y_{1}\cdots y_{n} \right\rangle}}$$

$$= \frac{1}{\sqrt{N}}\sum_{y = 0}^{N - 1}{\prod_{k = 1}^{n}e^{2\pi ix\frac{y_{k}}{2^{k}}}\left| y_{1}\cdots y_{n} \right\rangle}$$

å°†å’Œçš„æŒ‡æ•°å±•å¼€ä¸ºæŒ‡æ•°çš„ç§¯åï¼š

$$= \frac{1}{\sqrt{N}}{\bigotimes_{}^{}\left( \left| 0 \right\rangle + e^{\frac{2\pi ix}{2^{k}}}\left| 1 \right\rangle \right)}_{k = 1}^{n}$$

é‡æ–°æ’åˆ—å’Œä¸ç§¯å¹¶å±•å¼€$\sum_{y = 0}^{N - 1}{= \sum_{y_{1} = 0}^{1}{\sum_{y_{2} = 0}^{1}{\cdots\sum_{y_{n} = 0}^{1}}}}$

$$= \frac{1}{\sqrt{N}}(\left| 0 \right\rangle + e^{\frac{2\pi i}{2}x}\left| 1 \right\rangle)\bigotimes(\left| 0 \right\rangle + e^{\frac{2\pi i}{2^{2}}x}\left| 1 \right\rangle)\bigotimes\cdots\bigotimes(\left| 0 \right\rangle + e^{\frac{2\pi i}{2^{n - 1}}x}\left| 1 \right\rangle)\bigotimes(\left| 0 \right\rangle + e^{\frac{2\pi i}{2^{n}}x}\left| 1 \right\rangle)$$

è¿™å°±æ˜¯åœ¨ç›´è§‰ä¸­åŠ¨ç”»æ•°å­¦æè¿°ï¼š

![](pics/media/image186.gif)

### 5. å®ç°QFTçš„é‡å­å›è·¯

å®ç°QFTçš„é‡å­å›è·¯ä½¿ç”¨ä¸¤ä¸ªé‡å­é—¨ã€‚ç¬¬ä¸€ä¸ªä¸ºå•é‡å­æ¯”ç‰¹é˜¿è¾¾é©¬é—¨$H$ã€‚è‡ªä¸Šæ–‡ç¤ºä¾‹1ä¸­ï¼Œæ‚¨å·²ç»çœ‹åˆ°äº†ä½œç”¨å¤„äºæ€$|x_{k}\rangle$å•é‡å­æ¯”ç‰¹çš„$H$çš„åŠŸèƒ½ï¼š

$$H|x_{k}\rangle = |0\rangle + \exp{\left( \frac{2\pi i}{2}x_{k} \right)|1\rangle}$$

ç¬¬äºŒä¸ªä¸ºä»¥å—å¯¹è§’å½¢å¼ï¼ˆblock-diagonal
formï¼‰ç»™å‡ºçš„åŒé‡å­æ¯”ç‰¹å—æ§æ—‹è½¬$C\text{ROT}_{k}$ï¼š

$$C\text{ROT}_{k} = \begin{bmatrix}
I & 0 \\
0 & U\text{ROT}_{k} \\
\end{bmatrix}$$

å…¶ä¸­

$$U\text{ROT}_{k} = \begin{bmatrix}
I & 0 \\
0 & \exp\left( \frac{2\pi i}{2^{k}} \right) \\
\end{bmatrix}$$

ä½œç”¨å¤„äºæ€$|x_{j}x_{k}\rangle$åŒé‡å­æ¯”ç‰¹$C\text{ROT}_{k}$çš„åŠŸèƒ½ä¸ºå…¶ä¸­ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸ºå—æ§ç«¯ï¼Œç¬¬äºŒä¸ªä¸ºç›®æ ‡ç«¯ï¼š

$$C\text{ROT}_{k}|1x_{j}\rangle = |0x_{j}\rangle$$

ä»¥åŠ

$$C\text{ROT}_{k}|1x_{j}\rangle = \exp\left( \frac{2\pi i}{2^{k}}x_{j} \right)|1x_{j}\rangle$$

åœ¨ç»™å‡ºè¿™ä¸¤ä¸ªé‡å­é—¨ä¹‹åï¼Œå®ç°n-é‡å­æ¯”ç‰¹QFTçš„é‡å­å›è·¯ä¸ºï¼š

![image1](pics/media/image187.png)

è¿™ä¸€å›è·¯çš„å®ç°æ­¥éª¤å¦‚ä¸‹æ‰€ç¤ºï¼Œæˆ‘ä»¬ä»å¤„äºæ€$|x_{0}x_{1}\ldots x_{n}\rangle$çš„n-é‡å­æ¯”ç‰¹å¼€å§‹ã€‚

1\. åœ¨H-gateåº”ç”¨äºé‡å­æ¯”ç‰¹1ä¹‹åï¼ŒçŠ¶æ€ç”±è¾“å…¥æ—¶çš„å˜æ¢ä¸ºï¼š

$$H_{1}|x_{0}x_{1}\ldots x_{n}\rangle = \frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2}x_{1} \right)|1\rangle}\rbrack\bigotimes|x_{2}x_{3}\ldots x_{n}\rangle$$

2\.
åœ¨å°†$U\text{ROT}_{2}$åº”ç”¨äºç”±é‡å­æ¯”ç‰¹2æ§åˆ¶çš„é‡å­æ¯”ç‰¹1ä¹‹åï¼ŒçŠ¶æ€è½¬å˜ä¸ºï¼š

$$\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{2}}x_{2} + \frac{2\pi i}{2}x_{1} \right)|1\rangle}\rbrack\bigotimes|x_{2}x_{3}\ldots x_{n}\rangle$$

3\.
åœ¨å¯¹ç”±é‡å­æ¯”ç‰¹næ§åˆ¶çš„é‡å­æ¯”ç‰¹1åº”ç”¨æœ€åä¸€ä¸ª$C\text{ROT}_{2}$ä¹‹åï¼ŒçŠ¶æ€å˜ä¸ºï¼š

$$\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{n}}x_{n} + \frac{2\pi i}{2^{n - 1}}x_{n - 1} + \cdots + \frac{2\pi i}{2^{2}}x_{2} + \frac{2\pi i}{2}x_{1} \right)|1\rangle}\rbrack\bigotimes|x_{2}x_{3}\ldots x_{n}\rangle$$

æ³¨æ„åˆ°ï¼š

$$x = 2^{n - 1}x_{1} + 2^{n - 2}x_{2} + \cdots + 2^{1}x_{n - 1} + 2^{0}x_{n}$$

æˆ‘ä»¬å¯ä»¥å°†ä¸Šé¢çš„çŠ¶æ€æ”¹å†™ä¸ºï¼š

$$\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{n}}x \right)|1\rangle}\rbrack\bigotimes|x_{2}x_{3}\ldots x_{n}\rangle$$

4\.
å†å¯¹é‡å­æ¯”ç‰¹$2\cdots n$åº”ç”¨ç›¸ä¼¼çš„é‡å­é—¨åºåˆ—ä¹‹åï¼Œæˆ‘ä»¬å‘ç°æœ€ç»ˆçš„çŠ¶æ€ä¸ºï¼š

$$\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{n}}x \right)|1\rangle}\rbrack\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{n - 1}}x \right)|1\rangle}\rbrack\bigotimes\cdots\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{2}}x \right)|1\rangle}\rbrack\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{1}}x \right)|1\rangle}\rbrack$$

ä»¥ä¸Šæ­£æ˜¯ä¸Šæ–‡ä¸­æ‰€æ¨å¯¼çš„è¾“å…¥æ€çš„QFTï¼Œä½†åº”æ³¨æ„æ­¤æ—¶é‡å­æ¯”ç‰¹çš„é¡ºåºä¸è¾“å‡ºæ€ç›¸åã€‚

### 6. ç¤ºä¾‹2ï¼š1-é‡å­æ¯”ç‰¹QFT

åˆ›å»º$|y_{3}y_{2}y_{1}\rangle = \text{QFT}_{8}|x_{3}x_{2}x_{1}\rangle$é‡å­å›è·¯çš„æ­¥éª¤å¦‚ä¸‹ï¼š

1\. åœ¨$|x_{1}\rangle$ä¸Šåº”ç”¨H-gateï¼š

$$\psi_{1} = |x_{3}\rangle\bigotimes|x_{2}\rangle\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2}x_{1} \right)|1\rangle}\rbrack$$

2\. ä¾æ®$|x_{2}\rangle$åœ¨$|x_{1}\rangle$ä¸Šåº”ç”¨$U\text{ROT}_{2}$ï¼š

$$\psi_{2} = |x_{3}\rangle\bigotimes|x_{2}\rangle\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{2}}x_{2} + \frac{2\pi i}{2}x_{1} \right)|1\rangle}\rbrack$$

3\. ä¾æ®$|x_{3}\rangle$åœ¨$|x_{1}\rangle$ä¸Šåº”ç”¨$U\text{ROT}_{3}$ï¼š

$$\psi_{3} = |x_{3}\rangle\bigotimes|x_{2}\rangle\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{2}}x_{3} + \frac{2\pi i}{2^{2}}x_{2} + \frac{2\pi i}{2}x_{1} \right)|1\rangle}\rbrack$$

4\. åœ¨$|x_{2}\rangle$ä¸Šåº”ç”¨H-gateï¼š

$$\psi_{4} = |x_{3}\rangle\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2}x_{2} \right)|1\rangle}\rbrack\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{3}}x_{3} + \frac{2\pi i}{2^{2}}x_{2} + \frac{2\pi i}{2}x_{1} \right)|1\rangle}\rbrack$$

5\. ä¾æ®$|x_{3}\rangle$åœ¨$|x_{2}\rangle$ä¸Šåº”ç”¨$U\text{ROT}_{2}$ï¼š

$$\psi_{5} = |x_{3}\rangle\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{2}}x_{3} + \frac{2\pi i}{2}x_{2} \right)|1\rangle}\rbrack\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{3}}x_{3} + \frac{2\pi i}{2^{2}}x_{2} + \frac{2\pi i}{2}x_{1} \right)|1\rangle}\rbrack$$

6\. åœ¨$|x_{3}\rangle$ä¸Šåº”ç”¨H-gateï¼š

$$\psi_{6} = \frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2}x_{3} \right)|1\rangle}\rbrack\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{2}}x_{3} + \frac{2\pi i}{2}x_{2} \right)|1\rangle}\rbrack\bigotimes\frac{1}{\sqrt{2}}\lbrack|0\rangle + \exp{\left( \frac{2\pi i}{2^{3}}x_{3} + \frac{2\pi i}{2^{2}}x_{2} + \frac{2\pi i}{2}x_{1} \right)|1\rangle}\rbrack$$

7\.
åº”å½“è®°ä½è¾“å‡ºçŠ¶æ€æ˜¯æ‰€éœ€QFTçš„é€†åºã€‚å› æ­¤æˆ‘ä»¬å¿…é¡»å°†é‡å­æ¯”ç‰¹çš„é¡ºåºåè¿‡æ¥ï¼ˆåœ¨æœ¬ç¤ºä¾‹ä¸­å¯äº¤æ¢$y_{3}$å’Œ$y_{1}$ï¼‰ã€‚

### 7. QFTé‡å­å›è·¯å½¢å¼çš„æ³¨è§£

ä¸Šæ–‡ç¤ºä¾‹è¯æ˜äº†ä¸€ç§éå¸¸æœ‰ç”¨çš„$N = 2^{n}$çš„QFTå½¢å¼ã€‚å¯ä»¥çœ‹åˆ°åªæœ‰æœ€åä¸€ä¸ªé‡å­æ¯”ç‰¹å–å†³äºæ‰€æœ‰å…¶ä»–è¾“å…¥ç«¯é‡å­æ¯”ç‰¹çš„å€¼ï¼Œæ¯å‰ä¸€ä¸ªé‡å­æ¯”ç‰¹å¯¹äºè¾“å…¥ç«¯é‡å­æ¯”ç‰¹çš„ä¾èµ–è¶Šæ¥è¶Šå°ã€‚è¿™ä¸€ç‚¹å¯¹æ— åŠ›å®ç°QFTå¾ˆé‡è¦ï¼Œå› æœ€è¿‘é‚»è€¦åˆæ¯”é‡å­æ¯”ç‰¹ä¹‹é—´çš„è¿œè·ç¦»è€¦åˆæ›´å®¹æ˜“å®ç°ã€‚

æ­¤å¤–ï¼Œå½“QFTé‡å­å›è·¯å¾ˆå¤§çš„æ—¶å€™ï¼Œä¼šæœ‰è¶Šæ¥è¶Šå¤šçš„æ—¶é—´èŠ±åœ¨åšè¶Šæ¥è¶Šå°çš„æ—‹è½¬ä¸Šã€‚ç»“æœè¡¨æ˜ï¼šå½“æˆ‘ä»¬å¿½ç•¥ä½äºæŸä¸ªé˜ˆå€¼çš„æ—‹è½¬æ—¶ä»ç„¶å¯ä»¥å¾—åˆ°å¾ˆå¥½çš„ç»“æœï¼Œè¿™å°±æ˜¯æ‰€è°“çš„è¿‘ä¼¼QFTã€‚è¿™åœ¨ç‰©ç†å®ç°ä¸­ä¹Ÿå¾ˆé‡è¦ï¼Œå› ä¸ºå‡å°‘æ“ä½œçš„æ•°é‡å¯ä»¥å¤§å¤§å‡å°‘é€€ç›¸å¹²å’Œæ½œåœ¨çš„é‡å­é—¨é”™è¯¯ã€‚

### 8. Qiskitå®ç°

åœ¨Qiskitä¸­ä½¿ç”¨ä¸Šæ–‡ä¸­è®¨è®ºçš„å—æ§ç›¸ä½æ—‹è½¬é—¨æ¥å®ç°$C\text{ROT}$é—¨ã€‚è¿™ä¸€é‡å­é—¨åœ¨åœ¨[OpenQASM](https://github.com/QISKit/openqasm)ä¸­è¢«å®šä¹‰ä¸ºï¼š

$$\text{CU}_{1} = \left\lbrack \begin{matrix}
1 \\
0 \\
0 \\
0 \\
\end{matrix}\text{\ \ }\begin{matrix}
0 \\
1 \\
0 \\
0 \\
\end{matrix}\text{\ \ }\begin{matrix}
0 \\
0 \\
1 \\
0 \\
\end{matrix}\text{\ \ }\begin{matrix}
0 \\
0 \\
0 \\
e^{\text{iÎ¸}} \\
\end{matrix} \right\rbrack$$

å› æ­¤ï¼Œå°†ä¸Šæ–‡ä¸­æ‰€è®¨è®º$C\text{ROT}_{k}$æ˜ å°„ä¸º$\text{CU}_{1}$ç­‰å¼å¦‚ä¸‹ï¼š

$$\theta = \frac{2\pi}{2^{k}} = \frac{\pi}{2^{k - 1}}$$

#### 8.1 3-é‡å­æ¯”ç‰¹çš„ç¤ºä¾‹

> import numpy as np
>
> from numpy import pi
>
> \# importing Qiskit
>
> from qiskit import QuantumCircuit, execute, Aer, IBMQ
>
> from qiskit.providers.ibmq import least_busy
>
> from qiskit.tools.monitor import job_monitor
>
> from qiskit.visualization import plot_histogram,
> plot_bloch_multivector
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images look
> nice

åœ¨ç”Ÿæˆn-é‡å­æ¯”ç‰¹QFTä¹‹å‰å…ˆç”Ÿæˆ3-é‡å­æ¯”ç‰¹QFTçš„ç›¸å…³ä»£ç éå¸¸æœ‰ç”¨ã€‚ç¬¬ä¸€æ­¥ï¼Œæˆ‘ä»¬å¿…é¡»å®šä¹‰é‡å­å›è·¯ï¼š

qc = QuantumCircuit(3)

**æ³¨**ï¼šæ˜¯å¦è¿˜è®°å¾—Qiskitçš„æœ€é«˜æœ‰æ•ˆä½å…ƒæ‰€æœ‰çš„æœ€å°ç´¢å¼•ï¼ˆ0ï¼‰ï¼Œå› æ­¤è¿™ä¸€é‡å­å›è·¯æ˜¯ç¬¬5ç« ä¸­ç›¸å…³å›¾åƒçš„æ°´å¹³é•œåƒã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯¹é‡å­æ¯”ç‰¹2åº”ç”¨ä¸€ä¸ªH-gateï¼š

> qc.h(2)
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image188.png)

ç„¶åï¼Œå¦‚æœé‡å­æ¯”ç‰¹1å¤„äºæ€$|1\rangle$æ—¶å†è½¬å››åˆ†ä¹‹ä¸€åœˆï¼š

> qc.cu1(pi/2, 1, 2) \# CROT from qubit 1 to qubit 2
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image189.png)

å¦‚æœæœ€é«˜æœ‰æ•ˆé‡å­æ¯”ç‰¹1æ˜¯$\left| 1 \right\rangle$æ—¶ï¼Œå†æ—‹è½¬å…«åˆ†ä¹‹ä¸€åœˆï¼š

> qc.cu1(pi/4, 0, 2) \# CROT from qubit 2 to qubit 0
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image190.png)

åœ¨å¤„ç†å®Œè¿™ä¸€é‡å­æ¯”ç‰¹ä¹‹åï¼Œå°†å…¶å¿½ç•¥å¹¶é‡å¤è¿™ä¸€è¿‡ç¨‹ï¼Œå¯¹é‡å­æ¯”ç‰¹1å’Œ2ä½¿ç”¨ç›¸åŒçš„é€»è¾‘ï¼š

> qc.h(1)
>
> qc.cu1(pi/2, 0, 1) \# CROT from qubit 0 to qubit 1
>
> qc.h(0)
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image191.png)

æœ€åï¼Œæˆ‘ä»¬å¿…é¡»äº¤æ¢é‡å­æ¯”ç‰¹0å’Œ2æ¥å®ŒæˆQFTï¼š

> qc.swap(0,2)
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image192.png)

#### 8.2 é€šç”¨QFTå‡½æ•°

ç°åœ¨æˆ‘ä»¬åœ¨Qiskitä¸­åˆ›å»ºä¸€ä¸ªQFTçš„é€šç”¨é‡å­å›è·¯ï¼Œåˆ›å»ºå¤§å‹é€šç”¨å›è·¯æ­£æ˜¯Qiskitçš„äº®ç‚¹ã€‚

åˆ›å»ºé‡å­æ¯”ç‰¹å€’ç½®çš„QFTå›è·¯æ¯”è¾ƒå®¹æ˜“ï¼Œç„¶åå†å°†å…¶äº¤æ¢ï¼›æˆ‘ä»¬å°†ä»åˆ›å»ºæ­£ç¡®æ—‹è½¬é‡å­æ¯”ç‰¹çš„å‡½æ•°å¼€å§‹ã€‚åœ¨æ­¤å¤„æˆ‘ä»¬é€šè¿‡æ­£ç¡®æ—‹è½¬æœ€é«˜æœ‰æ•ˆé‡å­æ¯”ç‰¹ï¼ˆæ‹¥æœ‰æœ€å¤§ç´¢å¼•å€¼çš„é‡å­æ¯”ç‰¹ï¼‰ï¼Œä»ä¸Šè¿°3-é‡å­æ¯”ç‰¹çš„ç¤ºä¾‹å¼€å§‹ï¼š

> def qft_rotations(circuit, n):
>
> if n == 0: \# Exit function if circuit is empty
>
> return circuit
>
> n -= 1 \# Indexes start from 0
>
> circuit.h(n) \# Apply the H-gate to the most significant qubit
>
> for qubit in range(n):
>
> \# For each less significant qubit, we need to do a
>
> \# smaller-angled controlled rotation:
>
> circuit.cu1(pi/2\*\*(n-qubit), qubit, n)

è¿è¡Œè¯¥å‡½æ•°ï¼Œçœ‹çœ‹å…¶ç»“æœå¦‚ä½•ï¼š

> qc = QuantumCircuit(4)
>
> qft_rotations(qc,4)
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image193.png)

æˆ‘ä»¬å¯ä»¥ä¸‹é¢çš„å°éƒ¨ä»¶æ¥æŸ¥çœ‹è¿™ä¸€å›è·¯å¦‚ä½•å› é‡å­æ¯”ç‰¹çš„æ•°é‡è€Œç¼©æ”¾ï¼š

> from qiskit_textbook.widgets import scalable_circuit
>
> scalable_circuit(qft_rotations)

ä¸Šé¢çš„ä»£ç å®ç°äº†æˆ‘ä»¬QFTçš„ç¬¬ä¸€éƒ¨åˆ†ã€‚ç°åœ¨è‹¥è¦æ­£ç¡®æ—‹è½¬æœ€é«˜æœ‰æ•ˆé‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬éœ€è¦æ­£ç¡®åœ°æ—‹è½¬ç¬¬äºŒæœ€é«˜æœ‰æ•ˆé‡å­æ¯”ç‰¹ï¼Œç„¶åå¿…é¡»å¤„ç†ç¬¬ä¸‰æœ€é«˜æœ‰æ•ˆé‡å­æ¯”ç‰¹ï¼Œç­‰ç­‰ã€‚ä½†ä¸ºä½•ç¼–å†™æ›´å¤šçš„ä»£ç å‘¢ï¼Ÿå½“qft_rotations()å‡½æ•°è¿è¡Œè‡³æœ«å°¾æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç›¸åŒçš„ä»£ç åœ¨ä¸‹ä¸€ä¸ªn-1é‡å­æ¯”ç‰¹ä¸Šé‡å¤è¿™ä¸€è¿‡ç¨‹ï¼š

> def qft_rotations(circuit, n):
>
> \"\"\"Performs qft on the first n qubits in circuit (without
> swaps)\"\"\"
>
> if n == 0:
>
> return circuit
>
> n -= 1
>
> circuit.h(n)
>
> for qubit in range(n):
>
> circuit.cu1(pi/2\*\*(n-qubit), qubit, n)
>
> \# At the end of our function, we call the same function again on
>
> \# the next qubits (we reduced n by one earlier in the function)
>
> qft_rotations(circuit, n)
>
> \# Let\'s see how it looks:
>
> qc = QuantumCircuit(4)
>
> qft_rotations(qc,4)
>
> qc.draw(\'mpl\')

![](pics/media/image194.png)

å¾ˆç®€å•å§ï¼åœ¨ä¸€ä¸ªå‡½æ•°å†…éƒ¨è°ƒç”¨å…¶è‡ªèº«ç§°ä¸ºé€’å½’ï¼ˆ*recursion*ï¼‰ï¼Œè¿™ä¸€æ–¹æ³•å¯ä»¥æå¤§çš„ç®€åŒ–ä»£ç ã€‚ä½¿ç”¨ä¸‹é¢çš„å°éƒ¨ä»¶ï¼Œå¯ä»¥å†æ¬¡çœ‹çœ‹å›è·¯æ˜¯å¦‚ä½•ç¼©æ”¾çš„ï¼š

scalable_circuit(qft_rotations)

æœ€åä¸ºäº†æ»¡è¶³QFTçš„å®šä¹‰ï¼Œéœ€è¦åœ¨è¿™ä¸ªQFTå‡½æ•°çš„å°¾éƒ¨æ·»åŠ ä¸€äº›äº¤æ¢ã€‚æˆ‘ä»¬å°†è¿™ä¸€æ­¥æ”¾å…¥æœ€ç»ˆçš„å‡½æ•°qft()ä¸­ï¼š

> def swap_registers(circuit, n):
>
> for qubit in range(n//2):
>
> circuit.swap(qubit, n-qubit-1)
>
> return circuit
>
> def qft(circuit, n):
>
> \"\"\"QFT on the first n qubits in circuit\"\"\"
>
> qft_rotations(circuit, n)
>
> swap_registers(circuit, n)
>
> return circuit
>
> \# Let\'s see how it looks:
>
> qc = QuantumCircuit(4)
>
> qft(qc,4)
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image195.png)

ä»¥ä¸Šå°±æ˜¯ä¸ºé‡å­å‚…é‡Œå¶å˜æ¢ç”Ÿæˆçš„é‡å­å›è·¯ã€‚æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨å°éƒ¨ä»¶çœ‹çœ‹è¿™ä¸€å›è·¯çš„ç¼©æ”¾æƒ…å†µï¼š

scalable_circuit(qft)

ä¸ºäº†è¦è¯æ˜è¿™ä¸ªå›è·¯è¿è¡Œçš„å‡†ç¡®æ€§ï¼Œæˆ‘ä»¬å…ˆè¦å°†ä¸€ä¸ªæ•°å­—ç¼–ç ä¸ºè®¡ç®—åŸºã€‚å°†æ•°å­—5ç¼–ç ä¸ºäºŒè¿›åˆ¶101ï¼š

> bin(5)
>
> è¾“å‡ºï¼š
>
> '0b101'

ï¼ˆè¾“å‡ºä¸­çš„0bä»…æ˜¯æé†’æˆ‘ä»¬è¿™æ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶æ•°å­—ï¼‰ã€‚ç°åœ¨å°†å…¶ç¼–å…¥é‡å­æ¯”ç‰¹ä¸­ï¼š

> \# Create the circuit
>
> qc = QuantumCircuit(3)
>
> \# Encode the state 5
>
> qc.x(0)
>
> qc.x(2)
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images fit
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image196.png)

ç„¶åä½¿ç”¨æ€å‘é‡æ¨¡æ‹Ÿå™¨æ£€æŸ¥è¿™äº›é‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼š

> backend = Aer.get_backend(\"statevector_simulator\")
>
> statevector = execute(qc, backend=backend).result().get_statevector()
>
> plot_bloch_multivector(statevector)
>
> è¾“å‡ºï¼š

![](pics/media/image197.png)

æœ€åå¯¹å…¶ä½¿ç”¨ä¹‹å‰å®šä¹‰çš„QFTå‡½æ•°å¹¶æŸ¥çœ‹é‡å­æ¯”ç‰¹çš„æœ€ç»ˆçŠ¶æ€ï¼š

> qft(qc,3)
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image198.png)

> statevector = execute(qc, backend=backend).result().get_statevector()
>
> plot_bloch_multivector(statevector)
>
> è¾“å‡ºï¼š

![](pics/media/image199.png)

ä»ä¸Šé¢æ‰€ç¤ºçš„çŠ¶æ€å¯ä»¥çœ‹å‡ºæ‰€å®šä¹‰çš„QFTå‡½æ•°å‡†ç¡®åœ°å®Œæˆäº†å…¶å·¥ä½œã€‚ç›¸å¯¹äºæ€$|\widetilde{0}\rangle = | + + + \rangle$ï¼Œé‡å­æ¯”ç‰¹0è¢«æ—‹è½¬äº†$\frac{5}{8}$å‘¨ï¼Œé‡å­æ¯”ç‰¹1æ—‹è½¬äº†$\frac{10}{8}$å‘¨ï¼ˆç›¸å½“äº$\frac{1}{4}$å‘¨ï¼‰ï¼Œé‡å­æ¯”ç‰¹2æ—‹è½¬äº†$\frac{20}{8}$å‘¨ï¼ˆç›¸å½“äº$\frac{1}{2}$å‘¨ï¼‰ã€‚

#### 8.3 åœ¨çœŸå®çš„è®¾å¤‡ä¸Šè¿è¡ŒQFT

å¦‚æœåœ¨çœŸæ­£çš„é‡å­è®¾å¤‡ä¸Šå°è¯•è¿è¡Œ8.2èŠ‚ä¸­çš„é‡å­å›è·¯ï¼Œé‚£ä¹ˆå…¶å°†äº§ç”Ÿå®Œå…¨éšæœºçš„ç»“æœï¼Œå› ä¸ºæ‰€æœ‰çš„é‡å­æ¯”ç‰¹éƒ½å¤„äº$|0\rangle$å’Œ$|1\rangle$ä¹‹é—´ç›¸ç­‰çš„å åŠ æ€ä¹‹ä¸­ã€‚å¦‚æœæƒ³è¦è¯æ˜å’Œæ¢è®¨è¿™ä¸€åœ¨çœŸå®è®¾å¤‡ä¸Šè¿è¡Œçš„QFTå›è·¯ï¼Œæˆ‘ä»¬å¯ä»¥ä»£ä¹‹ä»¥8.2èŠ‚å°¾éƒ¨åˆ›å»ºçš„æ€$|\widetilde{5}\rangle$ï¼Œåå‘è¿è¡Œè¯¥QFTå›è·¯å¹¶éªŒè¯è¾“å‡ºæ˜¯å¦æ˜¯æ‰€æœŸæœ›çš„$|5\rangle$ã€‚

é¦–å…ˆï¼Œä½¿ç”¨Qiskitå¾ˆå®¹æ˜“åè½¬QFTçš„æ“ä½œæ­¥éª¤ï¼š

> def inverse_qft(circuit, n):
>
> \"\"\"Does the inverse QFT on the first n qubits in circuit\"\"\"
>
> \# First we create a QFT circuit of the correct size:
>
> qft_circ = qft(QuantumCircuit(n), n)
>
> \# Then we take the inverse of this circuit
>
> invqft_circ = qft_circ.inverse()
>
> \# And add it to the first n qubits in our existing circuit
>
> circuit.append(invqft_circ, circuit.qubits\[:n\])
>
> return circuit.decompose() \# .decompose() allows us to see the
> individual gates

ç„¶åï¼Œå°†é‡å­æ¯”ç‰¹ç½®äºæ€$|\widetilde{5}\rangle$ï¼š

> nqubits = 3
>
> number = 5
>
> qc = QuantumCircuit(nqubits)
>
> for qubit in range(nqubits):
>
> qc.h(qubit)
>
> qc.u1(number\*pi/4,0)
>
> qc.u1(number\*pi/2,1)
>
> qc.u1(number\*pi,2)
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image200.png)

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç»è¿‡è¿™ä¸€æ­¥éª¤åç¡®å®å¾—åˆ°äº†å‚…é‡Œå¶çŠ¶æ€$|\widetilde{5}\rangle$ï¼š

> backend = Aer.get_backend(\"statevector_simulator\")
>
> statevector = execute(qc, backend=backend).result().get_statevector()
>
> plot_bloch_multivector(statevector)
>
> è¾“å‡ºï¼š

![](pics/media/image201.png)

æœ€åå¯¹å…¶åº”ç”¨åè½¬çš„QFTï¼š

> qc = inverse_qft(qc,nqubits)
>
> qc.measure_all()
>
> qc.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image202.png)

> \# Load our saved IBMQ accounts and get the least busy backend device
> with less than or equal to nqubits
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> backend = least_busy(provider.backends(filters=lambda x:
> x.configuration().n_qubits \>= nqubits
>
> and not x.configuration().simulator
>
> and x.status().operational==True))
>
> print(\"least busy backend: \", backend)
>
> è¾“å‡ºï¼š
>
> least busy backend: ibmq_london
>
> shots = 2048
>
> job = execute(qc, backend=backend, shots=shots, optimization_level=3)
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> counts = job.result().get_counts()
>
> plot_histogram(counts)
>
> è¾“å‡ºï¼š

![](pics/media/image203.png)

æ­£å¦‚æˆ‘ä»¬æ‰€æœŸæœ›ï¼Œæœ€å¤§æ¦‚ç‡çš„ç»“æœæ˜¯$101$ã€‚

### 9. ç»ƒä¹ 

1\.
ä¸Šè¿°çš„QFTå®ç°å·²é€šè¿‡å°†å‚…é‡Œå¶çŠ¶æ€$|\widetilde{5}\rangle$è½¬æ¢ä¸º$\text{QFT}^{\dagger}|\widetilde{5}\rangle = |101\rangle$çš„è¿‡ç¨‹è¿›è¡Œäº†éªŒè¯ã€‚å°è¯•æ‰¾å‡ºå°†$\text{QFT}^{\dagger}|a\rangle = |100\rangle$çš„ä¸­æ€$|a\rangle$ã€‚

2\. æ‰¾å‡º$\text{QFT}^{\dagger}|b\rangle = |011\rangle$çš„ä¸­æ€$|b\rangle$ã€‚

3\. å°è¯•ç¼–å†™ä¸ä½¿ç”¨é€’å½’çš„QFTå‡½æ•°å¹¶ä½¿ç”¨Qiskitä¸­çš„å¹ºæ­£æ¨¡æ‹Ÿå™¨æ¥éªŒè¯ç»“æœã€‚

### 10. å‚è€ƒæ–‡çŒ®

1\. M. Nielsen and I. Chuang, Quantum Computation and Quantum
Information, Cambridge Series on Information and the Natural Sciences
(Cambridge University Press, Cambridge, 2000).

3.8 é‡å­ç›¸ä½ä¼°è®¡ï¼ˆQuantum Phase Estimationï¼‰
--------------------------------------------

### å†…å®¹

1\. æ¦‚è¿°

1.1 ç›´è§‰

1.2 æ•°å­¦åŸºç¡€

2\. ç¤ºä¾‹ï¼šT-gate

2.1 åˆ›å»ºé‡å­å›è·¯

2.2 ç»“æœ

3\. ç¤ºä¾‹ï¼šè·å–æ›´é«˜ç²¾åº¦

3.1 é—®é¢˜

3.2 è§£å†³æ–¹æ³•

4\. åœ¨çœŸå®è®¾å¤‡ä¸Šå®éªŒ

4.1 ä½¿ç”¨2.1èŠ‚ä¸­çš„å›è·¯

5\. ç»ƒä¹ 

6\. å±•æœ›

7\. å‚è€ƒæ–‡çŒ®

8\. è´¡çŒ®è€…

é‡å­ç›¸ä½ä¼°è®¡æ˜¯é‡å­è®¡ç®—ä¸­æœ€é‡è¦çš„å­ç¨‹åºä¹‹ä¸€ï¼Œæ˜¯è®¸å¤šé‡å­ç®—æ³•çš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ã€‚è¯¥ç®—æ³•çš„ç›®æ ‡å¦‚ä¸‹ï¼š

ç»™å®šä¸€ä¸ªå¹ºæ­£ç®—å­$U$ï¼Œè¯¥ç®—æ³•ä¼°è®¡$U\left| \psi \right\rangle = e^{2\pi i\theta}\left| \psi \right\rangle$ä¸­çš„$\theta$ã€‚æ­¤å¤„çš„$\psi$æ˜¯ä¸€ä¸ªæœ¬å¾å‘é‡ï¼Œ$e^{2\pi i\theta}$æ˜¯ç›¸å¯¹åº”çš„æœ¬å¾å€¼ã€‚ç”±äº$U$æ˜¯å¹ºæ­£çš„ï¼Œå…¶æ‰€æœ‰æœ¬å¾å€¼çš„èŒƒæ•°éƒ½æ˜¯1ã€‚

### 1. æ¦‚è¿°

ä¸‹å›¾æ‰€ç¤ºä¸ºç›¸ä½ä¼°è®¡çš„é€šç”¨é‡å­å›è·¯ã€‚ä¸Šéƒ¨å¯„å­˜å™¨$t$åŒ…å«"è®¡æ•°"é‡å­æ¯”ç‰¹ï¼Œä¸‹éƒ¨åŒ…å«å¤„äºæ€$\left| \psi \right\rangle$çš„é‡å­æ¯”ç‰¹ï¼š

![image1](pics/media/image204.png)

#### 1.1 ç›´è§‰

é‡å­ç›¸ä½ä¼°è®¡ç®—æ³•ä½¿ç”¨ç›¸ä½åå†²å°†ç›¸ä½$U$ï¼ˆå‚…ç«‹å¶åŸºï¼‰å†™å…¥è®¡æ•°å¯„å­˜å™¨ä¸­çš„é‡å­æ¯”ç‰¹$t$ã€‚ç„¶åä½¿ç”¨é€†QFTå°†å…¶ä»å‚…ç«‹å¶åŸºè½¬æ¢ä¸ºå¯æµ‹é‡çš„è®¡ç®—åŸºã€‚

åœ¨QFTä¸€ç« ä¸­æåˆ°ï¼šåœ¨å‚…é‡Œå¶åŸºä¸­æœ€é¡¶ç«¯çš„é‡å­æ¯”ç‰¹åœ¨å¯¹$0$å’Œ$2^{t}$ä¹‹é—´è¿›è¡Œè®¡æ•°æ—¶ä¼šå®Œæˆä¸€ä¸ªå®Œæ•´çš„æ—‹è½¬ã€‚ä¸ºç®—å‡ºåœ¨$0$å’Œ$2^{t}$ä¹‹é—´çš„æ•°å­—$x$ï¼Œæˆ‘ä»¬ç»•Zè½´æ—‹è½¬è¿™ä¸€é‡å­æ¯”ç‰¹$\frac{x}{2^{t}}$åœˆï¼Œä¸‹ä¸€ä¸ªé‡å­æ¯”ç‰¹æ—‹è½¬$\frac{2x}{2^{t}}$ï¼Œç¬¬ä¸‰ä¸ªæ—‹è½¬$\frac{4x}{2^{t}}$ã€‚

![](pics/media/image205.png)

å½“æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªé‡å­æ¯”ç‰¹æ¥æ§åˆ¶U-gateæ—¶ï¼Œè¯¥é‡å­æ¯”ç‰¹ç”±äºåå†²çš„åŸå› å°†ä¼šç›¸åº”åœ°è½¬æ¢è‡³ç›¸ä½$e^{2\pi i\theta}$ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿ç»­çš„å—æ§å¹ºæ­£é‡å­é—¨ï¼ˆ$\text{CU}$-gateï¼‰å¤šæ¬¡é‡å¤è¿™ä¸€æ—‹è½¬è‡³ç›¸åº”çš„æ•°å­—ï¼Œç›´åˆ°æˆ‘ä»¬å°†ç›¸ä½$\theta$ç¼–ç ä¸ºå‚…ç«‹å¶åŸºä¸­åœ¨$0$å’Œ$2^{t}$ä¹‹é—´çš„æ•°å­—ã€‚

ç„¶åï¼Œç®€å•åœ°ä½¿ç”¨$\text{QFT}^{\dagger}$å°†å…¶è½¬æ¢ä¸ºè®¡ç®—åŸºã€‚

#### 1.2 æ•°å­¦åŸºç¡€

æ­£å¦‚ä¸Šæ–‡ä¸­æ‰€æåˆ°çš„ï¼Œè¯¥é‡å­å›è·¯ç”¨äºä¼°è®¡å¹ºæ­£ç®—å­$U$çš„ç›¸ä½ï¼Œå…¶ä¼°è®¡$U\left| \psi \right\rangle = e^{2\pi i\theta}\left| \psi \right\rangle$ä¸­çš„$\theta$ï¼Œå…¶ä¸­$\psi$æ˜¯ä¸€ä¸ªæœ¬å¾å‘é‡è€Œ$e^{2\pi i\theta}$æ˜¯ç›¸å¯¹åº”çš„æœ¬å¾å€¼ã€‚è¯¥å›è·¯çš„å·¥ä½œæ­¥éª¤å¦‚ä¸‹ï¼š

**i.
è®¾ç½®**ï¼š$\left| \psi \right\rangle$åœ¨ä¸€ç»„é‡å­æ¯”ç‰¹å¯„å­˜å™¨ä¸­ï¼Œæ¥è‡ªè®¡æ•°å¯„å­˜å™¨çš„å¦ä¸€ç»„$n$-é‡å­æ¯”ç‰¹è¢«ç”¨äºå­˜å‚¨å€¼$2^{n}\theta$ï¼š

$$\psi_{0} = \left| 0 \right\rangle^{\bigotimes n}\left| \psi \right\rangle$$

**ii. å åŠ **ï¼šåœ¨è®¡æ•°å¯„å­˜å™¨ä¸Šåº”ç”¨ä¸€ä¸ªn-æ¯”ç‰¹çš„é˜¿è¾¾é©¬é—¨$H^{\bigotimes n}$ï¼š

$$\psi_{1} = \frac{1}{2^{\frac{n}{2}}}{(\left| 0 \right\rangle + \left| 1 \right\rangle)}^{\bigotimes n}\left| \psi \right\rangle$$

**iii.
å—æ§å¹ºæ­£æ“ä½œ**ï¼šåœ¨è¿™é‡Œæˆ‘ä»¬éœ€è¦å¼•å…¥å—æ§å¹ºæ­£å˜æ¢$C - U$ï¼Œè¯¥å˜æ¢åœ¨æ§åˆ¶æ¯”ç‰¹ä¸º$\left| 1 \right\rangle$æ—¶åœ¨ç›®æ ‡å¯„å­˜å™¨ä¸Šåº”ç”¨å¹ºæ­£ç®—å­$U$ã€‚ç”±äº$U$æ˜¯ç±»ä¼¼äº$U\left| \psi \right\rangle = e^{2\pi i\theta}\left| \psi \right\rangle$ä¸­æœ¬å¾å‘é‡$\left| \psi \right\rangle$çš„å¹ºæ­£æ“ä½œï¼Œè¡¨æ˜ï¼š

$$U^{2j}\left| \psi \right\rangle = U^{2j - 1}U\left| \psi \right\rangle = U^{2j - 1}e^{2\pi i\theta}\left| \psi \right\rangle = \cdots = e^{2\pi i2^{j}\theta}\left| \psi \right\rangle$$

åº”ç”¨åœ¨$0 \leq j \leq n - 1$ä¸­çš„æ‰€æœ‰$n$ä¸ªå—æ§æ“ä½œ$C - U^{2j}$ï¼Œç„¶ååˆ©ç”¨å…³ç³»å¼$\left| 0 \right\rangle\bigotimes\left| \psi \right\rangle + \left| 1 \right\rangle\bigotimes e^{2\pi i\theta}\left| \psi \right\rangle = (\left| 0 \right\rangle + e^{2\pi i\theta}\left| 1 \right\rangle)\bigotimes\left| \psi \right\rangle$ï¼š

$${\psi_{2} = \frac{1}{2^{\frac{n}{2}}}\left( \left| 0 \right\rangle + e^{2\pi i\theta 2^{n - 1}}\left| 1 \right\rangle \right)\bigotimes\cdots\bigotimes\left( \left| 0 \right\rangle + e^{2\pi i\theta 2^{1}}\left| 1 \right\rangle \right)\bigotimes\left( \left| 0 \right\rangle + e^{2\pi i\theta 2^{0}}\left| 1 \right\rangle \right)\bigotimes\left| \psi \right\rangle
}{\ \ \ \ \ \  = \frac{1}{2^{\frac{n}{2}}}\sum_{k = 0}^{2^{n} - 1}{e^{2\pi i\theta k}\left| k \right\rangle\bigotimes\left| \psi \right\rangle}}$$

å…¶ä¸­$k$ä¸ºn-æ¯”ç‰¹äºŒè¿›åˆ¶æ•°å­—çš„æ•´æ•°è¡¨ç¤ºã€‚

**iv.
é€†å‚…ç«‹å¶å˜æ¢**ï¼šå¯ä»¥çœ‹å‡ºä¸Šè¿°è¡¨ç¤ºäº†åº”ç”¨é‡å­å‚…é‡Œå¶å˜æ¢åçš„ç²¾ç¡®ç»“æœã€‚é‡å­å‚…é‡Œå¶å˜æ¢å°†n-é‡å­æ¯”ç‰¹çš„è¾“å…¥çŠ¶æ€$|x\rangle$æ˜ å°„è‡³ï¼š

$\text{QFT}\left| x \right\rangle = \frac{1}{2^{\frac{n}{2}}}\left( \left| 0 \right\rangle + e^{\frac{2\pi i}{2}x}\left| 1 \right\rangle \right)\bigotimes\cdots\bigotimes\left( \left| 0 \right\rangle + e^{\frac{2\pi i}{2^{2}}x}\left| 1 \right\rangle \right)\bigotimes\left( \left| 0 \right\rangle + e^{\frac{2\pi i}{2^{n - 1}}x}\left| 1 \right\rangle \right)\bigotimes\left( \left| 0 \right\rangle + e^{\frac{2\pi i}{2^{n}}x}\left| 1 \right\rangle \right)$

é€šè¿‡å°†ä¸Šå¼ä¸­çš„$x$æ›¿æ¢ä¸º$2^{n}\theta$ä¼šç»™å‡ºç¬¬äºŒæ­¥ä¸­ç²¾ç¡®è¡¨è¾¾å¼ã€‚å› æ­¤ï¼Œä¸ºäº†æ¢å¤æ€$\left| 2^{n}\theta \right\rangle$ï¼Œéœ€è¦åœ¨é™„å±å¯„å­˜å™¨ä¸Šåº”ç”¨ä¸€ä¸ªé€†å‚…é‡Œå¶å˜æ¢ã€‚ç»è¿‡è¿™äº›æ­¥éª¤åå‘ç°ï¼š

$$\left| \psi_{3} \right\rangle = \frac{1}{2^{\frac{n}{2}}}\sum_{k = 0}^{2^{n} - 1}{e^{2\pi i\theta k}\left| k \right\rangle\bigotimes\left| \psi \right\rangle}\overset{\text{QFT}_{n}^{- 1}}{\rightarrow}\frac{1}{2^{n}}\sum_{x = 0}^{2^{n} - 1}{\sum_{k = 0}^{2^{n} - 1}{e^{- \frac{2\pi ik}{2^{n}}(x - 2^{n}\theta)}\left| x \right\rangle\bigotimes\left| \psi \right\rangle}}$$

**v.
æµ‹é‡**ï¼šä¸Šè¿°è¡¨è¾¾å¼åœ¨æ¥è¿‘$x = 2^{n}\theta$æ—¶è¾¾åˆ°å³°å€¼ã€‚åœ¨$2^{n}\theta$æ˜¯ä¸€ä¸ªæ•´æ•°çš„æƒ…å†µæ—¶ï¼Œåœ¨è®¡ç®—åŸºä¸Šæµ‹é‡ä¼šç»™å‡ºé™„å±å¯„å­˜å™¨ä¸­å…·æœ‰é«˜æ¦‚ç‡çš„ç›¸ä½ï¼š

$$\left| \psi_{4} \right\rangle = \left| 2^{n}\theta \right\rangle\bigotimes\left| \psi \right\rangle$$

åœ¨$2^{n}\theta$ä¸æ˜¯æ•´æ•°çš„æƒ…å†µæ—¶ï¼Œèƒ½å¤Ÿçœ‹å‡ºä¸Šé¢çš„è¡¨è¾¾å¼åœ¨ä¸´è¿‘$x = 2^{n}\theta$æ—¶ä»èƒ½æ¯”$4/\pi^{2} \approx 40\%$
\[1\]æœ‰æ›´é«˜çš„æ¦‚ç‡ã€‚

### 2. ç¤ºä¾‹ï¼šT-gate

æˆ‘ä»¬ä»¥å·²çŸ¥çš„é‡å­é—¨$T$-gateåšç¤ºä¾‹ï¼Œå¹¶ä½¿ç”¨é‡å­ç›¸ä½ä¼°è®¡æ¥ä¼°è®¡è¯¥é‡å­é—¨çš„ç›¸ä½ã€‚$T$-gateèƒ½å¤Ÿå°†ç›¸ä½$e^{\frac{\text{iÏ€}}{4}}$æ·»åŠ è‡³æ€$\left| 1 \right\rangle$ï¼š

$$T\left| 1 \right\rangle = \begin{bmatrix}
1 & 0 \\
0 & e^{\frac{\text{iÏ€}}{4}} \\
\end{bmatrix}\begin{bmatrix}
0 \\
1 \\
\end{bmatrix} = e^{\frac{\text{iÏ€}}{4}}\left| 1 \right\rangle$$

å› æ­¤é‡å­ç›¸ä½ä¼°è®¡ï¼ˆQPEï¼‰ä¼šç»™å‡º$\theta$ï¼š

$$T\left| 1 \right\rangle = e^{2i\text{Ï€Î¸}}\left| 1 \right\rangle$$

æˆ‘ä»¬æœŸæœ›æ‰¾åˆ°ï¼š

$$\theta = \frac{1}{8}$$

åœ¨æœ¬ç¤ºä¾‹ä¸­æˆ‘ä»¬å°†ä¼šç”¨åˆ°ä¸‰ä¸ªé‡å­æ¯”ç‰¹ï¼Œå¹¶è·å–ä¸€ä¸ªå‡†ç¡®çš„ç»“æœè€Œä¸æ˜¯ä¸€ä¸ªä¼°è®¡ã€‚

#### 2.1 åˆ›å»ºé‡å­å›è·¯

é¦–å…ˆå‡†å¤‡å¥½ç¨‹åºç¯å¢ƒï¼š

> \#initialization
>
> import matplotlib.pyplot as plt
>
> %matplotlib inline
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images look
> nice
>
> import numpy as np
>
> import math
>
> \# importing Qiskit
>
> from qiskit import IBMQ, Aer
>
> from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister,
> execute
>
> \# import basic plot tools
>
> from qiskit.visualization import plot_histogram

ç„¶åï¼Œè®¾ç½®è¯¥é‡å­å›è·¯ã€‚åœ¨æ­¤å›è·¯ä¸­æˆ‘ä»¬å°†ä¼šç”¨åˆ°å››ä¸ªé‡å­æ¯”ç‰¹------é‡å­æ¯”ç‰¹0è‡³2ç”¨ä½œè®¡æ•°ï¼Œé‡å­æ¯”ç‰¹3ç”¨ä½œå¹ºæ­£ç®—å­ï¼ˆ$T$ï¼‰çš„æœ¬å¾æ€ã€‚

é€šè¿‡åº”ç”¨ä¸€ä¸ª$X$-gateåˆå§‹åŒ–$\left| \psi \right\rangle = \left| 1 \right\rangle$ï¼š

> qpe = QuantumCircuit(4, 3)
>
> qpe.x(3)
>
> qpe.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image206.png)

æ¥ç€ï¼Œæˆ‘ä»¬åœ¨è®¡æ•°é‡å­æ¯”ç‰¹ä¸Šåº”ç”¨H-gateï¼š

> for qubit in range(3):
>
> qpe.h(qubit)
>
> qpe.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image207.png)

ä¸‹ä¸€æ­¥æˆ‘ä»¬æ‰§è¡Œå—æ§å¹ºæ­£æ“ä½œã€‚**è®°ä½**ï¼šQiskitå¯¹é‡å­æ¯”ç‰¹çš„æ’åºä¸ä¸Šå›¾ç›¸åã€‚

repetitions = 1

for counting_qubit in range(3):

for i in range(repetitions):

qpe.cu1(math.pi/4, counting_qubit, 3); \# This is C-U

repetitions \*= 2

qpe.draw(output=\'mpl\')

è¾“å‡ºï¼š

![](pics/media/image208.png)

æˆ‘ä»¬åº”ç”¨é€†é‡å­å‚…ç«‹å¶å˜æ¢æ¥è½¬æ¢è®¡æ•°å¯„å­˜å™¨çš„çŠ¶æ€ã€‚æ­¤å¤„ç»™å‡º$\text{QFT}^{\dagger}$çš„ä»£ç ï¼š

> def qft_dagger(circ, n):
>
> \"\"\"n-qubit QFTdagger the first n qubits in circ\"\"\"
>
> \# Don\'t forget the Swaps!
>
> for qubit in range(n//2):
>
> circ.swap(qubit, n-qubit-1)
>
> for j in range(n):
>
> for m in range(j):
>
> circ.cu1(-math.pi/float(2\*\*(j-m)), m, j)
>
> circ.h(j)

ç„¶åæµ‹é‡è®¡æ•°å¯„å­˜å™¨ã€‚åœ¨æ­¤åˆ»é‡å­æ¯”ç‰¹çš„é¡ºåºæ˜¯åçš„ï¼è¿™åœ¨é‡å­è®¡ç®—ä¸­æ˜¯ä¸€ä¸ªå¸¸è§çš„é—®é¢˜ã€‚æˆ‘ä»¬é€šè¿‡é€†åºæµ‹é‡ç»å…¸æ¯”ç‰¹æ¥ä¿®å¤è¯¥é—®é¢˜ï¼š

> qpe.barrier()
>
> \# Apply inverse QFT
>
> qft_dagger(qpe, 3)
>
> \# Measure
>
> qpe.barrier()
>
> for n in range(3):
>
> qpe.measure(n,n)
>
> qpe.draw(output=\"mpl\")
>
> è¾“å‡ºï¼š

![](pics/media/image209.png)

#### 2.2 ç»“æœ

> backend = Aer.get_backend(\'qasm_simulator\')
>
> shots = 2048
>
> results = execute(qpe, backend=backend, shots=shots).result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image210.png)

å¯ä»¥çœ‹åˆ°æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªç¡®å®šçš„ç»“æœï¼ˆ001ï¼‰ï¼Œè½¬åŒ–æˆå°æ•°ä¸º1ã€‚ç°åœ¨éœ€è¦é€šè¿‡å°†$2^{n}$é™¤ä»¥ç»“æœï¼ˆ1ï¼‰æ¥è·å–$\theta$ï¼š

$$\theta = \frac{1}{2^{3}} = \frac{1}{8}$$

è¿™æ­£å¼æˆ‘ä»¬æ‰€æœŸæœ›çš„ç²¾ç¡®ç»“æœï¼

### 3. ç¤ºä¾‹ï¼šè·å–æ›´é«˜ç²¾åº¦

#### 3.1 é—®é¢˜

æˆ‘ä»¬ä½¿ç”¨$\theta = \frac{1}{3}$çš„é‡å­é—¨ä»£æ›¿$T$-gateã€‚æŒ‰ç…§æœ€åä¸€ä¸ªç¤ºä¾‹çš„æ ·å­è®¾ç½®è¿™ä¸€é‡å­å›è·¯ï¼š

> \# Create and set up circuit
>
> qpe2 = QuantumCircuit(4, 3)
>
> \# Apply H-Gates to counting qubits:
>
> for qubit in range(3):
>
> qpe2.h(qubit)
>
> \# Prepare our eigenstate \|psi\>:
>
> qpe2.x(3)
>
> \# Do the controlled-U operations:
>
> angle = 2\*math.pi/3
>
> repetitions = 1
>
> for counting_qubit in range(3):
>
> for i in range(repetitions):
>
> qpe2.cu1(angle, counting_qubit, 3);
>
> repetitions \*= 2
>
> \# Do the inverse QFT:
>
> qft_dagger(qpe2, 3)
>
> \# Measure of course!
>
> for n in range(3):
>
> qpe2.measure(n,n)
>
> qpe2.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image211.png)

> \# Let\'s see the results!
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> shots = 4096
>
> results = execute(qpe2, backend=backend, shots=shots).result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image212.png)

æˆ‘ä»¬æœŸæœ›ç»“æœä¸º$\theta = 0.3333\cdots$ï¼Œå¯ä»¥çœ‹åˆ°æœ€æœ‰å¯èƒ½çš„ç»“æœæ˜¯010(bin)
= 2(dec)å’Œ011(bin) = 3(dec)ã€‚è¿™ä¸¤ä¸ªç»“æœåˆ†åˆ«å‘Šè¯‰æˆ‘ä»¬$\theta = 0.25$ï¼ˆoff
by 25%ï¼‰ä»¥åŠ$\theta = 0.375$ï¼ˆoff by
13%ï¼‰ã€‚$\theta$çš„çœŸå€¼å¤„äºä»è®¡æ•°æ¯”ç‰¹è·å–çš„å€¼ä¹‹ä¸­ï¼Œå¯¼è‡´äº†ä¸ç¡®å®šä»¥åŠä¸ç²¾ç¡®ã€‚

#### 3.2 è§£å†³æ–¹æ³•

ä¸ºäº†è·å–æ›´é«˜çš„ç²¾åº¦ï¼Œåªéœ€ç®€å•åœ°æ·»åŠ æ›´å¤šçš„è®¡æ•°æ¯”ç‰¹ã€‚æˆ‘ä»¬å°†ä¼šå¢åŠ ä¸¤ä¸ªè®¡æ•°æ¯”ç‰¹ï¼š

> \# Create and set up circuit
>
> qpe3 = QuantumCircuit(6, 5)
>
> \# Apply H-Gates to counting qubits:
>
> for qubit in range(5):
>
> qpe3.h(qubit)
>
> \# Prepare our eigenstate \|psi\>:
>
> qpe3.x(5)
>
> \# Do the controlled-U operations:
>
> angle = 2\*math.pi/3
>
> repetitions = 1
>
> for counting_qubit in range(5):
>
> for i in range(repetitions):
>
> qpe3.cu1(angle, counting_qubit, 5);
>
> repetitions \*= 2
>
> \# Do the inverse QFT:
>
> qft_dagger(qpe3, 5)
>
> \# Measure of course!
>
> for n in range(5):
>
> qpe3.measure(n,n)
>
> qpe3.draw(output=\'mpl\')

è¾“å‡ºï¼š

![](pics/media/image213.png)

![](pics/media/image214.png)

> \# Let\'s see the results!
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> shots = 4096
>
> results = execute(qpe3, backend=backend, shots=shots).result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image215.png)

ç°åœ¨æœ€å¯èƒ½çš„ä¸¤ä¸ªæµ‹é‡å€¼æ˜¯01011ï¼ˆåè¿›åˆ¶11ï¼‰å’Œ01010ï¼ˆåè¿›åˆ¶10ï¼‰ã€‚æµ‹é‡è¿™äº›ç»“æœä¼šå‘Šè¯‰æˆ‘ä»¬$\theta$æ˜¯ï¼š

$\theta = \frac{11}{2^{5}} = 0.344$ æˆ–
$\theta = \frac{10}{2^{5}} = 0.313$

è¿™ä¸¤ä¸ªç»“æœåˆ†åˆ«åœ¨3%å’Œ6%å¤„ç›¸å·®$\frac{1}{3}$ï¼Œå·²ç»æ˜¯æ›´é«˜çš„ç²¾åº¦äº†ã€‚

### 4. åœ¨çœŸå®è®¾å¤‡ä¸Šå®éªŒ

4.1 é‡‡ç”¨2.1ä¸­çš„å›è·¯

æˆ‘ä»¬å¯ä»¥åœ¨çœŸå®çš„è®¾å¤‡ä¸Šè¿è¡Œ2.1èŠ‚ä¸­çš„é‡å­å›è·¯ï¼Œå…ˆè®©æˆ‘ä»¬å›å¿†ä¸€ä¸‹è¿™ä¸€å›è·¯ï¼š

> qpe.draw(output=\"mpl\")
>
> è¾“å‡ºï¼š

![](pics/media/image209.png)

> \# Load our saved IBMQ accounts and get the least busy backend device
> with less than or equal to n qubits
>
> IBMQ.load_account()
>
> from qiskit.providers.ibmq import least_busy
>
> from qiskit.tools.monitor import job_monitor
>
> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> backend = least_busy(provider.backends(filters=lambda x:
> x.configuration().n_qubits \>= 4 and not x.configuration().simulator
> and x.status().operational==True))
>
> print(\"least busy backend: \", backend)
>
> \# Run with 2048 shots
>
> shots = 2048
>
> job = execute(qpe, backend=backend, shots=2048, optimization_level=3)
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> least busy backend: ibmqx2
>
> Job Status: job has successfully run
>
> \# get the results from the computation
>
> results = job.result()
>
> answer = results.get_counts(qpe)
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image216.png)

æˆ‘ä»¬å¸Œæœ›çœ‹åˆ°æœ€æœ‰å¯èƒ½çš„ç»“æœæ˜¯001ï¼Œä»æ¨¡æ‹Ÿå™¨ä¸­è·å¾—çš„æœŸæœ›ç»“æœã€‚ä¸æ¨¡æ‹Ÿå™¨ä¸åŒçš„æ˜¯ï¼Œæµ‹é‡æ‰€å¾—æ¦‚ç‡ç»™å‡ºçš„ä¸æ˜¯001ï¼Œè¿™æ˜¯ç”±äºé‡å­è®¡ç®—æœºä¸­çš„å™ªå£°å’Œé‡å­é—¨è¯¯å·®å¯¼è‡´çš„ç»“æœã€‚

### 5. ç»ƒä¹ 

1\.
å°è¯•ä½¿ç”¨ä¸åŒçš„é‡å­é—¨ï¼ˆ$\text{CNOT}ï¼ŒS$ï¼Œ$T^{\dagger}$ï¼‰æ¥è¿›è¡Œä¸Šè¿°çš„å®éªŒï¼Œç»“æœæ˜¯å¦å¦‚æ‚¨æ‰€æœŸæœ›ï¼Ÿè·å¾—äº†å“ªäº›ç»“æœï¼Ÿ

2\.
å°è¯•ä½¿ç”¨$Y$-gateå®éªŒï¼Œæ˜¯å¦èƒ½å¤Ÿè·å–æ­£ç¡®çš„ç»“æœï¼Ÿï¼ˆæç¤ºï¼šç¡®è®¤$|\psi\rangle$æ˜¯$Y$çš„æœ¬å¾æ€ï¼ï¼‰

### 6. å±•æœ›

é‡å­ç›¸ä½ä¼°è®¡ç®—æ³•çœ‹ä¸Šå»æ¯«æ— æ„ä¹‰ï¼Œå› ä¸ºåœ¨é‡å­è®¡ç®—æœºä¸Šæ‰§è¡Œå—æ§-$U$æ“ä½œå¿…é¡»çŸ¥é“$\theta$ã€‚æˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­çœ‹åˆ°åœ¨ä¸çŸ¥é“$\theta$çš„æƒ…å†µä¸‹åˆ›å»ºé‡å­å›è·¯çš„å¯èƒ½æ€§ï¼Œå¯¹å­¦ä¹ thetaå¯ä»¥å‘Šè¯‰æˆ‘ä»¬ä¸€äº›éå¸¸æœ‰ç”¨çš„ä¸œè¥¿ï¼ˆå…¶ä¸­æœ€è‘—åçš„å°±æ˜¯å¦‚ä½•å› å¼åˆ†è§£ä¸€ä¸ªæ•°å­—ï¼‰ã€‚

### 7. å‚è€ƒæ–‡çŒ®

\[1\] Michael A. Nielsen and Isaac L. Chuang. 2011. Quantum Computation
and Quantum Information: 10th Anniversary Edition (10th ed.). Cambridge
University Press, New York, NY, USA.

### 8. è´¡çŒ®è€…

03/20/2020 --- Hwajung Kang (\@HwajungKang) ---
ä¿®å¤äº†ä¸ä¸€è‡´çš„é‡å­æ¯”ç‰¹é¡ºåº

3.9 Shorç®—æ³•
------------

Shorç®—æ³•ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´ï¼ˆPolynomial
Timeï¼‰å†…åˆ†è§£æ•´æ•°è€Œé—»åã€‚ç”±äºæœ€è‘—åçš„ç»å…¸ç®—æ³•éœ€è¦å­æŒ‡æ•°æ—¶é—´ï¼ˆSub-Exponential
Timeï¼‰æ¥åˆ†è§£ä¸¤ä¸ªç´ æ•°çš„ä¹˜ç§¯ï¼Œå› æ­¤å¹¿æ³›ä½¿ç”¨çš„RSAå¯†ç ç³»ç»ŸåŸºäºè¶³å¤Ÿå¤§çš„æ•´æ•°ä¸å¯èƒ½åˆ†è§£ã€‚

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†é‡ç‚¹è®¨è®ºShorç®—æ³•çš„é‡å­éƒ¨åˆ†ï¼Œè¯¥ç®—æ³•å®é™…ä¸Šè§£å†³äº†å‘¨æœŸå¯»æ‰¾ï¼ˆperiod-findingï¼‰çš„é—®é¢˜ã€‚ç”±äºå› å¼åˆ†è§£é—®é¢˜å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è½¬åŒ–ä¸ºå‘¨æœŸå¯»æ‰¾é—®é¢˜ï¼Œå› æ­¤æœ‰æ•ˆçš„å‘¨æœŸå¯»æ‰¾ç®—æ³•ä¹Ÿå¯ä»¥æœ‰æ•ˆåœ°åˆ†è§£æ•´æ•°ã€‚ç°åœ¨è¯¥ç®—æ³•è¶³ä»¥è¡¨æ˜å¦‚æœæˆ‘ä»¬å¯ä»¥é«˜æ•ˆåœ°è®¡ç®—å‡ºæ®µ$a^{x}\text{mod}\ N$ï¼Œé‚£ä¹ˆä¹Ÿå¯ä»¥é«˜æ•ˆåœ°è¿›è¡Œå› å¼åˆ†è§£ã€‚ç”±äºå‘¨æœŸæŸ¥æ‰¾æœ¬èº«å°±å…¶æœ¬èº«è€Œè¨€æ˜¯ä¸€ä¸ªæœ‰ä»·å€¼çš„é—®é¢˜ï¼Œæˆ‘ä»¬å°†é¦–å…ˆè§£å†³è¿™ä¸€é—®é¢˜ï¼Œç„¶åè®¨è®ºå¦‚ä½•åœ¨æœ¬ç« çš„ç¬¬5èŠ‚ä¸­ä½¿ç”¨å®ƒæ¥è¿›è¡Œå› å¼åˆ†è§£ã€‚

> import matplotlib.pyplot as plt
>
> import numpy as np
>
> from qiskit import QuantumCircuit, Aer, execute
>
> from qiskit.visualization import plot_histogram
>
> from math import gcd
>
> from numpy.random import randint
>
> from tabulate import tabulate
>
> from fractions import Fraction
>
> print(\"Imports Successful\")
>
> è¾“å‡ºï¼š
>
> Imports Successful

### 1. é—®é¢˜ï¼šå‘¨æœŸå¯»æ‰¾

æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸ªå‘¨æœŸå‡½æ•°ï¼š

$$f\left( x \right) = a^{x}\text{mod}\ N$$

**æç¤ºï¼šæ‘¸å’Œæ¨¡è¿ç®—**

å–æ¨¡è¿ç®—(ç®€ç§°"mod")çš„æ„æ€æ˜¯æ±‚ä¸€ä¸ªæ•°é™¤ä»¥å¦ä¸€ä¸ªæ•°çš„ä½™æ•°ã€‚ä¾‹å¦‚ï¼š

$$17\ \text{mod}\ 5 = 2$$

ç”±äº$17 \div 5 = 3$ä½™$2$ï¼ˆ$17 = \left( 3 \times 5 \right)\_ 2$ï¼‰ã€‚åœ¨Pythonä¸­ï¼Œå–æ¨¡è¿ç®—ä½¿ç”¨ç¬¦å·$\%$ã€‚è¿™ä¸€è¡Œä¸ºè¢«ç”¨åœ¨æ¨¡è¿ç®—ï¼ˆ[modular
arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic)ï¼‰ï¼Œåœ¨è¿™ä¸€è¿ç®—ä¸­æ•°å­—é—´ç›¸äº’åŒ…è£¹ç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªç¡®å®šå€¼ï¼ˆæ¨¡æ•°
modulusï¼‰ã€‚æˆ‘ä»¬å¯ä»¥å°†æ¨¡è¿ç®—å†™æˆå¦‚ä¸‹ç­‰å¼ï¼š

$$17 \equiv 2(mod\ 5)$$

å¯ä»¥çœ‹å‡ºæ­¤å¤„çš„ï¼ˆ$mod\ 5$ï¼‰åº”ç”¨äºæ•´ä¸ªç­‰å¼ï¼ˆç”±äºå…¶åœ¨åœ†æ‹¬å¼§ä¸­ï¼‰ï¼Œä¸ä¹‹ä¸åŒåœ¨ä¸Šé¢çš„ç­‰å¼ä¸­ä»…å°†ï¼ˆ$mod\ 5$ï¼‰ä½œç”¨äºç­‰å¼çš„å·¦ä¾§ã€‚

ğ‘å’Œğ‘æ˜¯æ­£æ•´æ•°ï¼Œğ‘å°äºğ‘ï¼Œä¸”æ²¡æœ‰å…¬å› å­ã€‚å‘¨æœŸæˆ–è€…é˜¶($r$)æ˜¯æœ€å°éé›¶æ•´æ•°çš„æƒ…å†µå¦‚ï¼š

$$a^{r}\ \text{mod}\ N = 1$$

æˆ‘ä»¬å¯ä»¥åœ¨ä¸‹å›¾ä¸­çœ‹åˆ°è¿™ç±»å‡½æ•°çš„ä¸€ä¸ªä¾‹å­ã€‚è¯·æ³¨æ„ç‚¹ä¹‹é—´çš„çº¿æ˜¯ä¸ºäº†å¸®åŠ©æŸ¥çœ‹å‘¨æœŸæ€§ï¼Œä¸ç”¨äºè¡¨ç¤ºxæ ‡è®°ä¹‹é—´çš„ä¸­é—´å€¼ã€‚

> N = 35
>
> a = 3
>
> \# Calculate the plotting data
>
> xvals = np.arange(35)
>
> yvals = \[np.mod(a\*\*x, N) for x in xvals\]
>
> \# Use matplotlib to display it nicely
>
> fig, ax = plt.subplots()
>
> ax.plot(xvals, yvals, linewidth=1, linestyle=\'dotted\', marker=\'x\')
>
> ax.set(xlabel=\'\$x\$\', ylabel=\'\$%i\^x\$ mod \$%i\$\' % (a, N),
>
> title=\"Example of Periodic Function in Shor\'s Algorithm\")
>
> try: \# plot r on the graph
>
> r = yvals\[1:\].index(1) +1
>
> plt.annotate(s=\'\', xy=(0,1), xytext=(r,1),
> arrowprops=dict(arrowstyle=\'\<-\>\'))
>
> plt.annotate(s=\'\$r=%i\$\' % r, xy=(r/3,1.5))
>
> except:
>
> print(\'Could not find period, check a \< N and have no common
> factors.\')
>
> è¾“å‡ºï¼š

![](pics/media/image217.png)

### 2. è§£å†³æ–¹æ¡ˆ

Shorè§£å†³æ–¹æ¡ˆä¸ºåœ¨å¹ºæ­£ç®—å­ä¸Šä½¿ç”¨é‡å­ç›¸ä½ä¼°è®¡ï¼š

$$U|y\rangle \equiv |ay\ mod\ N\rangle$$

ä¸ºäº†çœ‹å‡ºä¸ºä½•è¿™ä¸€æ–¹æ³•å¯¹è§£å†³é—®é¢˜æœ‰å¸®åŠ©ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾å‡ºUçš„æœ¬å¾æ€çš„å…·ä½“æ ·å­ã€‚å¦‚æœè¡Œæ€$|1\rangle$å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ¯ä¸€é€ä¸ªçš„Uåº”ç”¨å°†ä¼šä¸å¯„å­˜å™¨çš„çŠ¶æ€ç›¸ä¹˜$a(mod\ N)$æ¬¡ï¼Œåœ¨$r$æ¬¡åº”ç”¨åæˆ‘ä»¬å°†ä¼šå†æ¬¡æŠµè¾¾æ€$|1\rangle$ã€‚ä¾‹å¦‚$a = 3$åŠ$N = 35$ï¼š

$${U\left| 1 \right\rangle = \left| 3 \right\rangle
}{U^{1}\left| 1 \right\rangle = \left| 9 \right\rangle
}{U^{3}\left| 1 \right\rangle = \left| 27 \right\rangle
}{\vdots 
}{U^{\left( r - 1 \right)}\left| 1 \right\rangle = \left| 12 \right\rangle
}{U^{r}\left| 1 \right\rangle = \left| 1 \right\rangle}$$

> ax.set(xlabel=\'Number of applications of U\', ylabel=\'End state of
> register\',
>
> title=\"Effect of Successive Applications of U\")
>
> fig
>
> è¾“å‡ºï¼š

![](pics/media/image218.png)

å› æ­¤$U$çš„æœ¬å¾æ€$\left| U^{0} \right\rangle$åœ¨è¿™ä¸€å¾ªç¯ä¸­å¯ä»¥æ˜¯ä¸€ä¸ªå åŠ æ€ï¼š

$$\left| u_{0} \right\rangle = \frac{1}{\sqrt{r}}\sum_{k = 0}^{r - 1}\left| a^{k}\ \text{mod}\ N \right\rangle$$

**æç¤ºï¼ša=3åŠN=35çš„ä¾‹å­**

$${\left| u_{0} \right\rangle = \frac{1}{\sqrt{12}}\left( \left| 1 \right\rangle + \left| 3 \right\rangle + \left| 9 \right\rangle\cdots + \left| 4 \right\rangle + \left| 12 \right\rangle \right)
}{U\left| u_{0} \right\rangle = \frac{1}{\sqrt{12}}\left( U\left| 1 \right\rangle + U\left| 3 \right\rangle + \left| U9 \right\rangle\cdots + U\left| 4 \right\rangle + U\left| 12 \right\rangle \right)
}{\ \ \ \ \ \ \ \ \ \ \ \  = \frac{1}{\sqrt{12}}\left( \left| 3 \right\rangle + \left| 9 \right\rangle + \left| 27 \right\rangle\cdots + \left| 12 \right\rangle + \left| 1 \right\rangle \right)
}{\ \ \ \ \ \ \ \ \ \ \ \  = \left| u_{0} \right\rangle}$$

è¿™ä¸€æœ¬å¾æ€æœ‰ä¸€ä¸ªæœ¬å¾å€¼1ï¼Œå› æ­¤è¯¥æœ¬å¾æ€å¹¶ä¸è®©äººæ„Ÿå…´è¶£ã€‚ä¸€ä¸ªæ›´åŠ æœ‰è¶£çš„æœ¬å¾æ€å¯èƒ½ä¸ºä¸åŒäºä¸‰ä¸ªè®¡ç®—åŸºçŠ¶æ€çš„ç›¸ä½ã€‚è®©æˆ‘ä»¬çœ‹ä¸€çœ‹ä¸$k$ç›¸å¯¹åº”çš„$k$æ¬¡çŠ¶æ€çš„ç›¸ä½ï¼š

$$\left| u_{1} \right\rangle = \frac{1}{\sqrt{r}}\sum_{k = 0}^{r - 1}{e^{- \frac{2\pi\text{ik}}{r}}\left| a^{k}\ \text{mod}\ N \right\rangle}$$

$$U\left| u_{1} \right\rangle = e^{\frac{2\pi i}{r}}\left| u_{1} \right\rangle$$

**æç¤ºï¼ša=3åŠN=35çš„ä¾‹å­**

$${\left| u_{1} \right\rangle = \frac{1}{\sqrt{12}}\left( \left| 1 \right\rangle + e^{- \frac{2\pi i}{12}}\left| 3 \right\rangle + e^{- \frac{4\pi i}{12}}\left| 9 \right\rangle\cdots + e^{- \frac{20\pi i}{12}}\left| 4 \right\rangle + e^{- \frac{22\pi i}{12}}\left| 12 \right\rangle \right)
}{U\left| u_{1} \right\rangle = \frac{1}{\sqrt{12}}\left( \left| 3 \right\rangle + e^{- \frac{2\pi i}{12}}\left| 9 \right\rangle + e^{- \frac{4\pi i}{12}}\left| 27 \right\rangle\cdots + e^{- \frac{22\pi i}{12}}\left| 12 \right\rangle + e^{- \frac{24\pi i}{12}}\left| 1 \right\rangle \right)
}{U\left| u_{1} \right\rangle = e^{\frac{2\pi i}{12}}\left| u_{1} \right\rangle}$$

ï¼ˆæˆ‘ä»¬å¯ä»¥åœ¨ç›¸ä½çš„åˆ†æ¯ä¸Šçœ‹åˆ°$r = 12$ï¼‰

è¿™æ˜¯ä¸€ä¸ªç‰¹åˆ«æœ‰è¶£çš„æœ¬å¾å€¼ï¼Œå› ä¸ºå…¶ä¸­åŒ…å«$r$ã€‚ä»¥ä¸Šå¹¶ä¸æ˜¯å”¯ä¸€æœ‰è¿™ç§è¡Œä¸ºçš„æœ¬å¾æ€ï¼Œä¸ºäº†å°†å…¶æ³›åŒ–æˆ‘ä»¬å¯ä»¥ä¹˜ä»¥ä¸€ä¸ªæ•´æ•°$s$æ¥å½¢æˆè¿™æ ·çš„ç›¸ä½å·®ï¼Œè¯¥ç›¸ä½å·®å°†å‡ºç°åœ¨æœ¬å¾å€¼ä¸­ï¼š

$$\left| u_{s} \right\rangle = \frac{1}{\sqrt{r}}\sum_{k = 0}^{r - 1}{e^{- \frac{2\pi\text{isk}}{r}}\left| a^{k}\ \text{mod}\ N \right\rangle}$$

$$U\left| u_{s} \right\rangle = e^{\frac{2\pi\text{is}}{r}}\left| u_{s} \right\rangle$$

**æç¤ºï¼ša=3åŠN=35çš„ä¾‹å­**

$${\left| u_{s} \right\rangle = \frac{1}{\sqrt{12}}\left( \left| 1 \right\rangle + e^{- \frac{2\pi is}{12}}\left| 3 \right\rangle + e^{- \frac{4\pi is}{12}}\left| 9 \right\rangle\cdots + e^{- \frac{20\pi is}{12}}\left| 4 \right\rangle + e^{- \frac{22\pi is}{12}}\left| 12 \right\rangle \right)
}{U\left| u_{s} \right\rangle = \frac{1}{\sqrt{12}}\left( \left| 3 \right\rangle + e^{- \frac{2\pi is}{12}}\left| 9 \right\rangle + e^{- \frac{4\pi is}{12}}\left| 27 \right\rangle\cdots + e^{- \frac{22\pi is}{12}}\left| 12 \right\rangle + e^{- \frac{24\pi is}{12}}\left| 1 \right\rangle \right)
}{U\left| u_{s} \right\rangle = e^{\frac{2\pi is}{12}}\left| u_{s} \right\rangle}$$

è‡³æ­¤åœ¨$0 < s < r - 1$ä¸­çš„æ¯ä¸ªæœ¬å¾å€¼$s$éƒ½æœ‰å”¯ä¸€çš„æœ¬å¾æ€ã€‚éå¸¸æ–¹ä¾¿å§ï¼å¦‚æœå°†æ‰€æœ‰æœ¬å¾æ€ç›¸åŠ ï¼Œä¸åŒçš„ç›¸ä½æ¶ˆé™¤äº†é™¤æ€$\left| 1 \right\rangle$ä¹‹å¤–çš„æ‰€æœ‰è®¡ç®—åŸºçš„çŠ¶æ€ï¼š

$$\frac{1}{\sqrt{r}}\sum_{k = 0}^{r - 1}\left| u_{s} \right\rangle = \left| 1 \right\rangle$$

**æç¤ºï¼ša=7åŠN=15çš„ä¾‹å­**

æˆ‘ä»¬å°†çœ‹ä¸€ä¸‹a=7åŠN=15çš„æƒ…å†µï¼Œåœ¨è¿™ä¸€æƒ…å†µä¸‹r=4ï¼š

$${\frac{1}{2}(\ \ \left| u_{0} \right\rangle = \frac{1}{2}\left( \left| 1 \right\rangle + \left| 7 \right\rangle + \left| 4 \right\rangle + \left| 13 \right\rangle \right)\cdots
}{+ \left| u_{1} \right\rangle = \frac{1}{2}\left( \left| 1 \right\rangle + e^{- \frac{2\pi i}{4}}\left| 7 \right\rangle + e^{- \frac{4\pi i}{4}}\left| 4 \right\rangle + e^{- \frac{6\pi i}{4}}\left| 13 \right\rangle \right)\cdots
}{+ \left| u_{2} \right\rangle = \frac{1}{2}\left( \left| 1 \right\rangle + e^{- \frac{4\pi i}{4}}\left| 7 \right\rangle + e^{- \frac{8\pi i}{4}}\left| 4 \right\rangle + e^{- \frac{12\pi i}{4}}\left| 13 \right\rangle \right)\cdots
}{+ \left| u_{3} \right\rangle = \frac{1}{2}\left( \left| 1 \right\rangle + e^{- \frac{6\pi i}{4}}\left| 7 \right\rangle + e^{- \frac{12\pi i}{4}}\left| 4 \right\rangle + e^{- \frac{18\pi i}{4}}\left| 13 \right\rangle \right)\ \ ) = \left| 1 \right\rangle}$$

æˆ‘ä»¬å¯ä»¥çœ‹å‡ºè®¡ç®—åŸºçš„çŠ¶æ€$\left| 1 \right\rangle$æ˜¯æ”¿åæœ¬å¾æ€ä¸­çš„å åŠ æ€ï¼Œè¡¨æ˜å¦‚æœä½¿ç”¨æ€$\left| 1 \right\rangle$åœ¨$U$ä¸Šè¿›è¡Œé‡å­ç›¸ä½ä¼°è®¡ï¼Œæˆ‘ä»¬å°†ä¼šæµ‹çš„å¦‚ä¸‹ç›¸ä½ï¼š

$$\phi = \frac{s}{r}$$

å…¶ä¸­$s$æ˜¯$0$è‡³$r - 1$ä¹‹é—´çš„ä¸€ä¸ªéšæœºæ•´æ•°ã€‚æˆ‘ä»¬æœ€ç»ˆåœ¨$\phi$ä¸Šä½¿ç”¨è¿åˆ†å¼ç®—æ³•æ¥æ‰¾å‡º$r$ã€‚è¯¥é‡å­å›è·¯çš„å›¾è§£å¦‚ä¸‹æ‰€ç¤ºï¼š

![](pics/media/image219.png)

æ¥ä¸‹æ¥æˆ‘å°†ä¼šä½¿ç”¨Qiskitçš„æ¨¡æ‹Ÿå™¨æ¥è¯æ˜Shorç®—æ³•ã€‚å¯¹äºè¿™ä¸€è¯æ˜è¿‡ç¨‹ï¼Œæˆ‘ä»¬å°†ç›´æ¥ç»™å‡º$U$çš„é‡å­å›è·¯è€Œä¸ç»è§£é‡Šï¼Œä½†åœ¨æœ¬ç« çš„ç¬¬4èŠ‚ä¸­æ¡å›è®¨è®ºå¦‚ä½•æœ‰æ•ˆåœ°æ„å»º$U^{2^{j}}$çš„é‡å­å›è·¯ã€‚

### 3. Qiskitå®ç°

åœ¨è¿™ä¸€ç¤ºä¾‹ä¸­æˆ‘ä»¬å°†ä¼šè§£å†³a=7å’ŒN=15çš„å‘¨æœŸæ‰¾å¯»é—®é¢˜ã€‚æˆ‘ç»™å‡ºå¦‚ä¸‹$U$å›è·¯ä¸”ä¸ç»è§£é‡Šï¼š

$$U|y\rangle = |ay\ mod\ 15\rangle$$

ä¸ºäº†åˆ›å»º$U^{x}$ï¼Œåªéœ€ç®€å•åœ°é‡å¤è¿™ä¸€å›è·¯$x$æ¬¡ã€‚åœ¨ä¸‹ä¸€èŠ‚ä¸­æˆ‘ä»¬å°†ä¼šè®¨è®ºåˆ›å»ºè¿™äº›æœ‰æ•ˆé‡å­å›è·¯çš„é€šç”¨æ–¹æ³•ã€‚å‡½æ•°c_amod15è¿”å›açš„é‡å¤æŒ‡æ•°æ¬¡çš„å—æ§U-gateã€‚

> def c_amod15(a, power):
>
> \"\"\"Controlled multiplication by a mod 15\"\"\"
>
> if a not in \[2,7,8,11,13\]:
>
> raise ValueError(\"\'a\' must be 2,7,8,11 or 13\")
>
> U = QuantumCircuit(4)
>
> for iteration in range(power):
>
> if a in \[2,13\]:
>
> U.swap(0,1)
>
> U.swap(1,2)
>
> U.swap(2,3)
>
> if a in \[7,8\]:
>
> U.swap(2,3)
>
> U.swap(1,2)
>
> U.swap(0,1)
>
> if a == 11:
>
> U.swap(1,3)
>
> U.swap(0,2)
>
> if a in \[7,11,13\]:
>
> for q in range(4):
>
> U.x(q)
>
> U = U.to_gate()
>
> U.name = \"%i\^%i mod 15\" % (a, power)
>
> c_U = U.control()
>
> return c_U

æˆ‘ä»¬è¿˜ç»™å‡ºäº†é€†é‡å­å‚…ç«‹å¶å˜æ¢çš„é‡å­å›è·¯ï¼š

> def qft_dagger(n):
>
> \"\"\"n-qubit QFTdagger the first n qubits in circ\"\"\"
>
> qc = QuantumCircuit(n)
>
> \# Don\'t forget the Swaps!
>
> for qubit in range(n//2):
>
> qc.swap(qubit, n-qubit-1)
>
> for j in range(n):
>
> for m in range(j):
>
> qc.cu1(-np.pi/float(2\*\*(j-m)), m, j)
>
> qc.h(j)
>
> qc.name = \"QFTâ€ \"
>
> return qc

é€šè¿‡è¿™äº›åŸºæœ¬æ„æˆè¦ç´ ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ˜“çš„æ„å»ºShorç®—æ³•çš„é‡å­å›è·¯ï¼š

> \# Specify variables
>
> n_count = 8 \# number of counting qubits
>
> a = 7
>
> \# Create QuantumCircuit
>
> qc = QuantumCircuit(4+n_count, n_count)
>
> \# Initialise counting qubits
>
> \# in state \|+\>
>
> for q in range(n_count):
>
> qc.h(q)
>
> \# And ancilla register in state \|1\>
>
> qc.x(3+n_count)
>
> \# Do controlled-U operations
>
> for q in range(n_count):
>
> qc.append(c_amod15(a, 2\*\*q),
>
> \[q\] + \[i+n_count for i in range(4)\])
>
> \# Do inverse-QFT
>
> qc.append(qft_dagger(n_count), range(n_count))
>
> \# Measure circuit
>
> qc.measure(range(n_count), range(n_count))
>
> qc.draw(\'text\')

![](pics/media/image221.png)

![](pics/media/image222.png)

![](pics/media/image223.png)

![](pics/media/image224.png)

![](pics/media/image225.png)

è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹æµ‹é‡çš„ç»“æœæ˜¯ä»€ä¹ˆï¼š

> backend = Aer.get_backend(\'qasm_simulator\')
>
> results = execute(qc, backend, shots=2048).result()
>
> counts = results.get_counts()
>
> plot_histogram(counts)
>
> è¾“å‡ºï¼š

![](pics/media/image226.png)

ç”±äºæˆ‘ä»¬æœ‰3ä¸ªé‡å­æ¯”ç‰¹ï¼Œä¸æµ‹å¾—ç›¸ä½å¯¹åº”çš„ç»“æœä¸ºï¼š

> rows, measured_phases = \[\], \[\]
>
> for output in counts:
>
> decimal = int(output, 2) \# Convert (base 2) string to decimal
>
> phase = decimal/(2\*\*n_count) \# Find corresponding eigenvalue
>
> measured_phases.append(phase)
>
> \# Add these values to the rows in our table:
>
> rows.append(\[\"%s(bin) = %i(dec)\" % (output, decimal), \"%i/%i =
> %.2f\" % (decimal, 2\*\*n_count, phase)\])
>
> \# Can use tabulate to print the rows this as a nice ASCII table:
>
> print(tabulate(rows, headers=\[\"Register Output\", \"Phase\"\],
> colalign=\[\"left\",\"right\"\]))
>
> è¾“å‡ºï¼š

![](pics/media/image227.png)

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨Pythonå†…å»ºçš„Fractionsæ¨¡å—å°†æµ®ç‚¹æ•°è½¬æ¢ä¸ºåˆ†æ•°å¯¹è±¡ï¼š

> Fraction(0.666)
>
> è¾“å‡ºï¼š
>
> Fraction(5998794703657501, 9007199254740992)
>
> 5998794703657501/9007199254740992
>
> è¾“å‡ºï¼š
>
> 0.666

å› å…¶ç»™å‡ºçš„åˆ†æ•°è¿”å›ç²¾ç¡®çš„ç»“æœ(åœ¨æœ¬ä¾‹ä¸­æ˜¯0.6660000...)ï¼Œæ‰€ä»¥å¯èƒ½ä¼šå¾—åˆ°ç±»ä¼¼ä¸Šé¢ç²—ç³™ç»“æœã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨.limit_denominator()æ–¹æ³•æ¥è·å¾—åˆ†æ¯åœ¨æŸä¸€å€¼ä»¥ä¸‹çš„æœ€æ¥è¿‘æµ®ç‚¹æ•°çš„åˆ†æ•°:

> \# Get fraction that most closely resembles 0.666
>
> \# with denominator \< 15
>
> Fraction(0.666).limit_denominator(15)
>
> è¾“å‡ºï¼š
>
> Fraction(2, 3)

å¥½å¤šäº†ï¼é˜¶(r)è‚¯å®šå°äºNï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠæœ€å¤§åˆ†æ¯è®¾ä¸º15ï¼š

> rows = \[\]
>
> for phase in measured_phases:
>
> frac = Fraction(phase).limit_denominator(15)
>
> rows.append(\[phase, \"%i/%i\" % (frac.numerator, frac.denominator),
> frac.denominator\])
>
> \# Print as a table
>
> headers=\[\"Phase\", \"Fraction\", \"Guess for r\"\]
>
> df = pd.DataFrame(rows, columns=headers)
>
> print(df)
>
> Phase Fraction Guess for r
>
> \-\-\-\-\-\-- \-\-\-\-\-\-\-\-\-- \-\-\-\-\-\-\-\-\-\-\-\--
>
> 0.75 3/4 4
>
> 0.5 1/2 2
>
> 0.25 1/4 4
>
> 0 0/1 1

å¯ä»¥çœ‹åˆ°å…¶ä¸­ä¸¤ä¸ªæµ‹å¾—çš„æœ¬å¾å€¼ç»™å‡ºäº†æ­£ç¡®çš„ç»“æœï¼š$r = 4$ï¼Œå¹¶ä¸”è¿˜èƒ½çœ‹å‡ºShorç®—æ³•æœ‰å¤±æ•ˆçš„å¯èƒ½ã€‚è¿™äº›é”™è¯¯çš„ç»“æœç”±äº$s = 0$ï¼Œæˆ–è€…ç”±äº$s$å’Œ$r$äº’ç´ å¹¶ä¸”æˆ‘ä»¬è¢«ç»™äºˆäº†$r$çš„ä¸€ä¸ªå› å­è€Œé$r$ã€‚æœ€ç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯ç®€å•åœ°é‡å¤è¿™ä¸€å®éªŒ,ç›´åˆ°å¾—åˆ°ä»¤äººæ»¡æ„çš„ç»“æœ$r$ã€‚

#### å¿«é€Ÿç»ƒä¹ 

-   ç”¨$a = 2ã€8ã€11å’Œ13$ä¿®æ”¹ä¸Šè¿°çš„å›è·¯ã€‚æ‚¨æ‰€è·çš„ç»“æœæ˜¯ä»€ä¹ˆï¼Ÿä¸ºä½•ï¼Ÿ

### 4. æ¨¡å¹‚è¿ç®—

æ‚¨å¯èƒ½å·²ç»å¯Ÿè§‰åˆ°é€šè¿‡é‡å¤ä¸ğ‘—å‘ˆæŒ‡æ•°çº§å¢é•¿çš„$U$åˆ›å»º$U^{2^{j}}$çš„æ–¹æ³•ï¼Œå¹¶ä¸”ä¸ä¼šå¾—åˆ°å¤šé¡¹å¼æ—¶é—´ç®—æ³•ã€‚æˆ‘ä»¬æƒ³è¦æ‰¾å‡ºåˆ›å»ºä¸ğ‘—å‘ˆæŒ‡æ•°çº§å¢é•¿çš„å¦‚ä¸‹ç®—å­çš„æ–¹æ³•ï¼š

$$U^{2^{j}}\left| y \right\rangle = \left| a^{2^{j}}y\ \text{mod}\ N \right\rangle$$

å¹¸è¿çš„æ˜¯æœ‰å¯èƒ½æœ‰æ•ˆçš„è®¡ç®—ä¸‹å¼ï¼š

$$a^{2^{j}}\ \text{mod}\ N$$

ç»å…¸è®¡ç®—æœºèƒ½å¤Ÿä½¿ç”¨åå¤å¹³æ–¹æ³•ï¼ˆrepeated-squaring
algorithmï¼‰æ¥è®¡ç®—å‡ºæŒ‡æ•°ã€‚åœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ä¸­ï¼Œç”±äºä»…éœ€å¤„ç†$2^{j}$å½¢å¼çš„æŒ‡æ•°ï¼Œåå¤å¹³æ–¹æ³•å°±ä¼šå˜å¾—éå¸¸ç®€å•ï¼š

> def a2jmodN(a, j, N):
>
> \"\"\"Compute a\^{2\^j} (mod N) by repeated squaring\"\"\"
>
> for i in range(j):
>
> a = np.mod(a\*\*2, N)
>
> return a
>
> a2jmodN(7, 2049, 53)
>
> è¾“å‡ºï¼š
>
> 47

å¦‚æœåœ¨Pythonä¸­å­˜åœ¨ä¸€ä¸ªæœ‰æ•ˆçš„ç®—æ³•ï¼Œé‚£ä¹ˆå°±å¯ä»¥åœ¨é‡å­è®¡ç®—æœºä¸Šä½¿ç”¨ç›¸åŒçš„ç®—æ³•ã€‚ä½†å¾ˆä¸å¹¸çš„æ˜¯ï¼šå°½ç®¡ç”¨$j$è¿›è¡Œäº†å¤šé¡¹å¼ç¼©æ”¾ï¼Œæ¨¡å¹‚è¿ç®—å›è·¯ä»ä¸ç®€å•,æ­¤ä¸ºShorç®—æ³•çš„ç“¶é¢ˆã€‚ä¸€ä¸ªå¯¹åˆå­¦è€…å‹å¥½çš„å®ç°å¯ä»¥åœ¨å‚è€ƒæ–‡çŒ®\[1\]ä¸­æ‰¾åˆ°ã€‚

### 5. å‘¨æœŸæ‰¾å¯»æ±‚å› å¼åˆ†è§£

å¹¶éæ‰€æœ‰çš„å› å¼åˆ†è§£é—®é¢˜éƒ½æ˜¯å›°éš¾çš„ï¼›æˆ‘ä»¬å¯ä»¥ç«‹å³å‘ç°ä¸€ä¸ªå¶æ•°çš„å› å­ä¹‹ä¸€æ˜¯2ã€‚äº‹å®ä¸Šå­˜åœ¨ä¸€äº›éš¾ä»¥æ‰¾å‡ºå› å­çš„æ•°å­—çš„[å…·ä½“æ ‡å‡†](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf#%5B%7B%22num%22%3A127%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C223%2C0%5D)ï¼Œä½†åŸºæœ¬æ€æƒ³æ˜¯é€‰æ‹©ä¸¤ä¸ªå¤§ç´ æ•°çš„ä¹˜ç§¯ã€‚

åœ¨ä½¿ç”¨Shorå‘¨æœŸæ‰¾å¯»ç®—æ³•åº”å¯¹æœ€åçš„æƒ…å†µçš„æƒ…å†µå‰ï¼Œä¸€ä¸ªé€šç”¨å› å¼åˆ†è§£ç®—æ³•é¦–å…ˆä¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨åˆ†è§£ä¸€ä¸ªæ•´æ•°çš„æ·å¾„ï¼ˆæ•°å­—æ˜¯å¶æ•°å—ï¼Ÿæ•°å­—æ˜¯ä¸æ˜¯$N = a^{b}$çš„å½¢å¼ï¼Ÿï¼‰ã€‚ç”±äºç›®æ ‡æ˜¯ç®—æ³•çš„é‡å­éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ç›´æ¥è·³åˆ°Næ˜¯ä¸¤ä¸ªç´ æ•°ä¹˜ç§¯çš„æƒ…å†µã€‚

#### ç¤ºä¾‹ï¼šå› å¼åˆ†è§£15

ä¸ºäº†è§‚å¯Ÿåˆ†è§£å°‘é‡é‡å­æ¯”ç‰¹çš„ä¾‹å­ï¼Œæˆ‘ä»¬å°†å› å¼åˆ†è§£ç”±ä¸å¤ªå¤§çš„è´¨æ•°3å’Œ5çš„ä¹˜ç§¯15ã€‚

N = 15

ç¬¬ä¸€æ­¥æ˜¯åœ¨$1$å’Œ$N - 1$ä¹‹é—´é€‰æ‹©ä¸€ä¸ªéšæœºæ•°å­—$x$ï¼š

> np.random.seed(1) \# This is to make sure we get reproduceable results
>
> a = randint(2, 15)
>
> print(a)
>
> è¾“å‡ºï¼š
>
> 7

æ¥ç€å¿«é€Ÿæ£€æŸ¥è¿™ä¸€æ•°å­—æ˜¯å¦æ˜¯Nçš„éå¹³å‡¡å› å­ï¼ˆæ³¨ï¼šè‹¥xèƒ½æ•´é™¤nä¸”1\<x\<nï¼Œåˆ™xæ˜¯nçš„éå¹³å‡¡å› å­ï¼‰ã€‚

> from math import gcd \# greatest common divisor
>
> gcd(a, 15)
>
> è¾“å‡ºï¼š
>
> 1

ä¸‹ä¸€æ­¥å¯¹a=7å’ŒN=15ä½¿ç”¨Shorçš„é˜¶æ‰¾å¯»ç®—æ³•ã€‚è®°ä½ï¼æˆ‘ä»¬æµ‹é‡çš„ç›¸ä½æ˜¯$s/r$ï¼Œå…¶ä¸­ï¼š

$$a^{r}\ \text{mod}\ N = 1$$

$s$æ˜¯$0$å’Œ$r - 1$ä¹‹é—´çš„ä¸€ä¸ªéšæœºæ•´æ•°ã€‚

> def qpe_amod15(a):
>
> n_count = 3
>
> qc = QuantumCircuit(4+n_count, n_count)
>
> for q in range(n_count):
>
> qc.h(q) \# Initialise counting qubits in state \|+\>
>
> qc.x(3+n_count) \# And ancilla register in state \|1\>
>
> for q in range(n_count): \# Do controlled-U operations
>
> qc.append(c_amod15(a, 2\*\*q),
>
> \[q\] + \[i+n_count for i in range(4)\])
>
> qc.append(qft_dagger(n_count), range(n_count)) \# Do inverse-QFT
>
> qc.measure(range(n_count), range(n_count))
>
> \# Simulate Results
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> \# Setting memory=True below allows us to see a list of each
> sequential reading
>
> result = execute(qc, backend, shots=1, memory=True).result()
>
> readings = result.get_memory()
>
> print(\"Register Reading: \" + readings\[0\])
>
> phase = int(readings\[0\],2)/(2\*\*n_count)
>
> print(\"Corresponding Phase: %f\" % phase)
>
> return phase

å¯¹äºè¿™ä¸€ç›¸ä½ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ˜“çš„æ‰¾å‡º$r$çš„ä¸€ä¸ªçŒœæµ‹ã€‚

> np.random.seed(3) \# This is to make sure we get reproduceable results
>
> phase = qpe_amod15(a) \# Phase = s/r
>
> Fraction(phase).limit_denominator(15) \# Denominator should
> (hopefully!) tell us r
>
> è¾“å‡ºï¼š
>
> Register Reading: 100
>
> Corresponding Phase: 0.500000
>
> Fraction(1, 2)
>
> frac = Fraction(phase).limit_denominator(15)
>
> s, r = frac.numerator, frac.denominator
>
> print(r)
>
> è¾“å‡ºï¼š
>
> 2

è‡³æ­¤æˆ‘ä»¬è·å¾—äº†$r$ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™ä¸ªæ•°å­—æ¥æ‰¾å‡º$N$çš„ä¸€ä¸ªå› å­ã€‚

ç”±äºï¼š

$$a^{r}\ \text{mod}\ N = 1$$

ç„¶åï¼š

$$(a^{r} - 1)\ \text{mod}\ N = 0$$

è¡¨æ˜$N$æ•´é™¤$a^{r} - 1$ã€‚å¦‚æœ$r$è¿˜æ˜¯ä¸€ä¸ªå¶æ•°ï¼Œåˆ™ï¼š

$$a^{r} - 1 = (a^{\frac{r}{2}} - 1)(a^{\frac{r}{2}} + 1)$$

ï¼ˆå¦‚æœ$r$ä¸æ˜¯å¶æ•°å°±ä¸èƒ½ç»§ç»­äº†ï¼Œå¿…é¡»ç”¨ä¸åŒçš„$a$å€¼å†è¯•ä¸€æ¬¡ã€‚ï¼‰é‚£ä¹ˆæœ‰å¾ˆå¤§çš„æ¦‚ç‡$a^{\frac{r}{2}} - 1$æˆ–$a^{\frac{r}{2}} + 1$çš„æœ€å¤§å…¬çº¦æ•°æ˜¯$N$çš„ä¸€ä¸ªå› å­
\[2\]ã€‚

> guesses = \[gcd(a\*\*(r//2)-1, N), gcd(a\*\*(r//2)+1, N)\]
>
> print(guesses)
>
> è¾“å‡ºï¼š
>
> \[3,1\]

ä¸‹é¢ä»£ç ä¸­å°†é‡å¤ç®—æ³•ç›´åˆ°è‡³å°‘æ‰¾å‡º15çš„ä¸€ä¸ªå› å­ã€‚æ‚¨åº”è¯¥å†æ¬¡è¿è¡Œè¿™äº›ä»£ç å¤šæ¬¡æ¥æŸ¥çœ‹å…¶ä½œç”¨ã€‚

> a = 7
>
> factor_found = False
>
> attempt = 0
>
> while not factor_found:
>
> attempt += 1
>
> print(\"\\nAttempt %i:\" % attempt)
>
> phase = qpe_amod15(a) \# Phase = s/r
>
> frac = Fraction(phase).limit_denominator(15) \# Denominator should
> (hopefully!) tell us r
>
> r = frac.denominator
>
> print(\"Result: r = %i\" % r)
>
> if phase != 0:
>
> \# Guesses for factors are gcd( x\^{r/2} Â±1 , 15)
>
> guesses = \[gcd(a\*\*(r//2)-1, 15), gcd(a\*\*(r//2)+1, 15)\]
>
> print(\"Guessed Factors: %i and %i\" % (guesses\[0\], guesses\[1\]))
>
> for guess in guesses:
>
> if guess != 1 and (15 % guess) == 0: \# Check to see if guess is a
> factor
>
> print(\"\*\*\* Non-trivial factor found: %i \*\*\*\" % guess)
>
> factor_found = True
>
> è¾“å‡ºï¼š
>
> Attempt 1:
>
> Register Reading: 110
>
> Corresponding Phase: 0.750000
>
> Result: r = 4
>
> Guessed Factors: 3 and 5
>
> \*\*\* Non-trivial factor found: 3 \*\*\*
>
> \*\*\* Non-trivial factor found: 5 \*\*\*

### 6. å‚è€ƒæ–‡çŒ®

1\. Stephane Beauregard, Circuit for Shor\'s algorithm using 2n+3
qubits, [arXiv:quant-ph/0205095](https://arxiv.org/abs/quant-ph/0205095)

2\. M. Nielsen and I. Chuang, Quantum Computation and Quantum
Information, Cambridge Series on Information and the Natural Sciences
(Cambridge University Press, Cambridge, 2000). (Page 633)

3.10 Grover\'s Algorithmï¼ˆé‡å­æœå¯»ç®—æ³•ï¼‰
----------------------------------------

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å¼•å…¥Groverç®—æ³•å¹¶è§£é‡Šå…¶å¦‚ä½•ç”¨äºè§£å†³éç»“æ„åŒ–æœç´¢é—®é¢˜ã€‚ç„¶åä½¿ç”¨Qiskitå®ç°è¿™ä¸€é‡å­ç®—æ³•ï¼Œå¹¶åœ¨æ¨¡æ‹Ÿå™¨å’ŒçœŸå®è®¾å¤‡ä¸Šè¿è¡Œè¯¥ç®—æ³•ã€‚

### å†…å®¹

1\. ç®€ä»‹

2\. ç¤ºä¾‹ï¼š2-é‡å­æ¯”ç‰¹

2.1 Qiskitå®ç°

2.1.1 æ¨¡æ‹Ÿå™¨

2.1.2 çœŸå®è®¾å¤‡

3\. ç¤ºä¾‹ï¼š3-é‡å­æ¯”ç‰¹

3.1 æ¨¡æ‹Ÿå™¨

3.2 çœŸå®è®¾å¤‡

4\. ç»ƒä¹ 

5\. å‚è€ƒæ–‡çŒ®

### 1. ç®€ä»‹

æ‚¨å¯èƒ½å·²ç»å¬è¿‡é‡å­è®¡ç®—æœºç›¸å¯¹äºä¼ ç»Ÿè®¡ç®—æœºæ‰€å…·æœ‰çš„ä¼—å¤šä¼˜åŠ¿ä¹‹ä¸€æ˜¯å…¶å“è¶Šçš„æ•°æ®åº“æœç´¢é€Ÿåº¦ã€‚Groverç®—æ³•è¯æ˜äº†è¿™ä¸€èƒ½åŠ›ã€‚è¯¥ç®—æ³•å¯ä»¥å¯¹éç»“æ„åŒ–æœç´¢é—®é¢˜è¿›è¡ŒäºŒæ¬¡åŠ é€Ÿï¼Œä½†æ˜¯å…¶ç”¨é€”ä¸ä»…é™äºæ­¤ï¼›å…¶å¯ä»¥ç”¨ä½œé€šç”¨æŠ€å·§æˆ–å­ä¾‹ç¨‹ï¼Œè®©å„ç§å…¶ä»–ç®—æ³•è·å¾—äºŒæ¬¡è¿è¡Œæ—¶é—´çš„æ”¹è¿›ã€‚è¿™è¢«ç§°ä¸ºå¹…å€¼æ”¾å¤§æŠ€å·§ã€‚

#### éç»“æ„åŒ–æœç´¢

å‡è®¾ç»™æ‚¨ä¸€ä¸ªæœ‰$N$ä¸ªé¡¹ç›®çš„å¤§åˆ—è¡¨ã€‚åœ¨è¿™äº›é¡¹ç›®ä¸­æœ‰ä¸€ä¸ªé¡¹ç›®å…·æœ‰ç‹¬ç‰¹çš„å±æ€§ï¼Œæˆ‘ä»¬å¸Œæœ›å°†å…¶æ‰¾å‡ºï¼›æˆ‘ä»¬å°†å…¶ç§°ä¸ºèµ¢å®¶$\omega$ã€‚æˆ‘ä»¬å°†åˆ—è¡¨ä¸­çš„æ¯ä¸€é¡¹çœ‹ä½œæ˜¯ä¸€ä¸ªç‰¹å®šé¢œè‰²çš„æ¡†ã€‚å‡è®¾é™¤äº†ç´«è‰²çš„èµ¢å®¶$\omega$ä¹‹å¤–ï¼Œåˆ—è¡¨ä¸­çš„æ‰€æœ‰é¡¹ç›®éƒ½æ˜¯ç°è‰²ã€‚

![](pics/media/image228.png)

ä¸ºäº†æ‰¾å‡ºç´«è‰²çš„æ¡†------æ ‡è®°é¡¹------ä½¿ç”¨ç»å…¸è®¡ç®—æ–¹æ³•å°†ä¼šæ£€æŸ¥è‡³å°‘$N/2$ä¸ªæ¡†ï¼Œæœ€å·®çš„æƒ…å†µéœ€è¦æ£€æŸ¥å…¨éƒ¨é¡¹ç›®ã€‚ç„¶è€Œåœ¨ä¸€ä¸ªé‡å­è®¡ç®—æœºä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Groverå¹…å€¼æ”¾å¤§æŠ€å·§åœ¨å¤§è‡´$\sqrt{N}$æ­¥å†…æ‰¾å‡ºè¢«æ ‡è®°é¡¹ã€‚åœ¨æŸ¥æ‰¾é•¿åˆ—è¡¨ä¸­çš„æ ‡è®°é¡¹æ—¶ï¼ŒäºŒæ¬¡åŠ é€Ÿç¡®å®å¯ä»¥èŠ‚çœå¤§é‡æ—¶é—´ã€‚æ­¤å¤–ï¼Œè¯¥ç®—æ³•ä¸ä½¿ç”¨åˆ—è¡¨çš„å†…éƒ¨ç»“æ„ï¼Œä½¿å…¶å…·æœ‰é€šç”¨æ€§ï¼›è¿™å°±æ˜¯ä¸ºä»€ä¹ˆè¿™ä¸€ç®—æ³•ç«‹å³ä¸ºè®¸å¤šç»å…¸é—®é¢˜æä¾›äº†äºŒæ¬¡é‡å­åŠ é€Ÿçš„åŸå› ã€‚

#### åˆ›å»ºä¸€ä¸ªé¢„è¨€

å¯¹äºç« ä¸­çš„ä¾‹å­ï¼Œæˆ‘ä»¬çš„"æ•°æ®åº“"æ˜¯ç”±é‡å­æ¯”ç‰¹å¯èƒ½æ‰€å¤„çš„æ‰€æœ‰è®¡ç®—åŸºçš„çŠ¶æ€ç»„æˆã€‚ä¾‹å¦‚,å¦‚æœæˆ‘ä»¬æœ‰3ä¸ªé‡å­æ¯”ç‰¹,åˆ—è¡¨æ˜¯æ€$|000\rangle|001\rangle\ldots\ldots|111\rangle$(å³æ€$|0\rangle$â†’æ€$|7\rangle$)ã€‚

Groverç®—æ³•è§£å†³äº†åœ¨è§£æ€ä¸Šæ·»åŠ è´Ÿç›¸ä½çš„é¢„è¨€ã€‚å³å¯¹ä»»æ„æ€$|x\rangle$å…¶è®¡ç®—åŸºä¸º:

$$U_{\omega}|x\rangle = \{\begin{matrix}
\text{\ \ \ }\left| x \right\rangle\text{\ \ \ }\text{if}\text{\ \ \ }x \neq \omega \\
 - \left| x \right\rangle\text{\ \ \ }\text{if}\text{\ \ \ }x = \omega \\
\end{matrix}$$

è¿™ä¸ªé¢„è¨€å°†æ˜¯ä¸€ä¸ªå¯¹è§’çŸ©é˜µï¼Œå…¶ä¸­å¯¹åº”äºæ ‡è®°é¡¹çš„æ¡ç›®å°†å…·æœ‰ä¸€ä¸ªè´Ÿç›¸ä½ã€‚ä¾‹å¦‚,å¦‚æœæˆ‘ä»¬æœ‰ä¸‰ä¸ªé‡å­æ¯”ç‰¹å’Œ$\omega = 101$,æ”¹é¢„è¨€å°†æ˜¯çŸ©é˜µ:

$$U_{\omega} = \begin{bmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & - 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
\end{bmatrix}\begin{matrix}
 \\
 \\
 \\
 \\
 \\
 \\
 \leftarrow \omega = \text{101} \\
 \\
 \\
 \\
\end{matrix}$$

æ˜¯ä»€ä¹ˆå¯¼è‡´Groverç®—æ³•å¯ä»¥å¦‚æ­¤è½»æ˜“å°†ä¸€ä¸ªé—®é¢˜è½¬æ¢ä¸ºå¦‚æ­¤å½¢åŠ¿çš„é¢„è¨€å‘¢ï¼Ÿåœ¨è®¸å¤šè®¡ç®—é—®é¢˜ä¸­å¾ˆéš¾*æ‰¾å‡º*ä¸€ä¸ªè§£ï¼Œä½†æ¯”è¾ƒå®¹æ˜“*éªŒè¯*ä¸€ä¸ªè§£ã€‚ä¾‹å¦‚é€šè¿‡æ£€æŸ¥æ˜¯å¦æ»¡è¶³æ‰€æœ‰è§„åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°éªŒè¯ä¸€ä¸ªæ•°ç‹¬æ¸¸æˆçš„è§£ã€‚å¯¹äºè¿™äº›é—®é¢˜,æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå‡½æ•°$f$å¹¶è¾“å…¥é¢„æƒ³çš„è§£$x$,åœ¨$x$å¹¶éè§£æ—¶$(x \neq \omega)$è¿”å›$f(x) = 0$å’Œåœ¨$x$æ˜¯ä¸€ä¸ªæœ‰æ•ˆè§£$(x = \omega)$æ—¶è¿”å›$f(x) = 1$ã€‚æˆ‘ä»¬çš„é¢„è¨€å¯ä»¥è¿™æ ·æè¿°:

$$U_{\omega}|x\rangle = ( - 1)^{f(x)}|x\rangle$$

æ­¤æ—¶é¢„è¨€çŸ©é˜µå°†æ˜¯å¯¹è§’çŸ©é˜µçš„å½¢å¼ï¼š

$$U_{\omega} = \begin{bmatrix}
( - 1)^{f\left( 0 \right)} & 0 & \cdots & 0 \\
0 & ( - 1)^{f\left( 1 \right)} & \cdots & 0 \\
 \vdots & 0 & \ddots & \vdots \\
0 & 0 & \cdots & ( - 1)^{f\left( 2^{n} \right)} \\
\end{bmatrix}$$

**æç¤ºï¼šä¸€ä¸ªGroveré¢„è¨€çš„å›è·¯ç»“æ„**

è‹¥æœ‰ä¸€ç»å…¸å‡½æ•°$f(x)$ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è½¬æ¢ä¸ºå¦‚ä¸‹å½¢å¼çš„å¯é€†å›è·¯ï¼š

![](pics/media/image229.png)

å¦‚æœæˆ‘ä»¬å°†"è¾“å‡º"é‡å­æ¯”ç‰¹åˆå§‹åŒ–ä¸ºæ€$| - \rangle$ï¼Œç›¸ä½åå†²æ•ˆæœä¼šå°†å…¶è½¬æ¢ä¸ºä¸€ä¸ªGroveré¢„è¨€ï¼ˆç±»ä¼¼äºDeutsch-Jozsaé¢„è¨€çš„ä½œç”¨æ•ˆæœï¼‰ï¼š

![](pics/media/image231.png)

ç„¶åæˆ‘ä»¬å¿½ç•¥è¾…åŠ©é‡å­æ¯”ç‰¹ï¼ˆ$| - \rangle$ï¼‰ã€‚

å¦‚ä½•å°†åˆ—è¡¨é¡¹æä¾›ç»™é‡å­è®¡ç®—æœºå‘¢ï¼Ÿç¼–ç æ­¤ç±»åˆ—è¡¨çš„ä¸€ç§å¸¸è§æ–¹æ³•æ˜¯ä½¿ç”¨å‡½æ•°$f$ï¼Œè¯¥å‡½æ•°å¯¹æ‰€æœ‰æœªæ ‡è®°é¡¹$x$è¿”å›$f(x) = 0$ï¼Œå¯¹èµ¢å®¶è¿”å›$f(w) = 1$ã€‚è‹¥è¦ä½¿ç”¨é‡å­è®¡ç®—æœºæ¥è§£å†³è¿™ä¸€é—®é¢˜ï¼Œæˆ‘ä»¬å¿…é¡»å‘è¿™ä¸€å‡½æ•°ç»™å‡ºè¿™äº›é¡¹ç›®çš„å åŠ æ€ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†è¿™ä¸ªå‡½æ•°ç¼–ç æˆä¸€ä¸ªç§°ä¸º*é¢„è¨€*çš„å¹ºæ­£çŸ©é˜µã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯¹è¿™äº›é¡¹ç›®è¿›è¡ŒäºŒè¿›åˆ¶ç¼–ç $x,w \in {\{ 0,1\}}^{n}$ï¼Œå› æ­¤$N = 2^{n}$ï¼›ç°åœ¨æˆ‘ä»¬å¯ä»¥åœ¨é‡å­è®¡ç®—æœºä¸Šç”¨é‡å­æ¯”ç‰¹æ¥è¡¨ç¤ºè¿™äº›é¡¹ç›®ã€‚ç„¶åå®šä¹‰ä¸€ä¸ªé¢„è¨€çŸ©é˜µ$U_{f}$æ‰§è¡Œä»»ä¸€ç®€å•æ“ä½œï¼Œé€šè¿‡$U_{f}\left| x \right\rangle = {( - 1)}^{f(x)}|x\rangle$è§„èŒƒåŸº$|x\rangle$çš„çŠ¶æ€ã€‚

å¯ä»¥çœ‹å‡ºå¦‚æœ$x$æ˜¯ä¸€ä¸ªæ²¡æœ‰æ ‡è®°çš„é¡¹ç›®ï¼Œåˆ™é¢„è¨€å°±ä¸ä¼šæ”¹å˜å…¶çŠ¶æ€ã€‚ç„¶è€Œï¼Œå½“æˆ‘ä»¬åœ¨åŸºæ€$|\omega\rangle$ä¸Šåº”ç”¨é¢„è¨€æ—¶ï¼Œå°±ä¼šå°†å…¶æ˜ å°„ä¸º$U_{f}\left| w \right\rangle = - |\omega\rangle$ã€‚ä»å‡ ä½•ä¸Šè®²ï¼Œè¿™ä¸€å¹ºæ­£çŸ©é˜µå¯¹åº”äºå…³äº$N = 2^{n}$ç»´å‘é‡ç©ºé—´ä¸­æ ‡è®°é¡¹åŸç‚¹çš„åå°„ã€‚

#### å¹…å€¼æ”¾å¤§

é‚£ä¹ˆè¿™ä¸€ç®—æ³•æ˜¯å¦‚ä½•å·¥ä½œçš„å‘¢ï¼Ÿåœ¨çœ‹é¡¹ç›®æ¸…å•ä¹‹å‰ï¼Œæˆ‘ä»¬ä¸çŸ¥é“æ ‡è®°é¡¹åœ¨å“ªé‡Œã€‚å› æ­¤å¯¹å…¶ä½ç½®çš„ä»»ä½•çŒœæµ‹éƒ½ç›¸åŒï¼Œå¯ä»¥ç”¨å‡åŒ€å åŠ çš„å½¢å¼è¡¨ç¤ºï¼š$\left| s \right\rangle = \frac{1}{\sqrt{N}}\sum_{x = 0}^{N - 1}{|x\rangle}$ã€‚

å¦‚æœæˆ‘ä»¬åœ¨æ ‡å‡†åŸº$\{|x\rangle\}$ä¸‹æµ‹é‡ï¼Œä¾æ®ç¬¬äº”é‡å­å®šå¾‹è¿™ä¸€å åŠ æ€å°†ä¼šåç¼©ï¼Œå¯¼è‡´ä»»ä¸€åŸºæ€éƒ½å°†æ˜¯åŒæ ·çš„æ¦‚ç‡$\frac{1}{N} = \frac{1}{2^{n}}$ã€‚æˆ‘ä»¬çŒœåˆ°æ­£ç¡®$\omega$å€¼çš„å‡ ç‡æ˜¯å¯é¢„è§çš„$\frac{1}{2^{n}}$ã€‚å› æ­¤ï¼Œé€šå¸¸æ¥è¯´æˆ‘ä»¬éœ€è¦å°è¯•$N = 2^{n}$æ¬¡æ‰èƒ½çŒœåˆ°æ­£ç¡®é¡¹ç›®ã€‚

è¿™æ˜¯ä¸€ä¸ªå«åšå¹…å€¼æ”¾å¤§çš„è¿‡ç¨‹ï¼Œé‡å­è®¡ç®—æœºå°±æ˜¯è¿™æ ·æ˜¾è‘—åœ°æé«˜äº†è¿™ç§å¯èƒ½æ€§ã€‚è¿™ä»¥è¿‡ç¨‹æ‰©å±•ï¼ˆæ”¾å¤§ï¼‰æ ‡è®°é¡¹çš„å¹…å€¼ä»è€Œç¼©å°å…¶ä»–é¡¹çš„å¹…å€¼ï¼Œå› æ­¤æµ‹é‡æœ€ç»ˆçŠ¶æ€å°†è¿‘ä¹ç¡®å®šåœ°è¿”å›æ­£ç¡®çš„é¡¹ç›®ã€‚

è¯¥ç®—æ³•å¯¹ä¸¤ç§åå°„å…·æœ‰è‰¯å¥½çš„å‡ ä½•æ¨æ–­ï¼Œä¼šåœ¨äºŒç»´å¹³é¢ä¸­äº§ç”Ÿä¸€ä¸ªæ—‹è½¬ã€‚æˆ‘ä»¬éœ€è¦è€ƒè™‘çš„åªæœ‰ä¸¤ä¸­ç‰¹æ®Šçš„çŠ¶æ€ï¼šèµ¢å®¶$|\omega\rangle$å’Œå‡åŒ€å åŠ $|s\rangle$ã€‚è¿™ä¸¤ä¸ªå‘é‡åœ¨å‘é‡ç©ºé—´$\mathbb{C}^{N}$ä¸­å¼ æˆä¸€ä¸ªäºŒç»´å¹³é¢ã€‚è¿™ä¸¤ä¸ªå‘é‡ä¹‹é—´å¹¶éç›¸äº’å‚ç›´,å› ä¸º$|\omega\rangle$å‡ºç°åœ¨å¹…å€¼ä¸º$N^{- 1/2}$çš„å åŠ æ€ä¸­ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™ä¸¤ä¸ªå‘é‡å¼ æˆçš„å¹³é¢ä¸­å¼•å…¥ä¸€ä¸ªé™„åŠ çŠ¶æ€$|s'\rangle$ï¼Œä½¿å…¶å‚ç›´äº$|\omega\rangle$å¹¶é€šè¿‡ç§»é™¤$|\omega\rangle$å’Œå°ºåº¦å˜æ¢ä»$|s\rangle$ä¸­è·å–è¿™ä¸€é™„åŠ çŠ¶æ€ã€‚

**æ­¥éª¤1**ï¼šå¹…å€¼æ”¾å¤§è¿‡ç¨‹ä»¥å‡åŒ€å åŠ $|s\rangle$å¼€å§‹,å…¶å¾ˆå®¹æ˜“ç”±$\left| s \right\rangle = H^{\bigotimes n}{|0\rangle}^{n}$æ„å»ºã€‚

![](pics/media/image233.png)

å·¦è¾¹çš„å›¾å¯¹åº”äºç”±ç›¸äº’å‚ç›´çš„å‘é‡$|w\rangle$å’Œ$|s'\rangle$å¼ æˆçš„äºŒä½å¹³é¢ï¼Œå¯å°†åˆå§‹çŠ¶æ€è¡¨è¿°ä¸º$|s\rangle = sin\theta|\omega\rangle + cos\theta|s'\rangle$ï¼Œå…¶ä¸­$\theta = \arcsin\langle s|\omega\rangle = arcsin\frac{1}{\sqrt{N}}$ã€‚å³è¾¹çš„å›¾ä¸º$N = 2^{2} = 4$æƒ…å†µä¸‹æ€$|s\rangle$å¹…å€¼çš„æŸ±çŠ¶å›¾ï¼Œå¹³å‡å¹…å€¼ç”¨è™šçº¿è¡¨ç¤ºã€‚

**æ­¥éª¤2**ï¼šåº”ç”¨é¢„è¨€åå°„$U_{f}$è‡³æ€$|s\rangle$ã€‚

![](pics/media/image234.png)

ä»å‡ ä½•ä¸Šæ¥è¯´è¿™ä¸€è¿‡ç¨‹å¯¹åº”äºå…³äº$|s'\rangle$çš„æ€$|s\rangle$çš„åå°„ã€‚è¿™ä¸€å˜æ¢æ„å‘³ç€å…ˆå‰æ€$|w\rangle$çš„å¹…å€¼å˜ä¸ºè´Ÿå€¼ï¼ŒåŒæ—¶å¹³å‡å¹…å€¼å˜å°ã€‚

**æ­¥éª¤3**ï¼šç°åœ¨åœ¨æ€$|s\rangle$åº”ç”¨ä¸€ä¸ªé¢å¤–çš„åå°„ï¼ˆ$U_{s}$ï¼‰:$U_{s} = 2|s\rangle\langle s| - \mathbb{1}$ã€‚è¿™ä¸€å˜æ¢å°†æ€$|s\rangle$æ˜ å°„è‡³$U_{s}U_{f}|s\rangle$å¹¶å®Œæˆäº†æ•´ä¸ªå˜æ¢è¿‡ç¨‹ã€‚

![](pics/media/image235.png)

ä¸¤æ¬¡åå°„å§‹ç»ˆå¯¹åº”äºä¸€ä¸ªæ—‹è½¬ã€‚å˜æ¢$U_{s}U_{f}$å°†åˆå§‹æ€$|s\rangle$æ—‹è½¬è‡³èµ¢å®¶$|\omega\rangle$é™„è¿‘ã€‚åœ¨å¹…å€¼çš„æ¡å½¢å›¾è§£ä¸­åå°„$U_{s}$çš„åŠ¨ä½œå¯è¢«ç†è§£ä¸ºå…³äºå¹³å‡å¹…å€¼çš„åå°„ã€‚ç”±äºåœ¨ç¬¬ä¸€ä¸ªåå°„ä¹‹åå¹³å‡å¹…å€¼å˜å°äº†ï¼Œè¿™ä¸€å˜æ¢å°†$|w\rangle$çš„å¹…å€¼æé«˜è‡³åŸæ¥çš„ä¸‰å€ï¼Œä¹ŸåŒæ—¶å‡å°äº†å…¶ä»–å¹…å€¼ã€‚ç„¶åé‡å¤æ­¥éª¤2ä¸­çš„åº”ç”¨ã€‚è¿™ä¸€è¿‡ç¨‹å°†é‡å¤å‡ æ¬¡ï¼Œä»¥é”å®šèµ¢å®¶$|w\rangle$ã€‚

ç»è¿‡$t$æ­¥åï¼Œæˆ‘ä»¬å°†è·å¾—æ€$|\psi_{t}\rangle$ï¼Œå…¶ä¸­$|\psi_{t}\rangle = {(U_{s}U_{f})}^{t}|s\rangle$ã€‚

æˆ‘ä»¬éœ€è¦åº”ç”¨å¤šå°‘æ¬¡æ—‹è½¬å‘¢ï¼Ÿäº‹å®è¯æ˜å¤§çº¦$\sqrt{N}$æ¬¡è¶³çŸ£ã€‚åœ¨è§‚å¯Ÿæ€$|\psi\rangle$çš„å¹…å€¼æ—¶å°±æ¸…æ¥šäº†ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ€$|\psi\rangle$çš„å¹…å€¼éšç€åº”ç”¨æ¬¡æ•°$tN^{- 1/2}$çš„å¢åŠ å‘ˆç°çº¿æ€§å¢é•¿ã€‚ç„¶è€Œï¼Œç”±äºæˆ‘ä»¬å…³å¿ƒçš„æ˜¯å¹…å€¼å¹¶éæ¦‚ç‡ï¼Œæ‰€ä»¥å‘é‡ç©ºé—´çš„ç»´æ•°ä»¥å¹³æ–¹æ ¹çš„å½¢å¼è¾“å…¥ã€‚å› æ­¤åœ¨è¿™ä¸€è¿‡ç¨‹ä¸­è¢«æ”¾å¤§çš„ä¸ä»…æ˜¯æ¦‚ç‡è¿˜æœ‰å¹…å€¼ã€‚åœ¨æœ‰$M$ä¸ªè§£çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥çœ‹å‡ºå¤§çº¦$\sqrt{(N/M)}$æ¬¡æ—‹è½¬å°±è¶³å¤Ÿäº†ã€‚

![IMG_256](pics/media/image236.png)

![](pics/media/image237.png)

### 2. ç¤ºä¾‹ï¼š2-é‡å­æ¯”ç‰¹

æˆ‘ä»¬é¦–å…ˆçœ‹ä¸€ä¸‹ç”¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹å®ç°Groverç®—æ³•$N = 4$çš„æƒ…å†µã€‚åœ¨è¿™ä¸€ä¸ç›´è§‰ç›¸åçš„ç‰¹æ®Šæƒ…å†µä¸­ï¼Œåªéœ€è¦ä¸€æ¬¡æ—‹è½¬å°±å¯ä»¥å°†åˆå§‹æ€$|s\rangle$å˜æ¢ä¸ºèµ¢å®¶$|\psi\rangle$ï¼ˆå‚é˜…å‚è€ƒæ–‡çŒ®\[3\]ï¼‰ã€‚

1\. ä¾æ®ä¸Šæ–‡çš„ä»‹ç»ï¼Œåœ¨$N = 4$æ—¶æˆ‘ä»¬æœ‰ï¼š

$$\theta = \arcsin\frac{1}{2} = \frac{\pi}{6}$$

2\. ç»è¿‡$t$æ­¥åï¼š

$${(U_{s}U_{f})}^{t}\left| s \right\rangle = \sin\theta_{t}\left| \omega \right\rangle + \cos\theta_{t}|s'\rangle$$

å…¶ä¸­ï¼š

$$\theta_{t} = (2t + 1)\theta$$

3\.
ä¸ºäº†è·å¾—$\left| \omega \right\rangle$éœ€è¦$\theta_{t} = \frac{\pi}{2}$ï¼Œå½“æ’å…¥$\theta = \frac{\pi}{6}$æ—¶ä¸Šé¢çš„ç»“æœä¸º$t = 1$ã€‚è¿™è¡¨æ˜åœ¨$t = 1$çš„æ—‹è½¬åï¼Œæƒ³è¦æœç´¢çš„å…ƒç´ å°±è¢«æ‰¾å‡ºæ¥äº†ã€‚

ç°åœ¨è®©æˆ‘ä»¬è€ƒå¯Ÿä¸€ä¸‹å¯èƒ½çš„é¢„è¨€ã€‚æˆ‘ä»¬æœ‰$N = 4$ä¸ªå¯èƒ½çš„å…ƒç´ ï¼Œå¦‚ï¼š$\left| 00 \right\rangle$ã€$\left| 01 \right\rangle$ã€$\left| 10 \right\rangle$å’Œ$\left| 11 \right\rangle$ï¼Œå› æ­¤æ€»å…±éœ€è¦4ä¸ªé¢„è¨€ã€‚

#### $\mathbf{|}\mathbf{w}\mathbf{\rangle = |11\rangle}$çš„é¢„è¨€

æˆ‘ä»¬ä»$|w\rangle = |11\rangle$çš„æƒ…å†µå¼€å§‹ã€‚åœ¨æ­¤æƒ…å†µä¸­é¢„è¨€$U_{f}$æŒ‰ç…§å¦‚ä¸‹æ­¥éª¤ä½œç”¨ï¼š

$$U_{f}\left| s \right\rangle = U_{f}\frac{1}{2}\left( \left| 00 \right\rangle + \left| 01 \right\rangle + \left| 10 \right\rangle + \left| 11 \right\rangle \right) = \frac{1}{2}\left( \left| 00 \right\rangle + \left| 01 \right\rangle + \left| 10 \right\rangle - \left| 11 \right\rangle \right)$$

ä¸ºäº†å®ç°$|11\rangle$çš„ç¬¦å·ç¿»è½¬ï¼Œæˆ‘ä»¬åªéœ€è¦å¯¹åˆå§‹çŠ¶æ€æ–½åŠ ä¸€ä¸ªå—æ§Zé—¨å³å¯ã€‚è¿™ä¼šå¯¼å‡ºä»¥ä¸‹å›è·¯ï¼š

![image6](pics/media/image238.png)

#### $\mathbf{|}\mathbf{\omega}\mathbf{\rangle = |00\rangle}$çš„é¢„è¨€

åœ¨$|w\rangle = |\mathbf{00}\rangle$çš„æƒ…å†µä¸­é¢„è¨€$U_{f}$æŒ‰ç…§å¦‚ä¸‹æ­¥éª¤ä½œç”¨ï¼š

$$U_{f}\left| s \right\rangle = U_{f}\frac{1}{2}\left( \left| 00 \right\rangle + \left| 01 \right\rangle + \left| 10 \right\rangle + \left| 11 \right\rangle \right) = \frac{1}{2}\left( - \left| 00 \right\rangle + \left| 01 \right\rangle + \left| 10 \right\rangle + \left| 11 \right\rangle \right)$$

ä¸ºäº†å®ç°$|00\rangle$çš„ç¬¦å·ç¿»è½¬ï¼Œæˆ‘ä»¬éœ€è¦å¯¹åˆå§‹çŠ¶æ€æ–½åŠ "åç›¸"å—æ§Zé—¨ï¼Œä»è€Œå¯¼å‡ºä»¥ä¸‹å›è·¯ï¼š

![image7](pics/media/image239.png)

#### $\mathbf{|}\mathbf{w}\mathbf{\rangle = |01\rangle}$å’Œ$\mathbf{|}\mathbf{w}\mathbf{\rangle = |10\rangle}$çš„é¢„è¨€

æŒ‰ç…§ä¸Šè¿°é€»è¾‘ï¼Œå¯ä»¥ç›´æ¥æ„é€ $|\omega\rangle = |01\rangle$ï¼ˆå·¦ä¾§çš„å›è·¯ï¼‰å’Œ$|\omega\rangle = |10\rangle$ï¼ˆå³ä¾§çš„å›è·¯ï¼‰çš„é¢„è¨€ï¼š

![image8](pics/media/image240.png)

#### åå°„$\mathbf{U}_{\mathbf{s}}$

ä¸ºäº†å®Œæˆè¿™ä¸€é‡å­å›è·¯ï¼Œæˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªé¢å¤–çš„åå°„$U_{s} = 2|s\rangle\langle s| - \mathbb{1}$ã€‚ç”±äºè¿™æ˜¯å…³äº$|s\rangle$çš„åå°„ï¼Œå› æ­¤æˆ‘ä»¬æƒ³å‘ä¸$|s\rangle$æ­£äº¤çš„æ¯ä¸ªçŠ¶æ€æ·»åŠ ä¸€ä¸ªè´Ÿç›¸ä½ã€‚

æƒ³è¦åšåˆ°è¿™ä¸€ç‚¹çš„ä¸€ç§æ–¹æ³•æ˜¯åˆ©ç”¨ä½¿$|s\rangle \rightarrow \left| 0 \right\rangle$çš„å˜æ¢æ“ä½œï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“è¿™æ˜¯åº”ç”¨äºæ¯ä¸ªé‡å­æ¯”ç‰¹çš„é˜¿è¾¾é©¬é—¨ï¼š

$$H^{\bigotimes n}|s\rangle = |0\rangle$$

ç„¶ååœ¨æ€$|0\rangle$ä¸Šåº”ç”¨æ·»åŠ ä¸€ä¸ªè´Ÿç›¸ä½çš„å›è·¯ï¼š

$$U_{0}\frac{1}{2}\left( \left| 00 \right\rangle + \left| 01 \right\rangle + \left| 10 \right\rangle + \left| 11 \right\rangle \right) = \frac{1}{2}\left( \left| 00 \right\rangle - \left| 01 \right\rangle - \left| 10 \right\rangle - \left| 11 \right\rangle \right)$$

å³ï¼šé™¤äº†$|00\rangle$ä¹‹å¤–ï¼Œæ¯ä¸ªçŠ¶æ€çš„ç¬¦å·éƒ½è¢«ç¿»è½¬äº†ã€‚æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°éªŒè¯ï¼Œå®ç°$U_{0}$çš„ä¸€ç§æ–¹æ³•æ˜¯ä»¥ä¸‹çš„å›è·¯ï¼š

![Circuit for reflection around
\|0\>](pics/media/image241.png)

æœ€åï¼Œæˆ‘ä»¬è¿›è¡Œå°†æ€$\left| 0 \right\rangle$å˜æ¢ä¸º$|s\rangle$çš„æ“ä½œï¼ˆåœ¨æ­¤åº”ç”¨H-gateï¼‰ï¼š

$$H^{\bigotimes n}U_{0}H^{\bigotimes n} = U_{s}$$

å®Œæ•´çš„$U_{s}$å›è·¯çœ‹èµ·æ¥å¦‚ä¸‹å›¾çš„æ ·å­ï¼š

![Circuit for reflection around
\|s\>](pics/media/image242.png)

æ³¨æ„ï¼è¯¥å›è·¯å®é™…ä¸Šåœ¨æ€$|s\rangle$ä¸Šå¢åŠ äº†ä¸€ä¸ªè´Ÿç›¸ä½ï¼Œå¹¶ä½¿æ‰€æœ‰æ­£äº¤çš„æ€ä¿æŒä¸å˜ï¼Œå› æ­¤è¯¥å›è·¯å®ç°äº†${- U}_{s}$ã€‚å¹¸è¿çš„æ˜¯ï¼Œæ­¤ç›¸ä½æ˜¯å…¨å±€ç›¸ä½ï¼Œå¯ä»¥å®‰å…¨åœ°å¿½ç•¥ã€‚

#### $\mathbf{|}\mathbf{\omega}\mathbf{\rangle = |00\rangle}$çš„å®Œæ•´å›è·¯

ç”±äº$N = 4$çš„ç‰¹å®šæƒ…å†µä»…éœ€ä¸€æ¬¡æ—‹è½¬ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸Šé¢çš„ç»„ä»¶ä¸º$|\omega\rangle = |00\rangle$æƒ…å†µçš„Groverç®—æ³•æ„å»ºå®Œæ•´çš„å›è·¯ï¼š

![image10](pics/media/image243.png)

å¦ä¸‰ä¸ªé‡å­å›è·¯å¯ç”¨åŒæ ·çš„æ–¹å¼æ„å»ºï¼Œæ­¤å¤„å°±ä¸å†ç´¯è¿°äº†ã€‚

#### 2.1 Qiskitå®ç°

ç°åœ¨æˆ‘ä»¬å®ç°ä¸Šæ–‡ä¸­ä¸¤ä¸ªé‡å­æ¯”ç‰¹$|\omega\rangle = |00\rangle$æƒ…å†µçš„Groverç®—æ³•ã€‚

> \#initialization
>
> import matplotlib.pyplot as plt
>
> import numpy as np
>
> %matplotlib inline
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images look
> nice
>
> \# importing Qiskit
>
> from qiskit import IBMQ, Aer
>
> from qiskit.providers.ibmq import least_busy
>
> from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister,
> execute
>
> \# import basic plot tools
>
> from qiskit.visualization import plot_histogram

æˆ‘ä»¬é€šè¿‡å‡†å¤‡ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„é‡å­å›è·¯å¼€å§‹ï¼š

> n = 2
>
> grover_circuit = QuantumCircuit(n)

ç„¶åï¼Œæˆ‘ä»¬åªéœ€ç®€å•åœ°å†™å‡ºä¸Šæ–‡ä¸­æ‰€æç»˜å›è·¯çš„å‘½ä»¤ã€‚

> def initialize_s(qc, qubits):
>
> \"\"\"Apply a H-gate to \'qubits\' in qc\"\"\"
>
> for q in qubits:
>
> qc.h(q)
>
> return qc

é¦–å…ˆï¼Œåˆå§‹åŒ–æ€$|s\rangle$ï¼š

> grover_circuit = initialize_s(grover_circuit, \[0,1\])
> grover_circuit.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image244.png)

å°†é¢„è¨€åº”ç”¨äº$|w\rangle = |00\rangle$ï¼š

> for qubit in range(n):
>
> grover_circuit.x(qubit)
>
> grover_circuit.cz(0, 1)
>
> for qubit in range(n):
>
> grover_circuit.x(qubit)
>
> grover_circuit.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image245.png)

åœ¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¸Šéƒ½åº”ç”¨ä¸€ä¸ªé˜¿è¾¾é©¬æ“ä½œï¼š

> for qubit in range(n):
>
> grover_circuit.h(qubit)
>
> grover_circuit.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image246.png)

åº”ç”¨$U_{s}$åå°„ï¼š

> for qubit in range(n):
>
> grover_circuit.z(qubit)
>
> grover_circuit.cz(0, 1)
>
> grover_circuit.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image247.png)

åœ¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¸Šéƒ½åº”ç”¨æœ€åçš„H-gateï¼š

> for qubit in range(n):
>
> grover_circuit.h(qubit)
>
> grover_circuit.draw(\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image248.png)

å¯ä»¥çœ‹åˆ°æˆ‘ä»¬å·²ç»ç»„è£…å‡ºäº†æ­£ç¡®çš„å›è·¯ã€‚

##### 2.1.1 åœ¨æ¨¡æ‹Ÿå™¨ä¸­å®éªŒ

æˆ‘ä»¬åœ¨æ¨¡æ‹Ÿå™¨ä¸­è¿è¡Œè¿™ä¸€å›è·¯æ¥å †ç Œè¿›è¡Œæµ‹è¯•ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥éªŒè¯è·å–äº†æ­£ç¡®çš„æ€å‘é‡ï¼š

> backend_sim = Aer.get_backend(\'statevector_simulator\')
>
> job_sim = execute(grover_circuit, backend_sim)
>
> statevec = job_sim.result().get_statevector()
>
> from qiskit_textbook.tools import vector2latex
>
> vector2latex(statevec, pretext=\"\|\\\\psi\\\\rangle =\")

![](pics/media/image249.png)

ç°åœ¨æµ‹é‡å…¶çŠ¶æ€ï¼Œå¹¶åˆ›å»ºç›¸åº”çš„ç›´æ–¹å›¾ï¼š

> grover_circuit.measure_all()
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> shots = 1024
>
> results = execute(grover_circuit, backend=backend,
> shots=shots).result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)

![](pics/media/image250.png)

æˆ‘ä»¬éªŒè¯äº†æ‰¾å‡ºå…ƒç´ $|00\rangle$æ¦‚ç‡ä¸º100%ã€‚

##### 2.1.2 åœ¨çœŸå®çš„è®¾å¤‡ä¸Šå®éªŒ

æˆ‘ä»¬å¯ä»¥åœ¨çœŸå®çš„è®¾å¤‡ä¸Šè¿è¡Œè¿™ä¸€å›è·¯ã€‚

> \# Load IBM Q account and get the least busy backend device
>
> provider = IBMQ.load_account()
>
> device = least_busy(provider.backends(filters=lambda x:
> x.configuration().n_qubits \>= 3 and
>
> not x.configuration().simulator and x.status().operational==True))
>
> print(\"Running on current least busy device: \", device)
>
> è¾“å‡ºï¼š
>
> Running on current least busy device: ibmq_ourense
>
> \# Run our circuit on the least busy backend. Monitor the execution of
> the job in the queue
>
> from qiskit.tools.monitor import job_monitor
>
> job = execute(grover_circuit, backend=device, shots=1024,
> max_credits=10)
>
> job_monitor(job, interval = 2)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> \# Get the results from the computation
>
> results = job.result()
>
> answer = results.get_counts(grover_circuit)
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image251.png)

æˆ‘ä»¬éªŒè¯äº†åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹å¯ä»¥æ‰¾å‡ºå…ƒç´ $|00\rangle$ã€‚å…¶ä»–æ˜¯ç”±é‡å­è®¡ç®—ä¸­çš„é”™è¯¯äº§ç”Ÿçš„ç»“æœã€‚

### 3. ç¤ºä¾‹ï¼š3-é‡å­æ¯”ç‰¹

ç°åœ¨æˆ‘ä»¬å°†å¿«é€Ÿæµè§ˆåŒ…å«ä¸¤ä¸ªæ ‡è®°æ€$|101\rangle$å’Œ$|110\rangle$çš„3-é‡å­æ¯”ç‰¹Groverç®—æ³•çš„ç¤ºä¾‹ï¼Œè¯¥ç¤ºä¾‹ä¾æ®å‚è€ƒæ–‡çŒ®\[2\]çš„å®ç°ã€‚è¿™ä¸€é‡å­å›è·¯ä½¿ç”¨ç›¸ä½é¢„è¨€å¤„ç†è¯¥é—®é¢˜ï¼š

![image11](pics/media/image252.png)

1\.
åœ¨ä¸‰ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨H-gateåˆå§‹åŒ–æ€$|000\rangle$æ¥åˆ›å»ºä¸€ä¸ªå‡åŒ€çš„å åŠ æ€ï¼š

$$\left| \psi_{1} \right\rangle = \frac{1}{8}\left( \left| 000 \right\rangle + \left| 001 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle + \left| 101 \right\rangle + \left| 110 \right\rangle + \left| 111 \right\rangle \right)$$

2\. ä½¿ç”¨ç›¸ä½é¢„è¨€æ ‡è®°æ€$|101\rangle$å’Œ$|110\rangle$ï¼š

$$\left| \psi_{2} \right\rangle = \frac{1}{8}\left( \left| 000 \right\rangle + \left| 001 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle - \left| 101 \right\rangle - \left| 110 \right\rangle + \left| 111 \right\rangle \right)$$

3\. ç»•å¹³å‡å¹…å€¼æ‰§è¡Œåå°„æ“ä½œï¼š

1\. åœ¨å„ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨H-gateï¼š

$$\left| \psi_{3a} \right\rangle = \frac{1}{2}\left( \left| 000 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle - \left| 111 \right\rangle \right)$$

2\. åœ¨å„ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨X-gateï¼š

$$\left| \psi_{3b} \right\rangle = \frac{1}{2}\left( - \left| 000 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle + \left| 111 \right\rangle \right)$$

> 3\.
> åœ¨é‡å­æ¯”ç‰¹1å’Œ2ï¼ˆæ§åˆ¶ç«¯ï¼‰ä¸é‡å­æ¯”ç‰¹3ï¼ˆç›®æ ‡ç«¯ï¼‰åº”ç”¨ä¸€ä¸ªåŒå—æ§Z-gateï¼š

$$\left| \psi_{3c} \right\rangle = \frac{1}{2}\left( - \left| 000 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle - \left| 111 \right\rangle \right)$$

4\. åœ¨å„ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨X-gateï¼š

$$\left| \psi_{3d} \right\rangle = \frac{1}{2}\left( - \left| 000 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle - \left| 111 \right\rangle \right)$$

5\. åœ¨å„ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨H-gateï¼š

$$\left| \psi_{3e} \right\rangle = \frac{1}{\sqrt{2}}\left( - \left| 101 \right\rangle - \left| 110 \right\rangle \right)$$

4\.
é€šè¿‡æµ‹é‡è¿™ä¸‰ä¸ªé‡å­æ¯”ç‰¹æ¥æ£€ç´¢æ€$\left| 101 \right\rangle$å’Œ$\left| 110 \right\rangle$

æ­¤æ—¶åº”æ³¨æ„ï¼Œç”±äºå…¶ä¸­æœ‰ä¸¤ä¸ªè§£ä»¥åŠå…«ä¸­å¯èƒ½æ€§ï¼Œéœ€è¦åœ¨æ­¥éª¤2å’Œ3ç§è¿è¡Œä¸€ä¸ªè¿­ä»£ã€‚

#### 3.1 Qiskitå®ç°

ç°åœ¨æˆ‘ä»¬å°†å®ç°ä¸Šè¿°3-é‡å­æ¯”ç‰¹çš„Groverç®—æ³•å¹¶æœç´¢ä¸¤ä¸ªæ ‡è®°æ€$|101\rangle$å’Œ$|110\rangle$ã€‚**æ³¨**ï¼šè®°ä½Qiskitç»„ç»‡é‡å­æ¯”ç‰¹é¡ºåºä¸æ­¤èµ„æºç›¸åï¼Œå› æ­¤æ‰€ç»˜åˆ¶çš„å›è·¯æ˜¾ç¤ºå‡ºåœ¨æ°´å¹³æ–¹å‘ä¸Šç¿»è½¬ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ ‡è®°æ€$|101\rangle$å’Œ$|110\rangle$ä¸ºç»“æœçš„ç›¸ä½é¢„è¨€ï¼ˆæ­¥éª¤1ï¼‰ã€‚

> def phase_oracle(circuit):
>
> circuit.cz(0, 2)
>
> circuit.cz(1, 2)

ç„¶åä¾æ®å¹³å‡å¹…å€¼è®¾ç½®ä¸€ä¸ªåè½¬å›è·¯ï¼ˆæ­¥éª¤2ï¼‰ï¼Œç§°ä¹‹ä¸º"æ‰©æ•£ç®—å­ï¼ˆdiffusion
operatorï¼‰"ï¼š

> def diffuser(circuit):
>
> \"\"\"Apply inversion about the average step of Grover\'s
> algorithm.\"\"\"
>
> qubits = circuit.qubits
>
> nqubits = len(qubits)
>
> for q in range(nqubits):
>
> circuit.h(q)
>
> circuit.x(q)
>
> \# Do controlled-Z
>
> circuit.h(2)
>
> circuit.ccx(0,1,2)
>
> circuit.h(2)
>
> for q in range(nqubits):
>
> circuit.x(q)
>
> circuit.h(q)

ç°åœ¨é€šè¿‡åœ¨å›è·¯çš„å¤´éƒ¨åˆ›å»ºå‡åŒ€çš„å åŠ æ€ä»¥åŠåœ¨å›è·¯çš„å°¾éƒ¨è¿›è¡Œæµ‹é‡ï¼Œå°†æ‰€æœ‰çš„ç‰‡æ®µéƒ½ç»“åˆèµ·æ¥ã€‚**æ³¨**ï¼šç”±äºå­˜åœ¨ä¸¤ä¸ªè§£ä»¥åŠå…«ç§å¯èƒ½æ€§ï¼Œæˆ‘ä»¬åªéœ€è¿è¡Œä¸€æ¬¡è¿­ä»£ã€‚

> n = 3
>
> barriers = True
>
> grover_circuit = QuantumCircuit(n)
>
> for qubit in range(n):
>
> grover_circuit.h(qubit)
>
> if barriers:
>
> grover_circuit.barrier()
>
> phase_oracle(grover_circuit)
>
> if barriers:
>
> grover_circuit.barrier()
>
> diffuser(grover_circuit)
>
> grover_circuit.measure_all()
>
> grover_circuit.draw(output=\"mpl\")
>
> è¾“å‡ºï¼š

![](pics/media/image253.png)

##### 3.1.1 åœ¨æ¨¡æ‹Ÿå™¨ä¸­å®éªŒ

æˆ‘ä»¬å¯ä»¥åœ¨æ¨¡æ‹Ÿå™¨ä¸­è¿è¡Œä¸Šé¢çš„é‡å­å›è·¯ã€‚

> backend = Aer.get_backend(\'qasm_simulator\')
>
> shots = 1024
>
> results = execute(grover_circuit, backend=backend,
> shots=shots).result()
>
> answer = results.get_counts()
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image254.png)

æ­£å¦‚è¾“å‡ºæ‰€ç¤ºï¼Œç®—æ³•æ‰¾å‡ºäº†æ ‡è®°æ€$|101\rangle$å’Œ$|110\rangle$ã€‚

##### 3.1.2 åœ¨çœŸå®è®¾å¤‡ä¸Šå®éªŒ

æˆ‘ä»¬ä½¿ç”¨ä¸‹é¢çš„ä»£ç åœ¨çœŸå®çš„è®¾å¤‡ä¸Šè¿è¡Œè¿™ä¸€é‡å­å›è·¯ã€‚

> backend = least_busy(provider.backends(filters=lambda x:
> x.configuration().n_qubits \>= 3 and
>
> not x.configuration().simulator and x.status().operational==True))
>
> print(\"least busy backend: \", backend)
>
> è¾“å‡ºï¼š
>
> least busy backend: ibmq_ourense
>
> \# Run our circuit on the least busy backend. Monitor the execution of
> the job in the queue
>
> from qiskit.tools.monitor import job_monitor
>
> shots = 1024
>
> job = execute(grover_circuit, backend=backend, shots=shots,
> optimization_level=3)
>
> job_monitor(job, interval = 2)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> \# Get the results from the computation
>
> results = job.result()
>
> answer = results.get_counts(grover_circuit)
>
> plot_histogram(answer)
>
> è¾“å‡ºï¼š

![](pics/media/image255.png)

æ­£å¦‚æˆ‘ä»¬æ‰€æœŸæœ›çš„æƒ…å†µï¼Œç®—æ³•åœ¨çœŸå®è®¾å¤‡ä¸Šä¹Ÿæ‰¾å‡ºäº†æ ‡è®°æ€$|101\rangle$å’Œ$|110\rangle$ã€‚é‡å­è®¡ç®—ä¸­çš„é”™è¯¯å¯¼è‡´äº†å…¶ä»–çš„ç»“æœã€‚

### 4. ç»ƒä¹ 

ä¸‹é¢çš„å‡½æ•°grover_problem_oracleæ¥å—è‹¥å¹²ä¸ªé‡å­æ¯”ç‰¹(n)å’Œä¸€ä¸ªå˜é‡ï¼Œå¹¶è¿”å›ä¸€ä¸ªné‡å­æ¯”ç‰¹çš„é¢„è¨€ã€‚å¯¹äºç›¸åŒçš„nå’Œå˜é‡ï¼Œå‡½æ•°æ€»æ˜¯è¿”å›ç›¸åŒçš„é¢„è¨€ã€‚æ‚¨å¯ä»¥é€šè¿‡åœ¨è°ƒç”¨grover_problem_oracleæ—¶è®¾ç½®print_solutions
= Trueæ¥æŸ¥çœ‹æ¯ä¸ªé¢„è¨€çš„è§£ã€‚

> from qiskit_textbook.problems import grover_problem_oracle
>
> \#\# Example Usage
>
> n = 4
>
> oracle = grover_problem_oracle(n, variant=1) \# 0th variant of oracle,
> with n qubits
>
> qc = QuantumCircuit(n)
>
> qc.append(oracle, \[0,1,2,3\])
>
> qc.draw()

![](pics/media/image256.png)

1\. grover_problem_oracle(4, variant=2)ä½¿ç”¨4ä¸ªé‡å­æ¯”ç‰¹ï¼Œè·å–è§£$1$ã€‚

a\. æˆ‘ä»¬éœ€è¦å¤šå°‘æ¬¡è¿­ä»£æ‰èƒ½æœ‰\> 90%çš„æœºä¼šæµ‹é‡è¯¥è§£?

b\. åˆ©ç”¨Groverç®—æ³•æ±‚è§£æ­¤è§£æ€ã€‚

c\. å¦‚æœæˆ‘ä»¬åº”ç”¨æ›´å¤šçš„è¿­ä»£æ¬¡æ•°ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä¸ºä½•ï¼Ÿ

2\.
è‹¥æœ‰2ä¸ªè§£å’Œ4ä¸ªé‡å­æ¯”ç‰¹ï¼Œéœ€è¦å¤šå°‘è¿­ä»£æ¬¡æ•°æ‰èƒ½åœ¨å¤§äº90%çš„æ¦‚ç‡ä¸‹æµ‹é‡åˆ°ä¸€ä¸ªè§£ï¼Ÿä½¿ç”¨é¢„è¨€grover_problem_oracle(4,
variant=1) ï¼ˆ2ä¸ªè§£ï¼‰æ¥éªŒè¯æ‚¨çš„ç­”æ¡ˆã€‚

3\. åˆ›å»ºä¸€ä¸ªå‡½æ•°grover_solver(oracle, iterations)ï¼Œè¾“å…¥ä¸º:

ä¸€ä¸ªé‡å­é—¨å®ç°çš„Groveré¢„è¨€ï¼ˆoracleï¼‰

è¿­ä»£æ¬¡æ•°ï¼ˆæ•´æ•°ï¼Œiterationsï¼‰

å¹¶è¿”å›ä¸€ä¸ªåœ¨"é¢„è¨€"é‡å­é—¨ä¸Šæ‰§è¡ŒGroverç®—æ³•çš„é‡å­å›è·¯ã€‚

*æ³¨ï¼šä¸Šè¿°çš„ä¸‰ä¸ªé—®é¢˜ç®€åŒ–äº†é—®é¢˜çš„éš¾åº¦ï¼Œæ‰€ä»¥ä»¥ä¸‹ä¸¤ä¸ªåŸé—®é¢˜ä»ç„¶ç»™å‡ºã€‚*

4\. ä¸Šæ–‡ä¸­Groverç®—æ³•çš„ç¤ºä¾‹å’Œå®ç°ç”¨äºæ‰¾å‡º3-é‡å­æ¯”ç‰¹æ ‡è®°æ€$|101\rangle$å’Œ

\|110âŸ©ï¼Œä¿®æ”¹è¿™ä¸€å®ç°ä½¿å…¶èƒ½å¤Ÿæ‰¾å‡º2-é‡å­æ¯”ç‰¹æ ‡è®°æ€$|01\rangle$ã€‚è¿è¡Œç»“æœæ˜¯å¦ç¬¦åˆ

è¦æ±‚ï¼Ÿä¸ºä½•ï¼Ÿ

5\. ä¿®æ”¹ä¸Šæ–‡ä¸­3-é‡å­æ¯”ç‰¹çš„Grover å®ç°ä½¿å…¶èƒ½å¤Ÿæ‰¾å‡º4-é‡å­æ¯”ç‰¹æ ‡è®°æ€

$|0101\rangle$ã€‚è¿è¡Œç»“æœæ˜¯å¦ç¬¦åˆè¦æ±‚ï¼Ÿä¸ºä½•ï¼Ÿ

### 5. ä½¿ç”¨Groverç®—æ³•è§£å†³æ•°ç‹¬

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåœ¨æœ¬ç« ä¸­ä½¿ç”¨çš„é¢„è¨€éƒ½æ˜¯ç”¨å…¶è§£çš„å…ˆéªŒçŸ¥è¯†æ¥åˆ›å»ºçš„ã€‚æˆ‘ä»¬ç°åœ¨ç”¨Groverç®—æ³•æ¥è§£å†³ä¸€ä¸ªç®€å•çš„é—®é¢˜ï¼Œå¯¹äºè¿™ä¸€é—®é¢˜ï¼Œæˆ‘ä»¬äº‹å…ˆä¸ä¸€å®šçŸ¥é“å…¶ç­”æ¡ˆã€‚æˆ‘ä»¬çš„é—®é¢˜æ˜¯ä¸€ä¸ª2Ã—2äºŒè¿›åˆ¶æ•°ç‹¬ï¼Œåœ¨æ­¤æƒ…å†µä¸‹æœ‰ä¸¤ä¸ªç®€å•çš„è§„åˆ™ï¼š

\* ä»»ä½•åˆ—éƒ½ä¸åŒ…å«ä¸¤æ¬¡ç›¸åŒçš„å€¼

\* ä»»ä½•è¡Œéƒ½ä¸åŒ…å«ä¸¤æ¬¡ç›¸åŒçš„å€¼

å¦‚æœæˆ‘ä»¬ç»™æ•°ç‹¬ä¸­çš„æ¯ä¸ªæ–¹å—åˆ†é…ä¸€ä¸ªå˜é‡ï¼š

![2Ã—2 binary sudoku, with each square allocated to a different
variable](pics/media/image257.png)

æˆ‘ä»¬æƒ³è¦çš„æ˜¯è®©é‡å­å›è·¯è¾“å‡ºè¿™ä¸€æ•°ç‹¬æ¸¸æˆçš„è§£ã€‚

è¯·æ³¨æ„ï¼Œè™½ç„¶è¿™ç§ä½¿ç”¨Groverç®—æ³•æ¥è§£å†³è¿™ä¸€é—®é¢˜çš„æ–¹æ³•æ˜¯ä¸å®é™…ï¼Œå› ä¸ºæ‚¨å¯ä»¥åœ¨è‡ªå·±çš„å¤´è„‘ä¸­æ‰¾åˆ°è§£å†³æ–¹æ¡ˆï¼ä½†æ˜¯è¿™ä¸€ç¤ºä¾‹çš„ç›®çš„æ˜¯æ¼”ç¤ºå¦‚ä½•å°†ç»å…¸çš„å†³ç­–é—®é¢˜è½¬æ¢ä¸ºGroverç®—æ³•çš„é¢„è¨€ã€‚

#### 5.1 æŠŠé—®é¢˜å˜æˆä¸€ä¸ªå›è·¯

æˆ‘ä»¬å¸Œæœ›åˆ›å»ºä¸€ä¸ªé¢„è¨€æ¥å¸®åŠ©æˆ‘ä»¬è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬å°†ä»åˆ›å»ºä¸€ä¸ªèƒ½å¤Ÿè¯†åˆ«æ­£ç¡®è§£çš„å›è·¯å¼€å§‹ã€‚ä¸æˆ‘ä»¬åœ¨*è®¡ç®—åŸº*ï¼ˆï¼‰ä¸­ä½¿ç”¨é‡å­ç”µè·¯åˆ›å»ºç»å…¸åŠ æ³•å™¨ç±»ä¼¼ï¼Œåªéœ€åœ¨é‡å­å›è·¯ä¸Šåˆ›å»ºä¸€ä¸ªç»å…¸å‡½æ•°æ¥æ£€æŸ¥å¯å˜æ¯”ç‰¹çš„çŠ¶æ€æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„è§£ã€‚

ç”±äºéœ€è¦æ£€æŸ¥ä¸¤åˆ—å’Œä¸¤è¡Œï¼Œæ‰€ä»¥æœ‰4ä¸ªæ¡ä»¶éœ€è¦æ£€æŸ¥ï¼š

> v0 â‰  v1 \# check along top row
>
> v2 â‰  v3 \# check along bottom row
>
> v0 â‰  v2 \# check down left column
>
> v1 â‰  v3 \# check down right column

è®°ä½ï¼Œæˆ‘ä»¬æ˜¯åœ¨ä¸ç»å…¸çš„(è®¡ç®—åŸº)çŠ¶æ€åšæ¯”è¾ƒã€‚ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ç»„æ¯”è¾ƒç¼–å†™ä¸ºæ¡ä»¶åˆ—è¡¨ï¼š

> clause_list = \[\[0,1\],
>
> \[0,2\],
>
> \[1,3\],
>
> \[2,3\]\]

æˆ‘ä»¬å°†æŠŠæ¯ä¸ªå˜é‡çš„å€¼èµ‹ç»™å›è·¯ä¸­çš„ä¸€ä¸ªæ¯”ç‰¹ã€‚ä¸ºäº†ä»¥è®¡ç®—çš„æ–¹å¼æ£€æŸ¥è¿™äº›æ¡ä»¶ï¼Œå°†ä¼šç”¨åˆ°å¼‚æˆ–é—¨ã€‚

> def XOR(qc, a, b, output):
>
> qc.cx(a, output)
>
> qc.cx(b, output)

åº”ç¡®ä¿¡åªå½“$input0 \neq input1$æ—¶ï¼Œä»¥ä¸‹å›è·¯çš„$output0$ä½æ‰ä¼šç¿»è½¬:

> \# We will use separate registers to name the bits
>
> in_qubits = QuantumRegister(2, name=\'input\')
>
> out_qubit = QuantumRegister(1, name=\'output\')
>
> qc = QuantumCircuit(in_qubits, out_qubit)
>
> XOR(qc, in_qubits\[0\], in_qubits\[1\], out_qubit)
>
> qc.draw()

è¾“å‡ºï¼š

![](pics/media/image258.png)

è¯¥å›è·¯æ£€æŸ¥$input0\  = = \ input1$å¹¶å°†è¾“å‡ºå­˜å‚¨åˆ°$output0$ã€‚ä¸ºäº†æ£€æŸ¥æ¯ä¸ªæ¡ä»¶ï¼Œæˆ‘ä»¬åœ¨clause_listä¸­çš„æ¯ä¸ªå¯¹é‡å¤è¿è¡Œè¿™ä¸€å›è·¯ï¼Œå¹¶å°†è¾“å‡ºå­˜å‚¨åˆ°ä¸€ä¸ªæ–°çš„æ¯”ç‰¹ä¸­ï¼š

> \# Create separate registers to name bits
>
> var_qubits = QuantumRegister(4, name=\'v\') \# variable bits
>
> clause_qubits = QuantumRegister(4, name=\'c\') \# bits to store
> clause-checks
>
> \# Create quantum circuit
>
> qc = QuantumCircuit(var_qubits, clause_qubits)
>
> \# Use XOR gate to check each clause
>
> i = 0
>
> for clause in clause_list:
>
> XOR(qc, clause\[0\], clause\[1\], clause_qubits\[i\])
>
> i += 1
>
> qc.draw()

è¾“å‡ºï¼š

![](pics/media/image259.png)

åªæœ‰å½“v0ã€v1ã€v2ã€v3çš„èµ‹å€¼æ˜¯æ•°ç‹¬çš„è§£æ—¶ï¼Œc0ã€c1ã€c2ã€c3æ¯”ç‰¹çš„æœ€ç»ˆçŠ¶æ€æ‰éƒ½æ˜¯1ã€‚ä¸ºäº†å®Œæˆè¿™ä¸€æ£€éªŒå›è·¯ï¼Œæˆ‘ä»¬å¸Œæœ›å½“(ä¸”ä»…å½“)æ‰€æœ‰æ¡ä»¶éƒ½æ»¡è¶³æ—¶ï¼Œå•ä¸ªæ¯”ç‰¹ä¸º1ï¼Œè¿™æ ·æˆ‘ä»¬åªéœ€è§‚å¯Ÿä¸€ä¸ªæ¯”ç‰¹å°±èƒ½æ£€æŸ¥èµ‹å€¼æ˜¯å¦æ˜¯ä¸€ä¸ªè§£ã€‚ï¼Œå¯ä»¥ä½¿ç”¨multi-controlled-Toffoli-gateï¼š

> \# Create separate registers to name bits
>
> var_qubits = QuantumRegister(4, name=\'v\')
>
> clause_qubits = QuantumRegister(4, name=\'c\')
>
> output_qubit = QuantumRegister(1, name=\'out\')
>
> qc = QuantumCircuit(var_qubits, clause_qubits, output_qubit)
>
> \# Compute clauses
>
> i = 0
>
> for clause in clause_list:
>
> XOR(qc, clause\[0\], clause\[1\], clause_qubits\[i\])
>
> i += 1
>
> \# Flip \'output\' bit if all clauses are satisfied
>
> qc.mct(clause_qubits, output_qubit)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image260.png)

ä¸Šé¢çš„å›è·¯ä»¥v0ã€v1ã€v2å’Œv3çš„åˆå§‹åˆ†é…ä½œä¸ºè¾“å…¥ï¼Œæ‰€æœ‰å…¶ä»–çš„æ¯”ç‰¹éƒ½åº”åˆå§‹åŒ–ä¸º0ã€‚è¿è¡Œè¯¥å›è·¯åï¼Œ$out0$ä½çš„çŠ¶æ€å‘Šè¯‰æˆ‘ä»¬è¿™ä¸€èµ‹å€¼æ˜¯å¦æ˜¯ä¸€ä¸ªè§£ï¼›$out0\  = \ 0$è¡¨ç¤ºèµ‹å€¼ä¸æ˜¯è§£ï¼Œ$out0\  = \ 1$è¡¨ç¤ºèµ‹å€¼æ˜¯è§£ã€‚

**é‡ç‚¹**ï¼šåœ¨æ‚¨ç»§ç»­åç»­æ­¥éª¤ä¹‹å‰ï¼Œåº”å……åˆ†ç†è§£è¿™ä¸€å›è·¯å¹¶ç¡®ä¿¡å…¶èƒ½å¦‚ä¸Šè¿°è¿‡ç¨‹ä¸€æ ·è¿è¡Œã€‚

#### 5.2 éè®¡ç®—ï¼Œå®Œæˆé¢„è¨€

æˆ‘ä»¬ç°åœ¨å¯ä»¥é€šè¿‡ç›¸ä½åå†²æŠŠè¿™ä¸€æ£€éªŒå›è·¯å˜æˆGroveé¢„è¨€ã€‚æ€»ç»“ä¸€ä¸‹ï¼Œæˆ‘ä»¬æœ‰3ä¸ªå¯„å­˜å™¨ï¼š

-   ä¸€ä¸ªå¯„å­˜å™¨ç”¨æ¥å­˜å‚¨æ•°ç‹¬å˜é‡(x=v3,v2,v1,v0)

-   ä¸€ä¸ªå¯„å­˜å™¨å­˜å‚¨æ¡æ¬¾(è¿™äº›æ¡ä»¶å­˜å‚¨åœ¨æ€$|0000\rangle$ä¸­ï¼Œå¼€å§‹æ—¶å°†å…¶ç¼©å†™ä¸º$|0\rangle$)

-   ä»¥åŠä¸€ä¸ªé‡å­æ¯”ç‰¹($|out_{0}\rangle$)ï¼Œæˆ‘ä»¬ä¸€ç›´ä½¿ç”¨è¯¥é‡å­æ¯”ç‰¹å­˜å‚¨æ£€éªŒå›è·¯çš„è¾“å‡ºã€‚

ä¸ºäº†åˆ›å»ºä¸€ä¸ªé¢„è¨€ï¼Œæˆ‘ä»¬éœ€è¦å›è·¯($U_{\omega}$)æ‰§è¡Œå˜æ¢ï¼š

$$U_{\omega}|x\rangle|0\rangle|\text{out}_{0}\rangle = |x\rangle|0\rangle|\text{out}_{0} \oplus f(x)\rangle$$

å¦‚æœæˆ‘ä»¬è®¾ç½®é‡å­æ¯”ç‰¹$\text{ou}t_{0}$ä¸ºå åŠ æ€$| - \rangle$ï¼š

$$\begin{matrix}
U_{\omega}|x\rangle|0\rangle| - \rangle & = U_{\omega}|x\rangle|0\rangle \otimes \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle) \\
 & = |x\rangle|0\rangle \otimes \frac{1}{\sqrt{2}}(|0 \oplus f(x)\rangle - |1 \oplus f(x)\rangle) \\
\end{matrix}$$

å¦‚æœ$f(x) = 0$,åˆ™æˆ‘ä»¬ä¼šå¾—åˆ°æ€ï¼š

$$\begin{matrix}
 & = |x\rangle|0\rangle \otimes \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle) \\
 & = |x\rangle|0\rangle| - \rangle \\
\end{matrix}$$

ï¼ˆå³ï¼šæ²¡æœ‰å˜åŒ–ï¼‰ã€‚ä½†è‹¥$f(x) = 1$ï¼ˆå³ï¼š$x = \omega$ï¼‰ï¼Œæˆ‘ä»¬å°±åœ¨é‡å­æ¯”ç‰¹$| - \rangle$ä¸Šå¼•å…¥ä¸€ä¸ªè´Ÿç›¸ä½ï¼š

$$\begin{matrix}
 & = |x\rangle|0\rangle \otimes \frac{1}{\sqrt{2}}(|1\rangle - |0\rangle) \\
 & = |x\rangle|0\rangle \otimes - \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle) \\
 & = - |x\rangle|0\rangle| - \rangle \\
\end{matrix}$$

è¿™ä¸ªåŠŸç”¨é¢„è¨€ä¼šç”¨åˆ°ä¸¤ä¸ªå¤„äºæ€$|0\rangle| - \rangle$çš„è¾…åŠ©å¯„å­˜å™¨ï¼š

$$U_{\omega}|x\rangle|0\rangle| - \rangle = \{\begin{matrix}
\text{\ \ \ }\left| x \right\rangle\left| 0 \right\rangle\left| - \right\rangle\text{\ \ \ }\text{for}\text{\ \ \ }x \neq \omega \\
 - \left| x \right\rangle\left| 0 \right\rangle\left| - \right\rangle\text{\ \ \ }\text{for}\text{\ \ \ }x = \omega \\
\end{matrix}$$

ä¸ºäº†å°†æ£€éªŒå›è·¯çº³å…¥ä¸€ä¸ªGoveré¢„è¨€ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¿è¯åœ¨è®¡ç®—å®Œæˆåä½äºç¬¬äºŒå¯„å­˜å™¨ï¼ˆcï¼‰çš„æ¯”ç‰¹å§‹ç»ˆè¿”å›æ€$|0000\rangle$ã€‚ä»…éœ€åœ¨å›è·¯è¿è¡Œæ—¶é‡å¤è®¡ç®—ä¿è¯æ¡ä»¶c0
= c1 = c2 = c3 =
0çš„éƒ¨åˆ†ï¼Œå°±å¯å®ç°ä¸Šè¿°è¦æ±‚ã€‚æˆ‘ä»¬å°†è¿™ä¸€æ­¥ç§°ä¸ºï¼šéè®¡ç®—"**uncomputation**"ã€‚

> var_qubits = QuantumRegister(4, name=\'v\')
>
> clause_qubits = QuantumRegister(4, name=\'c\')
>
> output_qubit = QuantumRegister(1, name=\'out\')
>
> cbits = ClassicalRegister(4, name=\'cbits\')
>
> qc = QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)
>
> def sudoku_oracle(qc, clause_list, var_qubits, clause_qubits, cbits):
>
> \# Compute clauses
>
> i = 0
>
> for clause in clause_list:
>
> XOR(qc, clause\[0\], clause\[1\], clause_qubits\[i\])
>
> i += 1
>
> \# Flip \'output\' bit if all clauses are satisfied
>
> qc.mct(clause_qubits, output_qubit)
>
> \# Uncompute clauses to reset clause-checking bits to 0
>
> i = 0
>
> for clause in clause_list:
>
> XOR(qc, clause\[0\], clause\[1\], clause_qubits\[i\])
>
> i += 1
>
> sudoku_oracle(qc, clause_list, var_qubits, clause_qubits, cbits)
>
> qc.draw()

è¾“å‡ºï¼š

![](pics/media/image261.png)

ç»¼ä¸Šæ‰€è¿°ï¼Œä¸Šè¿°å›è·¯æ‰§è¡Œå¦‚ä¸‹ï¼š

$$U_{\omega}|x\rangle|0\rangle|\text{out}_{0}\rangle = \{\begin{matrix}
\text{\ \ \ \ \ \ \ \ \ }\left| x \right\rangle\left| 0 \right\rangle\left| \text{out}_{0} \right\rangle\text{\ \ \ }\text{for}\text{\ \ \ \ }x \neq \omega \\
\left| x \right\rangle\left| 0 \right\rangle \otimes X\left| \text{out}_{0} \right\rangle\text{\ \ \ }\text{for}\text{\ \ \ \ }x = \omega \\
\end{matrix}$$

ä¸”å½“åˆå§‹æ€$|\text{out}_{0}\rangle = | - \rangle$ï¼š

$$U_{\omega}|x\rangle|0\rangle| - \rangle = \{\begin{matrix}
\phantom{\text{\ \ \ }}\left| x \right\rangle\left| 0 \right\rangle\left| - \right\rangle\text{\ \ \ }\text{for}\text{\ \ \ }x \neq \omega \\
 - \left| x \right\rangle\left| 0 \right\rangle\left| - \right\rangle\text{\ \ \ }\text{for}\text{\ \ \ }x = \omega \\
\end{matrix}$$

#### 5.3 å®Œæ•´çš„ç®—æ³•

ç°åœ¨è¦åšçš„å°±æ˜¯æŠŠè¿™ä¸€é¢„è¨€æ”¾åˆ°Groverç®—æ³•ä¸­!

> var_qubits = QuantumRegister(4, name=\'v\')
>
> clause_qubits = QuantumRegister(4, name=\'c\')
>
> output_qubit = QuantumRegister(1, name=\'out\')
>
> cbits = ClassicalRegister(4, name=\'cbits\')
>
> qc = QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)
>
> \# Initialise \'out0\' in state \|-\>
>
> qc.initialize(\[1, -1\]/np.sqrt(2), output_qubit)
>
> \# Initialise qubits in state \|s\>
>
> qc.h(var_qubits)
>
> qc.barrier() \# for visual separation
>
> \#\# First Iteration
>
> \# Apply our oracle
>
> sudoku_oracle(qc, clause_list, var_qubits, clause_qubits, cbits)
>
> qc.barrier() \# for visual separation
>
> \# Apply our diffuser
>
> qc.append(diffuser(4), \[0,1,2,3\])
>
> \#\# Second Iteration
>
> sudoku_oracle(qc, clause_list, var_qubits, clause_qubits, cbits)
>
> qc.barrier() \# for visual separation
>
> \# Apply our diffuser
>
> qc.append(diffuser(4), \[0,1,2,3\])
>
> \# Measure the variable qubits
>
> qc.measure(var_qubits, cbits)
>
> qc.draw()

è¾“å‡ºï¼š

![](pics/media/image262.png)

> \# Simulate and plot results
>
> qasm_simulator = Aer.get_backend(\'qasm_simulator\')
>
> result = execute(qc, backend=qasm_simulator, shots=1024).result()
>
> plot_histogram(result.get_counts())

![](pics/media/image263.png)

æœ‰ä¸¤ä¸ªæ¯”ç‰¹å­—ä¸²0110å’Œ1001å…·æœ‰æ¯”å…¶ä»–ä»»ä¸€ä¸€ä¸ªæ›´é«˜çš„æµ‹é‡æ¦‚ç‡ï¼Œä¸å…¶å¯¹åº”çš„èµ‹å€¼ä¸ºï¼š

> v0 = 0
>
> v1 = 1
>
> v2 = 1
>
> v3 = 0

ä»¥åŠï¼š

> v0 = 1
>
> v1 = 0
>
> v2 = 0
>
> v3 = 1

ä»¥ä¸Šå°±æ˜¯æ•°ç‹¬æ¸¸æˆçš„ä¸¤ç§è§£ï¼æœ¬èŠ‚çš„ç›®çš„æ˜¯å±•ç¤ºå¦‚ä½•ä»å®é™…é—®é¢˜ä¸­åˆ›é€ Groveré¢„è¨€ã€‚è™½ç„¶è¿™ä¸€ç‰¹å®šé—®é¢˜éå¸¸ç®€å•ï¼Œä½†æ­¤è¿‡ç¨‹åœ¨èƒ½å¤Ÿç”Ÿæˆè¶³å¤Ÿå¤§å›è·¯çš„é‡å­è®¡ç®—æœºä¸Šå¯ä»¥åº”ç”¨äºä»»æ„å†³ç­–é—®é¢˜ã€‚æ¦‚æ‹¬å…¶æ­¥éª¤å¦‚ä¸‹ï¼š

1\. åˆ›å»ºä¸€ä¸ªå¯é€†çš„ç»å…¸å›è·¯ï¼Œä»¥ç¡®å®šæ­£ç¡®çš„è§£ã€‚

2\. ä½¿ç”¨ç›¸ä½åå†²ä»¥åŠéè®¡ç®—å°†å…¶è½¬æ¢ä¸ºä¸€ä¸ªé¢„è¨€ã€‚

3\. ä½¿ç”¨Groverç®—æ³•å¤„ç†è¯¥é¢„è¨€ã€‚

### 6. å‚è€ƒæ–‡çŒ®

1\. L. K. Grover (1996), \"A fast quantum mechanical algorithm for
database search\", Proceedings of the 28th Annual ACM Symposium on the
Theory of Computing (STOC 1996),
[doi:10.1145/237814.237866](http://doi.acm.org/10.1145/237814.237866),
[arXiv:quant-ph/9605043](https://arxiv.org/abs/quant-ph/9605043)

2\. C. Figgatt, D. Maslov, K. A. Landsman, N. M. Linke, S. Debnath & C.
Monroe (2017), \"Complete 3-Qubit Grover search on a programmable
quantum computer\", Nature Communications, Vol 8, Art 1918,
[doi:10.1038/s41467-017-01904-7](https://doi.org/10.1038/s41467-017-01904-7),
[arXiv:1703.10535](https://arxiv.org/abs/1703.10535)

3\. I. Chuang & M. Nielsen, \"Quantum Computation and Quantum
Information\", Cambridge: Cambridge University Press, 2000.

3.11 é‡å­è®¡æ•°
-------------

### å†…å®¹

1\. ç®€ä»‹

1.1 ç›´è§‰

1.2 è¿‘è§‚

2\. ä»£ç 

2.1 åˆå§‹åŒ–ä»£ç 

2.2 å—æ§Groverè¿­ä»£

2.3 é€†QFT

2.4 ç»„åˆ

3\. æ¨¡æ‹Ÿ

4\. æ‰¾å‡ºè§£çš„æ•°é‡

5\. ç»ƒä¹ 

6\. å‚è€ƒæ–‡çŒ®

### 1. ç®€ä»‹

#### 1.1 ç›´è§‰

åœ¨é‡å­è®¡æ•°ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šç®€å•åœ°ä½¿ç”¨é‡å­ç›¸ä½ä¼°è®¡ç®—æ³•æ‰¾å‡ºGroveræœç´¢è¿­ä»£ä¸­åœ°æœ¬å¾å€¼ã€‚æ‚¨æ˜¯å¦è¿˜è®°å¾—Groverç®—æ³•ä¸­çš„ä¸€ä¸ªè¿­ä»£è¿‡ç¨‹$G$ï¼Œè¯¥è¿­ä»£è¿‡ç¨‹åœ¨åŸº$|\omega\rangle$å’Œ$|s'\rangle$ä¸Šå°†æ€å‘é‡æ—‹è½¬$\theta$ã€‚

![](pics/media/image264.png)

åœ¨æœå¯»ç©ºé—´ä¸­è§£çš„æ•°é‡æ¯”ä¾‹ä¼šå½±å“$|s\rangle$å’Œ\|sâ€²âŸ©ä¹‹é—´çš„å·®å¼‚ã€‚å‡è®¾æ²¡æœ‰å¾ˆå¤šè§£æ—¶ï¼Œ$|s\rangle$ä¼šä¸\|sâ€²âŸ©å¾ˆæ¥è¿‘ï¼Œè€Œä¸”$\theta$ä¼šå˜çš„å¾ˆå°ã€‚äº‹å®è¯æ˜Groverè¿­ä»£å™¨çš„æœ¬å¾å€¼æ˜¯$e^{\pm i\theta}$ï¼Œæˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨é‡å­ç›¸ä½ä¼°è®¡ï¼ˆGPEï¼‰å¯¹å…¶è¿›è¡Œæå–æ¥ä¼°è®¡è§£çš„æ•°é‡ï¼ˆMï¼‰ã€‚

#### 1.2 è¿‘è§‚

ä¾æ®åŸº$|\omega\rangle$å’Œ\|sâ€²âŸ©ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠGroverè¿­ä»£å™¨å†™æˆä¸€ä¸ªçŸ©é˜µï¼š

$$G = \begin{pmatrix}
\cos\theta & - sin\theta \\
\sin\theta & \cos\theta \\
\end{pmatrix}$$

ä¾æ®ä¸Šæ–‡ä¸­æ‰€æåŠçš„æœ¬å¾å€¼$e^{\pm i\theta}$ï¼Œè¯¥çŸ©é˜µ$G$æœ‰ä¸€ä¸ªæœ¬å¾å‘é‡ï¼š

$$\begin{pmatrix}
 - i \\
1 \\
\end{pmatrix},\begin{pmatrix}
i \\
1 \\
\end{pmatrix}$$

å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä¸ºè¿™ä¸¤ä¸ªçŠ¶æ€ä¸­çš„ä»»æ„ä¸€ä¸ªé¢„å¤‡å¯„å­˜å™¨ï¼Œæ€$|s\rangle$åœ¨$|\omega\rangle$ï¼Œ$|s'\rangle$æ‰€å¼ æˆçš„ç©ºé—´ä¸­ï¼Œå› æ­¤æ˜¯ä¸¤ä¸ªå‘é‡çš„å åŠ ã€‚

$$|s\rangle = \alpha|\omega\rangle + \beta|s'\rangle$$

ç»“æœæ˜¯QPEç®—æ³•çš„è¾“å‡ºä¼šæ˜¯ä¸¤ä¸ªç›¸ä½çš„å åŠ ï¼Œä¸”å½“æˆ‘ä»¬æµ‹é‡å¯„å­˜å™¨æ—¶å°†ä¼šè·å–åˆ°ä¸¤ä¸ªå€¼ä¸­çš„ä¸€ä¸ªï¼ç„¶åä½¿ç”¨ä¸€äº›ç®€å•çš„æ•°å­¦è¿ç®—å°±èƒ½è·å¾—æ•°é‡ä¼°è®¡$M$ã€‚

![](pics/media/image265.png)

### 2. ä»£ç 

#### 2.1 åˆå§‹åŒ–ä»£ç 

ç¬¬ä¸€æ­¥ï¼Œå¯¼å…¥æ‰€éœ€çš„å…¨éƒ¨åº“ã€‚

import matplotlib.pyplot as plt

import numpy as np

import math

\# importing Qiskit

import qiskit

from qiskit import IBMQ, Aer

from qiskit import QuantumCircuit, execute

\# import basic plot tools

from qiskit.visualization import plot_histogram

æœ¬èŠ‚ä¸­å°†ä¼šå¯¹é‡å­å›è·¯çš„å‰å››ä¸ªé‡å­æ¯”ç‰¹è¿›è¡Œ"è®¡æ•°"ï¼Œæˆ‘ä»¬å°†ç”¨äºè®¡æ•°é‡å­æ¯”ç‰¹çš„æ•°é‡ç§°ä¸º$t$ï¼Œæ­¤å¤„ä¸º$t = 4$ï¼ŒåŒç†é‡å­å›è·¯ä¸­ç”¨äºæœç´¢çš„åå››ä¸ªé‡å­æ¯”ç‰¹ï¼ˆ$n = 4$ï¼‰ã€‚ä¾æ®è¿™äº›è®¾å®šï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹æ„å»ºé‡å­å›è·¯çš„æ„æˆè¦ç´ äº†ã€‚

#### 2.2 å—æ§Groverè¿­ä»£

æˆ‘ä»¬å·²ç»åœ¨Groverç®—æ³•ä¸€èŠ‚ä¸­ä»‹ç»äº†Groverè¿­ä»£ã€‚æ­¤å¤„æ˜¯ä¸€ä¸ªä¸æ‰©æ•£ç®—å­ç›¸ç»“åˆåŒ…å«16ç§çŠ¶æ€ï¼ˆ$N = 2^{n} = 16$ï¼‰ä¸­5ä¸ªè§£ï¼ˆ$M = 5$ï¼‰çš„é¢„è¨€ã€‚

> def example_grover_iteration():
>
> \"\"\"Small circuit with 5/16 solutions\"\"\"
>
> \# Do circuit
>
> qc = QuantumCircuit(4)
>
> \# Oracle
>
> qc.h(\[2,3\])
>
> qc.ccx(0,1,2)
>
> qc.h(2)
>
> qc.x(2)
>
> qc.ccx(0,2,3)
>
> qc.x(2)
>
> qc.h(3)
>
> qc.x(\[1,3\])
>
> qc.h(2)
>
> qc.mct(\[0,1,3\],2)
>
> qc.x(\[1,3\])
>
> qc.h(2)
>
> \# Diffuser
>
> qc.h(range(3))
>
> qc.x(range(3))
>
> qc.z(3)
>
> qc.mct(\[0,1,2\],3)
>
> qc.x(range(3))
>
> qc.h(range(3))
>
> qc.z(3)
>
> return qc

å¯ä»¥çœ‹åˆ°è¯¥Pythonå‡½æ•°ä¸æ¥æ”¶ä»»ä½•è¾“å…¥ä¸”è¿”å›ä¸€ä¸ªæœ‰å››ä¸ªé‡å­æ¯”ç‰¹ç»„æˆçš„é‡å­å›è·¯å¯¹è±¡ã€‚åœ¨ä¹‹å‰æ‰€åˆ›å»ºçš„å‡½æ•°ä¸­å¸¦éƒ¨åˆ†ç”¨äºä¿®æ”¹ä¸€ä¸ªå·²ç»å­˜åœ¨é‡å­å›è·¯ï¼Œä½†ç±»ä¼¼ä¸Šé¢çš„å‡½æ•°å¯ä»¥å°†é‡å­å›è·¯ç”Ÿæˆä¸ºä¸€ä¸ªç”¨äºæ§åˆ¶çš„å•ä¸€é‡å­é—¨ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨.to_gate()å’Œ.control()æ–¹æ³•ä»ä¸€ä¸ªé‡å­å›è·¯åˆ›å»ºä¸€ä¸ªå—æ§é‡å­é—¨ï¼Œå°†Groverè¿­ä»£å™¨ç§°ä¹‹ä¸ºgritï¼Œå—æ§Groverè¿­ä»£å™¨ç§°ä¸ºcgritï¼š

> \# Create controlled-Grover
>
> grit = example_grover_iteration().to_gate()
>
> cgrit = grit.control()
>
> cgrit.label = \"Grover\"

#### 2.3 é€†é‡å­å‚…é‡Œå¶å˜æ¢ï¼ˆInverse QFTï¼‰

æˆ‘ä»¬ç°åœ¨éœ€è¦åˆ›å»ºä¸€ä¸ªé€†QFTã€‚ä»¥ä¸‹æ˜¯ç”¨äºåœ¨nä¸ªé‡å­æ¯”ç‰¹ä¸Šå®ç°QFTçš„ä»£ç ï¼š

> def qft(n):
>
> \"\"\"Creates an n-qubit QFT circuit\"\"\"
>
> circuit = QuantumCircuit(4)
>
> def swap_registers(circuit, n):
>
> for qubit in range(n//2):
>
> circuit.swap(qubit, n-qubit-1)
>
> return circuit
>
> def qft_rotations(circuit, n):
>
> \"\"\"Performs qft on the first n qubits in circuit (without
> swaps)\"\"\"
>
> if n == 0:
>
> return circuit
>
> n -= 1
>
> circuit.h(n)
>
> for qubit in range(n):
>
> circuit.cu1(np.pi/2\*\*(n-qubit), qubit, n)
>
> qft_rotations(circuit, n)
>
> qft_rotations(circuit, n)
>
> swap_registers(circuit, n)
>
> return circuit

å¯ä»¥çœ‹åˆ°æˆ‘ä»¬é€‰æ‹©äº†è¿”å›å¦ä¸€ä¸ªé‡å­å›è·¯å¯¹è±¡ï¼Œè¿™æ ·å°±å¯ä»¥è½»æ˜“çš„ç¿»è½¬é‡å­é—¨ã€‚åœ¨è¿™ä¸€é‡å­å›è·¯ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸è®¡æ•°é‡å­æ¯”ç‰¹ç›¸åŒçš„æ•°é‡ï¼ˆ$n = 4$ï¼‰æ¥åˆ›å»ºè¿™ä¸€é‡å­é—¨ï¼š

> qft_dagger = qft(4).to_gate().inverse()
>
> qft_dagger.label = \"QFTâ€ \"

2.4 ç»„åˆ

è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»ä¸ºå°†æ¥çš„å·¥ä½œå‡†å¤‡å¥½äº†ä¸€åˆ‡æ‰€éœ€ï¼ç°åœ¨è®©æˆ‘ä»¬å°†å…¶ç»„åˆèµ·æ¥ã€‚

ç¬¬ä¸€æ­¥ï¼Œéœ€è¦å°†æ‰€æœ‰çš„é‡å­æ¯”ç‰¹éƒ½ç½®äºæ€$| + \rangle$ï¼š

> \# Create QuantumCircuit
>
> t = 4 \# no. of counting qubits
>
> n = 4 \# no. of searching qubits
>
> qc = QuantumCircuit(n+t, t) \# Circuit with n+t qubits and t classical
> bits
>
> \# Initialise all qubits to \|+\>
>
> for qubit in range(t+n):
>
> qc.h(qubit)
>
> \# Begin controlled Grover iterations
>
> iterations = 1
>
> for qubit in range(t):
>
> for i in range(iterations):
>
> qc.append(cgrit, \[qubit\] + \[\*range(t, n+t)\])
>
> iterations \*= 2
>
> \# Do inverse QFT on counting qubits
>
> qc.append(qft_dagger, range(t))
>
> \# Measure counting qubits
>
> qc.measure(range(t), range(t))
>
> \# Display the circuit
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image266.png)

### 3. æ¨¡æ‹Ÿ

> \# Execute and see results
>
> emulator = Aer.get_backend(\'qasm_simulator\')
>
> job = execute(qc, emulator, shots=2048 )
>
> hist = job.result().get_counts()
>
> plot_histogram(hist)
>
> è¾“å‡ºï¼š

![](pics/media/image267.png)

å¯ä»¥çœ‹åˆ°æœ‰ä¸¤ä¸ªå€¼æ¯”è¾ƒçªå‡ºï¼Œæ¯”å…¶ä»–å€¼æœ‰æ›´é«˜çš„æµ‹é‡æ¦‚ç‡ã€‚è¿™ä¸¤ä¸ªå€¼å¯¹åº”äº$e^{i\theta}$å’Œ$e^{- i\theta}$ï¼Œä½†è¿˜ä¸èƒ½çœ‹å‡ºè§£çš„æ•°é‡ã€‚æˆ‘ä»¬éœ€è¦åšæ›´å¤šçš„å¤„ç†æ‰èƒ½è·å¾—æ­¤ä¿¡æ¯ï¼Œå› æ­¤é¦–å…ˆå°†è¾“å‡ºè½¬æ¢æˆå¯ä»¥ä½¿ç”¨çš„å†…å®¹ï¼ˆä¸€ä¸ªæ•´æ•°ï¼‰ã€‚

ä»è¾“å‡ºæ•°æ®ä¸­è·å–æœ€æœ‰å¯èƒ½ç»“æœçš„å­—ç¬¦ä¸²ï¼š

measured_str = max(hist, key=hist.get)

å¹¶å°†å…¶å­˜å‚¨ä¸ºä¸€ä¸ªæ•´æ•°ï¼š

> measured_int = int(measured_str,2)
>
> print(\"Register Output = %i\" % measured_int)
>
> è¾“å‡ºï¼š
>
> Register Output = 5

### 4. æ‰¾å‡ºè§£çš„æ•°é‡ï¼ˆ$\mathbf{M}$ï¼‰

æˆ‘ä»¬å°†ä¼šåˆ›å»ºä¸€ä¸ªåç§°ä¸ºcalculate_M()çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ªåè¿›åˆ¶æ•´æ•°ä½œä¸ºè¾“å…¥å¹¶è¾“å‡ºå¯„å­˜å™¨ã€è®¡æ•°é‡å­æ¯”ç‰¹çš„æ•°é‡ï¼ˆ$t$ï¼‰ä»¥åŠæœç´¢é‡å­æ¯”ç‰¹çš„æ•°é‡ï¼ˆ$n$ï¼‰ã€‚

é¦–å…ˆä»measured_intä¸­è·å–$\theta$ã€‚å›æƒ³ä¸€ä¸‹ï¼šé‡å­ç›¸ä½ä¼°è®¡ï¼ˆQPEï¼‰ä»æœ¬å¾å€¼$e^{2\pi i\varnothing}$ä¸­ç»™å‡ºæµ‹é‡å€¼ä¸º$2^{n}\varnothing$ï¼Œæ‰€ä»¥è‹¥è¦è·å¾—$\theta$åˆ™éœ€è¿›è¡Œå¦‚ä¸‹å˜æ¢ï¼š

$$\theta = æµ‹é‡å€¼ \times \frac{2\pi}{2^{t}}$$

ä»£ç å½¢å¼ä¸ºï¼š

> theta = (measured_int/(2\*\*t))\*math.pi\*2
>
> print(\"Theta = %.5f\" % theta)
>
> è¾“å‡ºï¼š
>
> Theta = 1.96350

æ‚¨å¯èƒ½è¿˜è®°å¾—æˆ‘ä»¬å¯ä»¥ä»$|s\rangle$å’Œ$|s'\rangle$çš„å†…ç§¯ä¸­è·å¾—è§’åº¦$\theta/2$ï¼š

![](pics/media/image268.png)

$$\langle s'|s\rangle = \cos\frac{\theta}{2}$$

è€Œè¿™äº›å‘é‡çš„å†…ç§¯ä¸ºï¼š

$$\langle s'|s\rangle = \sqrt{\frac{N - M}{N}}$$

å°†ä¸Šé¢çš„ä¸¤ä¸ªå¼å­ç»„åˆèµ·æ¥ï¼Œç„¶åè¿ç”¨ä¸‰è§’å’Œä»£æ•°çŸ¥è¯†å°†å…¶å˜æ¢ä¸ºï¼š

$$N\sin^{2}\frac{\theta}{2} = M$$

å›æƒ³ä¸€ä¸‹ï¼šåœ¨Groverç®—æ³•ä¸€ç« ä¸­åˆ›å»ºä¸€ä¸ªæ‰©æ•£ç®—å­$U_{s}$çš„é€šå¸¸æ–¹å¼å°±æ˜¯çœŸå®å®ç°$U_{s}$ã€‚Groverç®—æ³•ä¸€ç« ç»™å‡ºçš„è¿™ä¸€å®ç°è¢«ç”¨äºåˆ›å»ºGroverè¿­ä»£ã€‚åœ¨ä¸€ä¸ªé€šå¸¸çš„Groveræœç´¢ä¸­ï¼Œè¿™ä¸€ç›¸ä½æ˜¯å…¨å±€ç›¸ä½ä¸”ä¸èƒ½è¢«å¿½ç•¥ï¼Œä½†ç°åœ¨æˆ‘ä»¬æ§åˆ¶Groverè¿­ä»£æ—¶è¿™ä¸€ç›¸ä½ä»ç„¶å­˜åœ¨å½±å“ã€‚äº‹å®æƒ…å†µæ˜¯æˆ‘ä»¬å·²ç»æœ‰æ•ˆåœ°æœç´¢äº†*é*è§£çš„çŠ¶æ€ï¼Œå¹¶ä¸”é‡å­è®¡æ•°ç®—æ³•å‘Šè¯‰æˆ‘ä»¬æœ‰å¤šå°‘ä¸ªçŠ¶æ€æ˜¯*é*è§£ã€‚ä¸ºäº†ä¿®å¤è¿™ä¸€é—®é¢˜ï¼Œåªéœ€ç®€å•çš„$N - M$ã€‚

ä¸Šè¿°è¿‡ç¨‹çš„ä»£ç è¯•ä¸‹å¦‚ä¸‹æ‰€ç¤ºï¼š

> N = 2\*\*n
>
> M = N \* (math.sin(theta/2)\*\*2)
>
> print(\"No. of Solutions = %.1f\" % (N-M))
>
> è¾“å‡ºï¼š
>
> No. of Solutions = 4.9

ä»è¾“å‡ºå¯ä»¥çœ‹åˆ°å¤§çº¦æ­£ç¡®çš„ç­”æ¡ˆï¼æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•è¿‘ä¼¼è®¡ç®—æ­¤ç­”æ¡ˆä¸­çš„é”™è¯¯ï¼š

> m = t - 1 \# Upper bound: Will be less than this
>
> err = (math.sqrt(2\*M\*N) + N/(2\*\*(m-1)))\*(2\*\*(-m))
>
> print(\"Error \< %.2f\" % err)
>
> è¾“å‡ºï¼š
>
> Error \< 2.85

å¯¹é”™è¯¯è®¡ç®—çš„è§£é‡Šå·²ç»è¶…å‡ºæœ¬æ–‡çš„èŒƒå›´ï¼Œä½†å…¶ä¸­çš„ä¸€ç§è§£é‡Šå¯åœ¨å‚è€ƒæ–‡çŒ®\[1\]ä¸­æ‰¾åˆ°ã€‚

æœ€åï¼Œä¸‹è¿°ä»£ç æ˜¯å‡½æ•°calculate_M()çš„æœ€ç»ˆå½¢æ€ï¼š

> def calculate_M(measured_int, t, n):
>
> \"\"\"For Processing Output of Quantum Counting\"\"\"
>
> \# Calculate Theta
>
> theta = (measured_int/(2\*\*t))\*math.pi\*2
>
> print(\"Theta = %.5f\" % theta)
>
> \# Calculate No. of Solutions
>
> N = 2\*\*n
>
> M = N \* (math.sin(theta/2)\*\*2)
>
> print(\"No. of Solutions = %.1f\" % (N-M))
>
> \# Calculate Upper Error Bound
>
> m = t - 1 \#Will be less than this (out of scope)
>
> err = (math.sqrt(2\*M\*N) + N/(2\*\*(m-1)))\*(2\*\*(-m))
>
> print(\"Error \< %.2f\" % err)

### 5. ç»ƒä¹ 

1\. åˆ›å»ºä¸€ä¸ªä¸åŒæ•°é‡è§£çš„é¢„è¨€ã€‚æ‰€åˆ›å»ºé‡å­è®¡æ•°ç®—æ³•çš„å‡†ç¡®åº¦å¦‚ä½•å˜åŒ–ï¼Ÿ

2\. æ‚¨èƒ½å¤Ÿä½¿ç”¨æ›´å¤šæˆ–æ›´å°‘çš„è®¡æ•°é‡å­æ¯”ç‰¹è°ƒæ•´é‡å­å›è·¯è·å¾—ä¸åŒç²¾åº¦çš„ç»“æœå—ï¼Ÿ

### 6. å‚è€ƒæ–‡çŒ®

\[1\] Michael A. Nielsen and Isaac L. Chuang. 2011. Quantum Computation
and Quantum Information: 10th Anniversary Edition (10th ed.). Cambridge
University Press, New York, NY, USA.

3.12 é‡å­å¯†é’¥åˆ†å‘ï¼ˆQuantum Key Distribution QKDï¼‰
-------------------------------------------------

### å†…å®¹

1\. ç®€ä»‹

2\. åè®®æ¦‚è¿°

3\. ä¸åŒ…å«ç›‘å¬çš„Qiskitç¤ºä¾‹

4\. åŒ…å«ç›‘å¬çš„Qiskitç¤ºä¾‹

5\. é£é™©åˆ†æ

### 1. ç®€ä»‹

å½“Aliceå’ŒBobæƒ³è¦é€šè¿‡ä¸å®‰å…¨çš„æ¸ é“ï¼ˆå¦‚ï¼šäº’è”ç½‘ï¼‰ä¼ é€ç§˜å¯†ä¿¡æ¯ï¼ˆå¦‚ï¼šBobçš„åœ¨çº¿ç½‘ä¸Šé“¶è¡Œä¿¡æ¯ï¼‰ï¼Œå¯¹ä¿¡æ¯åŠ å¯†å°±æ˜¾å¾—è‡³å…³é‡è¦äº†ã€‚ç”±äºå¯†ç å­¦æ˜¯ä¸€ä¸ªå¹¿é˜”çš„é¢†åŸŸï¼Œå…¶å‡ ä¹æ‰€æœ‰çš„å†…å®¹éƒ½ä¸åœ¨æœ¬ä¹¦çš„è®¨è®ºèŒƒå›´ä¹‹å†…ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç¡®ä¿¡Aliceå’ŒBobæ‰€æ‹¥æœ‰çš„ä»–äººæœªçŸ¥çš„å¯†é’¥å°±å˜å¾—éå¸¸æœ‰ç”¨äº†ï¼Œä»–ä»¬å¯ä»¥ä½¿ç”¨å¯¹ç§°å¯†é’¥è¿›è¡ŒåŠ å¯†é€šä¿¡ã€‚

å¦‚æœAliceå’ŒBobè¦ä½¿ç”¨Eveçš„é€šå¸¸äº¤æµæ¸ é“æ¥å…±äº«å¯†é’¥ï¼Œé‚£ä¹ˆå°±æ— æ³•åˆ¤æ–­Eveæ˜¯å¦ä¸ºè‡ªå·±åˆ¶ä½œäº†è¿™ä¸ªå¯†é’¥çš„å‰¯æœ¬ã€‚å› æ­¤ä»–ä»¬å¿…é¡»å®Œå…¨ä¿¡ä»»Eveæ²¡æœ‰ç›‘å¬ã€‚ä½†æ˜¯ï¼Œå¦‚æœEveæä¾›äº†ä¸€ä¸ªé‡å­é€šä¿¡ä¿¡é“ï¼Œé‚£ä¹ˆAliceå’ŒBobä¸å†éœ€è¦å®Œå…¨ä¿¡ä»»Eve------ä»–ä»¬èƒ½å¤ŸçŸ¥é“Eveæ˜¯å¦åœ¨å°†ä¿¡æ¯å‘é€ç»™Aliceå‰å°è¯•è¯»å–Bobçš„æ¶ˆæ¯ã€‚

å¯¹äºæŸäº›è¯»è€…è€Œè¨€ï¼Œç»™å‡ºå¦‚ä½•ç‰©ç†å®ç°é‡å­ä¿¡é“çš„æƒ³æ³•å¯èƒ½ä¼šå¾ˆæœ‰å¸®åŠ©ã€‚ä¸€ä¸ªç»å…¸ä¿¡é“çš„ä¾‹å­å¯ä»¥æ˜¯ç”µè¯çº¿è·¯ï¼›æˆ‘ä»¬é€šè¿‡è¯¥çº¿è·¯å‘é€ä»£è¡¨ä¿¡æ¯ï¼ˆæˆ–æ¯”ç‰¹ï¼‰çš„ç”µä¿¡å·ã€‚æ‰€æåŠçš„é‡å­é€šä¿¡ä¿¡é“ç¤ºä¾‹å¯ä»¥æ˜¯æŸç§å…‰çº¤çº¿ç¼†ï¼Œé€šè¿‡è¯¥çº¿ç¼†æˆ‘ä»¬å¯ä»¥å‘é€å•ä¸ªå…‰å­ï¼ˆå…‰ç²’å­ï¼‰ã€‚å…‰å­å…·æœ‰ä¸€ä¸ªç§°ä¸ºæåŒ–ï¼ˆpolarisationï¼‰çš„å±æ€§ï¼Œè¿™ç§æåŒ–å¯ä»¥å‘ˆç°ä¸¤ç§çŠ¶æ€ä¸­çš„ä¸€ç§ï¼Œå¯ä»¥ä»¥æ­¤æ¥è¡¨ç¤ºä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚

### 2. åè®®æ¦‚è¿°

è¯¥åè®®åˆ©ç”¨äº†æµ‹é‡é‡å­æ¯”ç‰¹å¯ä»¥æ”¹å˜å…¶çŠ¶æ€çš„äº‹å®ã€‚å¦‚æœAliceå‘Bobå‘é€äº†ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼Œå¹¶ä¸”ä¸€ä¸ªçªƒå¬è€…ï¼ˆEveï¼‰è¯•å›¾åœ¨Bobä¹‹å‰è¿›è¡Œæµ‹é‡ï¼Œé‚£ä¹ˆEveçš„æµ‹é‡å¯èƒ½ä¼šæ”¹å˜é‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œè€ŒBobå°†ä¸ä¼šæ”¶åˆ°Aliceæ‰€å‘é€é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚

> from qiskit import QuantumCircuit, execute, Aer
>
> from qiskit.visualization import plot_histogram,
> plot_bloch_multivector
>
> from numpy.random import randint
>
> import numpy as np
>
> print(\"Imports Successful\")

å¦‚æœAliceå‡†å¤‡äº†ä¸€ä¸ªå¤„äºæ€$| + \rangle$çš„é‡å­æ¯”ç‰¹ï¼ˆåœ¨X-åŸºçŸ¢ä¸Šçš„0ï¼‰ï¼Œç„¶åBobå¯¹å…¶åœ¨X-åŸºçŸ¢ä¸Šè¿›è¡Œæµ‹é‡ï¼Œé‚£ä¹ˆå¯ä»¥ç¡®ä¿¡Bobæ‰€æµ‹å¾—çš„ç»“æœä¸º0.

> qc = QuantumCircuit(1,1)
>
> \# Alice prepares qubit in state \|+\>
>
> qc.h(0)
>
> qc.barrier()
>
> \# Alice now sends the qubit to Bob
>
> \# who measures it in the X-basis
>
> qc.h(0)
>
> qc.measure(0,0)
>
> \# Draw and simulate circuit
>
> display(qc.draw())
>
> svs = Aer.get_backend(\'qasm_simulator\')
>
> job = execute(qc, svs)
>
> plot_histogram(job.result().get_counts())
>
> è¾“å‡ºï¼š

![](pics/media/image269.png)

![](pics/media/image270.png)

ä½†å¦‚æœEveè¯•ç€åœ¨è¿™ä¸€é‡å­æ¯”ç‰¹è¾¾åˆ°Bobå¤„å‰å¯¹å…¶åœ¨Z-åŸºçŸ¢ä¸Šè¿›è¡Œæµ‹é‡ï¼Œè¿™ä¸€æ“ä½œå°†ä¼šä½¿å¾—è¿™ä¸ªé‡å­æ¯”ç‰¹ç”±æ€$| + \rangle$è½¬å˜ä¸º$|0\rangle$æˆ–$|1\rangle$ï¼ŒBobå°±ä¸èƒ½å¤Ÿç¡®å®šçš„æµ‹é‡åˆ°0äº†ï¼š

> qc = QuantumCircuit(1,1)
>
> \# Alice prepares qubit in state \|+\>
>
> qc.h(0)
>
> \# Alice now sends the qubit to Bob
>
> \# but Eve intercepts and tries to read it
>
> qc.measure(0, 0)
>
> qc.barrier()
>
> \# Eve then passes this on to Bob
>
> \# who measures it in the X-basis
>
> qc.h(0)
>
> qc.measure(0,0)
>
> \# Draw and simulate circuit
>
> display(qc.draw())
>
> svs = Aer.get_backend(\'qasm_simulator\')
>
> job = execute(qc, svs)
>
> plot_histogram(job.result().get_counts())
>
> è¾“å‡ºï¼š

![](pics/media/image271.png)

![](pics/media/image272.png)

å¯ä»¥çœ‹åˆ°Bobç°åœ¨çš„æµ‹é‡åˆ°1çš„æ¦‚ç‡ä¸ºçº¦ä¸º50%ï¼Œå¦‚æœç¡®å®å¦‚æ­¤åˆ™Bobå’ŒAliceå°±ä¼šçŸ¥é“ä¿¡é“å‘ç”Ÿäº†ä¸€äº›é”™è¯¯ã€‚

é‡å­å¯†é’¥åˆ†å‘åè®®æ¶‰åŠé‡å¤æ­¤è¿‡ç¨‹è¶³å¤Ÿå¤šæ¬¡ï¼Œä»¥ä½¿çªƒå¬è€…å®ç°ç›‘å¬çš„æœºç‡å˜å¾—å¾®ä¸è¶³é“ã€‚å…¶è¿‡ç¨‹å¤§è‡´å¦‚ä¸‹ï¼š

**-æ­¥éª¤1**

Aliceé€‰å‡ºä¸€ä¸ªéšæœºæ¯”ç‰¹å­—ä¸²ï¼Œå¦‚ï¼š

1000101011010100

ç„¶åä¸ºå…¶ä¸­çš„æ¯ä¸ªæ¯”ç‰¹éšæœºé€‰æ‹©åŸºçŸ¢ï¼š

ZZXZXXXZXZXXXXXX

AliceæŠŠè¿™ä¸¤æ¡ä¿¡æ¯ä¿å¯†èµ·æ¥ã€‚

**-æ­¥éª¤2**

ç„¶åAliceä½¿ç”¨æ‰€é€‰çš„åŸºçŸ¢å¯¹é‡å­æ¯”ç‰¹å­—ä¸²ä¸­çš„æ¯ä¸€ä¸ªè¿›è¡Œç¼–ç ï¼Œè¿™ä¸€æ“ä½œå°†æ¯ä¸ªé‡å­æ¯”ç‰¹éšæœºç½®äºæ€$|0\rangle$ã€$|1\rangle$ã€$| + \rangle$æˆ–$| - \rangle$ä¸­çš„ä¸€ä¸ªã€‚ç»è¿‡è¿™ä¸€æ“ä½œåé‡å­æ¯”ç‰¹å­—ä¸²å¯èƒ½åŒå¦‚ä¸‹æ‰€ç¤ºï¼š

$$|1\rangle|0\rangle| + \rangle|0\rangle| - \rangle| + \rangle| - \rangle|0\rangle| - \rangle|1\rangle| + \rangle| - \rangle| + \rangle| - \rangle| + \rangle| + \rangle$$

è¿™å°±æ˜¯Aliceå‘ç»™Bobçš„ä¿¡æ¯ã€‚

**-æ­¥éª¤3**

Bobæ”¶åˆ°æ¶ˆæ¯åéšæœºå¯¹è¿™äº›é‡å­æ¯”ç‰¹è¿›è¡Œæµ‹é‡ï¼Œæ¯”å¦‚å¯èƒ½ä½¿ç”¨å¦‚ä¸‹åŸºçŸ¢ï¼š

XZZZXZXZXZXZZZXZ

å¹¶å¯¹æ‰€æµ‹å¾—ç»“æœä¿å¯†ã€‚

**-æ­¥éª¤4**

ç„¶åBobå’ŒAliceå…¬å¼€åˆ†äº«ä»–ä»¬ä¸ºæ¯ä¸ªé‡å­æ¯”ç‰¹ä½¿ç”¨çš„åŸºçŸ¢ã€‚å¦‚æœBobä»¥Aliceæ‰€å‡†å¤‡çš„ç›¸åŒåŸºçŸ¢æµ‹é‡ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼Œåˆ™å°†å…¶ç”¨ä½œå…±äº«å¯†é’¥çš„ä¸€éƒ¨åˆ†ï¼Œå¦åˆ™å°†ä¸¢å¼ƒè¯¥æ¯”ç‰¹çš„ä¿¡æ¯ã€‚

**-æ­¥éª¤5**

æœ€åï¼ŒBobå’ŒAliceå…±äº«å¯†é’¥çš„éšæœºæ ·æœ¬ï¼Œå¦‚æœæ ·æœ¬åŒ¹é…å°±å¯ä»¥ç¡®ä¿¡ï¼ˆä»¥å¾ˆå°çš„è¯¯å·®ï¼‰ä¼ è¾“æˆåŠŸã€‚

### 3. ä¸åŒ…å«ç›‘å¬çš„Qiskitç¤ºä¾‹

é¦–å…ˆï¼Œè®©æˆ‘ä»¬çœ‹çœ‹å½“æ— äººç›‘å¬æ—¶è¯¥åè®®å¦‚ä½•å·¥ä½œï¼Œç„¶åçœ‹çœ‹Bobå’ŒAliceå¦‚ä½•èƒ½å¤Ÿæ£€æµ‹åˆ°çªƒå¬è€…ã€‚

ä¸ºäº†ç”Ÿæˆä¼ªéšæœºå¯†é’¥ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨numpyä¸­çš„randintå‡½æ•°ã€‚ä¸ºäº†ç¡®ä¿æ‚¨å¯ä»¥åœ¨æ­¤é¡µé¢ä¸Šé‡ç°ç»“æœï¼Œæˆ‘ä»¬å°†ç§å­è®¾ç½®ä¸º0ï¼š

np.random.seed(seed=0)

æˆ‘ä»¬å°†Aliceåˆå§‹ä¿¡æ¯çš„é•¿åº¦ç§°ä¸ºnã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼ŒAliceå°†å‘é€ä¸€æ¡é•¿åº¦ä¸º100ä¸ªé‡å­æ¯”ç‰¹çš„ä¿¡æ¯ï¼š

n = 100

#### 3.1 æ­¥éª¤1

éšæœºç”Ÿæˆæ¯”ç‰¹é›†ï¼š

> np.random.seed(seed=0)
>
> n = 100
>
> \#\# Step 1
>
> \# Alice generates bits
>
> alice_bits = randint(2, size=n)
>
> print(alice_bits)
>
> è¾“å‡ºï¼š
>
> \[0 1 1 0 1 1 1 1 1 1 1 0 0 1 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 1 0 1 0
> 1 1 0 1 1 0 0 1 0 1 1 1 1 1 0 1 0 1 1 1 1 0 1 0 0 1 1 0 1 0 1 0 0 0 0
> 0 1 1 0 0 0 1 1 0 1 0 0 1 0 1 1 1 1 1 1 0 1 1 0 0 1 0 0 1 1 0\]

ç›®å‰ï¼Œåªæœ‰Aliceæ‰çŸ¥é“åä¸º"alice_bits"çš„æ¯”ç‰¹é›†ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹è¡¨ä¸­è·Ÿè¸ªAliceåªçŸ¥é“å“ªäº›ä¿¡æ¯ï¼ŒBobåªçŸ¥é“å“ªäº›ä¿¡æ¯ä»¥åŠé€šè¿‡Eveçš„ä¿¡é“æ‰€å‘é€çš„ä¿¡æ¯ï¼š

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         

#### 3.2 æ­¥éª¤2

Aliceé€‰æ‹©éšæœºåœ¨X-åŸºçŸ¢æˆ–Z-åŸºçŸ¢çš„é‡å­æ¯”ç‰¹å¯¹æ¯ä¸€ä¿¡æ¯ä¸­çš„æ¯”ç‰¹è¿›è¡Œç¼–ç ï¼Œå¹¶å°†ç¼–ç åç»“æœå­˜å‚¨åœ¨alice_basesä¸­ã€‚æˆ‘ä»¬å®šä¹‰0è¡¨ç¤º"åœ¨Z-åŸºçŸ¢ä¸Šå‡†å¤‡"ï¼Œ1è¡¨ç¤º"åœ¨X-åŸºçŸ¢ä¸Šå‡†å¤‡"ï¼š

> np.random.seed(seed=0)
>
> n = 100
>
> \#\# Step 1
>
> \#Alice generates bits
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> \# Create an array to tell us which qubits
>
> \# are encoded in which bases
>
> alice_bases = randint(2, size=n)
>
> print(alice_bases)
>
> è¾“å‡ºï¼š
>
> \[1 0 0 1 0 0 0 1 1 0 1 0 0 0 0 0 1 0 1 0 1 1 1 1 1 0 1 1 1 1 0 1 1 0
> 0 1 0 0 0 0 1 1 0 0 1 0 1 1 1 1 0 0 0 1 0 1 1 1 0 1 0 0 1 0 1 1 0 0 1
> 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0\]

Aliceä»å°†è¿™ä¸€ä¿¡æ¯ä¿å¯†ï¼š

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        

ä¸‹é¢å‡½æ•°encode_messageç”¨äºåˆ›å»ºä¸€ä¸ªé‡å­å›è·¯çš„åˆ—è¡¨ï¼Œå…¶ä¸­çš„æ¯ä¸€ä¸ªé‡å­å›è·¯éƒ½ç”¨äºè¡¨ç¤ºAliceä¿¡æ¯ä¸­å•ä¸ªé‡å­æ¯”ç‰¹ï¼š

> def encode_message(bits, bases):
>
> message = \[\]
>
> for i in range(n):
>
> qc = QuantumCircuit(1,1)
>
> if bases\[i\] == 0: \# Prepare qubit in Z-basis
>
> if bits\[i\] == 0:
>
> pass
>
> else:
>
> qc.x(0)
>
> else: \# Prepare qubit in X-basis
>
> if bits\[i\] == 0:
>
> qc.h(0)
>
> else:
>
> qc.x(0)
>
> qc.h(0)
>
> qc.barrier()
>
> message.append(qc)
>
> return message
>
> np.random.seed(seed=0)
>
> n = 100
>
> \#\# Step 1 Alice generates bits
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2 Create an array to tell us which qubits are encoded in
> which bases
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨alices_bitsä¸­çš„ç¬¬ä¸€ä¸ªæ¯”ç‰¹æ˜¯0ï¼Œå¯¹å…¶è¿›è¡Œç¼–ç çš„ä¸ºX-åŸºçŸ¢ï¼ˆè¡¨ç¤ºä¸º1ï¼‰ï¼š

> print(\'bit = %i\' % alice_bits\[0\])
>
> print(\'basis = %i\' % alice_bases\[0\])
>
> è¾“å‡ºï¼š
>
> bit = 0
>
> basis = 1

å¦‚æœæŸ¥çœ‹ç”¨äºè¡¨ç¤ºAliceä¿¡æ¯ä¸­ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„é‡å­å›è·¯ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®è®¤Aliceå°†è¿™ä¸€é‡å­æ¯”ç‰¹ç½®äºæ€$| + \rangle$ï¼š

> message\[0\].draw()
>
> è¾“å‡ºï¼š

![](pics/media/image273.png)

å¦ä¸€ç¤ºä¾‹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°alice_bitsä¸­çš„ç¬¬å››ä¸ªæ¯”ç‰¹ä¸º1ï¼Œå¹¶åœ¨Z-åŸºçŸ¢ä¸Šå¯¹å…¶ç¼–ç ï¼ŒAliceæ‰€å‡†å¤‡ç›¸åº”çš„é‡å­æ¯”ç‰¹å¤„äºæ€$|1\rangle$ï¼š

> print(\'bit = %i\' % alice_bits\[4\])
>
> print(\'basis = %i\' % alice_bases\[4\])
>
> message\[4\].draw()
>
> è¾“å‡ºï¼š

![](pics/media/image274.png)

è¿™äº›é‡å­æ¯”ç‰¹ä¿¡æ¯å°†ä¼šé€šè¿‡Eveçš„é‡å­ä¿¡é“å‘é€ç»™Bobï¼š

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        
  message                  message                   message

#### 3.3 æ­¥éª¤3

Bobä¼šåœ¨æ¥æ”¶åˆ°ä¿¡æ¯åéšæœºåœ¨X-åŸºçŸ¢æˆ–Z-åŸºçŸ¢ä¸Šå¯¹å…¶æµ‹é‡å¹¶ä¿å­˜æµ‹é‡ç»“æœï¼š

> np.random.seed(seed=0)
>
> n = 100
>
> \#\# Step 1
>
> \# Alice generates bits
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> \# Create an array to tell us which qubits
>
> \# are encoded in which bases
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> \#\# Step 3
>
> \# Decide which basis to measure in:
>
> bob_bases = randint(2, size=n)
>
> print(bob_bases)
>
> è¾“å‡ºï¼š
>
> \[1 0 1 0 0 1 1 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 1 1 1 0 0 1 1 1 1 0 0
> 0 1 1 0 1 0 0 1 0 1 1 1 1 0 0 0 1 1 1 0 1 1 1 1 0 0 1 1 0 0 0 1 1 0 1
> 1 1 1 1 0 0 0 1 0 1 0 1 1 0 0 0 1 0 0 1 1 1 1 0 1 0 0 0 0 1 1\]

Bobå°†é€‰æ‹©åœ¨å“ªä¸€åŸºçŸ¢ä¸Šæµ‹é‡æ¯ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„ä¿¡æ¯ä¿å­˜åœ¨bob_basesä¸­ï¼š

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        
  message                  message                   message
                                                     bob_bases

ä¸‹é¢çš„å‡½æ•°measure_messageä¼šåº”ç”¨å¯¹åº”çš„æµ‹é‡å¹¶æ¨¡æ‹Ÿå‡ºæ¯ä¸ªé‡å­æ¯”ç‰¹çš„æµ‹é‡ç»“æœã€‚æˆ‘ä»¬å°†æµ‹é‡ç»“æœå­˜å‚¨åœ¨bob_resultsä¸­ã€‚

> def measure_message(message, bases):
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> measurements = \[\]
>
> for q in range(n):
>
> if bases\[q\] == 0: \# measuring in Z-basis
>
> message\[q\].measure(0,0)
>
> if bases\[q\] == 1: \# measuring in X-basis
>
> message\[q\].h(0)
>
> message\[q\].measure(0,0)
>
> result = execute(message\[q\], backend, shots=1, memory=True).result()
>
> measured_bit = int(result.get_memory()\[0\])
>
> measurements.append(measured_bit)
>
> return measurements
>
> np.random.seed(seed=0)
>
> n = 100
>
> \#\# Step 1
>
> \# Alice generates bits
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> \# Create an array to tell us which qubits
>
> \# are encoded in which bases
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> \#\# Step 3
>
> \# Decide which basis to measure in:
>
> bob_bases = randint(2, size=n)
>
> bob_results = measure_message(message, bob_bases)

å¯ä»¥çœ‹åˆ°æ¶ˆæ¯\[0\]ï¼ˆè¡¨ç¤ºç¬¬0ä¸ªé‡å­æ¯”ç‰¹ï¼‰ä¸­çš„å›è·¯å·²ç”±Bobæ·»åŠ äº†X-é‡åº¦ï¼š

> message\[0\].draw()
>
> è¾“å‡ºï¼š

![](pics/media/image275.png)

ç”±äºBobå¶ç„¶åœ°é€‰ä¸­ä¸Aliceç¼–ç é‡å­æ¯”ç‰¹ç›¸åŒçš„åŸºçŸ¢ï¼ŒBobå¯ä»¥ç¡®ä¿¡æ‰€å¾—ç»“æœæ˜¯0ã€‚å¯¹äºç¬¬å…­ä¸ªé‡å­æ¯”ç‰¹ï¼ˆå¦‚ä¸‹æ‰€ç¤ºï¼‰ï¼ŒBobéšæœºé€‰æ‹©çš„æµ‹é‡åŸºçŸ¢ä¸Aliceçš„ä¸åŒï¼ŒBobçš„æµ‹é‡ç»“æœä»…æœ‰50%çš„æ¦‚ç‡åŒ¹é…Aliceçš„ä¿¡æ¯ã€‚

> message\[6\].draw()
>
> è¾“å‡ºï¼š

![](pics/media/image276.png)

> print(bob_results)
>
> è¾“å‡ºï¼š
>
> \[0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0,
> 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
> 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0,
> 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1,
> 0, 0, 1, 0, 0, 1, 0, 0\]

Bobè¿˜å°†å…¶ç»“æœä¿å¯†ã€‚

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        
  message                  message                   message
                                                     bob_bases
                                                     bob_results

#### 3.4 æ­¥éª¤4

ç»è¿‡ä¸Šè¿°æ­¥éª¤ä¹‹åï¼ŒAliceå°†å“ªä¸€é‡å­æ¯”ç‰¹åœ¨å“ªä¸€åŸºçŸ¢ä¸Šç¼–ç çš„ä¿¡æ¯é€šè¿‡Eveçš„ä¿¡é“å‘é€å‡ºå»ï¼š

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        
  message                  message                   message
                                                     bob_bases
                                                     bob_results
                           alice_bases               alice_bases

Bobåˆ™å°†ä½¿ç”¨å“ªä¸€åŸºçŸ¢æµ‹é‡é‡å­æ¯”ç‰¹çš„ä¿¡æ¯å‘é€ï¼š

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        
  message                  message                   message
                                                     bob_bases
                                                     bob_results
                           alice_bases               alice_bases
  bob_bases                bob_bases                 

å¦‚æœBobç¢°å·§ä»¥Aliceä¸ºå…¶å‡†å¤‡çš„ç›¸åŒåŸºçŸ¢è¿›è¡Œæµ‹é‡ï¼Œåˆ™è¡¨æ˜bob_resultsä¸­çš„æ¡ç›®å°†ä¸alice_bitsä¸­çš„ç›¸åº”æ¡ç›®ç›¸åŒ¹é…ï¼Œå¹¶ä¸”ä»–ä»¬å¯ä»¥å°†è¯¥æ¯”ç‰¹ç”¨ä½œå…¶å¯†é’¥çš„ä¸€éƒ¨åˆ†ã€‚å¦‚æœä»–ä»¬ä»¥ä¸åŒçš„åŸºå‡†è¿›è¡Œè¡¡é‡ï¼Œé‚£ä¹ˆBobæ‰€æµ‹å¾—æ˜¯éšæœºç»“æœï¼Œå¹¶ä¸”ä»–ä»¬éƒ½ä¼šå°†è¯¥æ¯”ç‰¹ä¸¢å¼ƒã€‚å¦‚ä¸‹remove_garbageå‡½æ•°ä¸ºæˆ‘ä»¬æ‰§è¡Œæ­¤æ“ä½œçš„åŠŸèƒ½ï¼š

> def remove_garbage(a_bases, b_bases, bits):
>
> good_bits = \[\]
>
> for q in range(n):
>
> if a_bases\[q\] == b_bases\[q\]:
>
> \# If both used the same basis, add
>
> \# this to the list of \'good\' bits
>
> good_bits.append(bits\[q\])
>
> return good_bits

åœ¨Aliceå’ŒBobéƒ½ä¸¢å¼ƒäº†æ— ç”¨çš„æ¯”ç‰¹åä½¿ç”¨å‰©ä½™çš„æ¯”ç‰¹æ¥å½¢æˆå…¶ç§é’¥ï¼š

> np.random.seed(seed=0)
>
> n = 100
>
> \#\# Step 1
>
> \# Alice generates bits
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> \# Create an array to tell us which qubits
>
> \# are encoded in which bases
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> \#\# Step 3
>
> \# Decide which basis to measure in:
>
> bob_bases = randint(2, size=n)
>
> bob_results = measure_message(message, bob_bases)
>
> \#\# Step 4
>
> alice_key = remove_garbage(alice_bases, bob_bases, alice_bits)
>
> print(alice_key)
>
> è¾“å‡ºï¼š
>
> \[0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1,
> 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1,
> 0, 0\]

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        
  message                  message                   message
                                                     bob_bases
                                                     bob_results
                           alice_bases               alice_bases
  bob_bases                bob_bases                 
  alice_key                                          

> np.random.seed(seed=0)
>
> n = 100
>
> \#\# Step 1
>
> \# Alice generates bits
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> \# Create an array to tell us which qubits
>
> \# are encoded in which bases
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> \#\# Step 3
>
> \# Decide which basis to measure in:
>
> bob_bases = randint(2, size=n)
>
> bob_results = measure_message(message, bob_bases)
>
> \#\# Step 4
>
> alice_key = remove_garbage(alice_bases, bob_bases, alice_bits)
>
> bob_key = remove_garbage(alice_bases, bob_bases, bob_results)
>
> print(bob_key)
>
> è¾“å‡ºï¼š
>
> \[0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1,
> 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1,
> 0, 0\]

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        
  message                  message                   message
                                                     bob_bases
                                                     bob_results
                           alice_bases               alice_bases
  bob_bases                bob_bases                 
  alice_key                                          bob_key

##### 3.5 æ­¥éª¤5

æœ€åï¼ŒAliceå’ŒBobå¯¹æ¯”å¯†åŒ™ä¸­çš„éšæœºé€‰æ‹©æ¥ç¡®è®¤è¿™ä¸€åè®®è¿è¡Œæ­£ç¡®ï¼š

> def sample_bits(bits, selection):
>
> sample = \[\]
>
> for i in selection:
>
> \# use np.mod to make sure the
>
> \# bit we sample is always in
>
> \# the list range
>
> i = np.mod(i, len(bits))
>
> \# pop(i) removes the element of the
>
> \# list at index \'i\'
>
> sample.append(bits.pop(i))
>
> return sample

Aliceå’ŒBobéƒ½å¹¿æ’­äº†è¿™äº›å…¬å¼€å†…å®¹ï¼Œå› å…¶ä¸å†æ˜¯ç§˜å¯†äº†ï¼Œæ‰€ä»¥ä»å¯†é’¥ä¸­å°†å…¶åˆ é™¤ï¼š

> np.random.seed(seed=0)
>
> n = 100
>
> \#\# Step 1
>
> \# Alice generates bits
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> \# Create an array to tell us which qubits
>
> \# are encoded in which bases
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> \#\# Step 3
>
> \# Decide which basis to measure in:
>
> bob_bases = randint(2, size=n)
>
> bob_results = measure_message(message, bob_bases)
>
> \#\# Step 4
>
> alice_key = remove_garbage(alice_bases, bob_bases, alice_bits)
>
> bob_key = remove_garbage(alice_bases, bob_bases, bob_results)
>
> \#\# Step 5
>
> sample_size = 15
>
> bit_selection = randint(n, size=sample_size)
>
> bob_sample = sample_bits(bob_key, bit_selection)
>
> print(\" bob_sample = \" + str(bob_sample))
>
> alice_sample = sample_bits(alice_key, bit_selection)
>
> print(\"alice_sample = \"+ str(alice_sample))
>
> è¾“å‡ºï¼š
>
> bob_sample = \[0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0\]
>
> alice_sample = \[0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0\]

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        
  message                  message                   message
                                                     bob_bases
                                                     bob_results
                           alice_bases               alice_bases
  bob_bases                bob_bases                 
  alice_key                                          bob_key
  bob_sample               bob_sample                bob_sample
  alice_sample             alice_sample              alice_sample

å¦‚æœåœ¨æ²¡æœ‰ç›‘å¬çš„æƒ…å†µä¸‹è¯¥åè®®æ­£å¸¸è¿è¡Œï¼Œåˆ™å…¶æ ·æœ¬åº”åŒ¹é…ï¼š

> bob_sample == alice_sample
>
> è¾“å‡º
>
> True

å¦‚æœæ ·æœ¬åŒ¹é…ï¼Œè¡¨æ˜alice_keyå’Œbob_keyé«˜æ¦‚ç‡ç›¸ç­‰ã€‚ç°åœ¨ä»–ä»¬å¯ä»¥åˆ†äº«å¯†åŒ™ç”¨äºåŠ å¯†ä¹‹é—´çš„é€šä¿¡ä¿¡æ¯ã€‚

  **Alice\'s Knowledge**   **Over Eve\'s Channel**   **Bob\'s Knowledge**
------------------------ ------------------------- ----------------------
  alice_bits                                         
  alice_bases                                        
  message                  message                   message
                                                     bob_bases
                                                     bob_results
                           alice_bases               alice_bases
  bob_bases                bob_bases                 
  alice_key                                          bob_key
  bob_sample               bob_sample                bob_sample
  alice_sample             alice_sample              alice_sample
  shared_key                                         shared_key

> print(bob_key)
>
> print(alice_key)
>
> print(\"key length = %i\" % len(alice_key))
>
> è¾“å‡ºï¼š
>
> \[1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1,
> 1, 0, 0, 0, 1, 1, 0, 1, 0, 0\]
>
> \[1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1,
> 1, 0, 0, 0, 1, 1, 0, 1, 0, 0\]
>
> key length = 33

### 4. åŒ…å«ç›‘å¬çš„Qiskitç¤ºä¾‹

ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹å¦‚æœEveåœ¨è¯•ç€ç›‘å¬é‡å­ä¿¡æ¯æ—¶Aliceå’ŒBobå¦‚ä½•è·çŸ¥ã€‚æˆ‘ä»¬å°†é‡å¤æ— ç›‘å¬ä¸­çš„æ­¥éª¤ï¼Œä½†åœ¨Bobæ”¶åˆ°é‡å­æ¯”ç‰¹ä¹‹å‰ï¼ŒEveä¼šè¯•ç€é‡ä¸­æå–ä¿¡æ¯ã€‚è¿™æ¬¡æˆ‘ä»¬å°†è®¾ç½®ä¸€ä¸ªä¸åŒçš„éšæœºæ•°ç§å­ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾—åˆ°äº†ä¸€ç»„ç‰¹å®šä¸”å¯å†ç°çš„"éšæœº"ç»“æœï¼š

np.random.seed(seed=3)

#### 4.1 æ­¥éª¤1

Aliceç”Ÿæˆå…¶éšæœºæ¯”ç‰¹é›†ï¼š

> np.random.seed(seed=3)
>
> \#\# Step 1
>
> alice_bits = randint(2, size=n)
>
> print(alice_bits)
>
> è¾“å‡ºï¼š
>
> \[0 0 1 1 0 0 0 1 1 1 0 1 1 1 0 1 1 0 0 0 0 1 1 0 0 0 1 0 0 0 0 1 0 1
> 1 0 1 0 0 1 1 0 0 1 0 1 0 1 1 1 1 0 1 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 1
> 1 0 0 1 1 1 0 1 1 1 1 1 1 0 1 0 0 1 1 0 1 0 0 0 0 0 1 1 0 1 1\]

#### 4.2 æ­¥éª¤2

Aliceéšæœºåœ¨Z-åŸºçŸ¢å’ŒX-åŸºçŸ¢ä¸Šå¯¹ä¸Šé¢çš„ä¿¡æ¯è¿›è¡Œç¼–ç ï¼Œå¹¶å°†ç¼–ç åçš„ç»“æœé€šè¿‡Eveçš„é‡å­ä¿¡é“å‘é€ç»™Bobã€‚

> np.random.seed(seed=3)
>
> \#\# Step 1
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> print(alice_bases)
>
> è¾“å‡ºï¼š
>
> \[1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 1 0 0 1 1 0 0 1 1 1
> 1 0 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1 1 0 0 1 0 1 0 1 1 0 0 1 0
> 0 1 1 1 1 1 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 1 0 0 0 1 0 1 1 1\]

åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼ŒAliceä¿¡æ¯ä¸­çš„ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹è¢«ç½®äºæ€$| + \rangle$ï¼š

> message\[0\].draw()
>
> è¾“å‡ºï¼š

![](pics/media/image277.png)

#### ç›‘å¬ï¼

åœ¨Aliceçš„ä¿¡æ¯ç»è¿‡Eveçš„ä¿¡é“æ—¶ï¼ŒEveå¯¹å…¶è¿›è¡Œäº†ç›‘å¬ã€‚å¥¹å°è¯•ä»¥éšæœºé€‰æ‹©çš„åŸºçŸ¢ä¸Šæµ‹é‡è¿™äº›é‡å­æ¯”ç‰¹ï¼Œè¿™ä¸€æ“ä½œä¸Bobæ”¶åˆ°ä¿¡æ¯çš„å¤„ç†æ–¹å¼ç›¸åŒã€‚

> np.random.seed(seed=3)
>
> \#\# Step 1
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> \#\# Interception!!
>
> eve_bases = randint(2, size=n)
>
> intercepted_message = measure_message(message, eve_bases)
>
> print(intercepted_message)
>
> è¾“å‡ºï¼š
>
> \[1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0,
> 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0,
> 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0,
> 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,
> 0, 0, 0, 1, 1, 0, 1, 0\]

ä¸‹é¢æ‰€ç¤ºçš„ä¸ºè¯¥æƒ…å†µä¸‹çš„é‡å­æ¯”ç‰¹0ï¼›Eveæ‰€éšæœºé€‰æ‹©çš„åŸºçŸ¢ä¸Aliceçš„ä¸åŒï¼Œè¿™ä¼šå°†åŸé‡å­æ€$| + \rangle$æ”¹å˜ä¸ºZ-åŸºçŸ¢ä¸Šçš„éšæœºæ€ï¼Œ$|0\rangle$æˆ–$|1\rangle$å„æœ‰50%çš„æ¦‚ç‡ã€‚

> message\[0\].draw()
>
> è¾“å‡ºï¼š

![](pics/media/image278.png)

#### 4.3 æ­¥éª¤3

ç„¶åï¼ŒEveä¼šå°†å·²ç»è¿‡ç›‘å¬çš„é‡å­æ¯”ç‰¹ä¼ ç»™Bobï¼ŒBobä¼šåœ¨æ”¶åˆ°åå¯¹å…¶è¿›è¡Œéšæœºæµ‹é‡ã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼ŒBobå¶ç„¶é€‰ä¸­äº†ä¸Aliceå‡†å¤‡é‡å­æ¯”ç‰¹æ—¶ç›¸åŒçš„åŸºçŸ¢ã€‚åœ¨æ²¡æœ‰ç›‘å¬çš„æƒ…å†µä¸‹Bobä¼šè·å¾—æµ‹é‡å€¼0ï¼Œä½†ç”±äºEveæœ‰å°è¯•è¯»å–ä¿¡æ¯çš„æ“ä½œå¯¼è‡´Bobç°åœ¨æœ‰50%çš„æ¦‚ç‡è·å¾—æµ‹é‡å€¼1ã€‚

> np.random.seed(seed=3)
>
> \#\# Step 1
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> \#\# Interception!!
>
> eve_bases = randint(2, size=n)
>
> intercepted_message = measure_message(message, eve_bases)
>
> \#\# Step 3
>
> bob_bases = randint(2, size=n)
>
> bob_results = measure_message(message, bob_bases)
>
> message\[0\].draw()

![](pics/media/image279.png)

#### 4.4 æ­¥éª¤4

Bobå’ŒAliceå…¬å¼€äº†ä»–ä»¬çš„åŸºçŸ¢é€‰æ‹©ï¼Œå¹¶åˆ é™¤äº†æ— ç”¨çš„æ¯”ç‰¹ï¼š

> np.random.seed(seed=3)
>
> \#\# Step 1
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> \#\# Interception!!
>
> eve_bases = randint(2, size=n)
>
> intercepted_message = measure_message(message, eve_bases)
>
> \#\# Step 3
>
> bob_bases = randint(2, size=n)
>
> bob_results = measure_message(message, bob_bases)
>
> \#\# Step 4
>
> bob_key = remove_garbage(alice_bases, bob_bases, bob_results)
>
> alice_key = remove_garbage(alice_bases, bob_bases, alice_bits)

#### 4.5 æ­¥éª¤5

Bobå’ŒAliceé€šè¿‡å¯¹æ¯”ä»–ä»¬å¯†åŒ™ä¸­ç›¸åŒä½ç½®çš„éšæœºé€‰æ‹©æ¥æŸ¥çœ‹é‡å­æ¯”ç‰¹æ˜¯å¦è¢«ç›‘å¬ï¼š

> np.random.seed(seed=3)
>
> \#\# Step 1
>
> alice_bits = randint(2, size=n)
>
> \#\# Step 2
>
> alice_bases = randint(2, size=n)
>
> message = encode_message(alice_bits, alice_bases)
>
> \#\# Interception!!
>
> eve_bases = randint(2, size=n)
>
> intercepted_message = measure_message(message, eve_bases)
>
> \#\# Step 3
>
> bob_bases = randint(2, size=n)
>
> bob_results = measure_message(message, bob_bases)
>
> \#\# Step 4
>
> bob_key = remove_garbage(alice_bases, bob_bases, bob_results)
>
> alice_key = remove_garbage(alice_bases, bob_bases, alice_bits)
>
> \#\# Step 5
>
> sample_size = 15
>
> bit_selection = randint(n, size=sample_size)
>
> bob_sample = sample_bits(bob_key, bit_selection)
>
> print(\" bob_sample = \" + str(bob_sample))
>
> alice_sample = sample_bits(alice_key, bit_selection)
>
> print(\"alice_sample = \"+ str(alice_sample))
>
> è¾“å‡ºï¼š
>
> bob_sample = \[1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1\]
>
> alice_sample = \[1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0\]
>
> bob_sample == alice_sample
>
> è¾“å‡ºï¼š
>
> False

çœ‹åˆ°æ²¡æœ‰ï¼Aliceå’ŒBobçš„å¯†åŒ™ä¸åŒ¹é…ã€‚æˆ‘ä»¬ç›´åˆ°è¿™æ—¶ç”±äºEveåœ¨æ­¥éª¤2å’Œ3ä¹‹é—´å°è¯•è¯»å–è¿™ä¸€ä¿¡æ¯æ‰€è‡´ï¼Œä»è€Œå¯¼è‡´äº†é‡å­æ¯”ç‰¹çŠ¶æ€çš„æ”¹å˜ã€‚å¯¹äºAliceå’ŒBobæ¥è¯´ï¼Œå¯†åŒ™ä¸åŒ¹é…çš„åŸå› å¯èƒ½æ˜¯é‡å­ä¿¡é“ä¸­çš„å™ªå£°å¼•èµ·çš„ï¼Œä½†æ— è®ºå¦‚ä½•ä»–ä»¬éƒ½å¿…é¡»èˆå¼ƒç°æœ‰ç»“æœï¼Œç„¶åå†è¯•ä¸€æ¬¡------Eveçš„ç›‘å¬å°è¯•å¤±è´¥äº†ï¼

### 5. é£é™©åˆ†æ

å¯¹äºè¿™ç§Eveæµ‹é‡æ‰€æœ‰é‡å­æ¯”ç‰¹çš„ç›‘å¬ï¼Œåœ¨Aliceé€šè¿‡Eveçš„ä¿¡é“å‘é€å¥¹æ˜“å—æ”»å‡»çš„ä¿¡æ¯æ—¶ï¼ŒAliceå’ŒBobä¹‹é—´æ ·æœ¬åŒ¹é…çš„å‡ ç‡æå°ã€‚è®©æˆ‘ä»¬è®¡ç®—è¿™ä¸€å‡ ç‡å¹¶çœ‹ä¸€ä¸‹é‡å­å¯†é’¥åˆ†å‘æœ‰å¤šå±é™©ã€‚

-   ä¸ºäº†ä½¿Aliceå’ŒBobä½¿ç”¨ç›¸åŒé‡å­æ¯”ç‰¹ç»“æœï¼Œä»–ä»¬å¿…é¡»éƒ½é€‰ä¸­ç›¸åŒåŸºçŸ¢ã€‚å¦‚æœEveä¹Ÿé€‰ä¸­äº†è¿™ä¸€åŸºçŸ¢ï¼Œå¥¹å°†ä¼šåœ¨ä¸ä¼šå¼•å…¥ä»»ä½•é”™è¯¯çš„æƒ…å†µä¸‹æˆåŠŸç›‘å¬è¿™ä¸ªæ¯”ç‰¹ã€‚è¿™ä¸€æƒ…å†µå‘ç”Ÿçš„å‡ ç‡ä¸º50%ã€‚

-   å¦‚æœEveé€‰ä¸­äº†é”™è¯¯çš„åŸºçŸ¢ï¼ŒBobä»æœ‰50%çš„å‡ ç‡æµ‹é‡åˆ°Aliceå‘é€çš„å€¼ã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œç›‘å¬æ— æ³•è¢«æ¢æµ‹åˆ°ã€‚

-   å¦‚æœEveé€‰ä¸­äº†é”™è¯¯çš„åŸºçŸ¢ï¼ŒBobæœ‰50%çš„å‡ ç‡æµ‹é‡ä¸åˆ°Aliceå‘é€çš„å€¼ï¼Œå¹¶ä¼šåœ¨Aliceå’ŒBobçš„å¯†åŒ™ä¸­å¼•å…¥é”™è¯¯ã€‚

![](pics/media/image280.png)

å¦‚æœAliceå’ŒBobå¯¹æ¯”äº†ä»–ä»¬å¯†åŒ™ä¸­çš„ä¸€ä¸ªæ¯”ç‰¹ï¼Œè¿™ä¸€æ¯”ç‰¹åŒ¹é…çš„æ¦‚ç‡æ˜¯$0.75$ï¼Œå› æ­¤ä»–ä»¬ä¸ä¼šå‘ç°Eveçš„ç›‘å¬ã€‚å¦‚æœä»–ä»¬æµ‹é‡äº†ä¸¤ä¸ªé‡å­æ¯”ç‰¹ï¼Œç›‘å¬ä¸è¢«å‘ç°çš„æ¦‚ç‡å°±æ˜¯${0.75}^{2} = 0.5625$ã€‚å¯ä»¥çœ‹å‡ºEveçš„ç›‘å¬ä¸è¢«å‘ç°çš„æ¦‚ç‡ç”±Aliceå’ŒBobç”¨äºæ¯”è¾ƒçš„æ¯”ç‰¹æ•°é‡ï¼ˆ$x$ï¼‰æ¥è®¡ç®—ï¼š

$$P(undeteced) = {0.75}^{x}$$

å¦‚æœæˆ‘ä»¬å†³å®šæŒ‰ç…§ä¸Šè¿°çš„è¿‡ç¨‹å¯¹æ¯”15ä¸ªæ¯”ç‰¹ï¼ŒEveçš„ç›‘å¬ä¸è¢«å‘ç°çš„å‡ ç‡ä¸º1.3%ã€‚å¦‚æœè¿™ä»¥å‡ ç‡å¯¹äºæˆ‘ä»¬æ¥è¯´ä»ç„¶è¿‡äºå±é™©ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹æ¯”50ä¸ªæ¯”ç‰¹ï¼Œæ­¤æ—¶ç›‘å¬ä¸è¢«å‘ç°çš„å‡ ç‡ä¸º0.00006ï¼…ã€‚

æ‚¨å¯ä»¥è¿è¡Œä¸‹é¢çš„ä»£ç æ¥é‡æ–°å®éªŒè¿™ä¸€åè®®ã€‚å°†sample_sizeæ›´æ”¹ä¸ºè¾ƒå°å€¼ï¼Œçœ‹çœ‹Eveæˆªå–Aliceå’ŒBobçš„å¯†é’¥æœ‰å¤šä¹ˆå®¹æ˜“ã€‚n
= 100

> \# Step 1
>
> alice_bits = randint(2, size=n)
>
> alice_bases = randint(2, size=n)
>
> \# Step 2
>
> message = encode_message(alice_bits, alice_bases)
>
> \# Interception!
>
> eve_bases = randint(2, size=n)
>
> intercepted_message = measure_message(message, eve_bases)
>
> \# Step 3
>
> bob_bases = randint(2, size=n)
>
> bob_results = measure_message(message, bob_bases)
>
> \# Step 4
>
> bob_key = remove_garbage(alice_bases, bob_bases, bob_results)
>
> alice_key = remove_garbage(alice_bases, bob_bases, alice_bits)
>
> \# Step 5
>
> sample_size = 15 \# Change this to something lower and see if
>
> \# Eve can intercept the message without Alice
>
> \# and Bob finding out
>
> bit_selection = randint(n, size=sample_size)
>
> bob_sample = sample_bits(bob_key, bit_selection)
>
> alice_sample = sample_bits(alice_key, bit_selection)
>
> if bob_sample != alice_sample:
>
> print(\"Eve\'s interference was detected.\")
>
> else:
>
> print(\"Eve went undetected!\")
>
> è¾“å‡ºï¼š
>
> Eve\'s interference was detected.

4. é‡å­ç®—æ³•çš„åº”ç”¨
=================

å…³äºæœ¬ç« 
--------

æ­¤åˆ»ï¼Œè¯»è€…å¯ä»¥é€‰æ‹©ç»§ç»­å­¦ä¹ åº”ç”¨é‡å­ç®—æ³•ï¼Œä¹Ÿå¯ä»¥è·³åˆ°"ä½¿ç”¨é‡å­å›è·¯ç ”ç©¶é‡å­ç¡¬ä»¶"ä¸€ç« ã€‚åœ¨4.1ä¸­ï¼Œæˆ‘ä»¬å°†æ¼”ç¤ºåº”ç”¨äºå®é™…é—®é¢˜çš„é‡å­ç®—æ³•ã€‚åœ¨4.2ä¸­ä¸ºå¸®åŠ©è¯»è€…äº†è§£è¯¥é¢†åŸŸçš„æœ€æ–°åŠ¨æ€ï¼Œæˆ‘ä»¬å°†ä»‹ç»æœ€æ–°çš„é‡å­ç®—æ³•ã€‚

4.1 åº”ç”¨é‡å­ç®—æ³•
----------------

### å…³äºæœ¬èŠ‚

èƒ½å¤Ÿæ„Ÿå—åˆ°é‡å­ç®—æ³•çš„å¹¿æ³›åº”ç”¨å¾ˆé‡è¦ï¼Œä½†æ­£å¦‚æˆ‘ä»¬æ‰€è§ï¼Œç†è§£ä¸€ä¸ªé—®é¢˜å¯èƒ½å’Œç†è§£è§£å†³è¿™ä¸€é—®é¢˜çš„ç®—æ³•ä¸€æ ·å›°éš¾ã€‚æœ¬èŠ‚çš„ä¸»é¢˜èŒƒå›´ä»åŒ–å­¦åˆ°æœºå™¨å­¦ä¹ ï¼Œåœ¨å…¶è‡ªèº«çš„é¢†åŸŸä¸­éƒ½æ˜¯å¤§ä¸”å¤æ‚çš„é—®é¢˜ï¼Œæœ¬Qiskitæ•™ç¨‹ä¸å¯èƒ½å¯¹å…¶ç»™å‡ºä¸€ä¸ªå®Œæ•´çš„ä»‹ç»ã€‚è™½ç„¶æˆ‘ä»¬è¯•å›¾åœ¨æœ¬æ•™ç¨‹ä¸­åŒ…å«å¿…è¦çš„èƒŒæ™¯æ¥è§£é‡Šç®—æ³•ï¼Œä½†è¿™äº›è§£é‡Šä¸æ˜¯å¯¹æŸä¸€é¢†åŸŸçš„ä¸¥æ ¼ä»‹ç»ï¼Œåœ¨è¿™äº›é¡µé¢ä¸­å°†ä¸å¯é¿å…åœ°æ¶‰åŠåˆ°æœ¬æ•™ç¨‹èŒƒå›´ä¹‹å¤–çš„æ¦‚å¿µã€‚

å»ºè®®æ‚¨ä½¿ç”¨æœ¬èŠ‚æ¥äº†è§£æˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢æ‰€å­¦çš„ç®—æ³•å¦‚ä½•åº”ç”¨äºå®é™…é—®é¢˜ï¼Œå¹¶æ›´æ·±å…¥åœ°é˜…è¯»æœ€æ„Ÿå…´è¶£çš„ä¸»é¢˜ã€‚

### 4.1.1 ä½¿ç”¨HHLæ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„

åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»HHLç®—æ³•å¹¶å¯¼å‡ºç›¸åº”çš„é‡å­å›è·¯ï¼Œç„¶åä½¿ç”¨Qiskitå¯¹å…¶è¿›è¡Œå®ç°ã€‚æˆ‘ä»¬å°†ä¼šå±•ç¤ºå¦‚ä½•åœ¨æ¨¡æ‹Ÿå™¨å’Œäº”ä¸ªé‡å­æ¯”ç‰¹çš„è®¾å¤‡ä¸Šè¿è¡ŒHHLã€‚

#### å†…å®¹

1\. ç®€ä»‹

2\. HHLç®—æ³•

2.1 æ•°å­¦èƒŒæ™¯

2.2 HHLç®—æ³•æè¿°

2.3 HHLä¸­çš„é‡å­ç›¸ä½ä¼°è®¡ï¼ˆQPEï¼‰

2.4 éç²¾ç¡®QPE

3\. ç¤ºä¾‹1ï¼š4é‡å­æ¯”ç‰¹HHL

4\. Qiskitå®ç°

4.1 åœ¨æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡ŒHHLï¼šä¸€èˆ¬æ–¹æ³•

4.2 åœ¨çœŸå®è®¾å¤‡ä¸Šè¿è¡ŒHHLï¼šä¼˜åŒ–çš„ä¾‹å­

5\. ç»ƒä¹ 

6\. å‚è€ƒæ–‡çŒ®

#### 1. ç®€ä»‹

çº¿æ€§æ–¹ç¨‹ç»„åœ¨è®¸å¤šå®é™…åº”ç”¨ä¸­è‡ªç„¶åœ°å‡ºç°åœ¨å¹¿æ³›çš„é¢†åŸŸä¸­ï¼Œä¾‹å¦‚åå¾®åˆ†æ–¹ç¨‹çš„æ±‚è§£ï¼Œè´¢åŠ¡æ¨¡å‹çš„æ ¡å‡†ï¼Œæµä½“æ¨¡æ‹Ÿæˆ–æ•°å€¼åœºè®¡ç®—ã€‚è¿™äº›é—®é¢˜å¯ä»¥å®šä¹‰ä¸ºï¼šç»™å®šä¸€ä¸ªçŸ©é˜µ$A \in \mathbb{C}^{N \times N}$å’Œå‘é‡$\overrightarrow{b} \in \mathbb{C}^{N}$ï¼Œæ‰¾å‡ºæ»¡è¶³$A\overrightarrow{x} = \overrightarrow{b}$ä¸­å±äº$\mathbb{C}^{N}$çš„å‘é‡$\overrightarrow{x}$ã€‚

ä¾‹å¦‚ï¼š$N = 2$ï¼Œ

$$A = \begin{pmatrix}
1 & - 1\text{/}3 \\
 - 1\text{/}3 & 1 \\
\end{pmatrix}\ ,\ \overrightarrow{x} = \left( \frac{x_{1}}{x_{2}} \right)\ å’Œ\ \overrightarrow{b} = \left( \frac{1}{0} \right)$$

è¿™ä¸€é—®é¢˜è¿˜å¯å†™æˆæ‰¾å‡ºå±äº$\mathbb{C}$çš„$x_{1}$å’Œ$x_{2}$ï¼š

$$\left\{ \begin{matrix}
x_{1} - \frac{x_{2}}{3} = 1 \\
 - \frac{x_{1}}{3} + x_{2} = 0 \\
\end{matrix} \right.\ $$

å¦‚æœçŸ©é˜µ$A$çš„æ¯è¡Œæˆ–æ¯åˆ—æœ€å¤šå…·æœ‰$s$ä¸ªéé›¶æ¡ç›®ï¼Œåˆ™è¿™ä¸€çº¿æ€§æ–¹ç¨‹ç»„ç§°ä¸º$s$-ç¨€ç–ã€‚ç”¨ç»å…¸è®¡ç®—æœºä½¿ç”¨å…±è½­æ¢¯åº¦æ³•^\[1\](\#conjgrad)^è§£å¤§å°ä¸º$N$çš„$s$-ç¨€ç–æ–¹ç¨‹ç»„éœ€è¦$\mathcal{O(}\text{Ns}\kappa log(1/\epsilon))$çš„è¿è¡Œæ—¶é—´ã€‚å…¶ä¸­çš„$\kappa$ä¸ºæ–¹ç¨‹ç»„çš„æ¡ä»¶æ•°ï¼Œ$\epsilon$ä¸ºè¿‘ä¼¼ç²¾åº¦ã€‚

å½“çŸ©é˜µAæ˜¯åœ¨æœ‰æ•ˆé¢„è¨€å‡è®¾ä¸‹åŠ è½½æ•°æ®ã€å“ˆå¯†é¡¿æ¨¡æ‹Ÿå’Œè®¡ç®—è§£å‡½æ•°çš„å„å¯†çŸ©é˜µæ—¶ï¼ŒHHLæ˜¯ä¸€ä¸ªé‡å­ç®—æ³•ï¼Œå…¶ä½œç”¨ä¸ºä¼°è®¡è¿è¡Œæ—¶é—´å¤æ‚åº¦ä¸º$\mathcal{O(}log(N)s^{2}\kappa^{2}/\epsilon)$^\[2\](\#hhl)^çš„è§£å‡½æ•°ã€‚HHLç®—æ³•ä¾æ®æ–¹ç¨‹ç»„çš„å¤§å°å¯¹æ±‚è§£æœ‰æŒ‡æ•°çº§åˆ«çš„åŠ é€Ÿï¼Œç„¶è€Œéœ€è¦ç‰¢è®°çš„ä¸€ç‚¹æ˜¯ç»å…¸ç®—æ³•è¿”å›å…¨éƒ¨è§£ï¼Œè€ŒHHLåªèƒ½ç»™å‡ºè§£å‘é‡çš„è¿‘ä¼¼å‡½æ•°ã€‚

#### 2. HHLç®—æ³•

##### A. æ•°å­¦èƒŒæ™¯çŸ¥è¯†

ç”¨é‡å­è®¡ç®—æœºè§£å†³çº¿æ€§æ–¹ç¨‹ç»„çš„ç¬¬ä¸€æ­¥æ˜¯ç”¨é‡å­è¯­è¨€å°†é—®é¢˜ç¼–ç ã€‚é€šè¿‡é‡æ–°è°ƒæ•´æ–¹ç¨‹ç»„çš„è§„æ¨¡ï¼Œæˆ‘ä»¬å¯ä»¥å‡å®šå°†å‘é‡$\overrightarrow{b}$å’Œ$\overrightarrow{x}$å½’ä¸€åŒ–åæ˜ å°„åˆ°å¯¹åº”çš„é‡å­æ€$|b\rangle$å’Œ$|x\rangle$ã€‚é€šå¸¸ï¼Œæ‰€ä½¿ç”¨çš„æ˜ å°„ä½¿å¾—å‘é‡$\overrightarrow{b}$çš„ç¬¬$i$ä¸ªåˆ†é‡å¯¹åº”äºé‡å­æ€$|b\rangle$çš„ç¬¬$i$ä¸ªåŸºæ€çš„å¹…å€¼ï¼Œå‘é‡$\overrightarrow{x}$åŒç†ã€‚

$$A|x\rangle = |b\rangle$$

ç”±äºçŸ©é˜µ$A$æ˜¯ä¸€ä¸ªå„ç±³çŸ©é˜µï¼Œå…¶æœ‰ä¸€ä¸ªè°±åˆ†è§£ï¼ˆåˆç§°ï¼šç‰¹å¾åˆ†è§£
EigenDecompositionï¼‰ï¼š

$$A = \sum_{j = 0}^{N - 1}{\lambda_{j}\left| u_{j} \right\rangle\left\langle u_{j} \right|}\ ,\ \ \lambda_{j} \in R$$

å…¶ä¸­$\left| u_{j} \right\rangle$æ˜¯çŸ©é˜µ$A$å¯¹åº”äºæœ¬å¾å€¼$\lambda_{j}$çš„æœ¬å¾å‘é‡ã€‚

$$A^{- 1} = \sum_{j = 0}^{N - 1}{{\lambda_{j}}^{- 1}\left| u_{j} \right\rangle\left\langle u_{j} \right|}$$

å¦‚æ­¤ï¼Œæ–¹ç¨‹ç»„çš„å³ä¾§å¯è¢«å†™æˆçŸ©é˜µ$A$çš„æœ¬å¾åŸºï¼š

$$\left| b \right\rangle = \sum_{j = 0}^{N - 1}{b_{j}\left| u_{j} \right\rangle}\ ,\ \ \ {\text{\ \ \ \ \ \ \ }b}_{j} \in \mathbb{C}$$

è¯·ç‰¢è®°HHLçš„ç›®æ ‡æ˜¯é€šè¿‡è¯»å–å¦‚ä¸‹å¯„å­˜å™¨ä¸­çš„çŠ¶æ€æ¥æ¨å‡ºè¯¥ç®—æ³•ï¼š

$$|x\rangle = A^{- 1}\left| b \right\rangle = \sum_{j = 0}^{N - 1}{{\lambda_{j}}^{- 1}b_{j}\left| u_{j} \right\rangle}$$

æ³¨æ„ï¼šç”±äºæˆ‘ä»¬æ­£åœ¨è®¨è®ºä¸€ä¸ªé‡å­æ€ï¼Œå› æ­¤æ­¤å¤„å·²ç»æœ‰äº†éšå¼å½’ä¸€åŒ–å¸¸æ•°ã€‚

##### Bï¼HHLç®—æ³•æè¿°

è¯¥ç®—æ³•ä½¿ç”¨ä¸‰ä¸ªé‡å­å¯„å­˜å™¨ï¼Œåœ¨ç®—æ³•å¼€å§‹æ—¶å°†å®ƒä»¬å…¨éƒ¨ç½®ä¸ºä¸º$|0\rangle$ã€‚å…¶ä¸­ä¸€ä¸ªå¯„å­˜å™¨ç”¨ä¸‹æ ‡æ ‡è®°ä¸º$n_{l}$ï¼Œç”¨äºå­˜å‚¨çŸ©é˜µ$A$æœ¬å¾å€¼çš„äºŒè¿›åˆ¶å½¢æ€ã€‚æ ‡è®°ä¸º$n_{b}$çš„ç¬¬äºŒä¸ªå¯„å­˜å™¨åŒ…å«è‡ª$N = 2^{n_{b}}$æ—¶çš„å‘é‡è§£ã€‚å‰©ä½™çš„ä¸€ä¸ªå¯„å­˜å™¨ç”¨ä½œè¾…åŠ©é‡å­ä½ã€‚è¿™äº›å„ä¸ªè®¡ç®—ä¸­ç”¨ä½œä¸­é—´æ­¥éª¤çš„é‡å­æ¯”ç‰¹å°†åœ¨ä¸‹é¢çš„å™è¿°ä¸­è¢«å¿½ç•¥ï¼Œå› ä¸ºå®ƒä»¬åœ¨æ¯æ¬¡è®¡ç®—å¼€å§‹æ—¶éƒ½ç½®ä¸º$|0\rangle$ï¼Œå¹¶åœ¨å„ä¸ªæ“ä½œç»“æŸæ—¶æ¢å¤ä¸ºæ€$|0\rangle$ã€‚

ä»¥ä¸‹æ˜¯HHLç®—æ³•çš„æ¦‚è¿°ä»¥åŠç›¸åº”å›è·¯çš„ç¤ºæ„å›¾ã€‚ä¸ºäº†å™è¿°çš„ç®€æ˜æ€§ï¼Œåœ¨éšåçš„æè¿°ä¸­å‡å®šæ‰€æœ‰è®¡ç®—éƒ½æ˜¯ç²¾ç¡®çš„ï¼Œæœ¬ç« ä¸­çš„èŠ‚2.DèŠ‚ç»™å‡ºäº†éç²¾ç¡®æƒ…å†µçš„æ›´è¯¦ç»†è¯´æ˜ã€‚

![](pics/media/image281.png)

1\. è½½å…¥æ•°æ®$|b\rangle \in \mathbb{C}^{N}$å¹¶æ‰§è¡Œè½¬æ¢ï¼š

$${|0\rangle}_{n_{b}} \mapsto {|b\rangle}_{n_{b}}$$

2\. åº”ç”¨å¦‚ä¸‹é‡å­ç›¸ä½ä¼°è®¡ï¼ˆQPEï¼‰ï¼š

$$U = e^{\text{iAt}}: = \sum_{j = 0}^{N - 1}{e^{i\lambda_{j}t}\left| u_{j} \right\rangle\left\langle u_{j} \right|}$$

ä»¥çŸ©é˜µ$A$çš„æœ¬å¾åŸºæ‰€è¡¨ç¤ºå¯„å­˜å™¨çš„é‡å­æ€ç°ä¸ºï¼š

$$\sum_{j = 0}^{N - 1}{b_{j}\left| \lambda_{j} \right\rangle_{n_{l}}\left\langle u_{j} \right|_{n_{b}}}$$

å…¶ä¸­$\left| \lambda_{j} \right\rangle_{n_{l}}$ä»£è¡¨$\lambda_{j}$çš„$n_{l}$-æ¯”ç‰¹çš„äºŒè¿›åˆ¶è¡¨ç¤ºã€‚

3\.
æ·»åŠ ä¸€ä¸ªè¾…åŠ©é‡å­ä½å¹¶åº”ç”¨ä¸€ä¸ªä»¥$\left| \lambda_{j} \right\rangle$ä¸ºæ¡ä»¶çš„æ—‹è½¬ï¼Œ

$$\sum_{j = 0}^{N - 1}{b_{j}\left| \lambda_{j} \right\rangle_{n_{l}}\left\langle u_{j} \right|_{n_{b}}}\left( \sqrt{1 - \frac{C^{2}}{\lambda_{j}^{2}}}\left| 0 \right\rangle + \frac{C}{\lambda}\left| 1 \right\rangle \right)$$

å…¶ä¸­$C$æ˜¯å½’ä¸€åŒ–å¸¸é‡ã€‚

4\. åº”ç”¨$\text{QPE}^{\dagger}$ã€‚é€šè¿‡å¿½ç•¥è‡ªQPEçš„å¯èƒ½é”™è¯¯ï¼Œå…¶ç»“æœä¸ºï¼š

$$\sum_{j = 0}^{N - 1}{b_{j}\left| 0 \right\rangle_{n_{l}}\left\langle u_{j} \right|_{n_{b}}}\left( \sqrt{1 - \frac{C^{2}}{\lambda_{j}^{2}}}\left| 0 \right\rangle + \frac{C}{\lambda}\left| 1 \right\rangle \right)$$

5\. ä»¥è®¡ç®—åŸºæµ‹é‡è¾…åŠ©é‡å­ä½ã€‚å¦‚æœæµ‹é‡ç»“æœä¸º$1$ï¼Œåˆ™è¯¥å¯„å­˜å™¨å¤„äºåæµ‹çŠ¶æ€ï¼š

$$\left( \sqrt{\frac{1}{\sum_{j = 0}^{N - 1}{{|b_{j}|}^{2}/{|\lambda_{j}|}^{2}}}} \right)\sum_{j = 0}^{N - 1}{b_{j}\left| 0 \right\rangle_{n_{l}}\left| u_{j} \right\rangle_{n_{b}}}$$

ç›¸å½“äºå½’ä¸€åŒ–å› å­å¯¹åº”äºç›¸åº”çš„è§£ã€‚

6\.
åº”ç”¨ä¸€ä¸ªå¯è§‚æµ‹$M$æ¥è®¡ç®—$F\left( x \right) â‰” \left\langle x \right|M\left| x \right\rangle$ã€‚

##### C. HHLä¸­çš„é‡å­ç›¸ä½ä¼°è®¡

é‡å­ç›¸ä½ä¼°è®¡å·²åœ¨ç¬¬3ç« è¯¦ç»†è®¨è®ºè¿‡äº†ã€‚ç„¶è€Œï¼Œç”±äºè¿™ä¸ªé‡å­è¿‡ç¨‹æ˜¯HHLç®—æ³•çš„æ ¸å¿ƒæ‰€åœ¨ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ­¤å›é¡¾ä¸€ä¸‹å…¶å®šä¹‰ã€‚å¤§è‡´è¯´æ¥ï¼Œé‡å­ç›¸ä½ä¼°è®¡æ˜¯åœ¨ç»™å®šæœ¬å¾å‘é‡ä¸º$\left| \psi \right\rangle_{m}$ä»¥åŠæœ¬å¾å€¼ä¸º$e^{2\pi i\theta}$çš„ä¸€ä¸ªå¹ºæ­£å˜æ¢$U$ä¸­æ‰¾å‡º$\theta$çš„è¿‡ç¨‹ã€‚æˆ‘ä»¬å¯ä»¥æ­£å¼å®šä¹‰å¦‚ä¸‹ã€‚

**å®šä¹‰ï¼š**ä»¤$U \in \mathbb{C}^{2^{m} \times 2^{m}}$æ˜¯ä¸€ä¸ªå¹ºæ­£çŸ©é˜µï¼Œä¸”ä»¤$\left| \psi \right\rangle_{m} \in \mathbb{C}^{2^{m}}$æ˜¯æ‰€å¯¹åº”æœ¬å¾å€¼$e^{2\pi i\theta}$çš„æœ¬å¾å‘é‡ä¹‹ä¸€ã€‚**é‡å­ç›¸ä½ä¼°è®¡ç®—æ³•**ï¼ˆ**QPE**ï¼‰æ¥æ”¶è‡ª$U$çš„U-gateä»¥åŠæ€$\left| 0 \right\rangle_{n}\left| \psi \right\rangle_{m}$ä½œä¸ºè¾“å…¥å¹¶è¿”å›æ€$\left| \widetilde{\theta} \right\rangle_{n}\left| \psi \right\rangle_{m}$ã€‚æ­¤å¤„çš„$\widetilde{\theta}$è¡¨ç¤ºå¯¹$2^{n}\theta$çš„äºŒè¿›åˆ¶è¿‘ä¼¼ï¼Œä¸‹æ ‡$n$è¡¨ç¤ºæˆªæ–­è‡³$n$ä½ã€‚

$$QPE(U,\left| 0 \right\rangle_{n}\left| \psi \right\rangle_{m}) = \left| \widetilde{\theta} \right\rangle_{n}\left| \psi \right\rangle_{m}$$

å¯¹äºHHL,æˆ‘ä»¬å°†ä½¿ç”¨$U = e^{\text{iAt}}$çš„QPEï¼Œå…¶ä¸­$A$æ˜¯ä¸æˆ‘ä»¬è¦æ±‚è§£çš„æ–¹ç¨‹ç»„å…³è”çš„çŸ©é˜µã€‚åœ¨æœ¬ä¾‹ä¸­ï¼š

$$e^{\text{iAt}} = \sum_{j = 0}^{N - 1}{e^{i\lambda_{j}t}\left| u_{j} \right\rangle\left\langle u_{j} \right|}$$

å› æ­¤ï¼Œå¯¹äºæ‹¥æœ‰æœ¬å¾å€¼ä¸º$e^{i\lambda_{j}t}$çš„æœ¬å¾å‘é‡$\left| u_{j} \right\rangle_{n_{b}}$ï¼ŒQPEå°†ä¼šè¾“å‡º$\left| \widetilde{\lambda_{j}} \right\rangle_{n_{l}}\left| u_{j} \right\rangle_{n_{b}}$ã€‚å…¶ä¸­$\widetilde{\lambda_{j}}$è¡¨ç¤ºå¯¹$2^{n_{l}}\frac{\lambda_{j}t}{2\pi}$çš„$n_{l}$ä½çš„äºŒè¿›åˆ¶ä¼°è®¡ã€‚å› æ­¤ï¼Œå¦‚æœæ¯ä¸ª$\lambda_{j}$éƒ½å¯ä»¥ç”¨$n_{l}$ä½ç²¾ç¡®è¡¨ç¤ºï¼š

$$QPE(e^{\text{iAt}},\sum_{j = 0}^{N - 1}{b_{j}\left| 0 \right\rangle_{n_{l}}\left| u_{j} \right\rangle_{n_{b}}}) = \sum_{j = 0}^{N - 1}{b_{j}\left| \lambda_{j} \right\rangle_{n_{l}}\left| u_{j} \right\rangle_{n_{b}}}$$

##### D. éç²¾ç¡®QPE

åœ¨ç°å®ä¸­ï¼Œåº”ç”¨QPEä¹‹åå¯„å­˜å™¨çš„é‡å­æ€è¢«åˆå§‹åŒ–ä¸ºæ€ï¼š

$$\sum_{j = 0}^{N - 1}b_{j}\left( \sum_{l = 0}^{2^{n_{l}} - 1}{\alpha_{l|j}|l\rangle_{n_{l}}} \right)|u_{j}\rangle_{n_{b}}$$

å…¶ä¸­ï¼š

$$\alpha_{l|j} = \frac{1}{2^{n_{l}}}\sum_{k = 0}^{2^{n_{l}} - 1}\left( e^{2\pi i(\frac{\lambda_{j}t}{2\pi} - \frac{l}{2^{n_{l}}})} \right)^{k}$$

è‹¥ç”¨$\overset{\sim}{\lambda_{j}}$è¡¨ç¤ºå¯¹$\lambda_{j}$çš„$n_{l}$ä½æœ€ä½³è¿‘ä¼¼ï¼Œ$1 \leq j \leq N$ã€‚ç„¶åæˆ‘ä»¬å¯ä»¥é‡æ–°æ ‡è®°$n_{l}$å¯„å­˜å™¨ï¼Œä½¿$\alpha_{l|j}$è¡¨ç¤º$|l + {\overset{\sim}{\lambda}}_{j}\rangle_{n_{l}}$çš„å¹…å€¼ï¼š

$$\alpha_{l|j}: = \frac{1}{2^{n_{l}}}\sum_{k = 0}^{2^{n_{l}} - 1}\left( e^{2\pi i(\frac{\lambda_{j}t}{2\pi} - \frac{l + \overset{\sim}{\lambda_{j}}}{2^{n_{l}}})} \right)^{k}$$

å¦‚æœæ¯ä¸€$\frac{\lambda_{j}t}{2\pi}$éƒ½èƒ½ç²¾ç¡®è¡¨ç¤ºä¸º$n_{l}$ä½äºŒè¿›åˆ¶ï¼Œé‚£ä¹ˆ$\forall j$éƒ½æœ‰$\frac{\lambda_{j}t}{2\pi} = \frac{{\overset{\sim}{\lambda}}_{j}}{2^{n_{l}}}$ã€‚å› æ­¤å¯¹äºä»»ä¸€$1 \leq j \leq N$ï¼Œåœ¨$\forall l \neq 0$æ—¶éƒ½æœ‰$\alpha_{0|j} = 1$ä»¥åŠ$\alpha_{0|j} = 0$ã€‚åªæœ‰åœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬æ‰å¯ä»¥å†™å‡ºåº”ç”¨QPEåçš„å¯„å­˜å™¨çŠ¶æ€ï¼š

$$\sum_{j = 0}^{N - 1}{b_{j}|\lambda_{j}\rangle_{n_{l}}|u_{j}\rangle_{n_{b}}}$$

å¦åˆ™$|\alpha_{0|j}|$ä¼šå¾ˆå¤§ï¼Œå½“ä¸”ä»…å½“$\frac{\lambda_{j}t}{2\pi} \approx \frac{l + {\overset{\sim}{\lambda}}_{j}}{2^{n_{l}}}$ï¼Œæ­¤æ—¶å¯„å­˜å™¨çš„çŠ¶æ€ä¸ºï¼š

$$\sum_{j = 0}^{N - 1}{}\sum_{l = 0}^{2^{n_{l}} - 1}{\alpha_{l|j}b_{j}|l\rangle_{n_{l}}|u_{j}\rangle_{n_{b}}}$$

#### 3. ç¤ºä¾‹ï¼š4-é‡å­æ¯”ç‰¹HHL

è®©æˆ‘ä»¬ä»¥ç®€ä»‹ä¸­çš„ä¸€ä¸ªå°ä¾‹å­æ¥è¯´æ˜è¿™ä¸€ç®—æ³•ã€‚è¯¥ç¤ºä¾‹ä¸ºï¼š

$$A = \begin{pmatrix}
1 & - 1/3 \\
 - 1/3 & 1 \\
\end{pmatrix}\ \text{å’Œ}\text{\ }|b\rangle = \begin{pmatrix}
1 \\
0 \\
\end{pmatrix}$$

æˆ‘ä»¬å°†ä½¿ç”¨$n_{b} = 1$ä¸ªé‡å­æ¯”ç‰¹æ¥è¡¨ç¤º$\left| b \right\rangle$ä»¥åŠä¹‹åçš„è§£$\left| x \right\rangle$ï¼Œ$n_{l} = 2$ä¸ªé‡å­æ¯”ç‰¹å­˜å‚¨æœ¬å¾å€¼çš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œ$1$ä¸ªè¾…åŠ©é‡å­æ¯”ç‰¹æ¥å­˜å‚¨æ˜¯å¦æœ‰æ¡ä»¶æ—‹è½¬ï¼Œå› æ­¤è¯¥ç®—æ³•æ˜¯æœ‰æ•ˆçš„ã€‚

ä¸ºäº†è¯´æ˜è¯¥ç®—æ³•ï¼Œæˆ‘ä»¬å°†ä½œå¼Šè®¡ç®—$A$çš„ç‰¹å¾å€¼ï¼Œä»¥ä¾¿èƒ½å¤Ÿé€‰æ‹©$t$ä»¥è·å¾—$n_{l}$-å¯„å­˜å™¨ä¸­è¢«é‡æ–°ç¼©æ”¾ç‰¹å¾å€¼çš„ç²¾ç¡®äºŒè¿›åˆ¶è¡¨ç¤ºã€‚ä½†æ˜¯ï¼Œè¯·è®°ä½å¯¹äºHHLç®—æ³•çš„å®ç°ï¼Œä¸éœ€è¦å…ˆå‰çš„ç‰¹å¾å€¼çŸ¥è¯†ã€‚è¯è™½å¦‚æ­¤ï¼Œç»è¿‡ç®€çŸ­çš„è®¡ç®—å°†å¾—å‡ºï¼š

$$\lambda_{1} = 2/3\ \text{å’Œ}\text{\ }\lambda_{2} = 4/3$$

å›é¡¾å‰ä¸€èŠ‚ä¸­çš„å†…å®¹æˆ‘ä»¬å¾—çŸ¥QPEå°†ä¼šè¾“å‡º$n_{l}$ä½ï¼ˆæœ¬ç¤ºä¾‹ä¸­ä¸º$2$ä½ï¼‰å¯¹äº$\frac{\lambda_{j}t}{2\pi}$çš„äºŒè¿›åˆ¶è¿‘ä¼¼ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬è®¾

$$t = 2\pi \cdot \frac{3}{8}$$

é‚£ä¹ˆQPEä¼šç»™å‡ºçš„$2$ä½äºŒè¿›åˆ¶çš„è¿‘ä¼¼ä¸ºï¼š

$$\frac{\lambda_{1}t}{2\pi} = 1/4\ \text{å’Œ}\text{\ }\frac{\lambda_{2}t}{2\pi} = 1/2$$

åˆ†åˆ«å¯¹åº”äºï¼š

$$|01\rangle_{n_{l}}\text{\ }\text{å’Œ}\text{\ }|10\rangle_{n_{l}}$$

æ­¤æ—¶çš„æœ¬å¾å‘é‡åˆ†åˆ«ä¸ºï¼š

$$|u_{1}\rangle = (\begin{matrix}
1 \\
 - 1 \\
\end{matrix})\ \text{å’Œ}\text{\ }|u_{2}\rangle = (\begin{matrix}
1 \\
1 \\
\end{matrix})$$

[å†æ¬¡å¼ºè°ƒå¯¹äºHHLçš„å®ç°ä¸éœ€è¦è®¡ç®—æœ¬å¾å‘é‡ã€‚]{.ul}å®é™…ä¸Šï¼Œç»´æ•°ä¸º$N$çš„ä¸€èˆ¬å„ç±³çŸ©é˜µ$A$æœ€å¤šå¯ä»¥å…·æœ‰$N$ä¸ªä¸åŒçš„æœ¬å¾å€¼ï¼Œå› æ­¤è®¡ç®—è¿‡ç¨‹å°†èŠ±è´¹$\mathcal{O(}N)$çš„æ—¶é—´ï¼Œé‡å­è®¡ç®—çš„ä¼˜åŠ¿å°±ä¼šä¸§å¤±ã€‚

ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å°†$|b\rangle$å†™åœ¨$A$çš„æœ¬å¾åŸºä¸Šï¼š

$$|b\rangle_{n_{b}} = \sum_{j = 1}^{2}{\frac{1}{\sqrt{2}}|u_{j}\rangle_{n_{b}}}$$

è‡³æ­¤æˆ‘ä»¬å·²ç»ä¸ºç»å†HHLç®—æ³•çš„ä¸åŒæ­¥éª¤åšå¥½äº†å‡†å¤‡ã€‚

1\. å› ä¸º$|b\rangle = |0\rangle$ï¼Œæ‰€ä»¥æœ¬ä¾‹ä¸­çš„çŠ¶æ€è®¾ç½®å¾ˆç®€å•ã€‚

2\. åº”ç”¨QPEä¼šç”Ÿæˆï¼š

$$\frac{1}{\sqrt{2}}|01\rangle|u_{1}\rangle + \frac{1}{\sqrt{2}}|10\rangle|u_{2}\rangle$$

3\. $C = 3/8$çš„æ¡ä»¶æ—‹è½¬å¯æŠµæ¶ˆæœ¬å¾å€¼çš„é‡æ–°ç¼©æ”¾ï¼Œä»è€Œå¾—åˆ°ï¼š

$$\frac{1}{\sqrt{2}}|01\rangle|u_{1}\rangle\left( \sqrt{1 - \frac{(3/8)^{2}}{(1/4)^{2}}}|0\rangle + \frac{3/8}{1/4}|1\rangle \right) + \frac{1}{\sqrt{2}}|10\rangle|u_{2}\rangle\left( \sqrt{1 - \frac{(3/8)^{2}}{(1/2)^{2}}}|0\rangle + \frac{3/8}{1/2}|1\rangle \right)$$

$$= \frac{1}{\sqrt{2}}|01\rangle|u_{1}\rangle\left( \sqrt{1 - \frac{9}{4}}|0\rangle + \frac{3}{2}|1\rangle \right) + \frac{1}{\sqrt{2}}|10\rangle|u_{2}\rangle\left( \sqrt{1 - \frac{9}{16}}|0\rangle + \frac{3}{4}|1\rangle \right)$$

4\. åœ¨åº”ç”¨$\text{QPE}^{\dagger}$åï¼Œé‡å­è®¡ç®—æœºå¤„äºæ€ï¼š

$$\frac{1}{\sqrt{2}}|00\rangle|u_{1}\rangle\left( \sqrt{1 - \frac{9}{4}}|0\rangle + \frac{3}{2}|1\rangle \right) + \frac{1}{\sqrt{2}}|00\rangle|u_{2}\rangle\left( \sqrt{1 - \frac{9}{16}}|0\rangle + \frac{3}{4}|1\rangle \right)$$

5\. åœ¨è¾…åŠ©é‡å­æ¯”ç‰¹æµ‹å¾—ç»“æœä¸º$1$æ—¶ï¼ŒçŠ¶æ€ä¸ºï¼š

$$\frac{\frac{1}{\sqrt{2}}|00\rangle|u_{1}\rangle\frac{3}{2}|1\rangle + \frac{1}{\sqrt{2}}|00\rangle|u_{2}\rangle\frac{3}{4}|1\rangle}{\sqrt{45/32}}$$

ç»å¿«é€Ÿè®¡ç®—è¡¨æ˜ï¼š

$$\frac{\frac{3}{2\sqrt{2}}|u_{1}\rangle + \frac{3}{4\sqrt{2}}|u_{2}\rangle}{\sqrt{45/32}} = \frac{|x\rangle}{||x||}$$

6\.
æ­¤æ—¶æ— éœ€ä½¿ç”¨é¢å¤–çš„é‡å­é—¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥è®¡ç®—å‡º$|x|$çš„èŒƒæ•°ï¼šè‡ªä¸Šä¸€æ­¥ä¸­åœ¨è¾…åŠ©é‡å­ä½ä¸­æµ‹å¾—$1$çš„æ¦‚ç‡ã€‚

$$P\lbrack|1\rangle\rbrack = {(\frac{3}{2\sqrt{2}})}^{2} + {(\frac{3}{4\sqrt{2}})}^{2} = \frac{45}{32} = |||x\rangle||^{2}$$

#### 4. Qiskitå®ç°

è‡³æ­¤æˆ‘ä»¬å·²ç»ç”±ç¤ºä¾‹è§£æåœ°è§£å†³äº†é—®é¢˜ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¯¥ç¤ºä¾‹æ¥è¯´æ˜å¦‚ä½•åœ¨é‡å­æ¨¡æ‹Ÿå™¨å’Œå®é™…ç¡¬ä»¶ä¸Šè¿è¡ŒHHLã€‚å¯¹äºé‡å­æ¨¡æ‹Ÿå™¨ï¼ŒQiskit
Aquaå·²æä¾›äº†HHLç®—æ³•çš„å®ç°ï¼Œè¯¥ç®—æ³•è¦æ±‚çŸ©é˜µ$A$å’Œ$|b\rangle$ä½œä¸ºåŸºæœ¬è¾“å…¥ã€‚å…¶ä¸»è¦ä¼˜ç‚¹åœ¨äºå¯ä»¥é‡‡ç”¨ä¸€èˆ¬çš„å„ç±³çŸ©é˜µå’Œä»»æ„åˆå§‹çŠ¶æ€ä½œä¸ºè¾“å…¥ã€‚è¿™æ„å‘³ç€è¯¥ç®—æ³•æ˜¯ä¸ºé€šç”¨ç›®çš„è€Œè®¾è®¡ï¼Œå¹¶æœªé’ˆå¯¹ç‰¹å®šé—®é¢˜åœ°ä¼˜åŒ–å›è·¯ï¼Œå¦‚æœæ‚¨åœ°ç›®æ ‡æ˜¯åœ¨ç°æœ‰çš„å®é™…ç¡¬ä»¶ä¸Šè¿è¡Œè¯¥å›è·¯ï¼Œè¿™å°±æœ‰é—®é¢˜äº†ã€‚åœ¨æ’°å†™æœ¬æ–‡æ—¶ï¼Œç°æœ‰çš„é‡å­è®¡ç®—æœºå™ªå£°å¾ˆå¤§ï¼Œåªèƒ½è¿è¡Œå°å‹å›è·¯ã€‚å› æ­¤ï¼Œåœ¨ç¬¬4.BèŠ‚ä¸­å°†ä¼šçœ‹åˆ°ä¸€ä¸ªå·²ä¼˜åŒ–çš„å›è·¯ï¼Œè¯¥å›è·¯å¯ç”¨äºç¤ºä¾‹æ‰€å±çš„ä¸€ç±»é—®é¢˜ï¼ŒåŒæ—¶æåŠäº†å¤„ç†é‡å­è®¡ç®—æœºå™ªå£°çš„ç°æœ‰ç¨‹åºã€‚

##### Aï¼åœ¨æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡ŒHHLï¼šä¸€èˆ¬æ–¹æ³•

è¦è¿è¡ŒQiskit
Aquaæä¾›çš„HHLç®—æ³•ï¼Œåªéœ€å¯¼å…¥æ­£ç¡®çš„æ¨¡å—å¹¶è®¾ç½®å¦‚ä¸‹å‚æ•°ã€‚åœ¨ä¸Šæ–‡ä¸­å¯è¿è¡Œçš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬è®¾ç½®å“ˆå¯†é¡¿æ¨¡æ‹Ÿçš„æ—¶é—´ä¸º$t = 2\pi \cdot \frac{3}{8}$ï¼Œç„¶è€Œæˆ‘ä»¬å°†ä¼šåœ¨ä¸è®¾ç½®æ­¤å‚æ•°çš„æƒ…å†µä¸‹è¿è¡Œæ¨¡æ‹Ÿï¼Œä»¥è¡¨æ˜å¯¹äºæœ¬å¾å€¼çš„äº†è§£å¹¶éå¿…é¡»ã€‚è™½ç„¶å¦‚æ­¤ï¼Œå¦‚æœçŸ©é˜µæœ‰ä¸€äº›å¯èƒ½ä¼šè·å¾—æœ¬å¾å€¼ä¿¡æ¯çš„ç»“æ„ï¼Œå°±å¯ä»¥ä½¿ç”¨å®ƒæ¥é€‰æ‹©ä¸€ä¸ªåˆé€‚çš„$t$ï¼Œä»¥æé«˜HHLæ‰€è¿”å›è§£çš„å‡†ç¡®æ€§ã€‚è¿è¡Œç®—æ³•æ—¶è®¾ç½®æ—¶é—´$t = 2\pi \cdot \frac{3}{8}$ï¼Œå¦‚æœæ“ä½œæ­£ç¡®åˆ™è§£çš„ä¿çœŸåº¦åº”ä¸º$1$ã€‚

> from qiskit import Aer
>
> from qiskit.circuit.library import QFT
>
> from qiskit.aqua import QuantumInstance, aqua_globals
>
> from qiskit.quantum_info import state_fidelity
>
> from qiskit.aqua.algorithms import HHL, NumPyLSsolver
>
> from qiskit.aqua.components.eigs import EigsQPE
>
> from qiskit.aqua.components.reciprocals import LookupRotation
>
> from qiskit.aqua.operators import MatrixOperator
>
> from qiskit.aqua.components.initial_states import Custom
>
> import numpy as np
>
> def create_eigs(matrix, num_ancillae, num_time_slices,
> negative_evals):
>
> ne_qfts = \[None, None\]
>
> if negative_evals:
>
> num_ancillae += 1
>
> ne_qfts = \[QFT(num_ancillae - 1), QFT(num_ancillae - 1).inverse()\]
>
> return EigsQPE(MatrixOperator(matrix=matrix),
>
> QFT(num_ancillae).inverse(),
>
> num_time_slices=num_time_slices,
>
> num_ancillae=num_ancillae,
>
> expansion_mode=\'suzuki\',
>
> expansion_order=2,
>
> evo_time=None, \# This is t, can set to: np.pi\*3/4
>
> negative_evals=negative_evals,
>
> ne_qfts=ne_qfts)

ä¸‹é¢çš„å‡½æ•°ç”¨äºè®¡ç®—HHLç®—æ³•è¿”å›è§£çš„ä¿çœŸåº¦ã€‚

> def fidelity(hhl, ref):
>
> solution_hhl_normed = hhl / np.linalg.norm(hhl)
>
> solution_ref_normed = ref / np.linalg.norm(ref)
>
> fidelity = state_fidelity(solution_hhl_normed, solution_ref_normed)
>
> print(\"Fidelity:\\t\\t %f\" % fidelity)
>
> matrix = \[\[1, -1/3\], \[-1/3, 1\]\]
>
> vector = \[1, 0\]
>
> orig_size = len(vector)
>
> matrix, vector, truncate_powerdim, truncate_hermitian =
> HHL.matrix_resize(matrix, vector)
>
> \# Initialize eigenvalue finding module
>
> eigs = create_eigs(matrix, 3, 50, False)
>
> num_q, num_a = eigs.get_register_sizes()
>
> \# Initialize initial state module
>
> init_state = Custom(num_q, state_vector=vector)
>
> \# Initialize reciprocal rotation module
>
> reci = LookupRotation(negative_evals=eigs.\_negative_evals,
> evo_time=eigs.\_evo_time)
>
> algo = HHL(matrix, vector, truncate_powerdim, truncate_hermitian,
> eigs,
>
> init_state, reci, num_q, num_a, orig_size)

é€‰æ‹©$t = 2\pi \cdot \frac{3}{8}$çš„ç†ç”±æ˜¯é‡æ–°ç¼©æ”¾çš„æœ¬å¾å€¼å¯ä»¥ç”¨$2$ä¸ªäºŒè¿›åˆ¶ä½ç²¾ç¡®è¡¨ç¤ºã€‚ç”±äºç°åœ¨ä¸æ˜¯è¿™ç§æƒ…å†µï¼Œå› æ­¤å°†æ˜¯è¿‘ä¼¼è¡¨ç¤ºï¼Œå› æ­¤QPEä¸ç²¾ç¡®ï¼Œæ‰€è¿”å›çš„è§£ä¹Ÿå°†æ˜¯è¿‘ä¼¼è§£ã€‚

> result =
> algo.run(QuantumInstance(Aer.get_backend(\'statevector_simulator\')))
>
> print(\"Solution:\\t\\t\", np.round(result\[\'solution\'\], 5))
>
> result_ref = NumPyLSsolver(matrix, vector).run()
>
> print(\"Classical Solution:\\t\", np.round(result_ref\[\'solution\'\],
> 5))
>
> print(\"Probability:\\t\\t %f\" % result\[\'probability_result\'\])
>
> fidelity(result\[\'solution\'\], result_ref\[\'solution\'\])
>
> è¾“å‡ºï¼š
>
> Solution: \[1.13586-0.j 0.40896+0.j\]
>
> Classical Solution: \[1.125 0.375\]
>
> Probability: 0.056291
>
> Fidelity: 0.999432

æˆ‘ä»¬å¯ä»¥æ‰“å°å‡ºç®—æ³•ä½¿ç”¨çš„èµ„æºã€‚å…¶ä¸­æ·±åº¦æ˜¯æ–½åŠ åˆ°å•ä¸ªé‡å­æ¯”ç‰¹ä¸Šæœ€å¤§é‡å­é—¨æ•°é‡ï¼Œè€Œå®½åº¦å®šä¹‰ä¸ºæ‰€éœ€çš„é‡å­æ¯”ç‰¹æ•°é‡ã€‚æˆ‘ä»¬è¿˜å°†æ‰“å°å‡ºCNOTçš„æ•°é‡ï¼Œå› ä¸ºè¯¥æ•°é‡å’Œå®½åº¦å¯ä»¥å¾ˆå¥½åœ°è¯´æ˜åœ¨å½“å‰å®é™…ç¡¬ä»¶ä¸Šè¿è¡Œè¿™ä¸€å›è·¯æ˜¯å¦å¯è¡Œã€‚

> print(\"circuit_width:\\t\", result\[\'circuit_info\'\]\[\'width\'\])
>
> print(\"circuit_depth:\\t\", result\[\'circuit_info\'\]\[\'depth\'\])
>
> print(\"CNOT gates:\\t\",
> result\[\'circuit_info\'\]\[\'operations\'\]\[\'cx\'\])
>
> è¾“å‡ºï¼š
>
> circuit_width: 7
>
> circuit_depth: 102
>
> CNOT gates: 54

##### B. åœ¨çœŸå®è®¾å¤‡ä¸Šè¿è¡ŒHHLï¼šä¼˜åŒ–ç¤ºä¾‹

ä¸Šä¸€èŠ‚ä¸­æˆ‘ä»¬è¿è¡Œäº†Qiskitä¸­æä¾›çš„æ ‡å‡†ç®—æ³•ï¼Œå¹¶çœ‹åˆ°å…¶ä½¿ç”¨äº†$7$ä¸ªé‡å­æ¯”ç‰¹ï¼Œæ·±åº¦ä¸º$102$ä¸ªé‡å­é—¨ï¼Œæ€»å…±éœ€è¦$54$ä¸ªCNOTé—¨ã€‚è¿™äº›æ•°é‡å¯¹äºå½“å‰å¯ç”¨çš„ç¡¬ä»¶ä¸å¯è¡Œï¼Œå› æ­¤éœ€è¦ç¼©å‡è¿™äº›æ•°é‡ã€‚ç›®æ ‡æ˜¯å°†CNOTçš„æ•°é‡å‡å°‘$5$å€ï¼Œå› å…¶çš„ä¿çœŸåº¦æ¯”å•ä¸ªé‡å­æ¯”ç‰¹é—¨å·®ã€‚æ­¤å¤–ï¼Œæ­£å¦‚é—®é¢˜çš„åŸå§‹è¯´æ˜ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å°†é‡å­æ¯”ç‰¹çš„æ•°é‡å‡å°‘åˆ°$4$ä¸ªï¼šQiskitçš„æ–¹æ³•æ˜¯ä¸ºè§£å†³ä¸€èˆ¬é—®é¢˜è€Œç¼–å†™çš„ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆéœ€è¦$3$ä¸ªé¢å¤–è¾…åŠ©é‡å­æ¯”ç‰¹çš„åŸå› ã€‚

ç„¶è€Œï¼Œä»…ä»…å‡å°‘é‡å­é—¨å’Œé‡å­æ¯”ç‰¹çš„æ•°é‡å¹¶ä¸èƒ½å¾ˆå¥½åœ°è¿‘ä¼¼å®é™…ç¡¬ä»¶ä¸Šçš„è§£ã€‚å…¶åŸå› ä¸ºå­˜åœ¨ä¸¤ä¸ªè¯¯å·®çš„æ¥æºï¼šè¿è¡Œç”µè·¯å’Œè¯»å–æ—¶å‘ç”Ÿçš„è¯¯å·®ã€‚

Qiskitæä¾›äº†ä¸€ä¸ªæ¨¡å—ï¼Œå¯é€šè¿‡å•ç‹¬å‡†å¤‡å’Œæµ‹é‡æ‰€æœ‰åŸºæ€æ¥å‡å°‘è¯»å–è¯¯å·®ï¼Œè¯¦ç»†å¤„ç†æ–¹æ³•è¯·å‚é˜…Dewesç­‰äººçš„è®ºæ–‡^\[3\]^ã€‚ä¸ºäº†å¤„ç†å›è·¯è¿è¡ŒæœŸé—´å‘ç”Ÿçš„è¯¯å·®ï¼Œå¯ä»¥ç”¨Richardsonå¤–æ¨æ³•å°†å›è·¯è¿è¡Œä¸‰æ¬¡ï¼ŒæœŸé—´æ¯ä¸ªCNOTé—¨åˆ†åˆ«æ›¿æ¢ä¸º$1$ã€$3$å’Œ$5$ä¸ªCNOTé—¨ï¼Œå¯å°†è¯¯å·®å‡å°‘è‡³æ— é™è¶‹è¿‘é›¶^\[4\]^ã€‚è¿™ä¸€æƒ³æ³•æ˜¯ç†è®ºä¸Šä¸‰ä¸ªå›è·¯åº”è¯¥äº§ç”Ÿç›¸åŒçš„ç»“æœï¼Œä½†åœ¨å®é™…çš„ç¡¬ä»¶ä¸­æ·»åŠ CNOTæ„å‘³ç€æ”¾å¤§è¯¯å·®ã€‚æ—¢ç„¶æˆ‘ä»¬çŸ¥é“å·²ç»è·å¾—äº†è¯¯å·®æ”¾å¤§åçš„ç»“æœï¼Œå¹¶ä¸”å¯ä»¥ä¼°è®¡æ¯ç§æƒ…å†µä¸‹è¯¯å·®æ”¾å¤§äº†å¤šå°‘ï¼Œé‚£ä¹ˆå°±å¯ä»¥é€šè¿‡é‡æ–°ç»„åˆè¿™äº›æ•°é‡æ¥å¾—åˆ°ä¸€ä¸ªæ–°çš„ç»“æœï¼Œè¿™ä¸€ç»“æœæ¯”ä»¥å‰å¾—åˆ°çš„ä»»ä½•å€¼éƒ½æ›´æ¥è¿‘è§£æè§£ã€‚

ä¸‹é¢æˆ‘ä»¬ç»™å‡ºäº†å¯ç”¨äºä»»ä½•å½¢å¼é—®é¢˜çš„ä¼˜åŒ–å›è·¯ï¼š

$$A = \begin{pmatrix}
a & b \\
b & a \\
\end{pmatrix}\text{å’Œ}\text{\ }\left| b \right\rangle = \begin{pmatrix}
\text{co}s\left( \theta \right) \\
\text{si}n\left( \theta \right) \\
\end{pmatrix}ï¼Œå…¶ä¸­a,b,\theta \in \mathbb{R}$$

ä¸‹é¢çš„ä¼˜åŒ–æå–è‡ªä¸‰å¯¹è§’å¯¹ç§°çŸ©é˜µçš„HHLå·¥ä½œ^\[\[5\]\]^ï¼Œè¿™ä¸€ç‰¹æ®Šçš„å›è·¯é€šè¿‡UniversalQCompilerè½¯ä»¶å¯¼å‡º^\[\[6\]\](\#qcompiler)^ã€‚

> from qiskit import QuantumRegister, QuantumCircuit
>
> import numpy as np
>
> t = 2 \# This is not optimal; As an exercise, set this to the
>
> \# value that will get the best results. See section 8 for solution.
>
> nqubits = 4 \# Total number of qubits
>
> nb = 1 \# Number of qubits representing the solution
>
> nl = 2 \# Number of qubits representing the eigenvalues
>
> theta = 0 \# Angle defining \|b\>
>
> a = 1 \# Matrix diagonal
>
> b = -1/3 \# Matrix off-diagonal
>
> \# Initialise the quantum and classical registers
>
> qr = QuantumRegister(nqubits)
>
> \# Create a Quantum Circuit
>
> qc = QuantumCircuit(qr)
>
> qrb = qr\[0:nb\]
>
> qrl = qr\[nb:nb+nl\]
>
> qra = qr\[nb+nl:nb+nl+1\]
>
> \# State preparation.
>
> qc.ry(2\*theta, qrb\[0\])
>
> \# QPE with e\^{iAt}
>
> for qu in qrl:
>
> qc.h(qu)
>
> qc.u1(a\*t, qrl\[0\])
>
> qc.u1(a\*t\*2, qrl\[1\])
>
> qc.u3(b\*t, -np.pi/2, np.pi/2, qrb\[0\])
>
> \# Controlled e\^{iAt} on \\lambda\_{1}:
>
> params=b\*t
>
> qc.u1(np.pi/2,qrb\[0\])
>
> qc.cx(qrl\[0\],qrb\[0\])
>
> qc.ry(params,qrb\[0\])
>
> qc.cx(qrl\[0\],qrb\[0\])
>
> qc.ry(-params,qrb\[0\])
>
> qc.u1(3\*np.pi/2,qrb\[0\])
>
> \# Controlled e\^{2iAt} on \\lambda\_{2}:
>
> params = b\*t\*2
>
> qc.u1(np.pi/2,qrb\[0\])
>
> qc.cx(qrl\[1\],qrb\[0\])
>
> qc.ry(params,qrb\[0\])
>
> qc.cx(qrl\[1\],qrb\[0\])
>
> qc.ry(-params,qrb\[0\])
>
> qc.u1(3\*np.pi/2,qrb\[0\])
>
> \# Inverse QFT
>
> qc.h(qrl\[1\])
>
> qc.rz(-np.pi/4,qrl\[1\])
>
> qc.cx(qrl\[0\],qrl\[1\])
>
> qc.rz(np.pi/4,qrl\[1\])
>
> qc.cx(qrl\[0\],qrl\[1\])
>
> qc.rz(-np.pi/4,qrl\[0\])
>
> qc.h(qrl\[0\])
>
> \# Eigenvalue rotation
>
> t1=(-np.pi +np.pi/3 - 2\*np.arcsin(1/3))/4
>
> t2=(-np.pi -np.pi/3 + 2\*np.arcsin(1/3))/4
>
> t3=(np.pi -np.pi/3 - 2\*np.arcsin(1/3))/4
>
> t4=(np.pi +np.pi/3 + 2\*np.arcsin(1/3))/4
>
> qc.cx(qrl\[1\],qra\[0\])
>
> qc.ry(t1,qra\[0\])
>
> qc.cx(qrl\[0\],qra\[0\])
>
> qc.ry(t2,qra\[0\])
>
> qc.cx(qrl\[1\],qra\[0\])
>
> qc.ry(t3,qra\[0\])
>
> qc.cx(qrl\[0\],qra\[0\])
>
> qc.ry(t4,qra\[0\])
>
> qc.measure_all()
>
> print(\"Depth: %i\" % qc.depth())
>
> print(\"CNOTS: %i\" % qc.count_ops()\[\'cx\'\])
>
> qc.draw(fold=100)
>
> è¾“å‡ºï¼š
>
> Depth: 26
>
> CNOTS: 10

![](pics/media/image282.png)

ä¸‹é¢çš„ä»£ç å°†æˆ‘ä»¬çš„å›è·¯ã€çœŸæ­£çš„ç¡¬ä»¶åç«¯å’Œæƒ³è¦ä½¿ç”¨çš„é‡å­æ¯”ç‰¹é›†ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¿”å›å¯ä»¥åœ¨æŒ‡å®šè®¾å¤‡ä¸Šè¿è¡Œçš„å®ä¾‹ã€‚ç”¨$3$ä¸ªå’Œ$5$ä¸ªCNOTåˆ›å»ºçš„ç”µè·¯æ˜¯ç›¸åŒçš„ï¼Œä½†æ˜¯éœ€è¦ç”¨æ­£ç¡®çš„é‡å­å›è·¯è°ƒç”¨transpileæ–¹æ³•ã€‚

çœŸå®çš„ç¡¬ä»¶è®¾å¤‡éœ€è¦å®šæœŸé‡æ–°æ ¡å‡†ï¼Œç‰¹å®šçš„é‡å­æ¯”ç‰¹æˆ–é—¨çš„ä¿çœŸåº¦ä¼šéšç€æ—¶é—´è€Œæ”¹å˜ã€‚æ­¤å¤–ï¼Œä¸åŒçš„èŠ¯ç‰‡æœ‰ä¸åŒçš„è”ç»“åº¦ã€‚å¦‚æœå°è¯•è¿è¡Œä¸€ä¸ªå›è·¯ï¼Œåœ¨æ²¡æœ‰è¿æ¥åˆ°æŒ‡å®šè®¾å¤‡ä¸Šçš„ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¹‹é—´æ‰§è¡Œä¸€ä¸ªäºŒé‡å­æ¯”ç‰¹çš„é—¨ï¼Œtranspilerå°†ä¼šæ·»åŠ äº¤æ¢é—¨ã€‚å› æ­¤åœ¨è¿è¡Œä»¥ä¸‹ä»£ç ä¹‹å‰ï¼Œæœ€å¥½å…ˆæŸ¥é˜…IBM
Q
Experienceé¡µé¢^\[\[7\]\])^ï¼Œå¹¶åœ¨ç»™å®šæ—¶é—´é€‰æ‹©ä¸€ç»„è¿æ¥æ­£ç¡®ä¸”é”™è¯¯ç‡æœ€ä½çš„é‡å­æ¯”ç‰¹ã€‚

from qiskit import execute, BasicAer, ClassicalRegister, IBMQ

from qiskit.compiler import transpile

from qiskit.ignis.mitigation.measurement import (complete_meas_cal, \#
Measurement error mitigation functions

CompleteMeasFitter,

MeasurementFilter)

provider = IBMQ.load_account()

backend = provider.get_backend(\'ibmqx2\') \# calibrate using real
hardware

layout = \[2,3,0,4\]

chip_qubits = 5

\# Transpiled circuit for the real hardware

qc_qa_cx = transpile(qc, backend=backend, initial_layout=layout)

ä¸‹ä¸€æ­¥æ˜¯åˆ›å»ºé¢å¤–çš„ç”µè·¯æ¥å‡å°‘è¯»å‡ºé”™è¯¯^\[3\]^ã€‚

> meas_cals, state_labels = complete_meas_cal(qubit_list=layout,
> qr=QuantumRegister(chip_qubits))
>
> qcs = meas_cals + \[qc_qa_cx\]
>
> shots = 10
>
> job = execute(qcs, backend=backend, shots=shots, optimization_level=0)

ä¸‹å›¾^\[5\]^æ˜¾ç¤ºäº†åœ¨$10$ç§ä¸åŒçš„åˆå§‹çŠ¶æ€ä¸‹åœ¨å®é™…ç¡¬ä»¶ä¸Šè¿è¡Œä¸Šè¿°ç”µè·¯çš„ç»“æœã€‚$x$è½´åˆ†åˆ«ä»£è¡¨æ¯ä¸€ç§æƒ…å†µä¸‹åˆå§‹çŠ¶æ€çš„è§’åº¦$\theta$ã€‚åœ¨å‡å°‘è¯»å–è¯¯å·®ä»¥åŠä»å…·æœ‰$1$ä¸ªï¼Œ$3$ä¸ªå’Œ$5$ä¸ªCNOTå›è·¯çš„ç»“æœä¸­æ¨æ–­å‡ºè¯¥å›è·¯è¿è¡Œè¿‡ç¨‹ä¸­å‡ºç°çš„è¯¯å·®ä¹‹åå¯è·å¾—ç»“æœã€‚

![](pics/media/image283.png)

åœ¨æ²¡æœ‰è¯¯å·®å‡å°æˆ–è‡ªCNOTçš„å¤–æ¨ä¸‹çš„ç»“æœæ¯”è¾ƒï¼š

![](pics/media/image284.png)

#### 8. ç»ƒä¹ 

1\. å°†è¿è¡Œæ—¶é—´"evo_time"è®¾ç½®ä¸º$2\pi(3/8)$ï¼Œæ­¤æ—¶çš„ä¿çœŸåº¦åº”ä¸º$1$ã€‚

##### çœŸå®è®¾å¤‡ï¼š

1\. è®¾ç½®ä¼˜åŒ–ç¤ºä¾‹çš„æ—¶é—´å‚æ•°ã€‚

**è§£**

æœ€å¥½çš„ç»“æœæ˜¯è®¾ç½®$t = 2.344915690192344$ï¼Œä»¥ä¾¿å¯ä»¥ç²¾ç¡®è¡¨ç¤ºæœ€å°çš„æœ¬å¾å€¼ï¼Œå› å…¶é€†åœ¨è§£ä¸­çš„è´¡çŒ®æœ€å¤§ã€‚

2\.
ä»ç»™å®šå›è·¯"qc"ä¸º$3$å’Œ$5$ä¸ªCNOTåˆ›å»ºè½¬æ¢å›è·¯ã€‚åœ¨åˆ›å»ºå›è·¯æ—¶å¿…é¡»æ·»åŠ å±éšœï¼ˆbarrierï¼‰ï¼Œä»¥ä¾¿åœ¨ä½¿ç”¨transpile()æ–¹æ³•æ—¶ä¸ä¼šå–æ¶ˆè¿™äº›è¿ç»­çš„CNOTé—¨ã€‚

3\. åœ¨å®é™…ç¡¬ä»¶ä¸Šè¿è¡Œå›è·¯å¹¶å¯¹ç»“æœè¿›è¡ŒäºŒæ¬¡æ‹Ÿåˆä»¥å¾—å‡ºå¤–æ¨å€¼ã€‚

#### 9. å‚è€ƒæ–‡çŒ®

1\. J. R. Shewchuk. An Introduction to the Conjugate Gradient Method
Without the Agonizing Pain. Technical Report CMU-CS-94-125, School of
Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania,
March 1994.

2\. A. W. Harrow, A. Hassidim, and S. Lloyd, "Quantum algorithm for
linear systems of equations," Phys. Rev. Lett. 103.15 (2009), p. 150502.

3\. A. Dewes, F. R. Ong, V. Schmitt, R. Lauro, N. Boulant, P. Bertet, D.
Vion, and D. Esteve, "Characterization of a two-transmon processor with
individual single-shot qubit readout," Phys. Rev. Lett. 108, 057002
(2012).

4\. N. Stamatopoulos, D. J. Egger, Y. Sun, C. Zoufal, R. Iten, N. Shen,
and S. Woerner, "Option Pricing using Quantum Computers,"
arXiv:1905.02666 .

5\. A. Carrera Vazquez, A. Frisch, D. Steenken, H. S. Barowski, R.
Hiptmair, and S. Woerner, "Enhancing Quantum Linear System Algorithm by
Richardson Extrapolation," (to be included).

6\. R. Iten, O. Reardon-Smith, L. Mondada, E. Redmond, R. Singh Kohli,
R. Colbeck, "Introduction to UniversalQCompiler," arXiv:1904.01072 .

7\. https://quantum-computing.ibm.com/ .

8\. D. Bucher, J. Mueggenburg, G. Kus, I. Haide, S. Deutschle, H.
Barowski, D. Steenken, A. Frisch, \"Qiskit Aqua: Solving linear systems
of equations with the HHL algorithm\"
https://github.com/Qiskit/qiskit-tutorials/blob/master/legacy_tutorials/aqua/linear_systems_of_equations.ipynb\"

### 4.1.2 ä½¿ç”¨VQEè¿›è¡Œåˆ†å­æ¨¡æ‹Ÿ

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»å˜åˆ†é‡å­ç‰¹å¾å€¼æ±‚è§£ç®—æ³•ï¼ˆVariational Quantum
Eigensolverï¼Œ**VDE**ï¼‰ï¼Œç»™å‡ºä½¿ç”¨çš„ç†ç”±ï¼Œå¯¹å¿…è¦çš„ç†è®ºè¿›è¡Œè§£é‡Šï¼Œå¹¶å…¶åœ¨å¯»æ‰¾åˆ†å­åŸºæ€èƒ½é‡ä¸­çš„åº”ç”¨ç»™å‡ºæ¼”ç¤ºã€‚

#### å†…å®¹

1\. ç®€ä»‹

2\. é‡å­åŠ›å­¦çš„å˜åˆ†æ³•

2.1 æ•°å­¦èƒŒæ™¯

2.2 åŸºæ€è¾¹ç•Œ

3\. å˜åˆ†é‡å­ç‰¹å¾å€¼æ±‚è§£ç®—æ³•

3.1 å˜åˆ†å½¢å¼

3.2 ç®€å•å˜åˆ†å½¢å¼

3.3 å‚æ•°ä¼˜åŒ–

3.4 å•é‡å­æ¯”ç‰¹å˜åˆ†å½¢å¼

3.5 å¸¸è§å˜åˆ†å½¢å¼çš„ç»“æ„

4\. åœ¨Qiskitä¸­å®ç°VDE

4.1 åœ¨æ€å‘é‡æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡ŒVDE

4.2 åœ¨åŒ…å«å™ªå£°çš„æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡ŒVDE

5\. ç»ƒä¹ 

6\. å‚è€ƒæ–‡çŒ®

#### 1. ç®€ä»‹

åœ¨è®¸å¤šåº”ç”¨ä¸­æ‰¾å‡ºçŸ©é˜µçš„æœ€å°æœ¬å¾å€¼å¾ˆé‡è¦ã€‚ä¾‹å¦‚åœ¨åŒ–å­¦ä¸­è¡¨å¾æŸåˆ†å­å„ç±³çŸ©é˜µçš„æœ€å°æœ¬å¾å€¼æ˜¯è¯¥ç³»ç»Ÿçš„åŸºæ€èƒ½é‡ã€‚ä¹Ÿè®¸åœ¨å°†æ¥å¯ä»¥ä½¿ç”¨é‡å­ç›¸ä½ä¼°è®¡ç®—æ³•æ¥æ‰¾åˆ°æœ€å°æœ¬å¾å€¼ã€‚ç„¶è€Œï¼Œå…¶åœ¨æœ‰ç”¨é—®é¢˜ä¸Šçš„å®ç°æ‰€è¦æ±‚çš„å›è·¯æ·±åº¦è¶…è¿‡äº†NISQ
eraå¯ç”¨ç¡¬ä»¶çš„æé™ã€‚å› æ­¤Peruzzoç­‰åœ¨åœ¨2014å¹´æå‡ºäº†ä½¿ç”¨å¤§é‡æµ…å›è·¯ï¼ˆshallower
circuit\[1\]ï¼‰ä¼°è®¡åˆ†å­åŸºæ€èƒ½é‡çš„VDEæ–¹æ³•ã€‚

å…¶æ­£å¼çš„é™ˆè¿°ä¸ºï¼šç»™å®šä¸€ä¸ªå„ç±³çŸ©é˜µ$H$åŠå…¶æœªçŸ¥æœ€å°æœ¬å¾å€¼$\lambda_{\min}$ï¼Œä»¥åŠä¸å…¶ç›¸å…³çš„æœ¬å¾æ€$|\psi_{\min}\rangle$ï¼ŒVDEç»™å‡ºäº†$\lambda_{\min}$è¾¹ç•Œçš„ä¼°è®¡$\lambda_{\theta}$ã€‚

$$\lambda_{\min} \leq \lambda_{\theta} \equiv \langle\psi(\theta)|H|\psi(\theta)\rangle$$

å…¶ä¸­$|\psi(\theta)\rangle$æ˜¯ä¸$\lambda_{\theta}$ç›¸å…³çš„æœ¬å¾æ€ã€‚é€šè¿‡åœ¨ä»»æ„çš„å¼€å§‹æ€$|\psi\rangle$ä¸Šåº”ç”¨ä¸€ä¸ªç”±$U(\theta)$ä»£è¡¨çš„å‚æ•°åŒ–å›è·¯ï¼Œè¯¥ç®—æ³•å¯ä»¥åœ¨æ€$|\psi_{\min}\rangle$ä¸Šè·å–ä¸€ä¸ªä¼°è®¡$U(\theta)|\psi\rangle \equiv |\psi(\theta)\rangle$ã€‚è¿™ä¸€ä¼°è®¡é€šè¿‡ç»å…¸æ§åˆ¶å™¨ä¸æ–­åœ°æ”¹å˜å‚æ•°$\theta$ä»¥ä½¿$\langle\psi(\theta)|H|\psi(\theta)\rangle$çš„æœŸæœ›å€¼æœ€å°åŒ–ï¼Œä»è€Œå®ç°è¿­ä»£ä¼˜åŒ–ã€‚

#### 2. é‡å­åŠ›å­¦çš„å˜åˆ†æ³•

##### 2.1 æ•°å­¦èƒŒæ™¯

VQEæ˜¯é‡å­åŠ›å­¦å˜åˆ†æ³•çš„åº”ç”¨ã€‚ä¸ºäº†æ›´å¥½åœ°ç†è§£å˜åˆ†æ³•ï¼Œæ­¤å¤„ç»™å‡ºäº†ä¸€äº›åˆæ­¥çš„æ•°å­¦èƒŒæ™¯ã€‚çŸ©é˜µ$A$çš„æœ¬å¾å‘é‡$|\psi_{i}\rangle$åœ¨ä¸æ ‡é‡ä¹˜æ³•å¸¸æ•°ï¼ˆç‰¹å¾å€¼$\lambda_{i}$ï¼‰ç›¸ä¹˜çš„æƒ…å†µä¸‹ä¿æŒä¸å˜ã€‚

$$A|\psi_{i}\rangle = \lambda_{i}|\psi_{i}\rangle$$

æ­¤å¤–ï¼Œå½“çŸ©é˜µ$H$ç­‰äºå…¶è‡ªèº«çš„å…±è½­è½¬ç½®æ—¶å°±æ˜¯ä¸€ä¸ªå„ç±³çŸ©é˜µã€‚

$$H = H^{\dagger}$$

è°±å®šç†æŒ‡å‡ºå„ç±³çŸ©é˜µçš„æœ¬å¾å€¼å¿…ç„¶æ˜¯å®æ•°ã€‚å› æ­¤ä»»ä¸€$H$çš„æœ¬å¾å€¼éƒ½æœ‰ä¸€ä¸ªç‰¹æ€§$\lambda_{i} = \lambda_{i}^{*}$ã€‚ç”±äºä»»ä¸€æµ‹é‡çš„ç»“æœå¿…ç„¶æ˜¯å®æ•°ï¼Œæ‰€ä»¥å„ç±³çŸ©é˜µé€‚ç”¨äºæè¿°é‡å­ç³»ç»Ÿçš„å“ˆå¯†é¡¿é‡ã€‚æ­¤å¤–$H$å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$H = \sum_{i = 1}^{N}{\lambda_{i}|\psi_{i}\rangle\langle\psi_{i}|}$$

å…¶ä¸­çš„æ¯ä¸€ä¸ª$\lambda_{i}$éƒ½æ˜¯å¯¹åº”äºå…¶æœ¬å¾æ€$|\psi_{i}\rangle$çš„æœ¬å¾å€¼ã€‚æ­¤å¤–ï¼Œåœ¨ä»»æ„é‡å­æ€$|\psi\rangle$ä¸Šå¯è§‚æµ‹$H$çš„æœŸæœ›å€¼å¦‚ä¸‹ï¼š

$$\langle H\rangle_{\psi} \equiv \langle\psi|H|\psi\rangle$$

å°†$H$çš„è¡¨ç¤ºå½¢å¼æ›¿æ¢ä¸ºå…¶ç‰¹å¾å‘é‡çš„åŠ æƒå’Œ

$$\langle H\rangle_{\psi} = \langle\psi|H|\psi\rangle = \langle\psi|\left( \sum_{i = 1}^{N}{\lambda_{i}\left| \psi_{i} \right\rangle\langle\psi_{i}|} \right)\left| \psi \right\rangle$$

$$= \sum_{i = 1}^{N}{\lambda_{i}\left\langle \psi \middle| \psi_{i} \right\rangle\left\langle \psi_{i} \middle| \psi \right\rangle}$$

$$= \sum_{i = 1}^{N}{\lambda_{i}|\langle\psi_{i}|\psi\rangle|^{2}}$$

ä¸Šé¢çš„æœ€åä¸€ä¸ªç­‰å¼è¯æ˜åœ¨ä»»ä¸€çŠ¶æ€ä¸‹å¯è§‚æµ‹çš„æœŸæœ›å€¼å¯ç”¨ä¸$H$ç›¸å…³çš„æœ¬å¾å€¼ä½œä¸ºæƒé‡è¡¨ç¤ºæˆçº¿æ€§ç»„åˆã€‚è€Œä¸”çº¿æ€§ç»„åˆä¸­çš„æ¯ä¸ªæƒé‡éƒ½å¤§äºç­‰äº0ï¼Œå¦‚$|\langle\psi_{i}|\psi\rangle|^{2} \geq 0$ï¼Œæ‰€ä»¥æ˜¾ç„¶ï¼š

$$\lambda_{\min} \leq \langle H\rangle_{\psi} = \langle\psi|H|\psi\rangle = \sum_{i = 1}^{N}{\lambda_{i}|\langle\psi_{i}|\psi\rangle|^{2}}$$

ä¸Šé¢çš„ç­‰å¼å°±æ˜¯è‘—åçš„**å˜åˆ†æ³•**ï¼ˆ**variational method**,
åœ¨æŸäº›æ•™æä¸­ä¹Ÿè¢«ç§°ä¸ºå˜åˆ†åŸç†ï¼‰\[2\]ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼šä¸Šå¼è¡¨æ˜ä»»ä¸€æ³¢åŠ¨å‡½æ•°çš„æœŸæœ›å€¼å§‹ç»ˆè‡³å°‘ä¸ºä¸$H$ç›¸å…³è”çš„æœ€å°æœ¬å¾å€¼ã€‚è€Œä¸”ï¼Œæ€$|\psi_{\min}\rangle$çš„æœŸæœ›å€¼ç”±$\langle\psi_{\min}|H|\psi_{\min}\rangle = \langle\psi_{\min}|\lambda_{\min}|\psi_{\min}\rangle = \lambda_{\min}$ç»™å‡ºã€‚å› æ­¤æ­£å¦‚æ‰€æœŸæœ›$\langle H\rangle_{\psi_{\min}} = \lambda_{\min}$ã€‚

##### 2.2 åŸºæ€è¾¹ç•Œ

å½“ç”¨å„ç±³çŸ©é˜µ$H$æè¿°ä¸€ä¸ªç³»ç»Ÿçš„å“ˆå¯†é¡¿é‡æ—¶ï¼Œè¯¥ç³»ç»Ÿçš„åŸºæ€èƒ½é‡$E_{\text{gs}}$æ˜¯ä¸$H$ç›¸å…³çš„æœ€å°æœ¬å¾å€¼ã€‚é€šè¿‡ä»»æ„é€‰æ‹©ä¸€ä¸ªæ³¢åŠ¨å‡½æ•°$|\psi\rangle$ï¼ˆç§°ä¸ºansatzï¼Œã€ç‰©ã€‘æ‹Ÿè®¾ï¼ˆå¾·è¯­ï¼‰ï¼‰ä½œä¸ºè¿‘ä¼¼$|\psi_{\min}\rangle$çš„åˆå§‹çŒœæµ‹å€¼ï¼Œè®¡ç®—å…¶æœŸæœ›å€¼${\langle H\rangle}_{\psi}$ï¼Œå¹¶é€šè¿‡è¿­ä»£æ›´æ–°è¯¥æ³¢åŠ¨å‡½æ•°å¯ä»¥å¾—åˆ°å“ˆå¯†é¡¿é‡åŸºæ€èƒ½é‡çš„ä»»æ„ç´§ç•Œã€‚

#### 3. å˜åˆ†é‡å­æœ¬å¾å€¼æ±‚è§£ç®—æ³•

##### 3.1 å˜åˆ†å½¢å¼

æ”¹å˜æ‹Ÿè®¾çš„ç³»ç»Ÿæ–¹æ³•è¦æ±‚åœ¨ä¸€å°é‡å­è®¡ç®—æœºä¸Šå®ç°å˜åˆ†æ³•ã€‚VQEé€šè¿‡ä½¿ç”¨å…·æœ‰å›ºå®šå½¢å¼çš„å‚æ•°åŒ–å›è·¯æ¥å®ç°è¿™ä¸€ç‚¹ã€‚è¿™ç§å›è·¯å¸¸ç§°ä¸º*å˜åˆ†å½¢å¼*ï¼ˆvariational
formï¼‰ï¼Œå…¶ä½œç”¨å¯ä»¥ç”¨çº¿æ€§å˜æ¢$U(\theta)$è¡¨ç¤ºã€‚ä¸€ä¸ªå˜åˆ†å½¢å¼åº”ç”¨äºå¼€å§‹çŠ¶æ€$|\psi\rangle$ï¼ˆè¯¸å¦‚ï¼šçœŸç©ºæ€$|0\rangle$æˆ–Hartree-Fockæ€ï¼‰åç”Ÿæˆè¾“å‡ºçŠ¶æ€$U(\theta)|\psi\rangle \equiv |\psi(\theta)\rangle$ã€‚åœ¨$|\psi(\theta)\rangle$ä¸Šè¿­ä»£ä¼˜åŒ–çš„ç›®çš„æ˜¯ç”Ÿæˆä¸€ä¸ªæœŸæœ›å€¼$\langle\psi(\theta)|H|\psi(\theta)\rangle \approx E_{\text{gs}} \equiv \lambda_{\min}$ã€‚ç†æƒ³æƒ…å†µä¸‹,å°½ç®¡åœ¨å®è·µä¸­$|\psi(\theta)\rangle$è´´è¿‘$|\psi_{\min}\rangle$ï¼ˆå…¶ä¸­"è´´è¿‘"ç”±æ€ä¿çœŸåº¦æˆ–æ›¼å“ˆé¡¿è·ç¦»è¡¨å¾ï¼‰ï¼Œç„¶è€Œå½“äº‹å®å¹¶éå¦‚æ­¤æ—¶ä»å¯è·å¾—æœ‰ç”¨çš„$E_{\text{gs}}$è¾¹ç•Œã€‚

æ­¤å¤–ï¼Œå…·æœ‰å¤šé¡¹å¼å‚æ•°çš„å›ºå®šå˜åˆ†å½¢å¼åªèƒ½ç”ŸæˆæŒ‡æ•°å¤§å°å¸Œå°”ä¼¯ç‰¹ç©ºé—´ä¸­æ‰€æœ‰çŠ¶æ€çš„å¤šé¡¹å¼å¤§å°å­ç©ºé—´çš„å˜æ¢ã€‚å› æ­¤å­˜åœ¨å„ç§å˜åˆ†å½¢å¼ã€‚è¯¸å¦‚Ryå’ŒRyRzæ˜¯ä¸€äº›å¯å‘å¼è®¾è®¡ï¼Œå¹¶æ²¡æœ‰è€ƒè™‘ç›®æ ‡åŸŸã€‚å…¶ä»–å¦‚UCCCDï¼Œåˆ™åˆ©ç”¨é¢†åŸŸç‰¹å®šçŸ¥è¯†åŸºäºé—®é¢˜çš„ç»“æ„ç”Ÿæˆè¿‘ä¼¼å€¼ã€‚å¸¸è§çš„å˜ä½“å½¢å¼ç»“æ„å°†åœ¨æœ¬èŠ‚çš„åé¢éƒ¨åˆ†è¿›è¡Œæ›´æ·±å…¥çš„è®¨è®ºã€‚

##### 3.2 ç®€å•å˜åˆ†å½¢å¼

å½“æ„å»ºä¸€ä¸ªå˜åˆ†å½¢å¼æ—¶æˆ‘ä»¬éœ€è¦å¹³è¡¡ä¸¤ä¸ªç›¸å¯¹çš„ç›®æ ‡ã€‚åœ¨ç†æƒ³çš„æƒ…å†µä¸‹ï¼Œ$n$é‡å­æ¯”ç‰¹å˜åˆ†å½¢å¼å°†èƒ½å¤Ÿç”Ÿæˆä»»æ„å¯èƒ½çš„çŠ¶æ€$|\psi\rangle$ï¼Œå…¶ä¸­$|\psi\rangle \in \mathbb{C}^{N}$å’Œ$N = 2^{n}$ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬æƒ³è¦å˜åˆ†å½¢å¼ä½¿ç”¨å°½å¯èƒ½å°‘çš„å‚æ•°ã€‚æ­¤å¤„ï¼Œæˆ‘ä»¬ç€çœ¼äºå¯¹æ»¡è¶³ç¬¬ä¸€ä¸ªç›®æ ‡å˜åˆ†å½¢å¼çš„æ„é€ ç»™å‡ºç›´è§‚çš„è®¤è¯†ï¼Œè€Œä¸ºäº†ç®€å•èµ·è§å¿½ç•¥ç¬¬äºŒä¸ªç›®æ ‡ã€‚

å‡è®¾$n = 1$çš„æƒ…å†µã€‚ä¸€ä¸ªU3-gateæ¥æ”¶ä¸‰ä¸ªå‚æ•°$\theta$ã€$\phi$å’Œ$\lambda$ï¼Œä»¥åŠè¡¨ç¤ºå¦‚ä¸‹å˜æ¢ï¼š

$$\begin{matrix}
U3(\theta,\phi,\lambda) = \begin{pmatrix}
\cos(\frac{\theta}{2}) & - e^{\text{iÎ»}}\sin(\frac{\theta}{2}) \\
e^{\text{iÏ•}}\sin(\frac{\theta}{2}) & e^{i\lambda + i\phi}\cos(\frac{\theta}{2}) \\
\end{pmatrix} \\
\end{matrix}$$

ä¸Šè‡³å…¨å±€ç›¸ä½éƒ½å¯ä»¥é€šè¿‡é€‚å½“è®¾ç½®è¿™äº›å‚æ•°æ¥å®ç°ä»»ä½•å¯èƒ½çš„å•ä¸ªé‡å­æ¯”ç‰¹è½¬æ¢ã€‚å› æ­¤å¯¹äºå•ä¸ªé‡å­æ¯”ç‰¹çš„æƒ…å†µï¼Œå›è·¯ç»™å‡ºäº†èƒ½å¤Ÿäº§ç”Ÿä»»ä½•å¯èƒ½çŠ¶æ€çš„å˜åˆ†å½¢å¼ï¼š

![image1](pics/media/image285.png)

æ­¤å¤–ï¼Œè¿™ä¸€é€šç”¨çš„"å˜åˆ†å½¢å¼"ä»…å…·æœ‰3ä¸ªå‚æ•°ï¼Œå› æ­¤å¯ä»¥æœ‰æ•ˆåœ°è¿›è¡Œä¼˜åŒ–ã€‚å€¼å¾—å¼ºè°ƒçš„æ˜¯ï¼Œç”Ÿæˆä»»æ„çŠ¶æ€çš„èƒ½åŠ›ç¡®ä¿äº†åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­ï¼Œå˜åˆ†å½¢å¼ä¸ä¼šé™åˆ¶æ‰€å–$H$çš„æœŸæœ›å€¼æ‰€èƒ½è¾¾åˆ°çš„çŠ¶æ€é›†ã€‚ä»è€Œåœ¨ç†æƒ³æƒ…å†µä¸‹å¯ç¡®ä¿æœ€å°æœŸæœ›å€¼ä»…å—ç»å…¸ä¼˜åŒ–å™¨çš„åŠŸèƒ½é™åˆ¶ã€‚

å¯¹äºä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„æƒ…å†µï¼Œå¯èƒ½ä¼šå¾—å‡ºä¸å¹³å‡¡çš„é€šç”¨å˜åˆ†å½¢å¼ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹å¿…é¡»è€ƒè™‘ä¸¤ä¸ªç‰©ä½“çš„ç›¸äº’ä½œç”¨ä»¥åŠçº ç¼ æ‰èƒ½å®ç°é€šç”¨æ€§ã€‚æ ¹æ®Shendeç­‰äººæå‡ºçš„å·¥ä½œ\[3\]ï¼Œä»¥ä¸‹æ˜¯é€šç”¨å‚æ•°åŒ–ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„ç¤ºä¾‹ï¼š

![image2](pics/media/image286.png)

å…è®¸ç”±ä¸Šè¿°å›è·¯æ‰§è¡Œçš„å˜æ¢ç”±$U(\theta)$è¡¨ç¤ºã€‚å½“è¿›è¡Œå˜åˆ†ä¼˜åŒ–æ—¶ï¼Œåœ¨$U\left( \theta \right)\left| \psi \right\rangle \equiv \left| \psi\left( \theta \right) \right\rangle \approx \left| \psi_{\min} \right\rangle$æ—¶$H$çš„æœŸæœ›å€¼æœ€å°ã€‚é€šè¿‡å…¬å¼åŒ–ï¼Œ$U(\theta)$ä¼šè½¬å˜æˆä»»ä½•å¯èƒ½çš„çŠ¶æ€ï¼Œå› æ­¤è¿™ç§å˜åŒ–å½¢å¼å¯ä»¥åœ¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹åŸºæ€èƒ½é‡ä¸Šè·å¾—ä»»æ„ç´§å¯†è¾¹ç•Œï¼Œè€Œè¿™ä»…å—ç»å…¸ä¼˜åŒ–å™¨åŠŸèƒ½çš„é™åˆ¶ã€‚

##### 3.3 å‚æ•°ä¼˜åŒ–

ä¸€æ—¦é€‰æ‹©äº†ä¸€ç§æœ‰æ•ˆçš„å‚æ•°åŒ–å˜åˆ†å½¢å¼ï¼Œä¾æ®å˜åˆ†æ–¹æ³•å¿…é¡»å¯¹å…¶å‚æ•°è¿›è¡Œä¼˜åŒ–ï¼Œä½¿ç›®æ ‡å“ˆå¯†é¡¿é‡çš„æœŸæœ›å€¼æœ€å°ã€‚å‚æ•°ä¼˜åŒ–è¿‡ç¨‹å­˜åœ¨å„ç§æŒ‘æˆ˜ã€‚ä¾‹å¦‚é‡å­ç¡¬ä»¶å…·æœ‰å¤šç§ç±»å‹çš„å™ªå£°ï¼Œå› æ­¤ç›®æ ‡å‡½æ•°è¯„ä»·ï¼ˆèƒ½é‡è®¡ç®—ï¼‰ä¸ä¸€å®šèƒ½åæ˜ çœŸå®çš„ç›®æ ‡å‡½æ•°ã€‚æ­¤å¤–ï¼Œä¸€äº›ä¼˜åŒ–å™¨æ ¹æ®å‚æ•°é›†çš„åŸºæ•°æ‰§è¡Œè®¸å¤šç›®æ ‡å‡½æ•°è¯„ä¼°ã€‚åº”è¯¥æ ¹æ®åº”ç”¨ç¨‹åºçš„éœ€æ±‚é€‰æ‹©åˆé€‚çš„ä¼˜åŒ–å™¨ã€‚

ä¸€ç§æµè¡Œçš„ä¼˜åŒ–ç­–ç•¥æ˜¯æ¢¯åº¦ä¸‹é™ï¼ˆ*gradient
decent*ï¼‰ï¼Œå…¶æ¯ä¸ªå‚æ•°åœ¨äº§ç”Ÿæœ€å¤§å±€éƒ¨èƒ½é‡å˜åŒ–çš„æ–¹å‘ä¸Šè¿›è¡Œæ›´æ–°ã€‚å› æ­¤æ‰€æ‰§è¡Œçš„è¯„ä¼°æ•°é‡å–å†³äºéœ€è¦ä¼˜åŒ–å‚æ•°çš„æ•°é‡ã€‚è¿™ä¸€æ–¹æ³•å…è®¸ç®—æ³•åœ¨æœç´¢ç©ºé—´ä¸­å¿«é€Ÿæ‰¾åˆ°*å±€éƒ¨æœ€ä¼˜*ã€‚ä½†æ˜¯ï¼Œè¿™ç§ä¼˜åŒ–ç­–ç•¥ç»å¸¸é™·å…¥ä¸è‰¯çš„å±€éƒ¨æœ€ä¼˜çŠ¶æ€ï¼Œå¹¶ä¸”åœ¨æ‰§è¡Œçš„å›è·¯è¯„ä¼°æ•°é‡æ–¹é¢çš„è®¡ç®—å¼€é”€ç›¸å¯¹æ˜‚è´µã€‚è™½ç„¶è¿™æ˜¯ä¸€ç§ç›´è§‚çš„ä¼˜åŒ–ç­–ç•¥ï¼Œä½†ä¸å»ºè®®åœ¨VQEä¸­ä½¿ç”¨ã€‚

åŒæ­¥æ‰°åŠ¨éšæœºè¿‘ä¼¼ä¼˜åŒ–å™¨ï¼ˆ*SPSAï¼šSimultaneous Perturbation Stochastic
Approximation
optimizer*ï¼‰é€‚ç”¨äºä¼˜åŒ–å™ªå£°ç›®æ ‡å‡½æ•°ã€‚SPSAä»…éœ€ä¸¤æ¬¡æµ‹é‡å³å¯è¿‘ä¼¼ç›®æ ‡å‡½æ•°çš„æ¢¯åº¦ã€‚æ­¤æ–¹æ³•æ˜¯é€šè¿‡ä»¥éšæœºæ–¹å¼åŒæ­¥æ‰°åŠ¨æ‰€æœ‰å‚æ•°æ¥å®ç°çš„ï¼Œè¿™ä¸æ¯ä¸ªå‚æ•°è¢«ç‹¬ç«‹æ‰°åŠ¨çš„æ¢¯åº¦ä¸‹é™ç›¸åã€‚åœ¨åŒ…å«å™ªå£°çš„æ¨¡æ‹Ÿå™¨æˆ–å®é™…ç¡¬ä»¶ä¸­ä½¿ç”¨VQEæ—¶ï¼Œå»ºè®®å°†SPSAä½œä¸ºç»å…¸çš„ä¼˜åŒ–å™¨ã€‚

å½“ä»£ä»·å‡½æ•°çš„è¯„ä¼°ä¸­ä¸å­˜åœ¨å™ªå£°æ—¶ï¼ˆä¾‹å¦‚ï¼šå°†VQEä¸æ€å‘é‡æ¨¡æ‹Ÿå™¨ä¸€èµ·ä½¿ç”¨æ—¶ï¼‰ï¼Œå„ç§ç»å…¸ä¼˜åŒ–å™¨å¯èƒ½ä¼šæœ‰ç”¨ã€‚Qiskit
Aquaä¸­æ‰€æ”¯æŒçš„ä¸¤ä¸ªæ­¤ç±»ä¼˜åŒ–å™¨æ˜¯åºè´¯æœ€å°äºŒä¹˜è§„åˆ’ä¼˜åŒ–å™¨ï¼ˆ*SLSQPï¼šSequential
Least Squares Programming
optimizer*ï¼‰å’Œçº¿æ€§è¿‘ä¼¼ä¼˜åŒ–å™¨çš„çº¦æŸä¼˜åŒ–ï¼ˆ*COBYLAï¼šConstrained
Optimization by Linear Approximation
optimizer*ï¼‰ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯COBYLAæ¯æ¬¡ä¼˜åŒ–è¿­ä»£ä»…æ‰§è¡Œä¸€æ¬¡ç›®æ ‡å‡½æ•°è¯„ä¼°ï¼ˆå› æ­¤è¯„ä¼°æ¬¡æ•°ä¸å‚æ•°é›†çš„åŸºæ•°æ— å…³ï¼‰ã€‚å› æ­¤ï¼Œå¦‚æœç›®æ ‡å‡½æ•°æ˜¯å™ªå£°å…ç–«å¹¶ä¸”å¸Œæœ›å°†æ‰§è¡Œçš„è¯„ä¼°æ¬¡æ•°å‡è‡³æœ€å°‘ï¼Œåˆ™å»ºè®®å°è¯•ä½¿ç”¨COBYLAã€‚

##### 3.4 å•é‡å­æ¯”ç‰¹å˜åˆ†å½¢å¼

ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç®€å•çš„å•é‡å­æ¯”ç‰¹å˜åˆ†å½¢å¼æ¥è§£å†³ç±»ä¼¼äºåŸºæ€èƒ½é‡ä¼°è®¡çš„é—®é¢˜ã€‚å…·ä½“æ¥è¯´ç»™å®šä¸€ä¸ªéšæœºæ¦‚ç‡å‘é‡$\overrightarrow{x}$ï¼Œå¸Œæœ›ä¸ºå•ä¸ªé‡å­æ¯”ç‰¹å˜åˆ†å½¢å¼ç¡®å®šå¯èƒ½çš„å‚æ•°åŒ–ï¼Œä»¥ä½¿å…¶è¾“å‡ºæ¥è¿‘$\overrightarrow{x}$çš„æ¦‚ç‡åˆ†å¸ƒï¼ˆå…¶ä¸­ï¼Œç´§å¯†åº¦æ˜¯æ ¹æ®ä¸¤ä¸ªæ¦‚ç‡ä¹‹é—´çš„æ›¼å“ˆé¡¿è·ç¦»å®šä¹‰çš„å‘é‡ï¼‰ã€‚

æˆ‘ä»¬é¦–å…ˆåœ¨Pythonä¸­åˆ›å»ºéšæœºæ¦‚ç‡å‘é‡ï¼š

> import numpy as np
>
> np.random.seed(999999)
>
> target_distr = np.random.rand(2)
>
> \# We now convert the random vector into a valid probability vector
>
> target_distr /= sum(target_distr)

éšååˆ›å»ºäº†ä¸€ä¸ªä»¥å•ä¸ªU3å˜åˆ†å½¢å¼ä½œä¸ºå‚æ•°å¹¶è¿”å›ç›¸åº”çš„é‡å­å›è·¯çš„å‡½æ•°ï¼š

> from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
>
> def get_var_form(params):
>
> qr = QuantumRegister(1, name=\"q\")
>
> cr = ClassicalRegister(1, name=\'c\')
>
> qc = QuantumCircuit(qr, cr)
>
> qc.u3(params\[0\], params\[1\], params\[2\], qr\[0\])
>
> qc.measure(qr, cr\[0\])
>
> return qc

åˆ›å»ºæŒ‡å®šç›®æ ‡å‡½æ•°ï¼Œå…¶ä»¥å˜åˆ†å½¢å¼çš„å‚æ•°åˆ—è¡¨ä½œä¸ºè¾“å…¥å¹¶è¿”å›ä¸è¿™äº›å‚æ•°ç›¸å…³çš„ä»£ä»·ï¼š

> from qiskit import Aer, execute
>
> backend = Aer.get_backend(\"qasm_simulator\")
>
> NUM_SHOTS = 10000
>
> def get_probability_distribution(counts):
>
> output_distr = \[v / NUM_SHOTS for v in counts.values()\]
>
> if len(output_distr) == 1:
>
> output_distr.append(0)
>
> return output_distr
>
> def objective_function(params):
>
> \# Obtain a quantum circuit instance from the paramters
>
> qc = get_var_form(params)
>
> \# Execute the quantum circuit to obtain the probability distribution
> associated with the current parameters
>
> result = execute(qc, backend, shots=NUM_SHOTS).result()
>
> \# Obtain the counts for each measured state, and convert those counts
> into a probability vector
>
> output_distr = get_probability_distribution(result.get_counts(qc))
>
> \# Calculate the cost as the distance between the output distribution
> and the target distribution
>
> cost = sum(\[np.abs(output_distr\[i\] - target_distr\[i\]) for i in
> range(2)\])
>
> return cost

æœ€åï¼Œåˆ›å»ºCOBYLAä¼˜åŒ–å™¨çš„ä¸€ä¸ªå®ä¾‹å¹¶è¿è¡Œç®—æ³•ã€‚è¯·æ³¨æ„ï¼šæ¯æ¬¡è¿è¡Œçš„è¾“å‡ºéƒ½ä¸ä¸€æ ·ã€‚è€Œä¸”åœ¨æ¥è¿‘çš„æƒ…å†µä¸‹ï¼Œå¾—åˆ°çš„åˆ†å¸ƒå¯èƒ½ä¸ç›®æ ‡åˆ†å¸ƒå¹¶ä¸å®Œå…¨ç›¸åŒï¼Œä½†é€šè¿‡å¢åŠ æ‹æ‘„çš„æ¬¡æ•°ä¼šå¢åŠ è¾“å‡ºçš„å‡†ç¡®æ€§ã€‚

> from qiskit.aqua.components.optimizers import COBYLA
>
> \# Initialize the COBYLA optimizer
>
> optimizer = COBYLA(maxiter=500, tol=0.0001)
>
> \# Create the initial parameters (noting that our single qubit
> variational form has 3 parameters)
>
> params = np.random.rand(3)
>
> ret = optimizer.optimize(num_vars=3,
> objective_function=objective_function, initial_point=params)
>
> \# Obtain the output distribution using the final parameters
>
> qc = get_var_form(ret\[0\])
>
> counts = execute(qc, backend, shots=NUM_SHOTS).result().get_counts(qc)
>
> output_distr = get_probability_distribution(counts)
>
> print(\"Target Distribution:\", target_distr)
>
> print(\"Obtained Distribution:\", output_distr)
>
> print(\"Output Error (Manhattan Distance):\", ret\[1\])
>
> print(\"Parameters Found:\", ret\[0\])
>
> è¾“å‡ºï¼š
>
> Target Distribution: \[0.51357006 0.48642994\]
>
> Obtained Distribution: \[0.5148, 0.4852\]
>
> Output Error (Manhattan Distance): 0.009140118738839131
>
> Parameters Found: \[1.59180522 1.23579418 0.65390252\]

##### 3.5 å¸¸è§å˜åˆ†å½¢å¼çš„ç»“æ„

å¦‚å‰æ‰€è¿°ï¼Œå¤šé¡¹å¼å‚æ•°åŒ–å˜åˆ†å½¢å¼ä¸èƒ½ç”Ÿæˆä»»æ„çŠ¶æ€çš„è½¬æ¢ã€‚å˜åˆ†å½¢å¼å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼Œå–å†³äºå¦‚ä½•å¤„ç†è¿™ä¸€é™åˆ¶ã€‚ç¬¬ä¸€ç±»å˜åˆ†å½¢å¼ä½¿ç”¨é¢†åŸŸæˆ–åº”ç”¨ç‰¹å®šçŸ¥è¯†æ¥é™åˆ¶å¯èƒ½çš„è¾“å‡ºçŠ¶æ€é›†ã€‚ç¬¬äºŒç§æ–¹æ³•ä½¿ç”¨å¯å‘å¼å›è·¯è€Œä¸å¿…å…·å¤‡é¢„å…ˆçš„é¢†åŸŸæˆ–åº”ç”¨çš„ç‰¹å®šçŸ¥è¯†ã€‚

ç¬¬ä¸€ç±»å˜åˆ†å½¢å¼åˆ©ç”¨é—®é¢˜åŸŸçš„ç‰¹å¾æ¥é™åˆ¶å¯èƒ½éœ€è¦çš„è½¬æ¢é›†ã€‚ä¾‹å¦‚ï¼Œå½“è®¡ç®—ä¸€ä¸ªåˆ†å­çš„åŸºæ€èƒ½é‡æ—¶ï¼Œç³»ç»Ÿä¸­çš„ç²’å­æ•°æ˜¯é¢„å…ˆæ˜ç¡®çš„ã€‚å› æ­¤ï¼Œå¦‚æœä½¿ç”¨å‡†ç¡®ç²’å­æ•°çš„åˆå§‹çŠ¶æ€ï¼Œé€šè¿‡å°†å˜ä½“å½¢å¼é™åˆ¶ä¸ºä»…ç”Ÿæˆä¿ç•™ç²’å­çš„å˜æ¢ï¼Œå¯ä»¥å¤§å¤§å‡å°‘è·¨è¶Šæ–°å˜æ¢å­ç©ºé—´æ‰€éœ€çš„å‚æ•°æ•°é‡ã€‚äº‹å®ä¸Šï¼Œåˆ©ç”¨è€¦åˆç°‡ç†è®ºçš„ç›¸ä¼¼ä¿¡æ¯ï¼Œå˜åˆ†å½¢å¼UCCSDåœ¨ä»Hartree
FockçŠ¶æ€å¼€å§‹æ—¶ï¼Œå¯ä»¥è·å¾—éå¸¸å‡†ç¡®çš„åˆ†å­åŸºæ€èƒ½é‡ä¼°è®¡ç»“æœã€‚å¦ä¸€è¯´æ˜å¯¹é¢†åŸŸç‰¹å®šçŸ¥è¯†åˆ©ç”¨çš„ä¾‹å­æ˜¯è€ƒè™‘åœ¨çœŸå®çš„é‡å­ç¡¬ä»¶ä¸Šå¯å®ç°çš„ä¸€ç»„å›è·¯ã€‚ç°æœ‰çš„é‡å­è®¡ç®—æœºï¼Œä¾‹å¦‚åŸºäºè¶…å¯¼é‡å­æ¯”ç‰¹çš„è®¡ç®—æœºï¼Œå…¶é‡å­æ¯”ç‰¹è”ç»“åº¦æœ‰é™ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨ä»»æ„é‡å­æ¯”ç‰¹å¯¹ä¸Šå®ç°2-é‡å­æ¯”ç‰¹é—¨æ˜¯ä¸å¯èƒ½çš„(ä¸æ’å…¥äº¤æ¢é—¨)ã€‚å› æ­¤ï¼Œå˜åˆ†å½¢å¼å·²ç»è¢«æ„é€ ä¸ºç‰¹å®šçš„é‡å­è®¡ç®—æœºæ¶æ„ï¼Œå…¶ä¸­çš„å›è·¯è¢«ç‰¹åˆ«è°ƒæ•´ï¼Œä»¥ä¾¿æœ€å¤§é™åº¦åœ°åˆ©ç”¨å…ˆå¤©å¯ç”¨çš„è”ç»“åº¦å’Œé—¨çš„ä¸€ä¸ªç»™å®šçš„é‡å­è®¾å¤‡ã€‚2017å¹´æ—¶åˆ©ç”¨è¿™ç§å˜åˆ†å½¢å¼ï¼Œåœ¨IBMé‡å­è®¡ç®—æœº\[4\]ä¸ŠæˆåŠŸåœ°å®ç°äº†VQEï¼Œå…¶ä½œç”¨æ˜¯ä¼°ç®—ç±»ä¼¼BeH~2~å¤§å°åˆ†å­çš„åŸºæ€èƒ½é‡ã€‚

åœ¨ç¬¬äºŒç§æ–¹æ³•ä¸­ï¼Œå°†é‡å­é—¨åˆ†å±‚ä»¥ä¾¿å¯ä»¥åœ¨å¾ˆå®½çš„çŠ¶æ€èŒƒå›´å†…è·å¾—è‰¯å¥½çš„è¿‘ä¼¼å€¼ã€‚Qiskit
Aquaæ”¯æŒä¸‰ç§è¿™æ ·çš„å˜åˆ†å½¢å¼ï¼šRyRzã€Ryå’ŒSwapRz(æˆ‘ä»¬å°†åªè®¨è®ºå‰ä¸¤ç§)ã€‚æ‰€æœ‰è¿™äº›å˜åˆ†å½¢å¼éƒ½å¯æ¥å—å¤šä¸ªç”¨æˆ·æŒ‡å®šçš„å‚æ•°ã€‚å…¶ä¸­çš„ä¸‰ä¸ªåŸºæœ¬å‚æ•°æ˜¯ç³»ç»Ÿä¸­çš„é‡å­æ¯”ç‰¹æ•°ã€æ·±åº¦è®¾ç½®å’Œçº ç¼ è®¾ç½®ã€‚å˜åˆ†å½¢å¼çš„ä¸€ä¸ªå±‚æŒ‡å®šäº†å•ä¸ªé‡å­æ¯”ç‰¹æ—‹è½¬å’ŒCXé—¨çš„æŸç§æ¨¡å¼ã€‚æ·±åº¦è®¾ç½®è¡¨ç¤ºå˜åˆ†å½¢å¼åº”é‡å¤æ­¤æ¨¡å¼å¤šå°‘æ¬¡ã€‚é€šè¿‡å¢åŠ æ·±åº¦è®¾ç½®ï¼Œä»¥å¢åŠ å¿…é¡»ä¼˜åŒ–å‚æ•°çš„æ•°é‡ä¸ºä»£ä»·ï¼Œå˜åˆ†å½¢å¼å¯ç”Ÿæˆçš„çŠ¶æ€é›†ä¼šå¢åŠ ã€‚æœ€åï¼Œçº ç¼ è®¾ç½®é€‰æ‹©CXé—¨çš„é…ç½®å’Œéšå¼æ•°ã€‚ä¾‹å¦‚,å½“çº ç¼ è®¾ç½®æ˜¯çº¿æ€§æ—¶CXé—¨æŒ‰é¡ºåºåº”ç”¨äºç›¸é‚»çš„é‡å­æ¯”ç‰¹å¯¹ä¸Š(å› æ­¤ä¼šåœ¨æ¯ä¸€ä¸ªå±‚ä¸Šæ·»åŠ $n - 1$ä¸ªCXé—¨)ã€‚å½“çº ç¼ è®¾ç½®ä¸ºfullæ—¶ï¼ŒCXé—¨åº”ç”¨äºæ¯ä¸€å±‚ä¸­çš„æ¯ä¸€é‡å­æ¯”ç‰¹å¯¹ã€‚æ‰§è¡Œä»¥ä¸‹ä»£ç ç‰‡æ®µå¯ä»¥çœ‹åˆ°entanglement=\"full\"å’Œentanglement=\"linear\"å¯¹åº”çš„RyRzç”µè·¯:

> from qiskit.circuit.library import EfficientSU2
>
> entanglements = \[\"linear\", \"full\"\]
>
> for entanglement in entanglements:
>
> form = EfficientSU2(num_qubits=4, entanglement=entanglement)
>
> if entanglement == \"linear\":
>
> print(\"=============Linear Entanglement:=============\")
>
> else:
>
> print(\"=============Full Entanglement:=============\")
>
> \# We initialize all parameters to 0 for this demonstration
>
> display(form.draw(fold=100))
>
> print()

=============Linear Entanglement:=============

![](pics/media/image287.png)

=============Full Entanglement:=============

![](pics/media/image288.png)

å…¶ä¸­å‡è®¾å°†æ·±åº¦è®¾ç½®è®¾ç½®ä¸º$d$ã€‚ä¸”RyRzæœ‰$n \times (d + 1) \times 2$ä¸ªå‚æ•°ï¼Œçº¿æ€§çº ç¼ çš„Ryæœ‰$2n \times (d + \frac{1}{2})$ä¸ªå‚æ•°ï¼Œå…¨çº ç¼ çš„Ryæœ‰$d \times n \times \frac{(n + 1)}{2} + n$ä¸ªå‚æ•°ã€‚

#### 4. åœ¨Qiskitä¸­å®ç°VDE

æœ¬èŠ‚ä¸­æ¼”ç¤ºäº†ä½¿ç”¨ç¼–ç¨‹æ–¹æ³•å®ç°VQEã€‚Qiskit
Aquaè¿˜æ”¯æŒå£°æ˜å¼å®ç°ï¼Œä½†æ˜¯å…¶æ‰€æ­ç¤ºå…³äºåº•å±‚ç®—æ³•çš„ä¿¡æ¯è¾ƒå°‘ã€‚è¯¥ä»£ç ï¼ˆç‰¹åˆ«æ˜¯é‡å­æ¯”ç‰¹è¿ç®—ç¬¦çš„å‡†å¤‡ï¼‰åŸºäºQiskitæ•™ç¨‹å­˜å‚¨åº“ä¸­çš„ä»£ç (æˆªæ­¢2019å¹´7æœˆï¼Œå¯ä»¥åœ¨<https://github.com/Qiskit/qiskit-tutorials>ä¸­æ‰¾åˆ°)ã€‚

ä¸‹é¢çš„åº“å¿…é¡»é¢„å…ˆå¯¼å…¥ã€‚

from qiskit.aqua.algorithms import VQE, NumPyEigensolver

import matplotlib.pyplot as plt

import numpy as np

from qiskit.chemistry.components.variational_forms import UCCSD

from qiskit.chemistry.components.initial_states import HartreeFock

from qiskit.circuit.library import EfficientSU2

from qiskit.aqua.components.optimizers import COBYLA, SPSA, SLSQP

from qiskit.aqua.operators import Z2Symmetries

from qiskit import IBMQ, BasicAer, Aer

from qiskit.chemistry.drivers import PySCFDriver, UnitsType

from qiskit.chemistry import FermionicOperator

from qiskit import IBMQ

from qiskit.aqua import QuantumInstance

from qiskit.ignis.mitigation.measurement import CompleteMeasFitter

from qiskit.providers.aer.noise import NoiseModel

##### 4.1 åœ¨æ€å‘é‡æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡ŒVDE

æˆ‘ä»¬æ¼”ç¤ºäº†ä¸åŒåŸå­é—´è·ç¦»ä¸‹LiHçš„åŸºæ€èƒ½é‡çš„è®¡ç®—ã€‚åˆ†å­çš„é©±åŠ¨å¿…é¡»åœ¨æ¯ä¸€ä¸ªè¿™æ ·çš„è·ç¦»ä¸Šåˆ›å»ºã€‚è¯·æ³¨æ„ï¼šåœ¨æ­¤å®éªŒä¸­ä¸ºäº†å‡å°‘æ‰€ä½¿ç”¨çš„é‡å­æ¯”ç‰¹æ•°é‡ï¼Œæˆ‘ä»¬å†»ç»“äº†æ ¸å¿ƒå¹¶åˆ é™¤äº†ä¸¤ä¸ªæœªå ç”¨çš„è½¨é“ã€‚ç¬¬ä¸€æ­¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—åŸå­é—´è·ç¦»æœ€ä¸ºå‚æ•°å¹¶è¿”å›é€‚å½“çš„é‡å­æ¯”ç‰¹è¿ç®—ç¬¦$H$ä»¥åŠæœ‰å…³è¯¥è¿ç®—ç¬¦çš„å…¶ä»–ä¿¡æ¯ã€‚

> def get_qubit_op(dist):
>
> driver = PySCFDriver(atom=\"Li .0 .0 .0; H .0 .0 \" + str(dist),
> unit=UnitsType.ANGSTROM,
>
> charge=0, spin=0, basis=\'sto3g\')
>
> molecule = driver.run()
>
> freeze_list = \[0\]
>
> remove_list = \[-3, -2\]
>
> repulsion_energy = molecule.nuclear_repulsion_energy
>
> num_particles = molecule.num_alpha + molecule.num_beta
>
> num_spin_orbitals = molecule.num_orbitals \* 2
>
> remove_list = \[x % molecule.num_orbitals for x in remove_list\]
>
> freeze_list = \[x % molecule.num_orbitals for x in freeze_list\]
>
> remove_list = \[x - len(freeze_list) for x in remove_list\]
>
> remove_list += \[x + molecule.num_orbitals - len(freeze_list) for x in
> remove_list\]
>
> freeze_list += \[x + molecule.num_orbitals for x in freeze_list\]
>
> ferOp = FermionicOperator(h1=molecule.one_body_integrals,
> h2=molecule.two_body_integrals)
>
> ferOp, energy_shift = ferOp.fermion_mode_freezing(freeze_list)
>
> num_spin_orbitals -= len(freeze_list)
>
> num_particles -= len(freeze_list)
>
> ferOp = ferOp.fermion_mode_elimination(remove_list)
>
> num_spin_orbitals -= len(remove_list)
>
> qubitOp = ferOp.mapping(map_type=\'parity\', threshold=0.00000001)
>
> qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)
>
> shift = energy_shift + repulsion_energy
>
> return qubitOp, num_particles, num_spin_orbitals, shift

é¦–å…ˆï¼Œä½¿ç”¨é‡å­æ¯”ç‰¹ç®—ç¬¦å’Œç»å…¸ç²¾ç¡®æœ¬å¾æ±‚è§£ç®—æ³•è®¡ç®—ç²¾ç¡®çš„åŸºæ€èƒ½é‡ã€‚éšå,åˆå§‹çŠ¶æ€$|\psi\rangle$è¢«åˆ›å»º,è¿™ä¸€VQEå®ä¾‹ç”¨äºç”Ÿæˆæœ€ç»ˆçš„æ‹Ÿè®¾$\min_{\theta}(|\psi(\theta)\rangle)$ã€‚æ¯ä¸ªåŸå­é—´è·ä¸Šçš„ç²¾ç¡®ç»“æœå’ŒVQEç»“æœä¼šè¢«å‚¨å­˜èµ·æ¥ã€‚è§‚å¯Ÿç”±vqe.run(backend)\[\'energy\'\]
+
shiftæ‰€ç»™å‡ºçš„ç»“æœç­‰äºé‡$\min_{\theta}(\langle\psi(\theta)|H|\psi(\theta)\rangle)$ï¼Œå…¶ä¸­çš„æœ€å°å€¼ä¸ä¸€å®šæ˜¯å…¨å±€æœ€å°å€¼ã€‚

å½“è®¾ç½®å‚æ•°VQE(qubitOp, var_form, optimizer,
\'matrix\')åˆå§‹åŒ–VQEå®ä¾‹æ—¶ï¼Œåœ¨$\left| \psi\left( \theta \right) \right\rangle$ä¸Šçš„æœŸæœ›å€¼$H$ç”±çŸ©é˜µä¹˜æ³•ç›´æ¥è®¡ç®—å¾—å‡ºã€‚ç„¶è€Œå½“ä½¿ç”¨çœŸå®è®¾å¤‡æˆ–ç±»ä¼¼è®¾ç½®å‚æ•°ä¸ºVQE(qubitOp,
var_form, optimizer,
\'paulis\')çš„qasm_simulatorçš„çœŸå®æ¨¡æ‹Ÿå™¨æ—¶ï¼ŒæœŸæœ›å€¼çš„è®¡ç®—è¿‡ç¨‹ä¼šæ›´åŠ å¤æ‚ã€‚ä¸€ä¸ªå“ˆå¯†é¡¿é‡å¯ä»¥è¡¨ç¤ºä¸ºPauliå­—ä¸²çš„æ€»å’Œï¼Œæ¯ä¸ªPaulié¡¹ä½œç”¨åœ¨ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸Šï¼Œå¹¶ä¾æ®æ‰€ä½¿ç”¨çš„æ˜ å°„æ‰€æŒ‡å®šã€‚æ¯ä¸ªPauliå­—ä¸²éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„å›è·¯ï¼Œè¯¥å›è·¯é™„åŠ åˆ°ä¸$|\psi(a)\rangle$ç›¸å¯¹åº”çš„å›è·¯ä¸Šã€‚éšåï¼Œæ‰§è¡Œæ‰€æœ‰è¿™äº›å›è·¯å¹¶å°†æ‰€æœ‰ç»“æœç”¨äºç¡®å®š$|\psi(\theta)\rangle$ä¸Š$H$çš„æœŸæœ›å€¼ã€‚åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨çŸ©é˜µæ¨¡å¼åˆå§‹åŒ–VQEå®ä¾‹ï¼Œå› æ­¤æœŸæœ›å€¼æ˜¯é€šè¿‡çŸ©é˜µä¹˜æ³•ç›´æ¥è®¡ç®—æ‰€å¾—ã€‚

è¯·æ³¨æ„ï¼Œä¸‹é¢çš„ä»£ç ç‰‡æ®µå¯èƒ½è¦è¿è¡Œå‡ åˆ†é’Ÿæ‰èƒ½å®Œæˆã€‚

> backend = BasicAer.get_backend(\"statevector_simulator\")
>
> distances = np.arange(0.5, 4.0, 0.1)
>
> exact_energies = \[\]
>
> vqe_energies = \[\]
>
> optimizer = SLSQP(maxiter=5)
>
> for dist in distances:
>
> qubitOp, num_particles, num_spin_orbitals, shift = get_qubit_op(dist)
>
> result = NumPyEigensolver(qubitOp).run()
>
> exact_energies.append(np.real(result.eigenvalues) + shift)
>
> initial_state = HartreeFock(
>
> num_spin_orbitals,
>
> num_particles,
>
> qubit_mapping=\'parity\'
>
> )
>
> var_form = UCCSD(
>
> num_orbitals=num_spin_orbitals,
>
> num_particles=num_particles,
>
> initial_state=initial_state,
>
> qubit_mapping=\'parity\'
>
> )
>
> vqe = VQE(qubitOp, var_form, optimizer)
>
> vqe_result = np.real(vqe.run(backend)\[\'eigenvalue\'\] + shift)
>
> vqe_energies.append(vqe_result)
>
> print(\"Interatomic Distance:\", np.round(dist, 2), \"VQE Result:\",
> vqe_result, \"Exact Energy:\", exact_energies\[-1\])
>
> print(\"All energies have been calculated\")

plt.plot(distances, exact_energies, label=\"Exact Energy\")

plt.plot(distances, vqe_energies, label=\"VQE Energy\")

plt.xlabel(\'Atomic distance (Angstrom)\')

plt.ylabel(\'Energy\')

plt.legend()

plt.show()

è¾“å‡ºï¼š

![](pics/media/image289.png)

æ³¨æ„ï¼VQEç»“æœä¸ç²¾ç¡®ç»“æœéå¸¸æ¥è¿‘ï¼Œå› æ­¤ç²¾ç¡®çš„èƒ½é‡æ›²çº¿éšè—åœ¨VQEæ›²çº¿ä¸­ã€‚

##### 4.2 åœ¨åŒ…å«å™ªå£°çš„æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡ŒVDE

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å«æœ‰å™ªå£°çš„æ¨¡æ‹Ÿå™¨è®¡ç®—H~2~çš„åŸºæ€èƒ½é‡å¹¶ç¼“è§£é”™è¯¯ã€‚

é¦–å…ˆå‡†å¤‡è¡¨ç¤ºè¯¥åˆ†å­å“ˆå¯†é¡¿é‡çš„é‡å­æ¯”ç‰¹ç®—å­ï¼š

> driver = PySCFDriver(atom=\'H .0 .0 -0.3625; H .0 .0 0.3625\',
> unit=UnitsType.ANGSTROM, charge=0, spin=0, basis=\'sto3g\')
>
> molecule = driver.run()
>
> num_particles = molecule.num_alpha + molecule.num_beta
>
> qubitOp = FermionicOperator(h1=molecule.one_body_integrals,
> h2=molecule.two_body_integrals).mapping(map_type=\'parity\')
>
> qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)

ç°åœ¨ï¼Œæˆ‘ä»¬ä»IBMQæä¾›ç¨‹åºåŠ è½½è®¾å¤‡è€¦åˆæ˜ å°„å’Œå™ªå£°æ¨¡å‹ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªé‡å­å®ä¾‹ä»è€Œå¯ç”¨é”™è¯¯ç¼“è§£åŠŸèƒ½ï¼š

> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> backend = Aer.get_backend(\"qasm_simulator\")
>
> device = provider.get_backend(\"ibmq_vigo\")
>
> coupling_map = device.configuration().coupling_map
>
> noise_model = NoiseModel.from_backend(device.properties())
>
> quantum_instance = QuantumInstance(backend=backend,
>
> shots=1000,
>
> noise_model=noise_model,
>
> coupling_map=coupling_map,
>
> measurement_error_mitigation_cls=CompleteMeasFitter,
>
> cals_matrix_refresh_period=30)

æœ€åï¼Œæˆ‘ä»¬å¿…é¡»é…ç½®ä¼˜åŒ–å™¨ã€å˜åˆ†å½¢å¼å’ŒVQEå®ä¾‹ã€‚ä¸¤ä¸ªé‡å­æ¯”ç‰¹é—¨å›è·¯çš„æ·±åº¦éšç€å™ªå£°çš„å¢åŠ è€Œå¢åŠ ï¼Œæ­¤å¤„æˆ‘ä»¬ä½¿ç”¨è¯•æ¢å¼å˜åˆ†å½¢å¼(RYRZ)è€ŒéUCCSDï¼Œå› ä¸ºRYRZçš„å›è·¯æ¯”UCCSDæµ…å¾—å¤šï¼Œå¹¶ä¸”å…¶æ‰€ä½¿ç”¨çš„äºŒé‡å­ä½é—¨ä¹Ÿå°‘å¾—å¤šã€‚

è¿è¡Œä»¥ä¸‹ä»£ç å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿæ—¶é—´ã€‚

> exact_solution = NumPyEigensolver(qubitOp).run()
>
> print(\"Exact Result:\", np.real(exact_solution.eigenvalues))
>
> optimizer = SPSA(max_trials=100)
>
> var_form = EfficientSU2(qubitOp.num_qubits, entanglement=\"linear\")
>
> vqe = VQE(qubitOp, var_form, optimizer=optimizer)
>
> ret = vqe.run(quantum_instance)
>
> vqe_result = np.real(ret\[\'eigenvalue\'\])
>
> print(\"VQE Result:\", vqe_result)
>
> è¾“å‡ºï¼š
>
> Exact Result: \[-1.86712098\]
>
> VQE Result: -1.80040360007339

å½“å™ªéŸ³ç¼“è§£è¢«å¯ç”¨æ—¶ï¼Œå³ä½¿ç»“æœä¸ç¬¦åˆåŒ–å­¦ç²¾åº¦(åœ¨ç²¾ç¡®ç»“æœçš„0.0016
HartreeèŒƒå›´å†…)ï¼Œä½†ä¹Ÿç›¸å½“æ¥è¿‘ç²¾ç¡®çš„è§£å†³æ–¹æ¡ˆäº†ã€‚

#### 5. ç»ƒä¹ 

1\. ç»™å®šä¸€ä¸ªå“ˆå¯†é¡¿é‡$H$ï¼Œä¿è¯å…¶åŸºæ€æ¥è¿‘æœ€å¤§çº ç¼ nä¸ªé‡å­æ¯”ç‰¹çŠ¶æ€ã€‚
è¯´æ˜å“ªç§å˜åˆ†å½¢å¼ï¼ˆä¸€ç§æˆ–å¤šç§å½¢å¼ï¼‰å¯èƒ½æœ‰æ•ˆè€Œå‡†ç¡®åœ°å­¦ä¹ $H$çš„åŸºæ€èƒ½é‡ã€‚
æ‚¨ä¹Ÿå¯ä»¥é€šè¿‡åˆ›å»ºè‡ªå·±çš„å˜åˆ†å½¢å¼å¹¶è§£é‡Šä¸ºä½•å…¶é€‚åˆäºè¯¥å“ˆå¯†é¡¿é‡ã€‚

2.å½“ä½¿ç”¨COBYLAä¼˜åŒ–å™¨ã€å‚æ•°shots=1000çš„qasm_simulatorä»¥åŠå’ŒåŒ…å«60ä¸ªæ³¡åˆ©å­—ä¸²çš„å“ˆå¯†é¡¿é‡æ—¶ï¼Œé€šè¿‡è®¡ç®—å›è·¯çš„æ•°é‡è¯„ä¼°æ¯æ¬¡ä¼˜åŒ–è¿­ä»£æ—¶æ‰€æ‰§è¡Œçš„å›è·¯ã€‚

3\. ä½¿ç”¨VQEä¼°è®¡åŸå­é—´è·ä¸º1.3Ã…çš„BeH~2~çš„åŸºæ€èƒ½é‡ã€‚æ‚¨å¯ä»¥é€šè¿‡æ›¿æ¢atom=\"Li
.0 .0 .0; H .0 .0 \" + str(dist)ä¸ºatom=\"Be .0 .0 .0; H .0 .0 -\" +
str(dist) + \"; H .0 .0 \" +
str(dist)æ¥é‡ç”¨å‡½æ•°get_qubit_op(dist)ï¼Œå¹¶é€šè¿‡get_qubit_op(1.3)è°ƒç”¨è¯¥å‡½æ•°ã€‚è¯·æ³¨æ„ç§»é™¤æœªå æ®çš„è½¨é“å¹¶ä¸èƒ½ä¿æŒåˆ†å­çš„åŒ–å­¦ç²¾åº¦ã€‚ç„¶è€Œï¼Œä¸ºäº†å°†æ‰€éœ€çš„é‡å­æ¯”ç‰¹æ•°é™ä½åˆ°6(ä»è€Œå…è®¸åœ¨å¤§å¤šæ•°ç¬”è®°æœ¬ç”µè„‘ä¸Šè¿›è¡Œæœ‰æ•ˆçš„æ¨¡æ‹Ÿ)ï¼Œè¿™ç§ç²¾åº¦çš„æŸå¤±å¯ä»¥æ¥å—ã€‚è™½ç„¶è¶…å‡ºäº†æœ¬ç»ƒä¹ çš„èŒƒå›´ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥ä½¿ç”¨é‡å­æ¯”ç‰¹é€æ¸å‡å°‘çš„æ“ä½œæ¥å‡å°‘æ‰€éœ€çš„é‡å­æ¯”ç‰¹æ•°åˆ°7ï¼Œè€Œä¸ä¼šæŸå¤±ä»»ä½•åŒ–å­¦ç²¾åº¦ã€‚

#### 6. å‚è€ƒæ–‡çŒ®

1\. Peruzzo, Alberto, et al. \"A variational eigenvalue solver on a
photonic quantum processor.\" Nature communications 5 (2014): 4213.

2\. Griffiths, David J., and Darrell F. Schroeter. Introduction to
quantum mechanics. Cambridge University Press, 2018.

3\. Shende, Vivek V., Igor L. Markov, and Stephen S. Bullock. \"Minimal
universal two-qubit cnot-based circuits.\" arXiv preprint
quant-ph/0308033 (2003).

4\. Kandala, Abhinav, et al. \"Hardware-efficient variational quantum
eigensolver for small molecules and quantum magnets.\" Nature 549.7671
(2017): 242.

### 4.1.3 ä½¿ç”¨QAOAè§£å†³ç»„åˆä¼˜åŒ–é—®é¢˜

åœ¨æœ¬èŠ‚ä¸­æˆ‘ä»¬å°†ä»‹ç»ç»„åˆä¼˜åŒ–é—®é¢˜ï¼Œè§£é‡Šè¿‘ä¼¼ä¼˜åŒ–ç®—æ³•ä»¥åŠé‡å­è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•(QAOAï¼šQuantum
Approximate Optimization
Algorithm)çš„å·¥ä½œåŸç†ï¼Œå¹¶ç»™å‡ºä¸€ä¸ªå¯ä»¥åœ¨æ¨¡æ‹Ÿå™¨æˆ–5é‡å­æ¯”ç‰¹çš„é‡å­èŠ¯ç‰‡ä¸Šè¿è¡Œçš„å®ä¾‹ã€‚

#### å†…å®¹

1\. ç®€ä»‹

2\. ç¤ºä¾‹

3\. è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•

4\. QAOAç®—æ³•

5\. Qiskitå®ç°

5.1 åœ¨æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡ŒQAOA

5.2 åœ¨çœŸå®é‡å­è®¾å¤‡ä¸Šè¿è¡ŒQAOA

6\. è”ç³»

7\. å‚è€ƒæ–‡çŒ®

#### 1.ç®€ä»‹

ç»„åˆä¼˜åŒ–^\[1\]^æ˜¯æŒ‡åœ¨æœ‰é™æˆ–å¯æ•°æ— é™çš„æ½œåœ¨è§£é›†ä¸­å¯»æ‰¾æœ€ä¼˜è§£ã€‚æœ€ä¼˜æ€§è¢«å®šä¹‰ä¸ºä¸€äº›åˆ¤åˆ«å‡½æ•°ï¼Œå…¶ä¸ºæœ€å°åŒ–è¿˜æ˜¯æœ€å¤§åŒ–ï¼Œè¿™äº›å‡½æ•°é€šå¸¸è¢«ç§°ä¸ºä»£ä»·å‡½æ•°ã€‚

åœ¨ç°å®ä¸–ç•Œä¸­æœ‰ç€å„ç§ç±»å‹çš„ä¼˜åŒ–é—®é¢˜ã€‚æŸäº›åŒ…å«æœ€å°åŒ–é—®é¢˜ï¼šæˆæœ¬ã€è·ç¦»ã€éå†çš„é•¿åº¦ã€é‡é‡ã€åŠ å·¥æ—¶é—´ã€ææ–™ã€èƒ½æºæ¶ˆè€—ã€å¯¹è±¡æ•°é‡ã€‚æŸäº›åŒ…å«æœ€å¤§åŒ–é—®é¢˜ï¼šåˆ©æ¶¦ã€ä»·å€¼ã€äº§å‡ºã€å›æŠ¥ã€äº§é‡ã€æ•ˆç”¨ã€æ•ˆç‡ã€å®¹é‡ã€å¯¹è±¡æ•°é‡ã€‚ä»»ä¸€æœ€å¤§åŒ–é—®é¢˜éƒ½å¯ä»¥ç”¨æœ€å°åŒ–é—®é¢˜æ¥è¡¨ç¤ºï¼Œåä¹‹äº¦ç„¶ã€‚ä»¥ä¸‹ç»™å‡ºäº†ç»„åˆä¼˜åŒ–é—®é¢˜çš„ä¸€èˆ¬å½¢å¼ï¼š

$$\text{maximize\ }C(x)$$

$$\text{subject\ to\ }x \in S$$

å…¶ä¸­$x \in S$æ˜¯ä¸€ä¸ªç¦»æ•£å˜é‡ï¼Œ$C:D \rightarrow \mathbb{R}$æ˜¯ä»£ä»·å‡½æ•°ã€‚è¿™ä¸€å½¢å¼å°†åŸŸ$S$æ˜ å°„è‡³å®æ•°$\mathbb{R}$ã€‚å˜é‡$x$å—åˆ¶äºä¸€ç»„çº¦æŸå¹¶ä½äºå¯è¡Œç‚¹çš„é›†åˆ$S \subset D$ä¹‹å†…ã€‚

åœ¨äºŒå…ƒç»„åˆä¼˜åŒ–é—®é¢˜ä¸­ï¼Œä»£ä»·å‡½æ•°é€šå¸¸å¯ä»¥è¡¨ç¤ºä¸ºåœ¨$x \in {\{ 0,1\}}^{n}$ä¸­$n$ä½å­—ä¸²çš„ä¸€ä¸ªå­é›†$Q \subset \lbrack n\rbrack$æ‰€æœ‰é¡¹çš„æ€»å’Œã€‚ä»£ä»·å‡½æ•°$C$é€šå¸¸ä»¥å¦‚ä¸‹æ ‡å‡†å½¢å¼ä¹¦å†™ï¼š

$$C\left( x \right) = \sum_{\left( Q,\overline{Q} \right) \subset \left\lbrack n \right\rbrack}^{}w_{\left( Q,\overline{Q} \right)}\prod_{i \in Q}^{}x_{i}\prod_{j \in \overline{Q}}^{}\left( 1 - x_{j} \right)$$

å…¶ä¸­$x_{i} \in \{ 0,1\}$ä»¥åŠ$w_{(Q,\overline{Q})} \in \mathbb{R}$ã€‚æˆ‘ä»¬æƒ³è¦æ‰¾å‡ºä½¿å¾—$C(x)$æœ€å¤§æ—¶çš„$n$-æ¯”ç‰¹å­—ä¸²$x$ã€‚

##### 1.1 å¯¹è§’å“ˆå¯†é¡¿é‡

è¿™ä¸€ä»£ä»·å‡½æ•°å¯ä»¥æ˜ å°„åˆ°ä¸€ä¸ªåœ¨è®¡ç®—åŸºä¸Šæ˜¯å¯¹è§’çš„å“ˆå¯†é¡¿é‡ã€‚ç»™å®šä»£ä»·å‡½æ•°$C$ï¼Œå“ˆå¯†é¡¿é‡å°±å¯ä»¥å†™æˆï¼š

$$H = \sum_{x \in \{ 0,1\}^{n}}^{}{C(x)|x\rangle\langle x|}$$

å…¶ä¸­$x \in \{ 0,1\}^{n}$æ ‡è®°è®¡ç®—åŸºçš„çŠ¶æ€$|x\rangle \in \mathbb{C}^{2^{n}}$ã€‚å¦‚æœä»£ä»·å‡½æ•°æœ€å¤šåªæœ‰$k$é¡¹æƒå€¼ï¼Œå¦‚ä»…æœ‰$Q$ç»™å‡ºè´¡çŒ®ä¸”ä»…æ¶‰åŠæœ€å¤š$Q \leq k$ä½ï¼Œé‚£ä¹ˆè¯¥å¯¹è§’å“ˆå¯†é¡¿é‡ä¹Ÿæ˜¯æƒé‡ä¸º$k$çš„Pauli
$Z$ç®—å­çš„å’Œã€‚

å“ˆå¯†é¡¿é‡$H$è‡³Pauli
$Z$ç®—å­çš„æ‰©å±•å¯ä»¥é€šè¿‡æŠŠæ¯ä¸ªäºŒå…ƒå˜é‡$x_{i} \in \{ 0,1\}$ä»£å…¥çŸ©é˜µ$x_{i} \rightarrow 2^{- 1}(1 - Z_{i})$ä»æˆæœ¬å‡½æ•°$C$çš„è§„èŒƒå±•å¼€ä¸­è·å¾—ã€‚æ­¤å¤„çš„$Z_{i}$è¢«è§†ä¸ºä½œç”¨äºé‡å­æ¯”ç‰¹$i$çš„Pauli
$Z$ç®—å­ï¼Œå…¶å¯¹æ‰€æœ‰å…¶ä»–éƒ½ä¸ºé›¶ã€‚å¦‚ï¼š

$$Z_{i} = \begin{pmatrix}
1 & 0 \\
0 & - 1 \\
\end{pmatrix}$$

è¿™æ„å‘³ç€ç»å…¸æˆæœ¬å‡½æ•°çš„è‡ªæ—‹-å“ˆå¯†é¡¿é‡å¯ç¼–ç ä¸ºä»…æ¶‰åŠPauli
$Z$ç®—å­çš„å±€éƒ¨é‡å­è‡ªæ—‹å“ˆå¯†é¡¿é‡$|Q|$ã€‚

$$H = \sum_{(Q,\overline{Q}) \subset \lbrack n\rbrack}^{}{w_{(Q,\overline{Q})}\frac{1}{2^{|Q| + |\overline{Q}|}}}\prod_{i \in Q}^{}{(1 - Z_{i})}\prod_{j \in \overline{Q}}^{}{(1 + Z_{j})}$$

ç°åœ¨ï¼Œæˆ‘ä»¬å‡è®¾ä¸€å°éƒ¨åˆ†$w_{(Q,\overline{Q})}$ä¸ºéé›¶ï¼ˆå¤šé¡¹å¼å¤§éƒ¨åˆ†åœ¨$n$ä¸­ï¼‰ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å‡è®¾é›†åˆ$|(Q,\overline{Q})|$æœ‰ç•Œä¸”ä¸ä¼šå¤ªå¤§ã€‚è¿™è¡¨æ˜æˆ‘ä»¬å¯ä»¥æŠŠä»£ä»·å‡½æ•°å’Œå“ˆå¯†é¡¿é‡$H$å†™æˆ$m$ä¸ªå±€éƒ¨é¡¹${\widehat{C}}_{k}$çš„å’Œï¼š

$$H = \sum_{k = 1}^{m}{\widehat{C}}_{k}$$

å…¶ä¸­må’Œ${\widehat{C}}_{k}$çš„æ”¯æ’‘é›†éƒ½æ˜¯åˆç†æœ‰ç•Œã€‚

#### 2. ç¤ºä¾‹

é€šè¿‡è€ƒè™‘ä¸¤ä¸ªä¾‹å­æ¥è¯´æ˜ç»„åˆä¼˜åŒ–é—®é¢˜ã€‚æˆ‘ä»¬å°†åœ¨Qiskitä¸­å®ç°ç¬¬ä¸€ä¸ªç¤ºä¾‹ï¼Œä½†æä¾›ä¸€ç³»åˆ—ç»ƒä¹ æ¥ç»™å‡ºå®ç°ç¬¬äºŒä¸ªç¤ºä¾‹çš„æŒ‡å¯¼ã€‚

##### 2.1 ï¼ˆåŠ æƒï¼‰*MAXCUT*

è€ƒè™‘ä¸€ä¸ª$n$èŠ‚ç‚¹çš„æ— å‘å›¾$G = (V,E)$ï¼Œå…¶ä¸­$|V| = n$çš„è¾¹æƒä¸º$w_{\text{ij}} > 0$ï¼Œå¯¹äº$(j,k) \in E$
$w_{\text{ij}} = w_{\text{ji}}$ã€‚åˆ‡å‰²è¢«å®šä¹‰ä¸ºå°†åŸå§‹é›†åˆVåˆ’åˆ†ä¸ºä¸¤ä¸ªå­é›†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œéœ€è¦ä¼˜åŒ–çš„ä»£ä»·å‡½æ•°æ˜¯ä¸¤ä¸ªä¸åŒå­é›†è¿æ¥ç‚¹çš„è¾¹æƒä¹‹å’Œï¼Œè¿™äº›è¿æ¥ç‚¹æ¨ªè¶Šï¼ˆ*crossing*ï¼‰äºåˆ‡å‰²ä¹‹é—´ã€‚é€šè¿‡å°†$x_{i} = 0$æˆ–$x_{i} = 1$åˆ†é…ç»™æ¯ä¸ªèŠ‚ç‚¹$i$ï¼Œå¯ä»¥å°è¯•æœ€å¤§åŒ–å…¨å±€åˆ©æ¶¦å‡½æ•°ï¼ˆåœ¨è¿™é‡Œå’Œä¸‹é¢çš„æ±‚å’Œä¸­ï¼Œç´¢å¼•ä¸º0,1ï¼Œ...n-1ï¼‰ã€‚

$$C(\text{x}) = \sum_{i,j = 1}^{n}{w_{\text{ij}}x_{i}\left( 1 - x_{j} \right)}$$

ä¸ºäº†ç®€åŒ–ç¬¦å·ï¼Œæˆ‘ä»¬å‡è®¾å¯¹äºæ‰€æœ‰$(i,j) \in E$ç»Ÿä¸€æƒé‡ä¸º$w_{\text{ij}} = 1$ã€‚ä¸ºäº†åœ¨é‡å­è®¡ç®—æœºä¸Šæ‰¾åˆ°è¿™ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼Œé¦–å…ˆéœ€è¦å°†å…¶æ˜ å°„åˆ°å¦‚ä¸Šæ‰€è¿°çš„å¯¹è§’å“ˆå¯†é¡¿é‡ã€‚æˆ‘ä»¬æŠŠå’Œå†™æˆé›†åˆ$(i,j) = E$ä¸­è¾¹çš„å’Œï¼š

$$C(\text{x}) = \sum_{i,j = 1}^{n}{w_{\text{ij}}x_{i}\left( 1 - x_{j} \right)} = \sum_{(i,j) \in E}^{}\left( x_{i}\left( 1 - x_{j} \right) + x_{j}\left( 1 - x_{i} \right) \right)$$

è¦æ˜ å°„åˆ°è‡ªæ—‹å“ˆå¯†é¡¿é‡ï¼Œæˆ‘ä»¬éœ€è¦å¯¹å…¶è¿›è¡Œèµ‹å€¼$x_{i} \rightarrow (1 - Z_{i})/2$ï¼Œå…¶ä¸­$Z_{i}$æ˜¯æœ¬å¾å€¼ä¸º$\pm 1$çš„æ³¡åˆ©Zç®—å­å¹¶è·å¾—$X \rightarrow H$

$$H = \sum_{(j,k) \in E}^{}{\frac{1}{2}\left( 1 - Z_{j}Z_{k} \right)}$$

è¿™è¡¨æ˜å“ˆå¯†é¡¿é‡å¯ä»¥å†™æˆ$m = |E|$å±€éƒ¨é¡¹${\overset{\hat{}}{C}}_{e} = \frac{1}{2}\left( 1 - Z_{e1}Z_{e2} \right)$ä¹‹å’Œï¼Œå…¶ä¸­$e = (e1,e2) \in E$ã€‚

##### 2.2 çº¦æŸæ»¡æ„åº¦é—®é¢˜ä¸$\mathbf{\text{MAX}}\mathbf{3 -}\mathbf{\text{SAT}}$

ç»„åˆä¼˜åŒ–é—®é¢˜çš„å¦ä¸€ä¸ªç¤ºä¾‹æ˜¯$3 - SAT$ã€‚æ­¤å¤„çš„ä»£ä»·å‡½æ•°$C(\text{x}) = \sum_{k = 1}^{m}{c_{k}(\text{x})}$æ˜¯æ¡æ¬¾$c_{k}(\text{x})$çš„å’Œï¼Œè¯¥æ¡æ¬¾çº¦æŸäº†å‚ä¸è¿™äº›æ¡æ¬¾çš„æŸäº›$\text{x} \in \{ 0,1\}^{n}$çš„3ä¸ªæ¯”ç‰¹çš„å€¼ï¼Œä¾‹å¦‚ï¼Œè€ƒè™‘å¯¹äºæ¯”ç‰¹å­—ä¸²$\text{x} \in \{ 0,1\}^{133}$çš„$3 - SAT$ç¤ºä¾‹ï¼š

$$c_{1}(\text{x}) = (1 - x_{1})(1 - x_{3})x_{132}$$

æ¡æ¬¾ä»…åœ¨å°†æ¯”ç‰¹è®¾ç½®ä¸º$x_{1} = 0$ã€$x_{3} = 0$å’Œ$x_{132} = 1$æ»¡è¶³è¦æ±‚ã€‚$3 - SAT$é—®é¢˜ç°åœ¨è¡¨è¯‰ä¸ºæ˜¯å¦å­˜åœ¨ä¸€ä¸ªæ»¡è¶³æ‰€æœ‰$m$æ¡æ¬¾çš„æ¯”ç‰¹å­—ä¸²æˆ–å…¶ä¸å­˜åœ¨ã€‚æ­¤å†³ç­–é—®é¢˜æ˜¯NPå®Œå…¨é—®é¢˜ï¼ˆNP-completeï¼‰çš„ä¸»è¦ç¤ºä¾‹ã€‚

ä¸ä¹‹å¯†åˆ‡ç›¸å…³çš„ä¼˜åŒ–é—®é¢˜$MAX3 - SAT$è¦æ±‚æ‰¾åˆ°æ»¡è¶³$C(x)$ä¸­æ¡æ¬¾æœ€å¤§æ•°é‡çš„æ¯”ç‰¹å­—ä¸²$x$ã€‚å¦‚æœæˆ‘ä»¬é—®åœ¨æ˜¯å¦å­˜åœ¨æ»¡è¶³$m$ä¸ªæ¡æ¬¾ä¸­$\overset{\sim}{m}$ä¸ªä»¥ä¸Šçš„æ¯”ç‰¹å­—ä¸²çš„é—®é¢˜ï¼Œè¿™å½“ç„¶åˆå˜ä¸ºäº†å†³ç­–é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯NPå®Œå…¨é—®é¢˜ã€‚

#### 3. è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•

å®é™…ä¸Šï¼Œå…ˆå‰è®¤ä¸ºçš„$\text{MAXCUT}$å’Œ$MAX3 - SAT$é—®é¢˜éƒ½æ˜¯NPéš¾é¢˜ï¼ˆNP-Hardï¼‰\[1\]ã€‚äº‹å®è¯æ˜ï¼Œè®¸å¤šç»„åˆä¼˜åŒ–é—®é¢˜é€šå¸¸åœ¨è®¡ç®—ä¸Šéš¾ä»¥è§£å†³ã€‚é‰´äºè¿™ä¸€äº‹å®ï¼Œæˆ‘ä»¬ä¸èƒ½æœŸæœ›æ‰¾åˆ°ä¸€ç§å¯è¯æ˜å…¶æœ‰æ•ˆçš„ç®—æ³•ï¼Œå³å¯è§£å†³è¿™äº›é—®é¢˜çš„è§„æ¨¡ä¸ºå¤šé¡¹å¼è¿è¡Œæ—¶é—´çš„ç®—æ³•ã€‚è¿™åŒæ—¶ä¹Ÿé€‚ç”¨äºé‡å­ç®—æ³•ã€‚è§£å†³æ­¤ç±»é—®é¢˜æœ‰ä¸¤ç§ä¸»è¦æ–¹æ³•ã€‚ç¬¬ä¸€ç§æ–¹æ³•æ˜¯è¿‘ä¼¼ç®—æ³•ï¼Œå¯ä»¥ä¿è¯åœ¨å¤šé¡¹å¼æ—¶é—´å†…æ‰¾åˆ°æŒ‡å®šç²¾åº¦çš„è§£ã€‚ç¬¬äºŒç§æ–¹æ³•æ˜¯å¯å‘å¼ç®—æ³•ï¼Œå…¶æ²¡æœ‰å¤šé¡¹å¼è¿è¡Œæ—¶é—´ä¿è¯ï¼Œä½†åœ¨æŸäº›æ­¤ç±»é—®é¢˜çš„å®ä¾‹ä¸Šè¡¨ç°è‰¯å¥½ã€‚

è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•æœ‰æ•ˆä¸”ä¸ºè¿‘ä¼¼è§£ä¸é—®é¢˜ä¹‹å®é™…æœ€ä¼˜å€¼ä¹‹é—´çš„æ¥è¿‘ç¨‹åº¦æä¾›äº†å¯è¯æ˜çš„ä¿è¯ã€‚è¿™ä¸€ä¿è¯é€šå¸¸ä»¥*è¿‘ä¼¼æ¯”*$\alpha \leq 0$çš„å½¢å¼å‡ºç°ã€‚æ¦‚ç‡è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•å¯ç¡®ä¿äº§ç”Ÿä¸€ä¸ªæ¯”ç‰¹å­—ä¸²$\text{x}^{*} \in \{ 0,1\}^{n}$ï¼Œå› æ­¤åœ¨é«˜æ¦‚ç‡çš„æƒ…å†µä¸‹å…·æœ‰æ­£çš„$C_{\max} = \max_{\text{x}}C(\text{x})$

$$C_{\max} \geq C\left( \text{x}^{*} \right) \geq \alpha C_{\max}$$

å¯¹äº$\text{MAXCUT}$é—®é¢˜Goemanså’ŒWilliamsonåˆ›å»ºäº†ä¸€ä¸ªè‘—åè¿‘ä¼¼ç®—æ³•\[2\]ã€‚è¯¥ç®—æ³•åŸºäºåŸå§‹é—®é¢˜çš„SDPæ¾å¼›ä¸æ¦‚ç‡èˆå…¥æŠ€æœ¯ç›¸ç»“åˆï¼Œè¯¥æ¦‚ç‡èˆå…¥æŠ€æœ¯äº§ç”Ÿäº†å…·æœ‰é«˜æ¦‚ç‡çš„è¿‘ä¼¼è§£$\text{x}^{*}$ï¼Œå…¶*è¿‘ä¼¼æ¯”*ä¸º$\alpha \approx 0.868$ã€‚å®é™…ä¸Šï¼Œè¿™ä¸€*è¿‘ä¼¼æ¯”*è¢«è®¤ä¸ºæ˜¯æœ€ä½³è¿‘ä¼¼æ¯”ï¼Œå› æ­¤æˆ‘ä»¬ä¸éœ€è¦é€šè¿‡ä½¿ç”¨é‡å­ç®—æ³•æ¥å¯¹å…¶è¿›è¡Œæ”¹è¿›ã€‚

#### 4. QAOAç®—æ³•

Farhiï¼ŒGoldsoneå’ŒGutmannçš„é‡å­è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•ï¼ˆQAOAï¼‰\[3\]æ˜¯å¯å‘å¼ç®—æ³•çš„ä¸€ä¸ªç¤ºä¾‹ã€‚ä¸Goemans-Williamsonç®—æ³•ä¸åŒï¼ŒQAOAä¸æä¾›æ€§èƒ½ä¿è¯ã€‚QAOAé‡‡ç”¨ç»å…¸è¿‘ä¼¼ç®—æ³•çš„æ–¹å¼ï¼Œå¯»æ‰¾ä¸€ç§å°†äº§ç”Ÿç»å…¸æ¯”ç‰¹å­—ä¸²$\text{x}^{*}$çš„é‡å­ç±»ä¼¼ç‰©ï¼Œè¯¥æ¯”ç‰¹å­—ä¸²é«˜æ¦‚ç‡å…·æœ‰è‰¯å¥½çš„è¿‘ä¼¼æ¯”$\alpha$ã€‚åœ¨è®¨è®ºç»†èŠ‚ä¹‹å‰ï¼Œè®©æˆ‘ä»¬é¦–å…ˆä»‹ç»ä¸€ä¸‹è¿™ä¸€æ–¹æ³•çš„åŸºç¡€æ¦‚å¿µã€‚

##### 4.1 ç®€ä»‹

æˆ‘ä»¬æƒ³è¦æ‰¾åˆ°åŸºäºä¸€äº›å®å‚æ•°$\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta} \in \mathbb{R}^{p}$çš„ä¸€ä¸ªé‡å­æ€$|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle$ï¼Œè¿™ä¸€é‡å­æ€å…·æœ‰å…³äºé—®é¢˜å“ˆå¯†é¡¿é‡ğ»çš„æœŸæœ›å€¼æœ€å¤§åŒ–çš„ç‰¹æ€§ã€‚é€šè¿‡ç»™å®šè¿™ä¸€åˆ¤åˆ«æ€ï¼ˆtrial
stateï¼‰ï¼Œæˆ‘ä»¬å°±å¯ä»¥æœç´¢ä½¿å¾—$F_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta}) = \langle\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|H|\psi_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle$æœ€å¤§åŒ–çš„å‚æ•°${\overset{\rightarrow}{\gamma}}^{*},{\overset{\rightarrow}{\beta}}^{*}$ã€‚

ä¸€æ—¦æˆ‘ä»¬è·å¾—äº†è¿™æ ·çš„çŠ¶æ€å’Œç›¸åº”çš„å‚æ•°ï¼Œå°±å¯ä»¥åœ¨é‡å­è®¡ç®—åŸºä¸Šå‡†å¤‡çŠ¶æ€$|\psi_{p}({\overset{\rightarrow}{\gamma}}^{*},{\overset{\rightarrow}{\beta}}^{*})\rangle$å¹¶åœ¨$Z$åŸº$|x\rangle = |x_{1},\ldots x_{n}\rangle$ä¸Šæµ‹é‡è¯¥çŠ¶æ€å¼€è·å–ä¸€ä¸ªéšæœºè¾“å‡º$x^{*}$ã€‚

æˆ‘ä»¬å°†ä¼šçœ‹åˆ°è¯¥éšæœº$x^{*}$æ˜¯ä¸€ä¸ªæ¯”ç‰¹å­—ä¸²ä¸”é«˜æ¦‚ç‡æ¥è¿‘æœŸæœ›å€¼$M_{p} = F_{p}({\overset{\rightarrow}{\gamma}}^{*},{\overset{\rightarrow}{\beta}}^{*})$ã€‚å› æ­¤ï¼Œå¦‚æœ$M_{p}$æ¥è¿‘$C_{\max}$åˆ™å…¶å°±æ˜¯$C(x^{*})$ã€‚

##### 4.2 QAOAç®—æ³•çš„æ„æˆ

###### 4.2.1 QAOAåˆ¤åˆ«æ€

QAOAçš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªå°†åœ¨é‡å­è®¡ç®—æœºä¸Šå‡†å¤‡çš„åˆ¤åˆ«æ€$\left| \psi_{p}\left( \overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta} \right) \right\rangle$ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›è¯¥åˆ¤åˆ«æ€å…³äºé—®é¢˜å“ˆå¯†é¡¿é‡$H$äº§ç”Ÿä¸€ä¸ªå¤§çš„æœŸæœ›å€¼$F_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta}) = \langle\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|H|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle$ã€‚åœ¨Frahi\[3\]ï¼Œåˆ¤åˆ«æ€$\left| \psi_{p}\left( \overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta} \right) \right\rangle$ç”±é—®é¢˜å“ˆå¯†é¡¿é‡$H$ä¸ä½†é‡å­æ¯”ç‰¹æ³¡åˆ©$X$æ—‹è½¬æ„å»ºã€‚è¿™ä¸€è¿‡ç¨‹è¡¨æ˜ï¼Œç»™å®šä¸€ä¸ªé—®é¢˜å“ˆå¯†é¡¿é‡ï¼š

$$H = \sum_{k = 1}^{m}{\overset{\hat{}}{C}}_{k}$$

å¯¹è§’è®¡ç®—åŸºå’Œæ¨ªå‘åœºå“ˆå¯†é¡¿é‡ä¸ºï¼š

$$B = \sum_{i = 1}^{n}X_{i}$$

é€šè¿‡åº”ç”¨$p$æ¬¡äº¤æ›¿å¹ºæ­£å‡†å¤‡åˆ¤åˆ«æ€ï¼š

$$|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle = e^{- i\beta_{p}B}e^{- i\gamma_{p}H}\ldots e^{- i\beta_{1}B}e^{- i\gamma_{1}H}| + \rangle^{n}$$

è‡³åŒ…å«$X| + \rangle = | + \rangle$çš„ç›´ç§¯æ€$| + \rangle^{n}$ã€‚

è¿™ä¸€ç‰¹å®šæ‹Ÿè®¾çš„ä¼˜ç‚¹æ˜¯å¯¹å‘é‡${\overset{\rightarrow}{\gamma}}^{*}$å’Œ${\overset{\rightarrow}{\beta}}^{*}$æœ‰æ˜ç¡®åœ°é€‰æ‹©ï¼Œä½¿å¾—å½“æˆ‘ä»¬å–æé™$\lim_{p \rightarrow \infty}M_{p} = C_{\max}$æ—¶$M_{p} = F_{p}({\overset{\rightarrow}{\alpha}}^{*},{\overset{\rightarrow}{\beta}}^{*})$ã€‚è¿™ä¸€è¿‡ç¨‹é€šè¿‡å°†åˆ¤åˆ«æ€$|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle$è§†ä¸ºå¯¹$H$å’Œæ¨ªå‘åœºå“ˆå¯†é¡¿é‡Bçš„æ¸è¿›ç»çƒ­æ¼”åŒ–è€Œå¾—å‡ºçš„çŠ¶æ€ï¼Œè¯·å‚é˜…å‚è€ƒæ–‡çŒ®\[3\]ã€‚

è¿™ç§åˆ¤åˆ«æ€çš„ç¼ºç‚¹æ˜¯é€šå¸¸ä¼šå¸Œæœ›ä»ä¸å¤ªæ·±çš„é‡å­å›è·¯ç”Ÿæˆä¸€ç§çŠ¶æ€ã€‚æ­¤å¤„çš„æ·±åº¦å¯¹åº”äºå¯ä»¥ç›´æ¥åº”ç”¨åœ¨é‡å­èŠ¯ç‰‡ä¸Šçš„é‡å­é—¨æµ‹é‡æ·±åº¦ã€‚å› æ­¤ï¼Œå¦ä¸€ä¸ªå»ºè®®æ˜¯ä½¿ç”¨æ›´åŠ é€‚åˆå‚è€ƒæ–‡çŒ®\[4\]å’Œ\[5\]æ‰€æåŠé‡å­èŠ¯ç‰‡ç¡¬ä»¶çš„æ‹Ÿè®¾åˆ¤åˆ«æ€ã€‚

###### 4.2.2 è®¡ç®—æœŸæœ›å€¼

è¿™ä¸€æ–¹æ³•çš„é‡è¦ç»„æˆéƒ¨åˆ†æ˜¯æˆ‘ä»¬å¿…é¡»è®¡ç®—æˆ–ä¼°è®¡æœŸæœ›å€¼ï¼š

$$F_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta}) = \langle\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|H|\psi_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle$$

æ‰èƒ½ä¼˜åŒ–å‚æ•°$\overset{\rightarrow}{\gamma}$å’Œ$\overset{\rightarrow}{\beta}$ã€‚æ­¤å¤„æˆ‘ä»¬å°†ä¼šè€ƒè™‘ä¸¤ç§æƒ…å†µã€‚

####### ç»å…¸æ±‚å€¼

å½“ç”¨äºå‡†å¤‡$|\psi_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle$çš„é‡å­å›è·¯ä¸å¤ªæ·±æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°æœ‰å¯èƒ½ä½¿ç”¨ç»å…¸æ–¹å¼å¯¹æœŸæœ›å€¼$F_{p}$è¿›è¡Œæ±‚å€¼ã€‚

ä¾‹å¦‚ï¼Œå½“æœ‰äººè€ƒè™‘å¯¹æœ‰ç•Œå¹‚çš„å›¾å½¢ä½¿ç”¨$\text{MAXCUT}$è€Œæœ‰äººè€ƒè™‘$p = 1$çš„å›è·¯æ—¶å°±ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚æˆ‘ä»¬å°†åœ¨ä¸‹é¢çš„Qiskitå®ç°ï¼ˆ5.2èŠ‚ï¼‰ä¸­çœ‹åˆ°ä¸€ä¸ªç¤ºä¾‹ï¼Œå¹¶ç»™å‡ºä¸€ä¸ªç»ƒä¹ æ¥è®¡ç®—æœŸæœ›å€¼ã€‚

ä¸ºäº†è¯´æ˜è¿™ä¸€æ€æƒ³ï¼Œè¯·å›æƒ³ä¸€ä¸‹å“ˆå¯†é¡¿é‡å¯ä»¥å†™æˆå•ä¸ªé¡¹çš„æ€»å’Œ$H = \sum_{k = 1}^{m}{\widehat{c}}_{k}$ã€‚ç”±äºæœŸæœ›å€¼æ˜¯çº¿æ€§çš„ï¼Œå› æ­¤è€ƒè™‘å„ä¸ªè¢«åŠ æ•°çš„æœŸæœ›å€¼å°±å¯ä»¥äº†ã€‚å¯¹äº$p = 1$çš„æƒ…å†µæœ‰ï¼š

$$\langle\psi_{1}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|{\widehat{c}}_{k}|\psi_{1}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle = \langle +^{n}|e^{i\gamma_{1}H}e^{i\beta_{1}B}|{\widehat{c}}_{k}|e^{- i\beta_{1}B}e^{- i\gamma_{1}H}| +^{n}\rangle$$

å¯è§‚å¯Ÿåˆ°ï¼šå½“$B = \sum_{i = 1}^{n}X_{i}$æ—¶ï¼Œå¹ºæ­£$e^{- i\beta_{1}B}$å®é™…ä¸Šæ˜¯å•ä¸ªé‡å­æ¯”ç‰¹ç»•$X$æ—‹è½¬$\beta$çš„ä¹˜ç§¯ï¼Œæˆ‘ä»¬å°†å…¶å†™ä¸º$X(\beta)_{k} = \exp(i\beta X_{k})$ã€‚

æ‰€æœ‰ä¸åšç”¨äºé‡å­æ¯”ç‰¹çš„å•ç‹¬æ—‹è½¬ï¼Œå› ${\widehat{c}}_{k}$æ”¯æŒä¸${\widehat{c}}_{k}$è½¬æ¢ï¼Œä»è€ŒæŠµæ¶ˆã€‚å› è€Œä¸ä¼šå¢åŠ å¯¹ç®—å­${\widehat{c}}_{k}$çš„æ”¯æŒã€‚è¡¨æ˜ç¬¬äºŒç»„U-gate
$e^{- i\gamma_{1}H} = \prod_{l = 1}^{m}{U_{l}(\gamma)}$å…·æœ‰å¤§é‡è½¬æ¢ä¸ºç®—å­$e^{i\beta_{1}B}{\widehat{c}}_{k}e^{- i\beta_{1}B}$çš„$U_{l}(\gamma) = )e^{- i\gamma_{1}{\widehat{c}}_{l}}$çš„é‡å­é—¨ã€‚å¯¹æœŸæœ›å€¼æœ‰å¸®åŠ©çš„ä»…æœ‰çš„é‡å­é—¨$U_{l}(\gamma) = )e^{- i\gamma_{1}{\widehat{c}}_{l}}$æ˜¯é‚£äº›åœ¨åŸæ¥${\widehat{c}}_{k}$çš„æ”¯æŒä¸‹æ‰€æ¶‰åŠé‡å­æ¯”ç‰¹çš„é‡å­é—¨ã€‚

å› æ­¤ï¼Œå¯¹äºæœ‰é™å¹‚ç›¸äº’ä½œç”¨$e^{i\gamma_{1}H}e^{i\beta_{1}B}{\widehat{c}}_{k}e^{- i\beta_{1}B}e^{- i\gamma_{1}H}$çš„æ”¯æŒä»…ç”±å¹‚$H$æ‰€ç»™å®šçš„é‡æ‰©å±•ï¼Œå› è€Œä¸ç³»ç»Ÿå¤§å°æ— å…³ã€‚è¿™æ„å‘³ç€å¯¹äºè¿™äº›è¾ƒå°çš„å­é—®é¢˜ï¼ŒæœŸæœ›å€¼ä¸$n$æ— å…³ï¼Œå¯ä»¥ç»å…¸ä¼°è®¡ã€‚é€šç”¨å¹‚ä¸º$3$çš„æƒ…å†µåœ¨å‚è€ƒæ–‡çŒ®\[3\]ä¸­è®²è¿°ã€‚

è¿™ä¸€ä¸ªæ™®éçš„è§‚å¯Ÿç»“æœè¡¨æ˜ï¼šå¦‚æœç”¨äºå‡†å¤‡åˆ¤åˆ«æ€çš„å›è·¯åªä¼šä»¥æ’å®šçš„é‡å¢åŠ å“ˆå¯†é¡¿é‡ä¸­æ¯ä¸€é¡¹ï¼Œåˆ™å¯ä»¥ç›´æ¥ä¼°è®¡ä»£ä»·å‡½æ•°ã€‚

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåœ¨å‡†å¤‡åˆ¤åˆ«æ€æ—¶åªéœ€è¦å‡ ä¸ªå‚æ•°$\beta$å’Œ$\gamma$ï¼Œå°±å¯ä»¥é€šè¿‡ç®€å•çš„ç½‘æ ¼æœç´¢è½»æ¾åœ°å°†å…¶æ‰¾å‡ºã€‚æ­¤å¤–ï¼Œç²¾ç¡®çš„æœ€ä½³$M_{p}$å€¼å¯ç”¨äºé™åˆ¶è¿‘ä¼¼æ¯”ï¼š

$$\frac{M_{p}}{C_{\max}} \geq \alpha$$

æ¥è·å–ä¼°è®¡å€¼$\alpha$ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼ŒQAOAç®—æ³•å…·æœ‰ä¸å¸¸è§„è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•ç›¸åŒçš„ç‰¹æ€§ï¼šå¯ç”¨é—®é¢˜è§„æ¨¡çš„å¤šé¡¹å¼æ•ˆç‡è·å¾—ç¡®ä¿çš„è¿‘ä¼¼æ¯”ã€‚

###### åœ¨é‡å­è®¡ç®—æœºä¸Šæ±‚å€¼

å½“é‡å­å›è·¯å˜å¾—å¤ªæ·±è€Œæ— æ³•ç»å…¸ä¼°è®¡æ—¶ï¼Œæˆ–è€…å½“é—®é¢˜å“ˆå¯†é¡¿é‡çš„è”ç»“åº¦å¤ªé«˜æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨å…¶ä»–æ–¹æ³•æ¥ä¼°è®¡æœŸæœ›å€¼ã€‚è¿™ä¸€è¿‡ç¨‹æ¶‰åŠåœ¨é‡å­è®¡ç®—æœºä¸Šç›´æ¥ä¼°è®¡$F_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})$ã€‚è¿™ä¸€æ–¹æ³•éµå¾ªVQE\[4\]ä¸­æ‰€ä½¿ç”¨çš„å¸¸è§„æœŸæœ›å€¼ä¼°è®¡è·¯å¾„ï¼Œå…¶ä¸­çš„åˆ¤åˆ«æ€$|\psi(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})$ç›´æ¥åœ¨é‡å­è®¡ç®—æœºä¸Šå‡†å¤‡å¹¶ä»é‡‡æ ·ä¸­è·å–æœŸæœ›å€¼ã€‚

ç”±äºQAOAå…·æœ‰å¯¹è§’å“ˆå¯†é¡¿é‡$H$ï¼Œå› æ­¤å®é™…ä¸Šå¯ä»¥ç›´æ¥ä¼°è®¡æœŸæœ›å€¼ã€‚æˆ‘ä»¬åªéœ€è¦åœ¨è®¡ç®—åŸºä¸Šä»åˆ¤åˆ«æ€è·å–æ ·æœ¬ã€‚å›æƒ³$H = \sum_{x \in \{ 0,1\}^{n}}^{}{C(x)|x\rangle\langle x|}$ï¼Œå› æ­¤æˆ‘ä»¬é€šè¿‡åœ¨$Z$-åŸºä¸Šé‡å¤æ€$|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle$çš„å•é‡å­æ¯”ç‰¹æµ‹é‡å¯ä»ä¸‹å¼ä¸­å¾—åˆ°æ ·æœ¬ä¼°è®¡ï¼š

$$\langle\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|H|\psi_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle = \sum_{x \in \{ 0,1\}^{n}}^{}{C(x)|\langle x|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle|^{2}}$$

å¯¹äºä»åˆ†å¸ƒ$|\langle x|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle|^{2}$ä¸­è·å–çš„æ¯ä¸ªæ¯”ç‰¹å­—ä¸²$x$ï¼Œæˆ‘ä»¬å¯¹ä»£ä»·å‡½æ•°è¿›è¡Œæ±‚å€¼å¹¶å°†å…¶é™¤ä»¥æ ·æœ¬æ€»æ•°æ±‚å¾—å‡å€¼ã€‚ç”±æ­¤äº§ç”Ÿçš„ç»éªŒå‡å€¼è¿‘ä¼¼äºæœŸæœ›å€¼ï¼Œç›´è‡³é™„åŠ æŠ½æ ·è¯¯å·®å¤„äºçŠ¶æ€æ–¹å·®èŒƒå›´å†…ã€‚æ–¹å·®å°†åœ¨ä¸‹æ–‡ä¸­è®¨è®ºã€‚

é€šè¿‡è®¿é—®æœŸæœ›å€¼ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥è¿è¡Œç»å…¸ä¼˜åŒ–ç®—æ³•ï¼ˆä¾‹å¦‚å‚è€ƒæ–‡çŒ®\[6\]ï¼‰æ¥ä¼˜åŒ–$F_{p}$ã€‚

è™½ç„¶è¿™ç§æ–¹æ³•ä¸èƒ½ä¿è¯$x^{*}$çš„a-å…ˆéªŒè¿‘ä¼¼ï¼Œä½†ä¼˜åŒ–çš„å‡½æ•°å€¼å¯ä»¥ç¨åç”¨äºç»™å‡ºè¿‘ä¼¼æ¯”$\alpha$çš„ä¼°è®¡ã€‚

##### 4.2.3 åœ¨ç»™å®šçš„è¿‘ä¼¼æ¯”ä¸‹æ±‚é«˜æ¦‚ç‡è§£

è¿™ä¸€ç®—æ³•æœ¬è´¨ä¸Šæ˜¯æ¦‚ç‡ï¼Œå¹¶ä¸”æ ¹æ®åˆ†å¸ƒ$|\langle x|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle|^{2}$äº§ç”Ÿéšæ¯”ç‰¹å­—ä¸²ã€‚é‚£ä¹ˆï¼Œå¦‚ä½•ç¡®å®šæˆ‘ä»¬ä¼šé‡‡é›†åˆ°æ¥è¿‘æœ€ä½³æœŸæœ›å€¼$M_{p}$çš„è¿‘ä¼¼å€¼$x^{*}$å‘¢ï¼Ÿè¯·æ³¨æ„ï¼è¿™ä¸ªé—®é¢˜é¦–å…ˆä¸é‡å­è®¡ç®—æœºä¸Š$M_{p}$çš„ä¼°ç®—æœ‰å…³ã€‚å¦‚æœä»$|\langle x|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle|^{2}$æå–çš„æ ·æœ¬æ–¹å·®å¤ªå¤§ï¼Œåˆ™éœ€è¦å¤§é‡æ ·æœ¬æ¥ç¡®å®šå‡å€¼ã€‚

æˆ‘ä»¬å°†ä¼šä»ç»˜åˆ¶å›¾ä¸­çœ‹åˆ°åœ¨èƒ½é‡ä½œä¸ºå˜é‡æ—¶æ¯”ç‰¹å­—ä¸²$x^{*}$æ¥è¿‘äºå‡å€¼$M_{p}$ï¼Œä¸”å‡ ä¹æ²¡æœ‰å˜åŒ–ã€‚

æ³¨æ„ï¼Œå“ˆå¯†é¡¿é‡$H = \sum_{k = 1}^{m}{\widehat{c}}_{k}$ä¸­çš„é¡¹æ•°ä»¥$m$ä¸ºç•Œã€‚å‡è®¾æ¯ä¸ªå•ç‹¬çš„è¢«åŠ æ•°${\widehat{c}}_{k}$éƒ½æœ‰ä¸€ä¸ªç®—å­èŒƒæ•°ï¼Œå¯¹äºæ‰€æœ‰$k = 1\ldots m$ï¼Œå…¶å¯ä»¥ç”±ä¸€ä¸ªé€šç”¨å¸¸æ•°$\|{\widehat{c}}_{k}\| \leq \widetilde{C}$ç•Œå®šã€‚ç„¶åè€ƒè™‘ï¼š

$$\begin{matrix}
\langle\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|H^{2}|\psi_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle - \langle\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|H|\psi_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle^{2} & \leq & \langle\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|H^{2}|\psi_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle \\
 & = & \sum_{k,l = 1}^{m}{\langle\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|{\overset{\hat{}}{C}}_{k}{\overset{\hat{}}{C}}_{l}|\psi_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle} \\
 & \leq & m^{2}{\overset{\sim}{C}}^{2} \\
\end{matrix}$$

å…¶ä¸­æˆ‘ä»¬ä½¿$\langle\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})|{\overset{\hat{}}{C}}_{k}{\overset{\hat{}}{C}}_{l}|\psi_{p}(\overset{\rightarrow}{\alpha},\overset{\rightarrow}{\beta})\rangle \leq {\overset{\sim}{C}}^{2}$ã€‚

è¿™è¡¨æ˜ä»»æ„æœŸæœ›å€¼çš„æ–¹å·®$F_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})$ç”±$m^{2}{\overset{\sim}{C}}^{2}$ç•Œå®šã€‚å› æ­¤ç‰¹åˆ«é€‚ç”¨äº$M_{p}$ã€‚æ­¤å¤–ï¼Œå¦‚æœ$m$ä»…åœ¨é‡å­æ¯”ç‰¹çš„å¤šé¡¹å¼æ•°é‡$n$ä¸Šå¢é•¿ï¼Œæˆ‘ä»¬çŸ¥é“ä»$|\langle x|\psi_{p}(\overset{\rightarrow}{\gamma},\overset{\rightarrow}{\beta})\rangle|^{2}$ä¸­å–å¤šé¡¹å¼å¢é•¿çš„æ ·æœ¬$s = O(\frac{{\overset{\sim}{C}}^{2}m^{2}}{\epsilon^{2}})$å°±è¶³ä»¥å¾—åˆ°$x^{*}$ä½¿å¾—$C(x^{*})$æ¥è¿‘$M_{p}$ã€‚

#### 5. Qiskitå®ç°

æˆ‘ä»¬åœ¨å…¬å¼€å¯ç”¨çš„è´è¶å›¾IBMQ
5-qubitèŠ¯ç‰‡ä¸Šå®ç°æ‰€è€ƒè™‘çš„$\text{MAXCUT}$é—®é¢˜ã€‚è¯¥å›¾å°†åœ¨ä¸‹æ–‡ä¸­å®šä¹‰ï¼Œå…¶å¯¹åº”äºè®¾å¤‡çš„æœ¬åœ°è¿é€šæ€§ã€‚è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿå®ç°çš„åŸå§‹ç‰ˆæœ¬$\text{QAOA}$ç®—æ³•,å…¶ä¸­ä»£ä»·å‡½æ•°$C$å’Œå“ˆå¯†é¡¿é‡$H$ç”¨äºç”Ÿæˆä¸€è‡´çš„çŠ¶æ€ã€‚æ­¤å¤–ï¼Œå¯¹äºè¿™æ ·ä¸€ä¸ªç®€å•çš„å›¾ï¼Œç²¾ç¡®çš„ä»£ä»·å‡½æ•°å¯ä»¥è§£æåœ°è®¡ç®—å‡ºæ¥ï¼Œä»è€Œé¿å…äº†ä¸æ–­å˜åŒ–åœ°å¯»æ‰¾æœ€ä¼˜å‚æ•°çš„éœ€æ±‚\[7\]ã€‚ä¸ºäº†å®ç°è¿™ä¸ªå›è·¯ï¼Œæˆ‘ä»¬éµå¾ªQiskitæ–‡æ¡£ä¸­çš„ç¬¦å·å’Œé‡å­é—¨çš„å®šä¹‰ã€‚

ç¬¬ä¸€æ­¥åŠ è½½Qiskitå’Œå…¶ä»–PythonåŒ…ã€‚

> %matplotlib inline
>
> \# useful additional packages
>
> \#import math tools
>
> import numpy as np
>
> \# We import the tools to handle general Graphs
>
> import networkx as nx
>
> \# We import plotting tools
>
> import matplotlib.pyplot as plt
>
> from matplotlib import cm
>
> from matplotlib.ticker import LinearLocator, FormatStrFormatter
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images look
> nice
>
> \# importing Qiskit
>
> from qiskit import Aer, IBMQ
>
> from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit,
> execute
>
> from qiskit.providers.ibmq import least_busy
>
> from qiskit.tools.monitor import job_monitor
>
> from qiskit.visualization import plot_histogram

##### 5.1 é—®é¢˜å®šä¹‰

æˆ‘ä»¬æ ¹æ®è¶…å¯¼èŠ¯ç‰‡çš„è¶å½¢å›¾å®šä¹‰ä»£ä»·å‡½æ•°ã€‚è¯¥å›¾å…·æœ‰$n = 5$ä¸ªé¡¶ç‚¹$V = \{ 0,1,2,3,4\}$å’Œå…­ä¸ªè¾¹$E = \{(0,1),(0,2),(1,2),(3,2),(3,4),(4,2)\}$ï¼Œä¸”å…·æœ‰ç›¸åŒçš„å•ä½æƒé‡$w_{\text{ij}} = 1$ã€‚æˆ‘ä»¬åŠ è½½ä¸€ä¸ªé™„åŠ çš„ç½‘ç»œç¨‹åºåŒ…ä»¥å¯¹å›¾å½¢è¿›è¡Œç¼–ç å¹¶ç»˜åˆ¶è¿æ¥æ€§ã€‚

> \# Generating the butterfly graph with 5 nodes
>
> n = 5
>
> V = np.arange(0,n,1)
>
> E =\[(0,1,1.0),(0,2,1.0),(1,2,1.0),(3,2,1.0),(3,4,1.0),(4,2,1.0)\]
>
> G = nx.Graph()
>
> G.add_nodes_from(V)
>
> G.add_weighted_edges_from(E)
>
> \# Generate plot of the Graph
>
> colors = \[\'r\' for node in G.nodes()\]
>
> default_axes = plt.axes(frameon=True)
>
> pos = nx.spring_layout(G)
>
> nx.draw_networkx(G, node_color=colors, node_size=600, alpha=1,
> ax=default_axes, pos=pos)
>
> è¾“å‡ºï¼š

![](pics/media/image290.png)

##### 5.2 æœ€ä¼˜åˆ¤åˆ«æ€å‚æ•°

è¿™æœ¬ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬è€ƒè™‘$p = 1$çš„æƒ…å†µï¼Œæ¯”å¦‚ï¼šä»…åŒ…å«ä¸€å±‚é‡å­é—¨ã€‚æœŸæœ›å€¼$F_{1}(\gamma,\beta) = \langle\psi_{1}(\beta,\gamma)|H|\psi_{1}(\beta,\gamma)\rangle$å¯é€šè¿‡æ­¤ç®€å•è®¾ç½®è¿›è¡Œè§£æè®¡ç®—ã€‚ç„¶åæ˜ç¡®åœ°è®¨è®ºå®ç°å“ˆå¯†é¡¿é‡$H = \sum_{(j,k) \in E}^{}{\frac{1}{2}(1 - Z_{i}Z_{k})}$çš„æ­¥éª¤ã€‚ç”±äºæ˜¯çº¿æ€§æœŸæœ›å€¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ†åˆ«è®¡ç®—è¾¹çš„æœŸæœ›å€¼ï¼š

$f_{(i,k)}(\beta,\alpha) = \langle\psi_{1}(\gamma,\beta)|\frac{1}{2}(1 - Z_{i}Z_{k})|\psi_{1}(\gamma,\beta)\rangle$ã€‚

å¯¹äºä¸Šé¢æ‰€åšçš„è´è¶å›¾ï¼Œå¯è§‚å¯Ÿåˆ°åªæœ‰ä¸¤ç§è¾¹$A = \{(0,1),(3,4)\}$å’Œ$B = \{(0,2),(1,2),(2,3),(2,4)\}$ã€‚åœ¨$A$ä¸­çš„è¾¹ä»…æœ‰ä¸¤ä¸ªé‚»è¾¹ï¼Œè€Œ$B$ä¸­çš„è¾¹æœ‰4ä¸ªé‚»è¾¹ã€‚å¯ç¡®è®¤ï¼šç”±äºå…¶ä»–è¾¹çš„æœŸæœ›å€¼ç›¸åŒï¼Œæˆ‘ä»¬åªéœ€è®¡ç®—æ¯ä¸ªé›†åˆä¸­å•ä¸ªè¾¹çš„æœŸæœ›å€¼ã€‚å…¶æ„ä¹‰ä¸ºï¼šé€šè¿‡ä»…è®¡ç®—ä¸¤ä¸ªæœŸæœ›å€¼å°±å¯ä»¥ç®—å‡º$F_{1}(\gamma,\beta) = 2f_{A}(\gamma,\beta) + 4f_{B}(\gamma,\beta)$ã€‚æ³¨æ„ï¼æŒ‰ç…§ç¬¬4.2.2èŠ‚ä¸­æ‰€è¿°çš„è®ºæ®ï¼Œæ‰€æœ‰ä¸ä¸Pauliç®—å­$Z_{0}Z_{1}$æˆ–$Z_{0}Z_{2}$ç›¸äº¤çš„é‡å­é—¨éƒ½è¿›è¡Œäº†å¯¹æ˜“å’ŒæŠµæ¶ˆï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦è®¡ç®—ï¼š

$$f_{A}(\gamma,\beta) = \frac{1}{2}(1 - \langle +^{3}|U_{21}(\gamma)U_{02}(\gamma)U_{01}(\gamma)X_{0}(\beta)X_{1}$$

$$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\beta)Z_{0}Z_{1}X_{1}^{\dagger}(\beta)X_{0}^{\dagger}(\beta)U_{01}^{\dagger}(\gamma)U_{02}^{\dagger}(\gamma)U_{12}^{\dagger}(\gamma)| +^{3}\rangle)$$

å’Œ

$$f_{B}(\gamma,\beta) = \frac{1}{2}(1 - \langle +^{5}|U_{21}(\gamma)U_{24}(\gamma)U_{23}(\gamma)U_{01}(\gamma)U_{02}(\gamma)X_{0}(\beta)X_{2}(\beta)$$

$$\text{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Z}_{0}Z_{2}X_{0}^{\dagger}(\beta)X_{2}^{\dagger}(\beta)U_{02}^{\dagger}(\gamma)U_{01}^{\dagger}(\gamma)U_{12}^{\dagger}(\gamma)U_{23}^{\dagger}(\gamma)U_{24}^{\dagger}(\gamma)| +^{5}\rangle)$$

è¿™äº›æœŸæœ›å€¼çš„å¤æ‚ç¨‹åº¦é€šå¸¸ä»…å–å†³äºæ‰€è€ƒè™‘å›¾çš„é˜¶æ•°ï¼Œå¹¶ä¸”å¦‚æœé˜¶æ•°æ˜¯æœ‰ç•Œçš„ï¼Œåˆ™ä¸æ•´ä¸ªå›¾çš„è§„æ¨¡æ— å…³ã€‚ä½¿ç”¨$U_{k,l}(\gamma) = \exp\frac{\text{iÎ³}}{2}(1 - Z_{k}Z_{l})$ä¸$X_{k}(\beta) = \exp(i\beta X_{k})$å¯¹è¿™ä¸€è¡¨è¾¾å¼ç›´æ¥æ±‚å€¼åç”Ÿæˆï¼š

$$f_{A}(\gamma,\beta) = \frac{1}{2}(sin(4\gamma)sin(4\beta) + sin^{2}(2\beta)sin^{2}(2\gamma))$$

å’Œ

$$f_{B}(\gamma,\beta) = \frac{1}{2}(1 - sin^{2}(2\beta)sin^{2}(2\gamma)cos^{2}(4\gamma) - \frac{1}{4}sin(4\beta)sin(4\gamma)(1 + cos^{2}(4\gamma)))$$

ç°åœ¨å¯ä»¥å¦‚ä¸Šæ–‡æ‰€è¿°ç»„åˆè¿™äº›ç»“æœï¼Œå› æ­¤æœŸæœ›å€¼ç”±ä¸‹å¼ç»™å‡ºã€‚

$$F_{1}(\gamma,\beta) = 3 - (sin^{2}(2\beta)sin^{2}(2\gamma) - \frac{1}{2}sin(4\beta)sin(4\gamma))(1 + cos^{2}(4\gamma)),$$

æˆ‘ä»¬å¯¹å‡½æ•°$F_{1}(\gamma,\beta)$è¿›è¡Œä½œå›¾ï¼Œå¹¶ä½¿ç”¨ç®€å•çš„ç½‘æ ¼æœç´¢æ¥æ‰¾åˆ°ä½¿æœŸæœ›å€¼æœ€å¤§çš„å‚æ•°$(\gamma^{*},\beta^{*})$ã€‚

> \# Evaluate the function
>
> step_size = 0.1;
>
> a_gamma = np.arange(0, np.pi, step_size)
>
> a_beta = np.arange(0, np.pi, step_size)
>
> a_gamma, a_beta = np.meshgrid(a_gamma,a_beta)
>
> F1 =
> 3-(np.sin(2\*a_beta)\*\*2\*np.sin(2\*a_gamma)\*\*2-0.5\*np.sin(4\*a_beta)\*np.sin(4\*a_gamma))\*(1+np.cos(4\*a_gamma)\*\*2)
>
> \# Grid search for the minimizing variables
>
> result = np.where(F1 == np.amax(F1))
>
> a = list(zip(result\[0\],result\[1\]))\[0\]
>
> gamma = a\[0\]\*step_size;
>
> beta = a\[1\]\*step_size;
>
> \# Plot the expetation value F1
>
> fig = plt.figure()
>
> ax = fig.gca(projection=\'3d\')
>
> surf = ax.plot_surface(a_gamma, a_beta, F1, cmap=cm.coolwarm,
> linewidth=0, antialiased=True)
>
> ax.set_zlim(1,4)
>
> ax.zaxis.set_major_locator(LinearLocator(3))
>
> ax.zaxis.set_major_formatter(FormatStrFormatter(\'%.02f\'))
>
> plt.show()
>
> \#The smallest parameters and the expectation can be extracted
>
> print(\'\\n \-\-- OPTIMAL PARAMETERS \-\-- \\n\')
>
> print(\'The maximal expectation value is: M1 = %.03f\' % np.amax(F1))
>
> print(\'This is attained for gamma = %.03f and beta = %.03f\' %
> (gamma,beta))

è¾“å‡ºï¼š

![](pics/media/image291.png)

> \-\-- OPTIMAL PARAMETERS \-\--
>
> The maximal expectation value is: M1 = 3.431
>
> This is attained for gamma = 1.900 and beta = 0.200

##### 5.3 é‡å­å›è·¯

é€šè¿‡è¿™äº›å‚æ•°ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥æ„é€ å›è·¯ï¼Œä¸ºä¸Šé—®æ‰€è¿°é¡¶ç‚¹é›†$V = \{ 0,1,2,3,4\}$å’Œè¾¹$E = \{(0,1),(0,2),(1,2),(3,2),(3,4),(4,2)\}$çš„å›¾æˆ–å›¾$G = (Vï¼ŒE)$å‡†å¤‡åˆ¤åˆ«æ€ã€‚è¯¥å›è·¯éœ€è¦$n = 5$ä¸ªé‡å­æ¯”ç‰¹ï¼Œä¸”æˆ‘ä»¬å°†è¦å‡†å¤‡æ€

$|\psi_{1}(\gamma,\beta)\rangle = e^{- i\beta B}e^{- i\gamma H}| + \rangle^{n}$ã€‚

å›æƒ³ç”±$B = \sum_{k \in V}^{}X_{k}$å’Œ$H = \sum_{(k,m) \in E}^{}{\frac{1}{2}(1 - Z_{k}Z_{m})}$ç»™å‡ºçš„é¡¹ã€‚æŒ‰ç…§å¦‚ä¸‹æ­¥éª¤ç”Ÿæˆè¿™ä¸€å›è·¯ï¼š

-   é¦–å…ˆï¼Œå®ç°5ä¸ª$H$é—¨æ¥ç”Ÿæˆç»Ÿä¸€çš„å åŠ æ€ã€‚

-   æ¥ç€ï¼Œæ²¿è¾¹$(k,l) \in E$å®ç°å…·æœ‰è§’åº¦$\gamma$çš„6ä¸ªIsingå‹é‡å­é—¨$U_{k,l}(\gamma)$ã€‚è¯¥é‡å­é—¨å¯ä»¥ç”¨åŸç”Ÿçš„Qiskité‡å­é—¨è¡¨ç¤ºï¼š

$$U_{k,l}(\gamma) = C_{u1}( - 2\gamma)_{k,l}u1(\gamma)_{k}u1(\gamma)_{l}$$

-   ç„¶åï¼Œå¯¹å…·æœ‰è§’åº¦$\beta$çš„æ¯ä¸ªé¡¶ç‚¹$k \in V$ä¸­å•ä¸ªé‡å­æ¯”ç‰¹$X$æ–½åŠ æ—‹è½¬$X_{k}(\beta)$ã€‚è¯¥é‡å­é—¨åœ¨Qiskitä¸­ç›´æ¥å‚æ•°åŒ–ä¸º$X_{k}(\beta) = R_{x}(2\beta)_{k}$ã€‚

-   æœ€åï¼Œåœ¨è®¡ç®—åŸºä¸Šæµ‹é‡è¿™äº›é‡å­æ¯”ç‰¹ï¼Œå³æ‰§è¡Œğ‘-æµ‹é‡å¹¶è®°å½•æ‰€å¾—çš„æ¯”ç‰¹ä¸²$x \in \{ 0,1\}^{5}$ã€‚

> \# prepare the quantum and classical resisters
>
> QAOA = QuantumCircuit(len(V), len(V))
>
> \# apply the layer of Hadamard gates to all qubits
>
> QAOA.h(range(len(V)))
>
> QAOA.barrier()
>
> \# apply the Ising type gates with angle gamma along the edges in E
>
> for edge in E:
>
> k = edge\[0\]
>
> l = edge\[1\]
>
> QAOA.cu1(-2\*gamma, k, l)
>
> QAOA.u1(gamma, k)
>
> QAOA.u1(gamma, l)
>
> \# then apply the single qubit X - rotations with angle beta to all
> qubits
>
> QAOA.barrier()
>
> QAOA.rx(2\*beta, range(len(V)))
>
> \# Finally measure the result in the computational basis
>
> QAOA.barrier()
>
> QAOA.measure(range(len(V)),range(len(V)))
>
> \#\#\# draw the circuit for comparison
>
> QAOA.draw(output=\'mpl\')
>
> è¾“å‡ºï¼š

![](pics/media/image292.png)

##### 5.4 ä»£ä»·å‡½æ•°æ±‚å€¼

æœ€åï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªä¾‹ç¨‹æ¥æ ¹æ®æ¯”ç‰¹ä¸²è®¡ç®—ä»£ä»·å‡½æ•°çš„å€¼ã€‚è¿™æ˜¯å†³å®šæˆ‘ä»¬æ˜¯å¦æ‰¾åˆ°"è‰¯å¥½å€™é€‰"æ¯”ç‰¹ä¸²$x$çš„å¿…è¦æ¡ä»¶ï¼Œä½†ä¹Ÿå¯ä»¥ç”¨äºåœ¨æ— æ³•ç›´æ¥æ±‚æœŸæœ›å€¼çš„æƒ…å†µä¸‹ä¼°è®¡æœŸæœ›å€¼$F_{1}(\gamma,\beta)$ã€‚

> \# Compute the value of the cost function
>
> def cost_function_C(x,G):
>
> E = G.edges()
>
> if( len(x) != len(G.nodes())):
>
> return np.nan
>
> C = 0;
>
> for index in E:
>
> e1 = index\[0\]
>
> e2 = index\[1\]
>
> w = G\[e1\]\[e2\]\[\'weight\'\]
>
> C = C + w\*x\[e1\]\*(1-x\[e2\]) + w\*x\[e2\]\*(1-x\[e1\])
>
> return C

###### 5a. åœ¨æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡ŒQAOA

æˆ‘ä»¬é¦–å…ˆåœ¨æœ¬åœ°çš„QASMæ¨¡æ‹Ÿå™¨ä¸Šè¿è¡Œè¯¥ç®—æ³•ã€‚

> \# run on local simulator
>
> backend = Aer.get_backend(\"qasm_simulator\")
>
> shots = 10000
>
> simulate = execute(QAOA, backend=backend, shots=shots)
>
> QAOA_results = simulate.result()
>
> plot_histogram(QAOA_results.get_counts(),figsize = (8,6),bar_labels =
> False)

è¾“å‡ºï¼š

![](pics/media/image293.png)

####### è¯„ä¼°æ¨¡æ‹Ÿæ•°æ®

ç°åœ¨ä»æ¨¡æ‹Ÿæ•°æ®ä¸­è®¡ç®—ç›¸å…³ä¿¡æ¯ã€‚æˆ‘ä»¬å°†ä½¿ç”¨è·å¾—çš„ç»“æœæ¥ï¼š

-   è®¡ç®—å¹³å‡èƒ½é‡å¹¶æ£€æŸ¥å…¶æ˜¯å¦ä¸ç†è®ºé¢„æµ‹ç›¸ç¬¦

-   æŠ¥å‘Šå…·æœ‰æœ€å¤§è§‚æµ‹çš„ä»£ä»·å‡½æ•°$C(x^{*})$çš„é‡‡æ ·æ¯”ç‰¹ä¸²$x^{*}$

-   é€šè¿‡ç»˜åˆ¶èƒ½é‡ç›´æ–¹å›¾æŸ¥çœ‹å…¶æ˜¯å¦ç¡®å®é›†ä¸­åœ¨é¢„æµ‹å‡å€¼å‘¨å›´

> \# Evaluate the data from the simulator
>
> counts = QAOA_results.get_counts()
>
> avr_C = 0
>
> max_C = \[0,0\]
>
> hist = {}
>
> for k in range(len(G.edges())+1):
>
> hist\[str(k)\] = hist.get(str(k),0)
>
> for sample in list(counts.keys()):
>
> \# use sampled bit string x to compute C(x)
>
> x = \[int(num) for num in list(sample)\]
>
> tmp_eng = cost_function_C(x,G)
>
> \# compute the expectation value and energy distribution
>
> avr_C = avr_C + counts\[sample\]\*tmp_eng
>
> hist\[str(round(tmp_eng))\] = hist.get(str(round(tmp_eng)),0) +
> counts\[sample\]
>
> \# save best bit string
>
> if( max_C\[1\] \< tmp_eng):
>
> max_C\[0\] = sample
>
> max_C\[1\] = tmp_eng
>
> M1_sampled = avr_C/shots
>
> print(\'\\n \-\-- SIMULATION RESULTS \-\--\\n\')
>
> print(\'The sampled mean value is M1_sampled = %.02f while the true
> value is M1 = %.02f \\n\' % (M1_sampled,np.amax(F1)))
>
> print(\'The approximate solution is x\* = %s with C(x\*) = %d \\n\' %
> (max_C\[0\],max_C\[1\]))
>
> print(\'The cost function is distributed as: \\n\')
>
> plot_histogram(hist,figsize = (8,6),bar_labels = False)
>
> \-\-- SIMULATION RESULTS \-\--
>
> The sampled mean value is M1_sampled = 3.29 while the true value is M1
> = 3.43
>
> The approximate solution is x\* = 00101 with C(x\*) = 4
>
> The cost function is distributed as:

![](pics/media/image294.png)

###### 5b. åœ¨çœŸå®è®¾å¤‡ä¸Šè¿è¡ŒQAOA

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä¼šçœ‹åˆ°å¦‚ä½•åœ¨çœŸå®è®¾å¤‡çš„åç«¯è¿è¡ŒåŒæ ·çš„å›è·¯ã€‚

> \# Use the IBMQ essex device
>
> provider = IBMQ.load_account()
>
> backend = provider.get_backend(\'ibmq_essex\')
>
> shots = 2048
>
> job_exp = execute(QAOA, backend=backend, shots=shots)
>
> job_monitor(job_exp)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> exp_results = job_exp.result()
>
> plot_histogram(exp_results.get_counts(),figsize = (10,8),bar_labels =
> False)
>
> è¾“å‡ºï¼š

![](pics/media/image295.png)

####### è¯„ä¼°å®éªŒæ•°æ®

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥é‡å¤ä¹‹å‰ç›¸åŒçš„åˆ†æå¹¶æ¯”è¾ƒå®éªŒç»“æœã€‚

> \# Evaluate the data from the experiment
>
> counts = exp_results.get_counts()
>
> avr_C = 0
>
> max_C = \[0,0\]
>
> hist = {}
>
> for k in range(len(G.edges())+1):
>
> hist\[str(k)\] = hist.get(str(k),0)
>
> for sample in list(counts.keys()):
>
> \# use sampled bit string x to compute C(x)
>
> x = \[int(num) for num in list(sample)\]
>
> tmp_eng = cost_function_C(x,G)
>
> \# compute the expectation value and energy distribution
>
> avr_C = avr_C + counts\[sample\]\*tmp_eng
>
> hist\[str(round(tmp_eng))\] = hist.get(str(round(tmp_eng)),0) +
> counts\[sample\]
>
> \# save best bit string
>
> if( max_C\[1\] \< tmp_eng):
>
> max_C\[0\] = sample
>
> max_C\[1\] = tmp_eng
>
> M1_sampled = avr_C/shots
>
> print(\'\\n \-\-- EXPERIMENTAL RESULTS \-\--\\n\')
>
> print(\'The sampled mean value is M1_sampled = %.02f while the true
> value is M1 = %.02f \\n\' % (M1_sampled,np.amax(F1)))
>
> print(\'The approximate solution is x\* = %s with C(x\*) = %d \\n\' %
> (max_C\[0\],max_C\[1\]))
>
> print(\'The cost function is distributed as: \\n\')
>
> plot_histogram(hist,figsize = (8,6),bar_labels = False)
>
> \-\-- EXPERIMENTAL RESULTS \-\--
>
> The sampled mean value is M1_sampled = 3.14 while the true value is M1
> = 3.43
>
> The approximate solution is x\* = 00101 with C(x\*) = 4
>
> The cost function is distributed as:

![](pics/media/image296.png)

#### 6. ç»ƒä¹ 

1.QAOAç®—æ³•ä¼šç”Ÿæˆä¸€ä¸ªæ¯”ç‰¹ä¸²ï¼Œæ­¤æ¯”ç‰¹ä¸²æ˜¯å¦æ˜¯è¯¥å›¾çš„æœ€ä¼˜è§£ï¼Ÿå°†è¶…å¯¼èŠ¯ç‰‡çš„å®éªŒç»“æœä¸æœ¬åœ°QASMä»¿çœŸçš„ç»“æœè¿›è¡Œæ¯”è¾ƒã€‚

2.æˆ‘ä»¬å·²ç»åœ¨5.2èŠ‚ä¸­åˆ†æäº†ä»£ä»·å‡½æ•°$F_{1}$ã€‚éªŒè¯æ­¥éª¤å¹¶è®¡ç®—$f_{A}(\gamma,\beta)$å’Œ$f_{B}(\gamma,\beta)$ã€‚

3.åœ¨Qiskitå®ç°ä¸­ä¸º$F_{1}$ç»™å‡ºäº†ç²¾ç¡®çš„è¡¨è¾¾å¼ï¼š

\-
ç¼–å†™ä¸€ä¸ªä¾‹ç¨‹ä»¥ä¾¿ä»ç»“æœæ‰€è·å¾—æ ·æœ¬ä¸­ä¼°è®¡æœŸæœ›å€¼$F_{1}(\gamma,\beta)$ï¼ˆæç¤ºï¼šä½¿ç”¨ç¬¬5.4èŠ‚ä¸­çš„å‡½æ•°function
cost_function_C(x,G)å’Œç¬¬5.a/5.bèŠ‚ä¸­çš„æ•°æ®è¯„ä¼°ï¼‰ã€‚

\-
ä½¿ç”¨ä¼˜åŒ–ä¾‹ç¨‹ï¼Œä¾‹å¦‚æœ¬æ•™ç¨‹VQEç¤ºä¾‹ä¸­çš„SPSAï¼Œä»¥æ•°å­—æ–¹å¼ä¼˜åŒ–é‡‡æ ·çš„$F_{1}(\gamma,\beta)$ä¸­çš„å‚æ•°ã€‚æ˜¯å¦æ‰¾åˆ°ä¸$\gamma^{*},\beta^{*}$ç›¸åŒçš„å€¼ï¼Ÿ

4\. ç¬¬5.3èŠ‚ä¸­çš„åˆ¤åˆ«å›è·¯å¯¹åº”äºæ·±åº¦$p = 1$ï¼Œå…¶ç›´æ¥ç›®çš„æ˜¯ä¸ç¡¬ä»¶å…¼å®¹ã€‚

\-
ä½¿ç”¨ç»ƒä¹ 2ä¸­çš„ä¾‹ç¨‹è¯„ä¼°$p = 2,3$çš„ä»£ä»·å‡½æ•°$F_{p}(\gamma,\beta)$ã€‚æ‚¨å¸Œæœ›åœ¨å®é™…çš„ç¡¬ä»¶ä¸­çœ‹åˆ°ä»€ä¹ˆï¼Ÿ

\- å°†æ­¤ç±»åˆ¤åˆ«æ€æ¨å¹¿åˆ°å…¶ä»–å€™é€‰æ³¢åŠ¨å‡½æ•°ï¼Œä¾‹å¦‚å‚è€ƒæ–‡çŒ®4ä¸­çš„ç¡¬ä»¶é«˜æ•ˆæ‹Ÿè®¾ã€‚

5.æ€è€ƒç¤ºä¾‹éƒ¨åˆ†ä¸­æ‰€è®¨è®ºçš„$\text{MAX}3 - \text{SAT}$ï¼Œå¹¶å°†å…¶ä¿®æ”¹ä¸º5.4èŠ‚ä¸­ç”¨äºè®¡ç®—$F_{p}$çš„çš„å‡½æ•°cost_function_C(c,G)ã€‚ä½¿ç”¨ç¡¬ä»¶é«˜æ•ˆç®—æ³•ä¸º$\text{MAX}3 - \text{SAT}$å®ä¾‹è¿è¡ŒQAOAç®—æ³•å¹¶åˆ†æç»“æœã€‚

#### 7. å‚è€ƒæ–‡çŒ®

1.  Garey, Michael R.; David S. Johnson (1979). Computers and
    > Intractability: A Guide to the Theory of NP-Completeness. W. H.
    > Freeman. ISBN 0-7167-1045-5

2.  Goemans, Michel X., and David P. Williamson.Â [Journal of the ACM
    > (JACM) 42.6 (1995):
    > 1115-1145](http://www-math.mit.edu/~goemans/PAPERS/maxcut-jacm.pdf).

3.  Farhi, Edward, Jeffrey Goldstone, and Sam Gutmann. \"A quantum
    > approximate optimization algorithm.\" arXiv
    > preprintÂ [arXiv:1411.4028 (2014)](https://arxiv.org/abs/1411.4028).

4.  Kandala, Abhinav, et al. \"Hardware-efficient variational quantum
    > eigensolver for small molecules and quantum magnets.\"Â [Nature
    > 549.7671 (2017):
    > 242](https://www.nature.com/articles/nature23879).

5.  Farhi, Edward, et al. \"Quantum algorithms for fixed qubit
    > architectures.\" arXiv
    > preprintÂ [arXiv:1703.06199 (2017)](https://arxiv.org/abs/1703.06199).

6.  Spall, J. C. (1992),Â [IEEE Transactions on Automatic Control, vol.
    
> 37(3), pp. 332--341](https://ieeexplore.ieee.org/document/119632).
    
7.  Michael Streif and Martin Leib \"Training the quantum approximate
    > optimization algorithm without access to a quantum processing
    > unit\" (2020)Â [Quantum Sci. Technol. 5
    > 034008](https://doi.org/10.1088/2058-9565/ab8c2b)

### 4.1.4 ç”¨Groverç®—æ³•è§£å†³å¯æ»¡è¶³æ€§é—®é¢˜

åœ¨æœ¬èŠ‚ä¸­ï¼Œå°†æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨Qiskit Aquaä¸­çš„Groverç®—æ³•å®ç°è§£å†³å¯æ»¡è¶³æ€§é—®é¢˜ã€‚

#### 1.ç®€ä»‹

åœ¨æœ¬æ•™ç¨‹çš„æ—©å…ˆéƒ¨åˆ†ä»‹ç»äº†Groverçš„éç»“æ„åŒ–æœç´¢ç®—æ³•ï¼Œå¹¶ç»™å‡ºäº†ä½¿ç”¨Qiskit
Terraçš„ç¤ºä¾‹å’Œå®ç°ã€‚æˆ‘ä»¬çœ‹åˆ°Groveræœç´¢æ˜¯ä¸€ç§é‡å­ç®—æ³•ï¼Œæ¯”å¯¹åº”çš„ä¼ ç»Ÿç®—æ³•æœç´¢å‡ºæ­£ç¡®è§£çš„é€Ÿåº¦å¿«ä¸¤å€ã€‚æ­¤å¤„ï¼Œæˆ‘ä»¬å°†è¯´æ˜ä½¿ç”¨Groverç®—æ³•æ¥è§£å†³ä¸€ä¸ªç‰¹æ®Šçš„ç»„åˆå¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜ï¼ˆBoolean
Satisfiability Problemï¼‰ã€‚

åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œå¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜æ˜¯ç¡®å®šæ˜¯å¦å­˜åœ¨æ»¡è¶³ç»™å®šå¸ƒå°”å…¬å¼è§£é‡Šçš„é—®é¢˜ã€‚æ¢å¥è¯è¯´ï¼Œè¯¥é—®é¢˜è¯¢é—®ç»™å®šå¸ƒå°”å…¬å¼çš„å˜é‡æ˜¯å¦å¯ä»¥ä¸€è‡´åœ°è¢«TRUEæˆ–FALSEå€¼æ›¿æ¢ï¼Œä»è€Œä½¿å…¬å¼çš„è®¡ç®—ç»“æœä¸ºTRUEã€‚è‹¥æ˜¯è¿™ç§æƒ…å†µï¼Œåˆ™è¿™ä¸€å…¬å¼è¢«ç§°ä¸ºå¯æ»¡è¶³ã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„èµ‹å€¼ï¼Œåˆ™å…¬å¼æ‰€è¡¨ç¤ºçš„å‡½æ•°å¯¹äºæ‰€æœ‰å¯èƒ½çš„å˜é‡èµ‹å€¼éƒ½ä¸ºFALSEï¼Œä¸”å…¬å¼ä¸å¯æ»¡è¶³ã€‚è¿™å°±å¯ä»¥å°†å…¶çœ‹ä½œæ˜¯ä¸€ä¸ªæœç´¢é—®é¢˜ï¼Œå…¶è§£æ˜¯æ»¡è¶³å¸ƒå°”å…¬å¼çš„èµ‹å€¼ã€‚

#### 2. 3-å¯æ»¡è¶³æ€§é—®é¢˜

3-å¯æ»¡è¶³æ€§é—®é¢˜ï¼ˆ3SATï¼‰å¯é€šè¿‡ä¸€ä¸‹å…·ä½“é—®é¢˜æ¥è§£é‡Šã€‚è€ƒè™‘å…·æœ‰ä¸‰ä¸ªå¸ƒå°”å˜é‡$v_{1}$ï¼Œ$v_{2}$ï¼Œ$v_{3}$çš„å¸ƒå°”å‡½æ•°$f$ï¼š

$$f(v_{1},v_{2},v_{3}) = (\neg v_{1} \vee \neg v_{2} \vee \neg v_{3}) \land (v_{1} \vee \neg v_{2} \vee v_{3}) \land (v_{1} \vee v_{2} \vee \neg v_{3}) \land (v_{1} \vee \neg v_{2} \vee \neg v_{3}) \land (\neg v_{1} \vee v_{2} \vee v_{3})$$

åœ¨ä¸Šé¢çš„å‡½æ•°ä¸­ï¼Œæ–¹ç¨‹å³ä¾§å¤„äºæ‹¬å·ï¼ˆï¼‰ä¸­çš„é¡¹ç§°ä¸ºå­å¥ï¼›è¯¥å‡½æ•°å…·æœ‰5ä¸ªå­å¥ã€‚ä½œä¸º3SATé—®é¢˜ï¼Œæ¯ä¸ªå­å¥æ°å¥½å…·æœ‰ä¸‰ä¸ªæ–‡å­—ã€‚æ¯”å¦‚ï¼Œç¬¬ä¸€ä¸ªå­å¥ä¸­$\neg v_{1}$ï¼Œ$\neg v_{2}$å’Œ$\neg v_{3}$å°±æ˜¯å…¶æ–‡å­—ã€‚ç¬¦å·$\neg$æ˜¯å¸ƒå°”è¿ç®—ä¸­çš„NOTï¼Œå…¶ä½œç”¨æ˜¯æŠµæ¶ˆï¼ˆæˆ–ç¿»è½¬ï¼‰å…¶åç»§æ–‡å­—çš„å€¼ã€‚ç¬¦å·$\vee$å’Œ$\land$åˆ†åˆ«å¯¹åº”äºå¸ƒå°”è¿ç®—ä¸­çš„ORå’ŒANDã€‚å¦‚æœå­˜åœ¨$v_{1}$ï¼Œ$v_{2}$ï¼Œ$v_{3}$çš„èµ‹å€¼å¾—å‡º$f(v_{1},v_{2},v_{3}) = 1$ï¼ˆå³$f$å¾—å‡ºTrueï¼‰ï¼Œåˆ™è¯¥å¸ƒå°”å‡½æ•°$f$æ»¡è¶³è¦æ±‚ã€‚

æŸ¥æ‰¾æ­¤ç±»æ’å¸ƒçš„ä¸€ç§ç®€å•æ–¹æ³•æ˜¯å°è¯•å¸ƒå°”å‡½æ•°$f$è¾“å…¥å€¼çš„æ‰€æœ‰å¯èƒ½ç»„åˆã€‚ä¸‹è¡¨æ˜¯$v_{1}$ï¼Œ$v_{2}$ï¼Œ$v_{3}$æ‰€æœ‰å¯èƒ½ç»„åˆçš„è¡¨ã€‚ä¸ºäº†ä¾¿äºè¯´æ˜ï¼Œæˆ‘ä»¬å®šä¹‰$0 = \text{False}$ï¼Œä»¥åŠ$1 = True$ã€‚

| $v_{1}$ | $v_{2}$ | $v_{3}$ | $f$ | **Comment**                       |
| --------- | --------- | --------- | ----- | --------------------------------- |
| 0         | 0         | 0         | 1     | Solution                          |
| 0         | 0         | 1         | 0     | Not a solution because ğ‘“ is False |
| 0         | 1         | 0         | 0     | Not a solution because ğ‘“ is False |
| 0         | 1         | 1         | 0     | Not a solution because ğ‘“ is False |
| 1         | 0         | 0         | 0     | Not a solution because ğ‘“ is False |
| 1         | 0         | 1         | 1     | Solution                          |
| 1         | 1         | 0         | 1     | Solution                          |
| 1         | 1         | 1         | 0     | Not a solution because ğ‘“ is False |


ä»ä¸Šé¢çš„è¡¨æ ¼ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ­¤3-SATé—®é¢˜å®ä¾‹å…·æœ‰ä¸‰ä¸ªå¯æ»¡è¶³çš„è§£å†³æ–¹æ¡ˆï¼š$(v_{1},v_{2},v_{3}) = (T,F,T)$æˆ–$(F,F,F)$æˆ–$(T,T,F)$ã€‚

é€šå¸¸æ¥è¯´ï¼Œå¸ƒå°”å‡½æ•°$f$å¯ä»¥å…·æœ‰è®¸å¤šå­å¥å’Œå¸ƒå°”å˜é‡ã€‚å¯ä»¥çœ‹åˆ°3SATé—®é¢˜å§‹ç»ˆå¯ä»¥ç”¨åˆå–èŒƒå¼ï¼ˆCNFï¼šConjunctive
Normal
Formï¼‰æ¥å†™ï¼Œå³ä¸€ä¸ªæˆ–å¤šä¸ªå­å¥çš„è¿æ¥ï¼Œå…¶ä¸­ä¸€ä¸ªå­å¥æ˜¯ä¸‰ä¸ªæ–‡å­—çš„æå–ï¼ˆdisjunctionï¼‰ï¼›å¦åˆ™å…¶å°±æ˜¯3ä¸ªORçš„ANDã€‚

#### 3. Qiskitå®ç°

ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨Qikitçš„Aquaæ¥æ±‚è§£3SATé—®é¢˜ï¼š

$$f(v_{1},v_{2},v_{3}) = (\neg v_{1} \vee \neg v_{2} \vee \neg v_{3}) \land (v_{1} \vee \neg v_{2} \vee v_{3}) \land (v_{1} \vee v_{2} \vee \neg v_{3}) \land (v_{1} \vee \neg v_{2} \vee \neg v_{3}) \land (\neg v_{1} \vee v_{2} \vee v_{3})$$

é¦–å…ˆéœ€è¦äº†è§£Qiskitçš„Aquaä¸­ç”¨äºè§£å†³æ­¤é—®é¢˜çš„è¾“å…¥[DIMACS
CNF](http://www.satcompetition.org/2009/format-benchmarks2009.html)æ ¼å¼ï¼Œç±»ä¼¼äºä»¥ä¸‹å†…å®¹ï¼š

c example DIMACS CNF 3-SAT

p cnf 3 5

-1 -2 -3 0

1 -2 3 0

1 2 -3 0

1 -2 -3 0

-1 2 3 0

-   ä»¥cå¼€å¤´çš„è¡Œæ˜¯æ³¨é‡Š

```{=html}
<!-- -->
```
-   æ¯”å¦‚ï¼šc example DIMACS CNF 3-SAT

```{=html}
<!-- -->
```
-   ç¬¬ä¸€æ¡éæ³¨é‡Šè¡Œçš„æ ¼å¼åº”ä¸ºp cnf nbvar nbclausesï¼Œå…¶ä¸­ï¼š

```{=html}
<!-- -->
```
-   cnfè¡¨ç¤ºè¾“å…¥ä¸ºCNFæ ¼å¼

-   nbvaræ˜¯æ–‡ä»¶ä¸­å‡ºç°å˜é‡çš„ç¡®åˆ‡æ•°é‡

-   nbclausesæ˜¯æ–‡ä»¶ä¸­æ‰€åŒ…å«å­å¥çš„ç¡®åˆ‡æ•°é‡

-   æ¯”å¦‚ï¼šp cnf 3 5

```{=html}
<!-- -->
```
-   ç„¶åæ¯ä¸ªå­å¥éƒ½æœ‰ä¸€è¡Œï¼Œå…¶ä¸­ï¼š

```{=html}
<!-- -->
```
-   æ¯ä¸ªå­å¥æ˜¯åœ¨åŒä¸€è¡Œä¸Šä»¥0ç»“å°¾çš„-nbvarå’Œnbvarä¹‹é—´ä¸åŒçš„éç©ºæ•°å­—åºåˆ—

-   ä¸èƒ½åŒæ—¶åŒ…å«ç›¸åçš„æ–‡å­—iå’Œ-i

-   æ­£æ•°è¡¨ç¤ºç›¸åº”çš„å˜é‡

-   è´Ÿæ•°è¡¨ç¤ºç›¸åº”å˜é‡çš„å–å

-   æ¯”å¦‚ï¼š-1 2 3 0å¯¹åº”äºå­å¥$\neg v_{1} \vee v_{2} \vee v_{3}$

åŒæ ·ï¼Œé—®é¢˜$(v_{1},v_{2},v_{3}) = (T,F,T)$çš„è§£å¯å†™ä¸º1 -2 3ï¼Œ-1 -2 -3æˆ–1 2
-3ã€‚

é€šè¿‡æ­¤ç¤ºä¾‹é—®é¢˜çš„è¾“å…¥ï¼Œæˆ‘ä»¬ä¸ºGroveræœç´¢åˆ›å»ºäº†ç›¸åº”çš„é¢„è¨€ã€‚æˆ‘ä»¬ä½¿ç”¨Aquaæä¾›çš„LogicalExpressionOracleç»„ä»¶ï¼Œè¯¥ç»„ä»¶æ”¯æŒè§£æDIMACS
CNFæ ¼å¼å­—ç¬¦ä¸²å¹¶æ„é€ ç›¸åº”çš„é¢„è¨€å›è·¯ã€‚

> import numpy as np
>
> from qiskit import BasicAer
>
> from qiskit.visualization import plot_histogram
>
> from qiskit.aqua import QuantumInstance
>
> from qiskit.aqua.algorithms import Grover
>
> from qiskit.aqua.components.oracles import LogicalExpressionOracle,
> TruthTableOracle
>
> input_3sat = \'\'\'
>
> c example DIMACS-CNF 3-SAT
>
> p cnf 3 5
>
> -1 -2 -3 0
>
> 1 -2 3 0
>
> 1 2 -3 0
>
> 1 -2 -3 0
>
> -1 2 3 0
>
> \'\'\'
>
> oracle = LogicalExpressionOracle(input_3sat)

ç°åœ¨å¯ä»¥ä½¿ç”¨é¢„è¨€åˆ›å»ºä¸€ä¸ªGroverå®ä¾‹ï¼š

grover = Grover(oracle)

ç„¶åé…ç½®æ¨¡æ‹Ÿå™¨åç«¯å¹¶è¿è¡ŒGroverå®ä¾‹ä»¥è·å–ç»“æœï¼š

> backend = BasicAer.get_backend(\'qasm_simulator\')
>
> quantum_instance = QuantumInstance(backend, shots=1024)
>
> result = grover.run(quantum_instance)
>
> print(result\[\'result\'\])
>
> è¾“å‡ºï¼š
>
> \[-1, -2, -3\]

å¦‚ä¸Šæ‰€ç¤ºï¼Œè·å¾—äº†æŒ‡å®šçš„3-SATé—®é¢˜çš„å¯æ»¡è¶³è§£ï¼Œå…¶ç»“æœç¡®ä¸ºä¸‰ä¸ªå¯æ»¡è¶³è§£ä¹‹ä¸€ã€‚

ç”±äºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯æ¨¡æ‹Ÿå™¨ï¼Œå› æ­¤è¿˜è¿”å›äº†å®Œæ•´çš„æµ‹é‡ç»“æœï¼ˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼‰ï¼Œå¯ä»¥çœ‹å‡ºäºŒè¿›åˆ¶å­—ç¬¦ä¸²000ã€011å’Œ101ï¼ˆæ³¨æ„æ¯ä¸ªå­—ç¬¦ä¸²ä¸­çš„ä½é¡ºåºï¼‰æ‰€å¯¹åº”çš„ä¸‰ä¸ªå¯æ»¡è¶³è§£éƒ½å…·æœ‰é«˜æ¦‚ç‡ã€‚

> plot_histogram(result\[\'measurement\'\])
>
> è¾“å‡ºï¼š

![](pics/media/image297.png)

æ¨¡æ‹Ÿå™¨å¯ä»¥æ‰¾åˆ°ç¤ºä¾‹é—®é¢˜çš„è§£ï¼Œå¦‚æœä½¿ç”¨å…·æœ‰å™ªå£°å’Œä¸å®Œç¾é‡å­é—¨çš„çœŸå®é‡å­å™¨ä»¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ

ç„¶è€Œï¼Œç”±äºå¯ä»¥é€šè¿‡ç½‘ç»œå‘é€åˆ°å®é™…è®¾å¤‡çš„å­—ç¬¦ä¸²çš„é•¿åº¦å—åˆ°é™åˆ¶ï¼ˆè¶…è¿‡QASMå›è·¯å…­ä¸‡ä¸ªå­—ç¬¦çš„é™åˆ¶ï¼‰ï¼Œå› æ­¤ç›®å‰ä¸Šè¿°å›è·¯æ— æ³•åœ¨å®é™…è®¾å¤‡åç«¯è¿è¡Œã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å®é™…è®¾å¤‡ibmq_16_melbourneåç«¯ä¸Šçœ‹åˆ°å·²ç¼–è¯‘çš„QASMï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

> \# Load our saved IBMQ accounts and get the ibmq_16_melbourne backend
>
> from qiskit import IBMQ
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\')
>
> backend = provider.get_backend(\'ibmq_16_melbourne\')
>
> from qiskit.compiler import transpile
>
> \# transpile the circuit for ibmq_16_melbourne
>
> grover_compiled = transpile(result\[\'circuit\'\], backend=backend,
> optimization_level=3)
>
> print(\'gates = \', grover_compiled.count_ops())
>
> print(\'depth = \', grover_compiled.depth())
>
> è¾“å‡ºï¼š
>
> gates = OrderedDict(\[(\'cx\', 437), (\'u2\', 130), (\'u1\', 85),
> (\'u3\', 75), (\'measure\', 3), (\'barrier\', 2)\])
>
> depth = 448

å¯ä»¥çœ‹åˆ°æ‰€éœ€é‡å­é—¨çš„æ•°é‡è¿œè¿œè¶…è¿‡äº†å½“å‰è¿‘æœŸé‡å­è®¡ç®—æœºé€€ç›¸å¹²æ—¶é—´é™åˆ¶ã€‚ç°ä»Šï¼Œè®¾è®¡ç”¨äºGroveræœç´¢çš„é‡å­å›è·¯æ¥è§£å†³å¯æ»¡è¶³æ€§å’Œå…¶ä»–ä¼˜åŒ–é—®é¢˜ä»æ˜¯ä¸€ä¸ªæŒ‘æˆ˜ã€‚

#### 4. ç»ƒä¹ 

1\. ä½¿ç”¨Qiskit Aquaè§£å†³ä»¥ä¸‹3SATé—®é¢˜ã€‚ç»“æœæ˜¯æ˜¯å¦å¦‚ä½ æ‰€æœŸæœ›ï¼Ÿ

$$f(x_{1},x_{2},x_{3}) = (x_{1} \vee x_{2} \vee \neg x_{3}) \land (\neg x_{1} \vee \neg x_{2} \vee \neg x_{3}) \land (\neg x_{1} \vee x_{2} \vee x_{3})$$

#### 5. å‚è€ƒæ–‡çŒ®

1\. Giacomo Nannicini (2017), \"An Introduction to Quantum Computing,
Without the
Physics\",Â [arXiv:1708.03684](https://arxiv.org/abs/1708.03684)

### 4.1.5 PyTorchå’ŒQiskitçš„æ··åˆé‡å­ç»å…¸ç¥ç»ç½‘ç»œ

æœºå™¨å­¦ä¹ ï¼ˆMLï¼šMachine
Learningï¼‰å·²å°†è‡ªå·±ç¡®ç«‹ä¸ºä¸€ä¸ªæˆåŠŸçš„è·¨å­¦ç§‘é¢†åŸŸï¼Œè¯¥é¢†åŸŸå¯»æ±‚ä»æ•°æ®ä¸­æ•°å­¦åŒ–åœ°æå–å¯æ¦‚æ‹¬çš„ä¿¡æ¯ã€‚é‡å­è®¡ç®—çš„å…´èµ·å¼•èµ·äº†æœ‰è¶£çš„ç ”ç©¶é¢†åŸŸï¼Œè¿™äº›é¢†åŸŸè¯•å›¾åˆ©ç”¨é‡å­åŠ›å­¦çš„åŸç†æ¥å¢å¼ºæœºå™¨å­¦ä¹ ï¼Œåä¹‹äº¦ç„¶ã€‚æ— è®ºæ‚¨æ˜¯è¦é€šè¿‡å°†å›°éš¾çš„è®¡ç®—å¤–åŒ…ç»™é‡å­è®¡ç®—æœºæ¥å¢å¼ºç»å…¸æœºå™¨å­¦ä¹ ç®—æ³•ï¼Œè¿˜æ˜¯è¦ä½¿ç”¨ç»å…¸æœºå™¨å­¦ä¹ ä½“ç³»ç»“æ„ä¼˜åŒ–é‡å­ç®—æ³•------ä¸¤è€…éƒ½å±äºé‡å­æœºå™¨å­¦ä¹ ï¼ˆQMLï¼šQuantum
Machine Learningï¼‰çš„èŒƒç•´ã€‚

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢ç´¢å¦‚ä½•æŠŠç»å…¸ç¥ç»ç½‘ç»œéƒ¨åˆ†é‡åŒ–æ¥åˆ›å»ºæ··åˆé‡å­ç»å…¸ç¥ç»ç½‘ç»œã€‚æˆ‘ä»¬å°†ç¼–å†™ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œå°†Qiskitä¸æœ€æ–°çš„å¼€æºè½¯ä»¶åŒ…PyTorché›†æˆåœ¨ä¸€èµ·ã€‚æœ¬ç¤ºä¾‹çš„ç›®çš„æ˜¯æ¼”ç¤ºå°†Qiskitä¸ç°æœ‰æœºå™¨å­¦ä¹ å·¥å…·é›†æˆçš„ç®€ä¾¿æ€§ï¼Œå¹¶é¼“åŠ±æœºå™¨å­¦ä¹ å®è·µè€…æ¢ç´¢é‡å­è®¡ç®—ã€‚

#### å†…å®¹

1\. å·¥ä½œåŸç†

1.1 åˆæ­¥å·¥ä½œ

2\. é‚£ä¹ˆé‡å­æ˜¯å¦‚ä½•è¿›å…¥è¿™ä¸ªä¸–ç•Œçš„å‘¢?

3\. å¼€å§‹ç¼–ç ï¼

3.1 å¯¼å…¥

3.2 ç”¨Qiskitåˆ›å»ºä¸€ä¸ª"é‡å­ç±»ï¼ˆQuantum Classï¼‰"

3.3 ç”¨PyTorchåˆ›å»ºä¸€ä¸ª"é‡å­-ç»å…¸ç±»ï¼ˆQuantum-Classical Classï¼‰"

3.4 æ•°æ®åŠ è½½å’Œé¢„å¤„ç†

3.5 åˆ›å»ºæ··åˆç¥ç»ç½‘ç»œ

3.6 è®­ç»ƒç½‘ç»œ

3.7 æµ‹è¯•ç½‘ç»œ

4\. ä¸‹ä¸€æ­¥è¯¥åšä»€ä¹ˆ?

#### 1. å·¥ä½œåŸç†

![](pics/media/image298.png)

ä¸Šå›¾å±•ç¤ºäº†æˆ‘ä»¬å°†åœ¨æœ¬ç« ä¸­æ„å»ºçš„æ¡†æ¶ã€‚æœ€åï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªé‡å­-ç»å…¸æ··åˆç¥ç»ç½‘ç»œï¼Œå¹¶å°†å…¶ç”¨äºå¯¹æ‰‹ç»˜æ•°å­—è¿›è¡Œåˆ†ç±»ã€‚æ³¨æ„ï¼Œå›¾ä¸­æ‰€æ˜¾ç¤ºåœ°çº¿éƒ½æ˜¯æŒ‡å‘ä¸‹ï¼›ä½†åœ¨è§†è§‰ä¸Šæ²¡æœ‰æŒ‡ç¤ºæ–¹å‘ã€‚

##### 1.1 åˆæ­¥å·¥ä½œ

æœ¬å°èŠ‚ä¸­æ‰€ä»‹ç»çš„ç»å…¸ç¥ç»ç½‘ç»œèƒŒæ™¯çŸ¥è¯†æ˜¯ä¸ºäº†å»ºç«‹ç›¸å…³æ€æƒ³å’Œå…±äº«æœ¯è¯­;ç„¶è€Œå…¶ä»ç„¶æ˜¯éå¸¸é«˜ç«¯ã€‚å¦‚æœæ‚¨æƒ³æ·±å…¥äº†è§£ç»å…¸çš„ç¥ç»ç½‘ç»œï¼Œå¯ä»¥çœ‹çœ‹[3Blue1Brown](https://youtu.be/aircAruvnKk)åˆ¶ä½œçš„è§†é¢‘ç³»åˆ—ã€‚å¦‚æœæ‚¨å·²ç»ç†Ÿæ‚‰ç»å…¸ç½‘ç»œï¼Œåˆ™å¯ä»¥è·³è½¬è‡³ä¸‹ä¸€èŠ‚ã€‚

###### ç¥ç»å…ƒå’Œæƒé‡

ç¥ç»ç½‘ç»œæœ€ç»ˆåªæ˜¯ä¸€ä¸ªç²¾å·§çš„å‡½æ•°ï¼Œç”±ç§°ä¸ºç¥ç»å…ƒçš„æ›´å°æ„å»ºå—ç»„æˆã€‚**ç¥ç»å…ƒ**ï¼ˆneuronï¼‰é€šå¸¸æ˜¯ä¸€ä¸ªç®€å•ã€æ˜“äºè®¡ç®—çš„éçº¿æ€§å‡½æ•°ï¼Œå…¶å°†ä¸€ä¸ªæˆ–å¤šä¸ªè¾“å…¥æ˜ å°„ä¸ºä¸€ä¸ªå®æ•°ã€‚ä¸€ä¸ªç¥ç»å…ƒçš„å•ä¸ªè¾“å‡ºé€šå¸¸è¢«å¤åˆ¶å¹¶ä½œä¸ºè¾“å…¥å¯¼å…¥åˆ°å…¶ä»–ç¥ç»å…ƒã€‚åœ¨å›¾å½¢ä¸Šï¼Œæˆ‘ä»¬å°†ç¥ç»å…ƒè¡¨ç¤ºä¸ºå›¾ä¸­çš„èŠ‚ç‚¹ï¼Œå¹¶åœ¨èŠ‚ç‚¹ä¹‹é—´ç”»æœ‰å‘çº¿æ¥è¡¨ç¤ºä¸€ä¸ªç¥ç»å…ƒçš„è¾“å‡ºå¦‚ä½•è¢«ç”¨ä½œå…¶ä»–ç¥ç»å…ƒçš„è¾“å…¥ã€‚åŒæ ·éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå›¾ä¸­çš„æ¯æ¡çº¿é€šå¸¸éƒ½ä¸ä¸€ä¸ªç§°ä¸º**æƒé‡**ï¼ˆweightï¼‰çš„æ ‡é‡å€¼ç›¸å…³è”ã€‚æ­¤å¤„åœ°è®¾æƒ³æ˜¯ï¼šæ¯ä¸ªç¥ç»å…ƒçš„è¾“å…¥åœ¨è¢«æ”¶é›†å’Œå¤„ç†æˆå•ä¸ªå€¼ä¹‹å‰å°†è¢«ä¹˜ä»¥ä¸åŒçš„æ ‡é‡ã€‚è®­ç»ƒç¥ç»ç½‘ç»œçš„ç›®æ ‡ä¸»è¦æ˜¯é€‰æ‹©æƒé‡ï¼Œä½¿å¾—ç½‘ç»œä»¥ç‰¹å®šçš„æ–¹å¼è¿è¡Œã€‚

###### å‰é¦ˆç¥ç»ç½‘ç»œï¼ˆFeed Forward Neural Networksï¼‰

æ³¨æ„ï¼æˆ‘ä»¬å°†è¦è®¨è®ºçš„ç‰¹æ®Šç±»å‹ç¥ç»ç½‘ç»œå«åšå‰é¦ˆç¥ç»ç½‘ç»œï¼ˆFFNNï¼‰ï¼Œè¡¨æ˜å½“æ•°æ®åœ¨æˆ‘ä»¬çš„ç¥ç»ç½‘ç»œä¸­æµåŠ¨æ—¶ï¼Œå…¶å°†æ°¸è¿œä¸ä¼šè¿”å›åˆ°å·²ç»è®¿é—®è¿‡çš„ç¥ç»å…ƒã€‚åŒç†ï¼Œæ‚¨å¯ä»¥è¯´æè¿°è¿™ä¸€ç¥ç»ç½‘ç»œä¸ºä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼šDirected
Acyclic
Graphï¼‰ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å®šä¹‰åœ¨ç¥ç»ç½‘ç»œä¸­åŒä¸€å±‚å†…çš„ç¥ç»å…ƒä¹‹é—´æ²¡æœ‰è¿æ¥çš„çº¿ã€‚

###### å±‚é—´è¾“å…¥è¾“å‡ºç»“æ„ï¼ˆIO Structureï¼‰

ç¥ç»ç½‘ç»œçš„è¾“å…¥æ˜¯ç»å…¸ï¼ˆå®å€¼ï¼‰å‘é‡ã€‚æ ¹æ®ç½‘ç»œçš„å›¾ç»“æ„ï¼Œå°†è¾“å…¥å‘é‡çš„æ¯ä¸ªåˆ†é‡ä¹˜ä»¥ä¸åŒçš„æƒé‡ï¼Œå¹¶é¦ˆå…¥ç¥ç»å…ƒå±‚ã€‚åœ¨è¯¥å±‚ä¸­çš„æ¯ä¸ªç¥ç»å…ƒæ±‚å€¼ä¹‹åï¼Œå°†ç»“æœæ”¶é›†åˆ°ä¸€ä¸ªæ–°çš„å‘é‡ä¸­ï¼Œç¬¬iä¸ªç»„ä»¶å°†è®°å½•ç¬¬iä¸ªç¥ç»å…ƒçš„è¾“å‡ºã€‚ç„¶åå°†æ­¤æ–°çŸ¢é‡è§†ä¸ºæ–°å±‚çš„è¾“å…¥ï¼Œä¾æ­¤ç±»æ¨ã€‚æˆ‘ä»¬ä½¿ç”¨æ ‡å‡†æœ¯è¯­"éšè—å±‚ï¼ˆhidden
layerï¼‰"æ¥æè¿°ç½‘ç»œçš„ç¬¬ä¸€å±‚å’Œæœ€åä¸€å±‚ä»¥å¤–çš„æ‰€æœ‰å±‚

#### 2. é‚£ä¹ˆé‡å­æ˜¯å¦‚ä½•è¿›å…¥è¿™ä¸ªä¸–ç•Œçš„å‘¢?

è‹¥è¦åˆ›å»ºä¸€ä¸ªé‡å­ç»å…¸ç¥ç»ç½‘ç»œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‚æ•°åŒ–é‡å­å›è·¯ä¸ºç¥ç»ç½‘ç»œå®ç°ä¸€ä¸ªéšè—å±‚ã€‚æ‰€è°“"å‚æ•°åŒ–é‡å­å›è·¯ï¼ˆparameterized
quantum
circuitï¼‰"ï¼Œæ˜¯æŒ‡æ¯ä¸ªé‡å­é—¨çš„æ—‹è½¬è§’åº¦ç”±ç»å…¸è¾“å…¥çŸ¢é‡çš„åˆ†é‡æŒ‡å®šçš„é‡å­å›è·¯ã€‚ç¥ç»ç½‘ç»œä¸Šä¸€å±‚çš„è¾“å‡ºå°†è¢«æ”¶é›†å¹¶ç”¨ä½œå‚æ•°åŒ–å›è·¯çš„è¾“å…¥ã€‚ç„¶åï¼Œé‡å­å›è·¯çš„æµ‹é‡ç»Ÿè®¡æ•°æ®å¯ä»¥è¢«æ”¶é›†å’Œä½œä¸ºä¸‹ä¸€å±‚çš„è¾“å…¥ã€‚ä¸‹å›¾æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼š

![](pics/media/image299.png)

æ­¤å¤„çš„$\sigma$æ˜¯ä¸€ä¸ªéçº¿æ€§å‡½æ•°ï¼Œ$h_{i}$æ˜¯æ¯ä¸ªéšè—å±‚çš„ç¥ç»å…ƒ$i$çš„å€¼ã€‚$R(h_{i})$ä»£è¡¨ä»»ä½•æ—‹è½¬é—¨ï¼Œå…¶æ—‹è½¬è§’åº¦ä¸º$h_{i}$ï¼Œ$y$æ˜¯ä»æ··åˆç½‘ç»œç”Ÿæˆçš„æœ€ç»ˆé¢„æµ‹å€¼ã€‚

##### åå‘ä¼ æ’­ï¼ˆbackpropagationï¼‰ï¼Ÿ

å¦‚æœæ‚¨ç†Ÿæ‚‰ç»å…¸æœºå™¨å­¦ä¹ ï¼Œå°±å¯èƒ½ä¼šç«‹å³æƒ³çŸ¥é“å½“æ¶‰åŠé‡å­å›è·¯æ—¶æˆ‘ä»¬å¦‚ä½•è®¡ç®—æ¢¯åº¦ï¼ˆgradientï¼‰ï¼Ÿä¸ºäº†è·å¾—å¼ºå¤§çš„ä¼˜åŒ–æŠ€æœ¯ï¼ˆå¦‚ï¼šæ¢¯åº¦ä¸‹é™gradient
descentï¼‰ï¼Œè¿™ä¸€ç‚¹å¿…é¡»å®ç°ã€‚å…¶åŒ…å«äº›è®¸æŠ€æœ¯æ€§ï¼Œä½†ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬å¯ä»¥å°†é‡å­å›è·¯è§†ä¸ºé»‘ç›’ï¼Œå¯ä»¥è®¡ç®—å‡ºè¯¥é»‘ç›’ç›¸å¯¹äºå…¶å‚æ•°çš„æ¢¯åº¦å¦‚ä¸‹ï¼š

![](pics/media/image300.png)

å…¶ä¸­$\theta$è¡¨ç¤ºé‡å­å›è·¯çš„å‚æ•°ï¼Œè€Œ$s$æ˜¯å®è§‚ä½ç§»ã€‚æ¢¯åº¦å°±æ˜¯é‡å­å›è·¯åœ¨$\theta + s$å’Œ$\theta - s$è¯„ä¼°ä¹‹é—´çš„å·®ã€‚å› æ­¤ä½œä¸ºè¾ƒå¤§çš„åå‘ä¼ æ’­ä¾‹ç¨‹çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å¯ä»¥ç³»ç»Ÿåœ°åŒºåˆ†å‡ºé‡å­å›è·¯ã€‚è¿™ç§ç”¨äºè®¡ç®—é‡å­å›è·¯å‚æ•°æ¢¯åº¦çš„é—­åˆå½¢å¼è§„åˆ™ç§°ä¸ºå‚æ•°ç§»ä½è§„åˆ™ï¼ˆ[parameter
shift rule](https://arxiv.org/pdf/1905.13311.pdf)ï¼‰ã€‚

#### 3. å¼€å§‹ç¼–ç ï¼

##### 3.1 å¯¼å…¥

é¦–å…ˆï¼Œæˆ‘ä»¬å¯¼å…¥ä¸€äº›å°†è¦é‚£ä¸ªåˆ°çš„Qiskitå’ŒPyTorchåŒ…ã€‚

> import numpy as np
>
> import matplotlib.pyplot as plt
>
> import torch
>
> from torch.autograd import Function
>
> from torchvision import datasets, transforms
>
> import torch.optim as optim
>
> import torch.nn as nn
>
> import torch.nn.functional as F
>
> import qiskit
>
> from qiskit.visualization import \*
>
> æ­¤å¤„æœ‰ä¸¤ä¸ªé”™è¯¯ï¼š

1.  pytorch torchvisionçš„ç‰ˆæœ¬

2.  ä¿®æ”¹..\\site-packages\\torchvision\\transforms\\functional.pyä¸­çš„"from
    > PIL import Image, ImageOps, ImageEnhance, PILLOW_VERSION"ä¸º"from
    > PIL import Image, ImageOps, ImageEnhance, \_\_version\_\_"

##### 3.2 ç”¨Qiskitåˆ›å»ºä¸€ä¸ª"é‡å­ç±»ï¼ˆQuantum Classï¼‰"

æˆ‘ä»¬å¯ä»¥æ–¹ä¾¿åœ°å°†Qiskité‡å­å‡½æ•°æ”¾å…¥ä¸€Pythonç±»ä¸­ã€‚é¦–å…ˆï¼ŒæŒ‡å®šå¯è®­ç»ƒçš„é‡å­å‚æ•°çš„æ•°é‡å’Œå¸Œæœ›åœ¨é‡å­å›è·¯ä¸­ä½¿ç”¨çš„æ¬¡æ•°ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä¸ºè®©å…¶ç®€å•ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª1ä¸ªé‡å­æ¯”ç‰¹çš„å›è·¯ä¸ä¸€ä¸ªå¯è®­ç»ƒçš„é‡å­å‚æ•°ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å¯¹è¿™ä¸€é‡å­å›è·¯è¿›è¡Œç¡¬ç¼–ç ï¼Œå¹¶ä½¿ç”¨$\text{RY}$-æ—‹è½¬è§’åº¦$\theta$æ¥è®­ç»ƒå›è·¯çš„è¾“å‡ºã€‚è¯¥é‡å­å›è·¯å¦‚ä¸‹æ‰€ç¤ºï¼š

![](pics/media/image301.png)

ä¸ºäº†åœ¨$z$-åŸºä¸Šæµ‹é‡è¾“å‡ºï¼Œæˆ‘ä»¬è®¡ç®—äº†æœŸæœ›å€¼$\sigma_{\mathbf{z}}$ã€‚

$$\sigma_{\mathbf{z}} = \sum_{i}^{}{z_{i}p(z_{i})}$$

åœ¨ç¨åçš„å™è¿°ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šçœ‹åˆ°ä»¥ä¸Šè¿™äº›æ˜¯å¦‚ä½•ä¸æ··åˆç¥ç»ç½‘ç»œè”ç³»èµ·æ¥çš„ã€‚

> class QuantumCircuit:
>
> \"\"\"
>
> This class provides a simple interface for interaction
>
> with the quantum circuit
>
> \"\"\"
>
> def \_\_init\_\_(self, n_qubits, backend, shots):
>
> \# \-\-- Circuit definition \-\--
>
> self.\_circuit = qiskit.QuantumCircuit(n_qubits)
>
> all_qubits = \[i for i in range(n_qubits)\]
>
> self.theta = qiskit.circuit.Parameter(\'theta\')
>
> self.\_circuit.h(all_qubits)
>
> self.\_circuit.barrier()
>
> self.\_circuit.ry(self.theta, all_qubits)
>
> self.\_circuit.measure_all()
>
> \# \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> self.backend = backend
>
> self.shots = shots
>
> def run(self, thetas):
>
> job = qiskit.execute(self.\_circuit,
>
> self.backend,
>
> shots = self.shots,
>
> parameter_binds = \[{self.theta: theta} for theta in thetas\])
>
> result = job.result().get_counts(self.\_circuit)
>
> counts = np.array(list(result.values()))
>
> states = np.array(list(result.keys())).astype(float)
>
> \# Compute probabilities for each state
>
> probabilities = counts / self.shots
>
> \# Get state expectation
>
> expectation = np.sum(states \* probabilities)
>
> return np.array(\[expectation\])

å¯¹è¯¥å®ä¾‹è¿›è¡Œæµ‹è¯•ã€‚

> simulator = qiskit.Aer.get_backend(\'qasm_simulator\')
>
> circuit = QuantumCircuit(1, simulator, 100)
>
> print(\'Expected value for rotation pi
> {}\'.format(circuit.run(\[np.pi\])\[0\]))
>
> circuit.\_circuit.draw()
>
> è¾“å‡ºï¼š
>
> Expected value for rotation pi 0.55

![](pics/media/image302.png)

##### 3.3 ç”¨PyTorchåˆ›å»ºä¸€ä¸ª"é‡å­-ç»å…¸ç±»ï¼ˆQuantum-Classical Classï¼‰"

æ—¢ç„¶å·²å®šä¹‰é‡å­å›è·¯ï¼Œå°±å¯ä»¥ä½¿ç”¨PyTorchåˆ›å»ºåå‘ä¼ æ’­æ‰€éœ€çš„å‡½æ•°ã€‚[å‘å‰å’Œå‘åä¼ æ’­](http://www.ai.mit.edu/courses/6.034b/backprops.pdf)åŒ…å«æ¥è‡ªQiskitç±»çš„å…ƒç´ ã€‚å‘åä¼ æ’­è¿‡ç¨‹ç›´æ¥ç”¨å‰é¢ä»‹ç»çš„æœ‰é™å·®åˆ†å…¬å¼è®¡ç®—è§£ææ¢¯åº¦ã€‚

> class HybridFunction(Function):
>
> \"\"\" Hybrid quantum - classical function definition \"\"\"
>
> \@staticmethod
>
> def forward(ctx, input, quantum_circuit, shift):
>
> \"\"\" Forward pass computation \"\"\"
>
> ctx.shift = shift
>
> ctx.quantum_circuit = quantum_circuit
>
> expectation_z = ctx.quantum_circuit.run(input\[0\].tolist())
>
> result = torch.tensor(\[expectation_z\])
>
> ctx.save_for_backward(input, result)
>
> return result
>
> \@staticmethod
>
> def backward(ctx, grad_output):
>
> \"\"\" Backward pass computation \"\"\"
>
> input, expectation_z = ctx.saved_tensors
>
> input_list = np.array(input.tolist())
>
> shift_right = input_list + np.ones(input_list.shape) \* ctx.shift
>
> shift_left = input_list - np.ones(input_list.shape) \* ctx.shift
>
> gradients = \[\]
>
> for i in range(len(input_list)):
>
> expectation_right = ctx.quantum_circuit.run(shift_right\[i\])
>
> expectation_left = ctx.quantum_circuit.run(shift_left\[i\])
>
> gradient = torch.tensor(\[expectation_right\]) -
> torch.tensor(\[expectation_left\])
>
> gradients.append(gradient)
>
> gradients = np.array(\[gradients\]).T
>
> return torch.tensor(\[gradients\]).float() \* grad_output.float(),
> None, None
>
> class Hybrid(nn.Module):
>
> \"\"\" Hybrid quantum - classical layer definition \"\"\"
>
> def \_\_init\_\_(self, backend, shots, shift):
>
> super(Hybrid, self).\_\_init\_\_()
>
> self.quantum_circuit = QuantumCircuit(1, backend, shots)
>
> self.shift = shift
>
> def forward(self, input):
>
> return HybridFunction.apply(input, self.quantum_circuit, self.shift)

##### 3.4 æ•°æ®åŠ è½½å’Œé¢„å¤„ç†

###### å°†æ‰€æœ‰ç»„åˆåœ¨ä¸€èµ·ï¼š

æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªç®€å•çš„æ··åˆç¥ç»ç½‘ç»œæ¥å¯¹MNISTæ•°æ®é›†ä¸­ä¸¤ç±»æ•°å­—(0æˆ–1)å›¾åƒè¿›è¡Œåˆ†ç±»ã€‚é¦–å…ˆåŠ è½½[MNIST](http://yann.lecun.com/exdb/mnist/)å¹¶è¿‡æ»¤åŒ…å«0å’Œ1çš„å›¾ç‰‡ã€‚è¿™äº›å›¾ç‰‡å°†è¾“å…¥æˆ‘ä»¬çš„ç¥ç»ç½‘ç»œè¿›è¡Œåˆ†ç±»ã€‚

###### è®­ç»ƒæ•°æ®

> \# Concentrating on the first 100 samples
>
> n_samples = 100
>
> X_train = datasets.MNIST(root=\'./data\', train=True, download=True,
>
> transform=transforms.Compose(\[transforms.ToTensor()\]))
>
> \# Leaving only labels 0 and 1
>
> idx = np.append(np.where(X_train.targets == 0)\[0\]\[:n_samples\],
>
> np.where(X_train.targets == 1)\[0\]\[:n_samples\])
>
> X_train.data = X_train.data\[idx\]
>
> X_train.targets = X_train.targets\[idx\]
>
> train_loader = torch.utils.data.DataLoader(X_train, batch_size=1,
> shuffle=True)
>
> æ³¨ï¼šè¯¥è¿‡ç¨‹ä¼šä¸‹è½½MNISTæ•°æ®
>
> n_samples_show = 6
>
> data_iter = iter(train_loader)
>
> fig, axes = plt.subplots(nrows=1, ncols=n_samples_show, figsize=(10,
> 3))
>
> while n_samples_show \> 0:
>
> images, targets = data_iter.\_\_next\_\_()
>
> axes\[n_samples_show - 1\].imshow(images\[0\].numpy().squeeze(),
> cmap=\'gray\')
>
> axes\[n_samples_show - 1\].set_xticks(\[\])
>
> axes\[n_samples_show - 1\].set_yticks(\[\])
>
> axes\[n_samples_show - 1\].set_title(\"Labeled:
> {}\".format(targets.item()))
>
> n_samples_show -= 1
>
> è¾“å‡ºï¼š

![](pics/media/image303.png)

###### æµ‹è¯•æ•°æ®

> n_samples = 50
>
> X_test = datasets.MNIST(root=\'./data\', train=False, download=True,
>
> transform=transforms.Compose(\[transforms.ToTensor()\]))
>
> idx = np.append(np.where(X_test.targets == 0)\[0\]\[:n_samples\],
>
> np.where(X_test.targets == 1)\[0\]\[:n_samples\])
>
> X_test.data = X_test.data\[idx\]
>
> X_test.targets = X_test.targets\[idx\]
>
> test_loader = torch.utils.data.DataLoader(X_test, batch_size=1,
> shuffle=True)

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»åŠ è½½äº†æ•°æ®å¹¶ç¼–å†™äº†ä¸€ä¸ªç±»æ¥åˆ›å»ºåŒ…å«1ä¸ªå¯è®­ç»ƒå‚æ•°çš„é‡å­å›è·¯ã€‚å°†è¯¥é‡å­å‚æ•°ä¸å…¶ä»–ç»å…¸å‚æ•°ä¸€èµ·æ’å…¥åˆ°ç»å…¸ç¥ç»ç½‘ç»œä¸­å°±å½¢æˆæ··åˆç¥ç»ç½‘ç»œã€‚æˆ‘ä»¬è¿˜åˆ›å»ºäº†å‘åå’Œå‘å‰ä¼ æ’­å‡½æ•°ï¼Œè¿™äº›å‡½æ•°å…è®¸æˆ‘ä»¬è¿›è¡Œåå‘ä¼ æ’­å¹¶ä¼˜åŒ–æˆ‘ä»¬çš„ç¥ç»ç½‘ç»œã€‚æœ€åéœ€è¦æŒ‡å®šç¥ç»ç½‘ç»œæ¶æ„ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¼€å§‹ä½¿ç”¨PyTorchæä¾›çš„ä¼˜åŒ–æŠ€æœ¯æ¥è®­ç»ƒå‚æ•°ã€‚

##### 3.5 åˆ›å»ºæ··åˆç¥ç»ç½‘ç»œ

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•´æ´çš„PyTorchç®¡é“æ¥åˆ›å»ºä¸€ä¸ªç¥ç»ç½‘ç»œæ¶æ„ã€‚å½“æˆ‘ä»¬æ’å…¥é‡å­å±‚(å³æˆ‘ä»¬çš„é‡å­å›è·¯)æ—¶ï¼Œè¯¥ç¥ç»ç½‘ç»œéœ€è¦åœ¨ç»´æ•°ä¸Šå…¼å®¹ã€‚ç”±äºæœ¬ä¾‹ä¸­çš„é‡å­å›è·¯åŒ…å«1ä¸ªå‚æ•°ï¼Œæˆ‘ä»¬å¿…é¡»ç¡®ä¿ç¥ç»ç½‘ç»œå°†ç¥ç»å…ƒå‹ç¼©åˆ°1ã€‚æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå…¸å‹çš„å·ç§¯ç¥ç»ç½‘ç»œï¼Œæœ€åæœ‰ä¸¤ä¸ªå…¨è¿æ¥çš„å±‚ã€‚å…¨è¿æ¥å±‚æœ€åä¸€ä¸ªç¥ç»å…ƒçš„å€¼ä½œä¸ºå‚æ•°$\theta$å¯¼å…¥æˆ‘ä»¬çš„é‡å­å›è·¯ã€‚ç„¶åï¼Œå¯¹é‡å­å›è·¯è¿›è¡Œ$\sigma_{z}$æµ‹é‡æ‰€ç»™å‡ºçš„0æˆ–1ä½œä¸ºæœ€ç»ˆé¢„æµ‹å€¼ã€‚

> class Net(nn.Module):
>
> def \_\_init\_\_(self):
>
> super(Net, self).\_\_init\_\_()
>
> self.conv1 = nn.Conv2d(1, 32, kernel_size=5)
>
> self.conv2 = nn.Conv2d(32, 64, kernel_size=5)
>
> self.dropout = nn.Dropout2d()
>
> self.fc1 = nn.Linear(256, 64)
>
> self.fc2 = nn.Linear(64, 1)
>
> self.hybrid = Hybrid(qiskit.Aer.get_backend(\'qasm_simulator\'), 100,
> np.pi / 2)
>
> def forward(self, x):
>
> x = F.relu(self.conv1(x))
>
> x = F.relu(self.conv2(x))
>
> x = F.max_pool2d(x, 2)
>
> x = self.dropout(x)
>
> x = x.view(-1, 256)
>
> x = F.relu(self.fc1(x))
>
> x = self.fc2(x)
>
> x = self.hybrid(x)
>
> return torch.cat((x, 1 - x), -1)

##### 3.6 è®­ç»ƒç½‘ç»œ

è‡ªæ­¤ï¼Œæˆ‘ä»¬æœ‰äº†è®­ç»ƒæ··åˆç½‘ç»œçš„æ‰€æœ‰è¦ç´ ï¼æˆ‘ä»¬å¯ä»¥æŒ‡å®šä»»ä¸€[PyTorchä¼˜åŒ–å™¨](https://pytorch.org/docs/stable/optim.html)ï¼Œ[å­¦ä¹ ç‡](https://en.wikipedia.org/wiki/Learning_rate)å’Œ[ä»£ä»·/æŸå¤±å‡½æ•°](https://en.wikipedia.org/wiki/Loss_function)ï¼Œä»¥åŠå¤šä¸ªè®­ç»ƒé›†ã€‚åœ¨æœ¬ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨[Adamä¼˜åŒ–å™¨](https://arxiv.org/abs/1412.6980)ï¼Œå­¦ä¹ ç‡ä¸º0.001å’Œ[è´Ÿå¯¹æ•°ä¼¼ç„¶æŸå¤±å‡½æ•°](https://pytorch.org/docs/stable/_modules/torch/nn/modules/loss.html)ã€‚

> model = Net()
>
> optimizer = optim.Adam(model.parameters(), lr=0.001)
>
> loss_func = nn.NLLLoss()
>
> epochs = 20
>
> loss_list = \[\]
>
> model.train()
>
> for epoch in range(epochs):
>
> total_loss = \[\]
>
> for batch_idx, (data, target) in enumerate(train_loader):
>
> optimizer.zero_grad()
>
> \# Forward pass
>
> output = model(data)
>
> \# Calculating loss
>
> loss = loss_func(output, target)
>
> \# Backward pass
>
> loss.backward()
>
> \# Optimize the weights
>
> optimizer.step()
>
> total_loss.append(loss.item())
>
> loss_list.append(sum(total_loss)/len(total_loss))
>
> print(\'Training \[{:.0f}%\]\\tLoss: {:.4f}\'.format(
>
> 100\. \* (epoch + 1) / epochs, loss_list\[-1\]))
>
> è¾“å‡ºï¼š
>
> Training \[5%\] Loss: -0.6586
>
> Training \[10%\] Loss: -0.8185
>
> Training \[15%\] Loss: -0.8316
>
> Training \[20%\] Loss: -0.8402
>
> Training \[25%\] Loss: -0.8683
>
> Training \[30%\] Loss: -0.8527
>
> Training \[35%\] Loss: -0.8611
>
> .
>
> .
>
> .
>
> Training \[80%\] Loss: -0.8684
>
> Training \[85%\] Loss: -0.8479
>
> Training \[90%\] Loss: -0.8428
>
> Training \[95%\] Loss: -0.8937
>
> Training \[100%\] Loss: -0.8838

ç»˜åˆ¶è®­ç»ƒæ•°æ®å›¾ã€‚

> plt.plot(loss_list)
>
> plt.title(\'Hybrid NN Training Convergence\')
>
> plt.xlabel(\'Training Iterations\')
>
> plt.ylabel(\'Neg Log Likelihood Loss\').
>
> è¾“å‡ºï¼š
>
> Text(0, 0.5, \'Neg Log Likelihood Loss\')

![](pics/media/image304.png)

> model.eval()
>
> with torch.no_grad():
>
> correct = 0
>
> for batch_idx, (data, target) in enumerate(test_loader):
>
> output = model(data)
>
> pred = output.argmax(dim=1, keepdim=True)
>
> correct += pred.eq(target.view_as(pred)).sum().item()
>
> loss = loss_func(output, target)
>
> total_loss.append(loss.item())
>
> print(\'Performance on test data:\\n\\tLoss: {:.4f}\\n\\tAccuracy:
> {:.1f}%\'.format(
>
> sum(total_loss) / len(total_loss),
>
> correct / len(test_loader) \* 100)
>
> )
>
> è¾“å‡ºï¼š
>
> Performance on test data:
>
> Loss: -0.8734
>
> Accuracy: 100.0%

##### 3.7 æµ‹è¯•ç½‘ç»œ

> n_samples_show = 6
>
> count = 0
>
> fig, axes = plt.subplots(nrows=1, ncols=n_samples_show, figsize=(10,
> 3))
>
> model.eval()
>
> with torch.no_grad():
>
> for batch_idx, (data, target) in enumerate(test_loader):
>
> if count == n_samples_show:
>
> break
>
> output = model(data)
>
> pred = output.argmax(dim=1, keepdim=True)
>
> axes\[count\].imshow(data\[0\].numpy().squeeze(), cmap=\'gray\')
>
> axes\[count\].set_xticks(\[\])
>
> axes\[count\].set_yticks(\[\])
>
> axes\[count\].set_title(\'Predicted {}\'.format(pred.item()))
>
> count += 1
>
> è¾“å‡ºï¼š

![](pics/media/image305.png)

#### 4. ä¸‹ä¸€æ­¥è¯¥åšä»€ä¹ˆ?

**è™½ç„¶å®Œå…¨å¯èƒ½åˆ›å»ºæ··åˆç¥ç»ç½‘ç»œï¼Œä½†æœ‰ä»€ä¹ˆå¥½å¤„å—?**

å®é™…ä¸Šï¼Œè¯¥ç½‘ç»œçš„ç»å…¸å±‚åœ¨æ²¡æœ‰é‡å­å±‚çš„æƒ…å†µä¸‹è®­ç»ƒå¾—éå¸¸å¥½ï¼ˆå®é™…ä¸Šæ›´å¥½ï¼‰ã€‚æ­¤å¤–ï¼Œæ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬åœ¨æ­¤å¤„è®­ç»ƒçš„é‡å­å±‚ä¸ä¼šäº§ç”Ÿçº ç¼ ï¼Œå› æ­¤ï¼Œå½“æˆ‘ä»¬æ‰©å¤§æ­¤ç‰¹å®šä½“ç³»ç»“æ„æ—¶ï¼Œå…¶å°†ç»§ç»­ç»å…¸å¯æ¨¡æ‹Ÿã€‚è¿™æ„å‘³ç€å¦‚æœæ‚¨å¸Œæœ›ä½¿ç”¨æ··åˆç¥ç»ç½‘ç»œè·å¾—é‡å­ä¼˜åŠ¿ï¼Œåˆ™éœ€è¦é¦–å…ˆæ‰©å±•æ­¤ä»£ç æ¥åŒ…æ‹¬æ›´å¤æ‚çš„é‡å­å±‚ã€‚

è¿™é¡¹ç»ƒä¹ çš„ç›®çš„æ˜¯è®©æ‚¨è€ƒè™‘å°†æœºå™¨å­¦ä¹ å’Œé‡å­è®¡ç®—ä¸­çš„æŠ€æœ¯é›†æˆåœ¨ä¸€èµ·ï¼Œç ”ç©¶æ˜¯å¦ç¡®å®å­˜åœ¨æŸäº›æœ‰è¶£çš„å…ƒç´ ï¼Œå¹¶ä¸”ç”±äºæœ‰äº†PyTorchå’ŒQiskitï¼Œä½¿å¾—è¿™ä¸€æƒ³æ³•çš„å®ç°å˜å¾—å®¹æ˜“äº†ã€‚

4.2 æœ€æ–°é‡å­ç®—æ³•çš„å®ç°
----------------------

### å…³äºæœ¬èŠ‚

å¯»æ‰¾æ–°çš„é‡å­ç®—æ³•ï¼Œæˆ–ç°æœ‰ç®—æ³•çš„æ–°åº”ç”¨æ˜¯ä¸€ä¸ªæ´»è·ƒçš„ç ”ç©¶é¢†åŸŸã€‚æœ¬èŠ‚ä»æœ€è¿‘çš„è®ºæ–‡ä¸­è§£é‡Šäº†ä¼ ç»Ÿæ•™ç§‘ä¹¦ä¸­æ²¡æœ‰è§£é‡Šçš„ç®—æ³•å’Œåº”ç”¨ã€‚è¿™äº›åº”è¯¥æœ‰åŠ©äºè®©è¯»è€…æ›´æ¥è¿‘äº†è§£å½“å‰çš„ç ”ç©¶é¢†åŸŸã€‚æœ¬æ•™ææ˜¯ä¸€ä¸ªæ»šåŠ¨æ›´æ–°çš„æ–‡ä»¶ï¼Œä»¥ä¾¿è·Ÿä¸Šè¯¥å„ä¸ªé¢†åŸŸçš„æœ€æ–°å‘å±•ã€‚

> import qiskit
>
> from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
>
> from qiskit import Aer, execute
>
> import math
>
> import random
>
> import numpy as np
>
> from scipy.optimize import minimize

### 4.2.1 å˜åˆ†é‡å­çº¿æ€§ç®—æ³•

#### 1. ç®€ä»‹

å˜åˆ†é‡å­çº¿æ€§ç®—æ³•æˆ–VQLSï¼ˆVariational Quantum Linear
Solverï¼‰æ˜¯ä¸€ç§å˜åˆ†é‡å­ç®—æ³•ï¼Œå…¶åˆ©ç”¨VQEå®ç°æ¯”ä¼ ç»Ÿè®¡ç®—ç®—æ³•æ›´æœ‰æ•ˆåœ°æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„ã€‚å…·ä½“æ¥è¯´ï¼šå¦‚æœç»™å®šçŸ©é˜µ$\text{A}$ï¼Œä½¿å¾—$\text{A}|x\rangle = |b\rangle$ï¼Œå…¶ä¸­$|b\rangle$æ˜¯ä¸€äº›å·²çŸ¥çŸ¢é‡ï¼Œåˆ™VQLSç®—æ³•ç†è®ºä¸Šèƒ½å¤Ÿæ‰¾åˆ°ä½¿ä¸Šè¿°å…³ç³»æˆç«‹çš„äº$|x\rangle$æˆæ¯”ä¾‹çš„å½’ä¸€åŒ–$|x\rangle$ã€‚

è¯¥ç®—æ³•çš„è¾“å‡ºä¸HHL
Quantumçº¿æ€§æ±‚è§£ç®—æ³•çš„è¾“å‡ºç›¸åŒï¼Œé™¤HHLåœ¨VQLSä¸Šæä¾›äº†æ›´æœ‰åˆ©çš„è®¡ç®—é€Ÿåº¦å¤–ï¼Œæˆ‘ä»¬ç®—æ³•çš„å˜ä½“ä½¿å…¶å¯ä»¥åœ¨NISQé‡å­è®¡ç®—æœºä¸Šæ‰§è¡Œï¼Œè€ŒHHLå°†éœ€è¦æ›´å¼ºå¤§çš„é‡å­ç¡¬ä»¶å’Œæ›´å¤šçš„é‡å­æ¯”ç‰¹ã€‚

#### 2. ç®—æ³•

é¦–å…ˆï¼Œè¯¥ç®—æ³•çš„è¾“å…¥æ˜¾ç„¶æ˜¯ä¸€ä¸ªçŸ©é˜µ$\text{A}$ï¼Œæˆ‘ä»¬å¿…é¡»å°†å…¶åˆ†è§£ä¸ºå…·æœ‰å¤æ•°ç³»æ•°çš„å¹ºæ­£çº¿æ€§ç»„åˆï¼š

$$A = \sum_{n}^{}{c_{n}A_{n}}$$

å…¶ä¸­æ¯ä¸ª$A_{n}$æ˜¯æŸä¸€å¹ºæ­£çŸ©é˜µï¼Œè€Œä¸€äº›å¹ºæ­£çŸ©é˜µ$U$åˆ™ä»$|0\rangle$å‡†å¤‡æ€$|b\rangle$ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å›é¡¾ä¸€ä¸‹å˜åˆ†é‡å­ç®—æ³•çš„ä¸€èˆ¬ç»“æ„ã€‚æˆ‘ä»¬å¿…é¡»æ„å»ºä¸€ä¸ªé‡å­ä»£ä»·å‡½æ•°ï¼Œå¯ä»¥ä½¿ç”¨ä½æ·±åº¦å‚æ•°åŒ–çš„é‡å­å›è·¯å¯¹å…¶è¿›è¡Œè¯„ä¼°ï¼Œç„¶åè¾“å‡ºè‡³ç»å…¸ä¼˜åŒ–å™¨ä¸­ã€‚è¿™æ ·å°±ä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨å‚æ•°ç©ºé—´ä¸­æœç´¢ä¸€ç»„å‚æ•°$\alpha$ï¼Œä½¿å¾—$|\psi(\alpha)\rangle = \frac{|x\rangle}{||x||}$ï¼Œå…¶ä¸­$|\psi(k)\rangle$æ˜¯ä¸æŸäº›å‚æ•°é›†$k$å¯¹åº”çš„å¤–é‡å­å›è·¯çš„è¾“å‡ºã€‚

åœ¨å¼€å§‹æ„å»ºæˆæœ¬å‡½æ•°ä¹‹å‰ï¼Œè®©æˆ‘ä»¬çœ‹ä¸€ä¸‹è¯¥ç®—æ³•ä¸­å­ä¾‹ç¨‹çš„"é«˜çº§"æ¦‚è¿°ï¼Œå¦‚åŸå§‹è®ºæ–‡ä¸­çš„å›¾åƒæ‰€ç¤ºï¼š

![alt text](pics/media/image306.png)

ä»æœ¬è´¨ä¸Šè®²ï¼Œæˆ‘ä»¬ä»ä¸€ä¸ªé‡å­æ¯”ç‰¹å¯„å­˜å™¨å¼€å§‹ï¼Œæ¯ä¸ªé‡å­æ¯”ç‰¹éƒ½åˆå§‹åŒ–ä¸º\|0âŸ©ã€‚æˆ‘ä»¬çš„ç®—æ³•ä»è¾“å…¥æŸç§æ‹Ÿè®¾$V(\alpha)$å¼€å§‹è·å–å…¶è¾“å…¥ï¼Œç„¶åå‡†å¤‡å¹¶è¯„ä¼°æˆæœ¬å‡½æ•°ã€‚å¦‚æœè®¡ç®—å‡ºçš„ä»£ä»·å¤§äºæŸä¸ªå‚æ•°$\gamma$ï¼Œåˆ™ä½¿ç”¨æ›´æ–°åçš„å‚æ•°å†æ¬¡è¿è¡Œè¯¥ç®—æ³•ï¼Œå¦åˆ™ç®—æ³•ç»ˆæ­¢ï¼Œå¹¶ä½¿ç”¨æœ€ä½³å‚æ•°ï¼ˆåœ¨ç»ˆæ­¢æ—¶ç¡®å®šçš„ï¼‰è®¡ç®—è¯¥æ–¹æ³•ã€‚è¿™å°±ç»™å‡ºäº†ä½¿å‘é‡å‡½æ•°æœ€å°çš„æ€å‘é‡ï¼Œä¹Ÿå°±æ˜¯$|x|$çš„å½’ä¸€åŒ–å½¢å¼ã€‚

#### 3. Qiskitå®æ–½

##### å›ºå®šç¡¬ä»¶æ‹Ÿè®¾

æˆ‘ä»¬å…ˆè€ƒè™‘æ‹Ÿè®¾$V(\alpha)$ï¼Œå…¶åªæ˜¯å‡†å¤‡ä¸€äº›ä»»æ„çŠ¶æ€$|\psi(k)\rangle$çš„å›è·¯ã€‚è¿™å°±ä½¿å¾—æˆ‘ä»¬å¯ä»¥é€šè¿‡æ”¹å˜å‚æ•°$k$æ¥"æœç´¢"æ€ç©ºé—´ã€‚ä¸ç®¡æ€æ ·ï¼Œæˆ‘ä»¬å°†ä¸ºæ­¤å®ç°ä½¿ç”¨çš„æ‹Ÿè®¾å¦‚ä¸‹ï¼š

> def apply_fixed_ansatz(qubits, parameters):
>
> for iz in range (0, len(qubits)):
>
> circ.ry(parameters\[0\]\[iz\], qubits\[iz\])
>
> circ.cz(qubits\[0\], qubits\[1\])
>
> circ.cz(qubits\[2\], qubits\[0\])
>
> for iz in range (0, len(qubits)):
>
> circ.ry(parameters\[1\]\[iz\], qubits\[iz\])
>
> circ.cz(qubits\[1\], qubits\[2\])
>
> circ.cz(qubits\[2\], qubits\[0\])
>
> for iz in range (0, len(qubits)):
>
> circ.ry(parameters\[2\]\[iz\], qubits\[iz\])
>
> circ = QuantumCircuit(3)
>
> apply_fixed_ansatz(\[0, 1, 2\], \[\[1, 1, 1\], \[1, 1, 1\], \[1, 1,
> 1\]\])
>
> circ.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image307.png)

è¿™è¢«ç§°ä¸º**å›ºå®šç¡¬ä»¶æ‹Ÿè®¾ï¼ˆfixed hardware
ansatzï¼‰**ï¼šé‡å­é—¨çš„é…ç½®åœ¨å›è·¯çš„æ¯æ¬¡è¿è¡Œä¸­éƒ½ä¿æŒä¸å˜ï¼Œæ‰€å˜åŒ–çš„éƒ½æ˜¯å‚æ•°ã€‚ä¸QAOAæ–¹æ³•ä¸åŒï¼Œå…¶ä¸æ˜¯ä»…ç”±æ¸è¿›å“ˆå¯†é¡¿é‡ç»„æˆã€‚$\text{Ry}$é—¨çš„åº”ç”¨ä½¿å¾—æˆ‘ä»¬å¯ä»¥æœç´¢æ€ç©ºé—´ï¼Œè€Œ$\text{CZ}$é—¨åœ¨ä¸åŒçš„é‡å­æ¯”ç‰¹çŠ¶æ€ä¹‹é—´åˆ›å»º"å¹²æ‰°"ã€‚

è‡ªæ­¤ï¼Œè€ƒè™‘å®é™…ä»£ä»·å‡½æ•°å¯¹æœ‰æœ‰æ„ä¹‰äº†ã€‚æˆ‘ä»¬ç®—æ³•çš„ç›®æ ‡æ˜¯ä½¿ä»£ä»·æœ€å°åŒ–ï¼Œå› æ­¤å½“$|\Phi\rangle = A|\psi(k)\rangle$æ—¶éå¸¸æ¥è¿‘$|b\rangle$ï¼Œæˆ‘ä»¬å¸Œæœ›ä»£ä»·å‡½æ•°çš„è¾“å‡ºéå¸¸å°ï¼Œä¸”ç”±äºæ­£äº¤å‘é‡ä¸å‘é‡ä¹‹é—´éå¸¸æ¥è¿‘æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›ä»£ä»·å‡½æ•°å¾ˆå¤§ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¼•å…¥"æŠ•å½±ï¼ˆprojectionï¼‰"å“ˆå¯†é¡¿é‡ï¼š

$$H_{P}\mathbb{= I - |}b\rangle\langle b|$$

å…¶ä¸­æˆ‘ä»¬æœ‰ï¼š

$$C_{P}\text{=}\left\langle \Phi\left| H_{P} \right|\Phi \right\rangle = \left\langle \Phi\left| \mathbb{(I - |}b\rangle\langle b|) \right|\Phi \right\rangle = \left\langle \Phi \middle| \Phi \right\rangle - \langle\Phi|b\rangle\langle b|\Phi\rangle$$

å¯ä»¥çœ‹å‡ºç¬¬äºŒé¡¹å‘Šè¯‰æˆ‘ä»¬$|\Phi\rangle$å€¾å‘$|b\rangle$æœ‰å¤šå°‘ã€‚ç„¶åï¼Œå½“$|\Phi\rangle$å’Œ$|b\rangle$çš„å†…ç§¯æœ€å¤§æ—¶ç”¨å¦ä¸€ä¸ªæ•°å‡å»å†…ç§¯å°±å¾—åˆ°äº†æƒ³è¦çš„å°æ•°ç›®ï¼Œè€Œå½“$|\Phi\rangle$å’Œ$|b\rangle$æ—¶åˆ™ç›¸åã€‚åˆ°ç›®å‰ä¸ºæ­¢çœ‹èµ·æ¥ä¸é”™ï¼ä½†æ˜¯ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç”¨æ ‡å‡†åŒ–ä»£ä»·å‡½æ•°æ¥æé«˜ç®—æ³•çš„å‡†ç¡®æ€§ã€‚è¿™ç”±äº$|\Phi\rangle$å…·æœ‰ä¸€ä¸ªå°çš„èŒƒæ•°ï¼Œé‚£ä¹ˆå³ä½¿$|\Phi\rangle$ä¸ä¸$|b\rangle$ç›¸ä¹˜ä»£ä»·å‡½æ•°çš„è¾“å‡ºä»ä¼šå¾ˆå°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç”¨$\frac{|\Phi\rangle}{\sqrt{\langle\Phi|\Phi\rangle}}$ä»£æ›¿$|\Phi\rangle$ï¼š

$${\widehat{C}}_{P} = \frac{\left\langle \Phi \middle| \Phi \right\rangle}{\left\langle \Phi \middle| \Phi \right\rangle} - \frac{\left\langle \Phi \middle| b \right\rangle\left\langle b \middle| \Phi \right\rangle}{\left\langle \Phi \middle| \Phi \right\rangle} = 1 - \frac{\left\langle \Phi \middle| b \right\rangle\left\langle b \middle| \Phi \right\rangle}{\left\langle \Phi \middle| \Phi \right\rangle} = 1 - \frac{\left| \left\langle b \middle| \Phi \right\rangle \right|^{2}}{\left\langle \Phi \middle| \Phi \right\rangle}$$

è‡ªæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸€æ‹Ÿè®¾å‡†å¤‡äº†æ€$|\psi(k)\rangle$ã€‚ä¸ºäº†è®¡ç®—å¤§å®¶å‡½æ•°ï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªå€¼éœ€è¦è®¡ç®—ï¼š$|\langle b|\Phi\rangle|^{2}$å’Œ$\left\langle \Phi \middle| \Phi \right\rangle$ã€‚å¹¸è¿çš„æ˜¯ï¼Œä¸€ä¸ªå«åš**Hadamardæµ‹è¯•**çš„æ¼‚äº®å°é‡å­å­ç¨‹åºå¯ä»¥å¸®åŠ©æˆ‘ä»¬ï¼ä»æœ¬è´¨ä¸Šè¯´ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€äº›å¹ºæ­£çŸ©é˜µ$U$å’Œä¸€äº›çŠ¶æ€$|\phi\rangle$ï¼Œå¹¶æ‰¾å‡ºæ‰€å¯¹åº”æ€$\langle\phi|U|\phi\rangle$çš„æœŸæœ›å€¼$U$ï¼Œç„¶åæˆ‘ä»¬å°±å¯ä»¥è¯„ä¼°ä»¥ä¸‹å›è·¯ï¼š

![image1](pics/media/image308.png)

ç„¶åï¼Œå°†ç¬¬ä¸€ä¸ªä¸º0çš„é‡å­æ¯”ç‰¹çš„æµ‹é‡æ¦‚ç‡ç­‰äº$\frac{1}{2}(1 + \text{Re}\langle U\rangle)$ï¼Œè€Œä¸º1çš„ç­‰äº$\frac{1}{2}(1 - \text{Re}\langle U\rangle)$ï¼Œå› æ­¤è¿™ä¸¤ä¸ªæ¦‚ç‡ç›¸å‡å¾—å‡º$\text{Re}\langle U\rangle$ã€‚å¹¸è¿çš„æ˜¯ï¼Œå½“æˆ‘ä»¬æµ‹è¯•è¯¥ç®—æ³•æ—¶è¦å¤„ç†çš„çŸ©é˜µå…¨éƒ¨ä¸ºå®æ•°ï¼Œå› æ­¤å¯¹äºæ­¤ç‰¹å®šå®ç°$\text{Re}\left\langle U \right\rangle = \langle U\rangle$ã€‚ä»¥ä¸‹ä¸ºHadamardæµ‹è¯•çš„å·¥ä½œåŸç†ã€‚ç”±å›è·¯å›¾å¯çŸ¥ï¼Œé€šå¸¸çš„æ€å‘é‡ä¸ºï¼š

$$\frac{|0\rangle + |1\rangle}{\sqrt{2}} \otimes |\psi\rangle = \frac{|0\rangle \otimes |\psi\rangle + |1\rangle \otimes |\psi\rangle}{\sqrt{2}}$$

åº”ç”¨å—æ§å¹ºæ­£å˜æ¢ï¼š

$$\frac{\left| 0 \right\rangle \otimes \left| \psi \right\rangle + \left| 1 \right\rangle \otimes \left| \psi \right\rangle}{\sqrt{2}}$$

$$\longrightarrow \frac{\left| 0 \right\rangle \otimes \left| \psi \right\rangle + \left| 1 \right\rangle \otimes U\left| \psi \right\rangle}{\sqrt{2}}$$

ç„¶åå°†Hadamardé—¨åº”ç”¨äºç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼š

$$\frac{\left| 0 \right\rangle \otimes \left| \psi \right\rangle + \left| 1 \right\rangle \otimes U\left| \psi \right\rangle}{\sqrt{2}} \longrightarrow \frac{1}{2}\left\lbrack \left| 0 \right\rangle \otimes \left| \psi \right\rangle + \left| 1 \right\rangle \otimes \left| \psi \right\rangle + \left| 0 \right\rangle \otimes U\left| \psi \right\rangle - \left| 1 \right\rangle \otimes U\left| \psi \right\rangle \right\rbrack$$

$$\Rightarrow \left| 0 \right\rangle\mathbb{\otimes (I +}U)\left| \psi \right\rangle + \left| 1 \right\rangle\mathbb{\otimes (I -}U)\left| \psi \right\rangle$$

å½“å¯¹ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹è¿›è¡Œæµ‹é‡æ—¶ï¼Œè®°ä½ä¸ºäº†æ‰¾åˆ°æµ‹é‡ç»“æœä¸º0çš„æ¦‚ç‡ï¼Œæˆ‘ä»¬å¿…é¡»å°†æ€å‘é‡çš„å†…ç§¯ä¸$|0\rangle$ç›¸ä¹˜ï¼Œç„¶åä¹˜ä»¥å…¶å¤å…±è½­ï¼ˆå¦‚æœ‰ï¼æ‚¨å¯¹æ­¤å¹¶ä¸ç†Ÿæ‚‰ï¼Œè¯·å‚è§æœ¬æ•™ç¨‹ä¸­çš„é‡å­åŠ›å­¦éƒ¨åˆ†ï¼‰ã€‚æµ‹é‡ç»“æœä¸º1çš„æ¦‚ç‡ä¹ŸåŒæ ·å¤„ç†ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ï¼š

$$P\left( 0 \right) = \frac{1}{4}\left\langle \psi\left| \left( \mathbb{I} + U \right)\left( \mathbb{I} + U^{\dagger} \right) \right|\psi \right\rangle$$

$$= \frac{1}{4}\left\langle \psi\left| \mathbb{I}^{2} + U + U^{\dagger} + U^{\dagger}U \right|\psi \right\rangle$$

$$= \frac{1}{4}\langle\psi|(2\mathbb{I} + U + U^{\dagger})|\psi\rangle$$

$$\Rightarrow \frac{1}{4}\left\lbrack 2 + \left\langle \psi\left| U^{\dagger} \right|\psi \right\rangle + \left\langle \psi\left| U \right|\psi \right\rangle \right\rbrack$$

$$= \frac{1}{4}\left\lbrack 2 + \left( \left\langle \psi\left| U \right|\psi \right\rangle \right)^{*} + \left\langle \psi\left| U \right|\psi \right\rangle \right\rbrack$$

$$= \frac{1}{2}(1 + \mathbf{\text{Re}}\left\langle \psi\left| U \right|\psi \right\rangle)$$

é€šè¿‡ç›¸åŒçš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š

$$P\left( 1 \right) = \frac{1}{2}(1 - \mathbf{\text{Re}}\left\langle \psi\left| U \right|\psi \right\rangle)$$

å› æ­¤é€šè¿‡ç›¸å‡ï¼š

$$P\left( 0 \right) - P\left( 1 \right) = \mathbf{\text{Re}}\left\langle \psi\left| U \right|\psi \right\rangle$$

é…·å§ï¼ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°è¿™ä¸¤ä¸ªè¦è®¡ç®—çš„å€¼ã€‚ä»$\left\langle \Phi \middle| \Phi \right\rangle$,æˆ‘ä»¬æœ‰ï¼š

$$\left\langle \Phi \middle| \Phi \right\rangle = \left\langle \psi\left( k \right)\left| A^{\dagger}A \right|\psi\left( k \right) \right\rangle = \left\langle 0\left| V\left( k \right)^{\dagger}A^{\dagger}\text{AV}\left( k \right) \right|0 \right\rangle = \langle 0|V\left( k \right)^{\dagger}\left( \sum_{n}^{}{c_{n}A_{n}} \right)^{\dagger}\left( \sum_{n}^{}{c_{n}A_{n}} \right)V(k)|0\rangle$$

$$\Rightarrow \left\langle \Phi \middle| \Phi \right\rangle = \sum_{m}^{}{\sum_{n}^{}{c_{m}^{*}c_{n}\langle 0|V\left( k \right)^{\dagger}A_{m}^{\dagger}A_{n}V(k)|0\rangle}}$$

å› æ­¤æˆ‘ä»¬çš„ä»»åŠ¡å°±æ˜¯ä½¿ç”¨Hadamardæµ‹è¯•è®¡ç®—æ¯ä¸ªå¯èƒ½çš„é¡¹$\langle 0|V\left( k \right)^{\dagger}A_{m}^{\dagger}A_{n}V(k)|0\rangle$ã€‚è¿™è¦æ±‚æˆ‘ä»¬å‡†å¤‡æ€$V(k)|0\rangle$ï¼Œç„¶åå¯¹ä¸€äº›çŸ©é˜µ$A_{m}^{\dagger}$å’Œ$A_{n}$ä½¿ç”¨ä¸€äº›è¾…åŠ©å—æ§é‡å­æ¯”ç‰¹æ‰§è¡Œå—æ§è¿ç®—ã€‚æˆ‘ä»¬å¯ä»¥ç”¨å¦‚ä¸‹ä»£ç å®ç°ï¼š

> \#Creates the Hadamard test
>
> def had_test(gate_type, qubits, ancilla_index, parameters):
>
> circ.h(ancilla_index)
>
> apply_fixed_ansatz(qubits, parameters)
>
> for ie in range (0, len(gate_type\[0\])):
>
> if (gate_type\[0\]\[ie\] == 1):
>
> circ.cz(ancilla_index, qubits\[ie\])
>
> for ie in range (0, len(gate_type\[1\])):
>
> if (gate_type\[1\]\[ie\] == 1):
>
> circ.cz(ancilla_index, qubits\[ie\])
>
> circ.h(ancilla_index)
>
> circ = QuantumCircuit(4)
>
> had_test(\[\[0, 0, 0\], \[0, 0, 1\]\], \[1, 2, 3\], 0, \[\[1, 1, 1\],
> \[1, 1, 1\], \[1, 1, 1\]\])
>
> circ.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image309.png)

åº”ç”¨ä¸¤ç§ä¸åŒç±»å‹é‡å­é—¨çš„ç†ç”±ä¸ºè¿™äº›é‡å­é—¨å‘ˆç°äº†$\left\langle \Phi \middle| \Phi \right\rangle$çš„æ‰©å±•å½¢å¼ã€‚

åŒæ ·é‡è¦ä¸”éœ€è¦æ³¨æ„çš„æ˜¯å¯¹äºæ­¤å®ç°çš„ç›®çš„ï¼ˆå®é™…ä¸Šè¦æ±‚è§£çš„æ–¹ç¨‹ç»„ï¼Œæˆ‘ä»¬åªå…³å¿ƒ$Z$å’Œ$\mathbb{I}$é—¨ï¼Œå› æ­¤ä»…åŒ…æ‹¬å¯¹è¿™äº›é‡å­é—¨çš„æ”¯æŒï¼ˆä»£ç ä¸­æ‰€åŒ…å«çš„æ•°å­—"æ ‡è¯†ç¬¦"è¡¨ç¤ºåº”ç”¨äº†ä¸åŒçš„é—¨ï¼š0è¡¨ç¤º$\mathbb{I}$ï¼Œ1è¡¨ç¤º$Z$ï¼‰ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­è®¡ç®—çš„ç¬¬äºŒä¸ªå€¼$|\langle b|\Phi\rangle|^{2}$ã€‚

$$\left| \left\langle b \middle| \Phi \right\rangle \right|^{2} = \left| \left\langle b\left| \text{AV}\left( k \right) \right|0 \right\rangle \right|^{2} = \left| \left\langle 0\left| U^{\dagger}\text{AV}\left( k \right) \right|0 \right\rangle \right|^{2}$$

$$= \left\langle 0\left| U^{\dagger}\text{AV}\left( k \right) \right|0 \right\rangle\left\langle 0\left| V\left( k \right)^{\dagger}A^{\dagger}U \right|0 \right\rangle$$

ç°åœ¨è¦åšçš„å°±æ˜¯å¯¹ä¹˜ç§¯$\langle 0|U^{\dagger}AV(k)|0\rangle\langle 0|V(k)^{\dagger}A^{\dagger}U|0\rangle$åšç›¸åŒçš„æ‰©å±•ï¼š

$$\langle 0\left| U^{\dagger}\text{AV}\left( k \right) \right|0\rangle^{2} = \sum_{m}^{}{\sum_{n}^{}{c_{m}^{*}c_{n}\left\langle 0\left| U_{n}^{\dagger A}V\left( k \right) \right|0 \right\rangle\left\langle 0\left| V\left( k \right)^{\dagger}A_{m}^{\dagger}U \right|0 \right\rangle}}$$

ç°åœ¨ï¼ŒæŒ‰ç…§æœ¬æ¬¡æ¼”ç¤ºçš„ç›®çš„ï¼Œæˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°æ¼”ç¤ºå®ç°çš„æ‰€æœ‰è¾“å‡ºå’ŒæœŸæœ›å€¼éƒ½ä¸ºå®æ•°ï¼Œå› æ­¤ï¼š

$$\Rightarrow \left\langle 0\left| U^{\dagger}\text{AV}\left( k \right) \right|0 \right\rangle = \left( \left\langle 0\left| U^{\dagger}\text{AV}\left( k \right) \right|0 \right\rangle \right)^{*} = \left\langle 0\left| V\left( k \right)^{\dagger}A^{\dagger}U \right|0 \right\rangle$$

å› æ­¤ï¼Œåœ¨è¿™ä¸€ç‰¹å®šçš„å®ç°ä¸­ï¼š

$$\left| \left\langle b \middle| \Phi \right\rangle \right|^{2} = \sum_{m}^{}{\sum_{n}^{}{c_{m}c_{n}\left\langle 0\left| U^{\dagger}A_{n}V\left( k \right) \right|0 \right\rangle\left\langle 0\left| U^{\dagger}A_{m}V\left( k \right) \right|0 \right\rangle}}$$

ä½¿ç”¨æ–°æå‡ºçš„å­ä¾‹ç¨‹Hadamardé‡å æµ‹è¯•ï¼ˆå‚è§å¼•ç”¨çš„è®ºæ–‡ï¼‰ï¼Œæœ‰ä¸€ç§æ±‚è§£è¯¥å€¼çš„å¤æ‚æ–¹æ³•ï¼Œä½†å¯¹äºæœ¬æ•™ç¨‹ï¼Œæˆ‘ä»¬ä»…ä½¿ç”¨æ ‡å‡†çš„Hadamardæµ‹è¯•ï¼Œåœ¨å…¶ä¸­æ§åˆ¶æ¯ä¸ªçŸ©é˜µã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™éœ€è¦ä½¿ç”¨é¢å¤–çš„è¾…åŠ©é‡å­æ¯”ç‰¹ã€‚ä»æœ¬è´¨æ¥è¯´åªæ˜¯å°†æ§åˆ¶ç½®äºæ‰€æ¶‰åŠçš„è¾…åŠ©é‡å­æ¯”ç‰¹ï¼Œæ€$|b\rangle$ç”¨äºå‡†å¤‡ä¸€ä¸ªå¹ºæ­£å˜æ¢ï¼Œåˆ™$A_{n}$æ˜¯å¹ºæ­£çŸ©é˜µã€‚å› æ­¤å¾—åˆ°äº†å¦‚ä¸‹å—æ§æ‹Ÿè®¾ï¼š

> \#Creates controlled anstaz for calculating \|\<b\|psi\>\|\^2 with a
> Hadamard test
>
> def control_fixed_ansatz(qubits, parameters, ancilla, reg):
>
> for i in range (0, len(qubits)):
>
> circ.cry(parameters\[0\]\[i\], qiskit.circuit.Qubit(reg, ancilla),
> qiskit.circuit.Qubit(reg, qubits\[i\]))
>
> circ.ccx(ancilla, qubits\[1\], 4)
>
> circ.cz(qubits\[0\], 4)
>
> circ.ccx(ancilla, qubits\[1\], 4)
>
> circ.ccx(ancilla, qubits\[0\], 4)
>
> circ.cz(qubits\[2\], 4)
>
> circ.ccx(ancilla, qubits\[0\], 4)
>
> for i in range (0, len(qubits)):
>
> circ.cry(parameters\[1\]\[i\], qiskit.circuit.Qubit(reg, ancilla),
> qiskit.circuit.Qubit(reg, qubits\[i\]))
>
> circ.ccx(ancilla, qubits\[2\], 4)
>
> circ.cz(qubits\[1\], 4)
>
> circ.ccx(ancilla, qubits\[2\], 4)
>
> circ.ccx(ancilla, qubits\[0\], 4)
>
> circ.cz(qubits\[2\], 4)
>
> circ.ccx(ancilla, qubits\[0\], 4)
>
> for i in range (0, len(qubits)):
>
> circ.cry(parameters\[2\]\[i\], qiskit.circuit.Qubit(reg, ancilla),
> qiskit.circuit.Qubit(reg, qubits\[i\]))
>
> q_reg = QuantumRegister(5)
>
> circ = QuantumCircuit(q_reg)
>
> control_fixed_ansatz(\[1, 2, 3\], \[\[1, 1, 1\], \[1, 1, 1\], \[1, 1,
> 1\]\], 0, q_reg)
>
> circ.draw()

è¾“å‡ºï¼š

![](pics/media/image310.png)

æ­£å¦‚æ‰€å»ºå›è·¯æ‰€ç¤ºï¼šé¢å¤–çš„é‡å­æ¯”ç‰¹q0_4ã€‚è¿™æ˜¯ä¸€ä¸ªè¾…åŠ©é‡å­æ¯”ç‰¹ï¼Œå¯ä»¥è®©æˆ‘ä»¬åˆ›å»º$\text{CZZ}$é‡å­é—¨ã€‚ç°åœ¨è¿˜éœ€ä¸º$U$åˆ›å»ºå›è·¯ã€‚åœ¨æœ¬ç¤ºä¾‹çš„å®ç°ä¸­ï¼Œæˆ‘ä»¬å°†$U$å–ä¸ºï¼š

$$U = H_{1}H_{2}H_{3}$$

å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ï¼š

> def control_b(ancilla, qubits):
>
> for ia in qubits:
>
> circ.ch(ancilla, ia)
>
> circ = QuantumCircuit(4)
>
> control_b(0, \[1, 2, 3\])
>
> circ.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image311.png)

æœ€åï¼Œæ„å»ºæ–°çš„Hadamardæµ‹è¯•ï¼š

> \#Create the controlled Hadamard test, for calculating \<psi\|psi\>
>
> def special_had_test(gate_type, qubits, ancilla_index, parameters,
> reg):
>
> circ.h(ancilla_index)
>
> control_fixed_ansatz(qubits, parameters, ancilla_index, reg)
>
> for ty in range (0, len(gate_type)):
>
> if (gate_type\[ty\] == 1):
>
> circ.cz(ancilla_index, qubits\[ty\])
>
> control_b(ancilla_index, qubits)
>
> circ.h(ancilla_index)
>
> q_reg = QuantumRegister(5)
>
> circ = QuantumCircuit(q_reg)
>
> special_had_test(\[\[0, 0, 0\], \[0, 0, 1\]\], \[1, 2, 3\], 0, \[\[1,
> 1, 1\], \[1, 1, 1\], \[1, 1, 1\]\], q_reg)
>
> circ.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image312.png)

å½“æˆ‘ä»¬å°†æ‰€æœ‰å‚æ•°éƒ½è®¾ç½®ä¸º1æ—¶ï¼Œè¿™å°±æ˜¯ä¸€ä¸ªç‰¹å®šçš„å®ç°ï¼Œæ­¤æ—¶é‡å­é—¨çš„é›†åˆ$A_{n}$ä»…ä¸º\[0,0,0\]å’Œ\[0,0,1\]ï¼Œå…¶æ‰€å¯¹åº”çš„æ˜¯æ‰€æœ‰é‡å­æ¯”ç‰¹çš„å•ä½çŸ©é˜µä»¥åŠç¬¬ä¸‰ä¸ªé‡å­æ¯”ç‰¹ä¸Šçš„$Z$çŸ©é˜µã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬å‡†å¤‡è®¡ç®—æœ€ç»ˆçš„ä»£ä»·å‡½æ•°ã€‚è¿™ä»…æ¶‰åŠæˆ‘ä»¬å°†æ¥è‡ªä¸åŒå›è·¯æœŸæœ›è¾“å‡ºçš„æ‰€æœ‰ç»„åˆçš„ä¹˜ç§¯ä¹˜ä»¥å„è‡ªçš„ç³»æ•°ï¼Œå¹¶å¯¼å…¥åˆ°æˆ‘ä»¬å…ˆå‰è®¨è®ºçš„ä»£ä»·å‡½æ•°ä¸­ï¼

> \#Implements the entire cost function on the quantum circuit
>
> def calculate_cost_function(parameters):
>
> global opt
>
> overall_sum_1 = 0
>
> parameters = \[parameters\[0:3\], parameters\[3:6\],
> parameters\[6:9\]\]
>
> for i in range(0, len(gate_set)):
>
> for j in range(0, len(gate_set)):
>
> global circ
>
> qctl = QuantumRegister(5)
>
> qc = ClassicalRegister(5)
>
> circ = QuantumCircuit(qctl, qc)
>
> backend = Aer.get_backend(\'statevector_simulator\')
>
> multiply = coefficient_set\[i\]\*coefficient_set\[j\]
>
> had_test(\[gate_set\[i\], gate_set\[j\]\], \[1, 2, 3\], 0, parameters)
>
> job = execute(circ, backend)
>
> result = job.result()
>
> outputstate = np.real(result.get_statevector(circ, decimals=100))
>
> o = outputstate
>
> m_sum = 0
>
> for l in range (0, len(o)):
>
> if (l%2 == 1):
>
> n = o\[l\]\*\*2
>
> m_sum+=n
>
> overall_sum_1+=multiply\*(1-(2\*m_sum))
>
> overall_sum_2 = 0
>
> for i in range(0, len(gate_set)):
>
> for j in range(0, len(gate_set)):
>
> multiply = coefficient_set\[i\]\*coefficient_set\[j\]
>
> mult = 1
>
> for extra in range(0, 2):
>
> qctl = QuantumRegister(5)
>
> qc = ClassicalRegister(5)
>
> circ = QuantumCircuit(qctl, qc)
>
> backend = Aer.get_backend(\'statevector_simulator\')
>
> if (extra == 0):
>
> special_had_test(gate_set\[i\], \[1, 2, 3\], 0, parameters, qctl)
>
> if (extra == 1):
>
> special_had_test(gate_set\[j\], \[1, 2, 3\], 0, parameters, qctl)
>
> job = execute(circ, backend)
>
> result = job.result()
>
> outputstate = np.real(result.get_statevector(circ, decimals=100))
>
> o = outputstate
>
> m_sum = 0
>
> for l in range (0, len(o)):
>
> if (l%2 == 1):
>
> n = o\[l\]\*\*2
>
> m_sum+=n
>
> mult = mult\*(1-(2\*m_sum))
>
> overall_sum_2+=multiply\*mult
>
> print(1-float(overall_sum_2/overall_sum_1))
>
> return 1-float(overall_sum_2/overall_sum_1)

è¿™æ®µä»£ç çœ‹èµ·æ¥é•¿è€Œä»¤äººæ€¯æ­¥ï¼Œä½†äº‹å®å¹¶éå¦‚æ­¤ï¼åœ¨è¿™ä¸ªæ¨¡æ‹Ÿä¸­é‡‡ç”¨äº†ä¸€ç§æ•°å€¼æ–¹æ³•ï¼Œè®¡ç®—æ¯ä¸ªå¯¹åº”çŠ¶æ€å¹…å€¼çš„å¹³æ–¹æ¥å¯¹å¤„äºæ€$1$çš„é‡å­æ¯”ç‰¹è¿›è¡Œè¾…åŠ©Hadamardæµ‹è¯•çš„æµ‹é‡ï¼Œç„¶åä¸€å¥æ‰€å¾—ä¿¡æ¯è®¡ç®—$P(0) - P(1) = 1 - 2P(1)$æ¯ã€‚è¿™ä¸€è®¡ç®—è¿‡ç¨‹æ˜¯éå¸¸ç²¾ç¡®ä½†ä¸ç°å®ï¼Œå› ä¸ºä¸€ä¸ªçœŸæ­£çš„é‡å­è®¾å¤‡å°†ä¸å¾—ä¸å¯¹ç”µè·¯è¿›è¡Œå¤šæ¬¡é‡‡æ ·ä»¥äº§ç”Ÿè¿™äº›æ¦‚ç‡ï¼ˆå°†åœ¨ä¸‹æ–‡ä¸­è®¨è®ºé‡‡æ ·ï¼‰ã€‚æ­¤å¤–ï¼Œè¿™æ®µä»£ç è¿˜æ²¡æœ‰å®Œå…¨ä¼˜åŒ–ï¼ˆå…¶æ‰€å®Œæˆçš„é‡å­å›è·¯çš„è¯„ä¼°æ¯”éœ€è¦å…¶å®Œæˆçš„è¿˜å¤šï¼‰ï¼Œä½†è¿™æ˜¯å®ç°ä»£ç çš„æœ€ç®€å•æ–¹å¼ï¼Œå°†åœ¨æœ¬æ•™ç¨‹çš„æ›´æ–°ä¸­å¯¹å…¶è¿›è¡Œä¼˜åŒ–ã€‚

æœ€åä¸€æ­¥æ˜¯ä½¿ç”¨è¿™ä¸€ä»£ç è§£å†³ä¸€ä¸ªçœŸæ­£çš„çº¿æ€§ç³»ç»Ÿé—®é¢˜ï¼š

$$A = 0.45Z_{3} + 0.55\mathbb{I}$$

ä¸ºäº†ä½¿ä»£ä»·å‡½æ•°æœ€å°ï¼Œæˆ‘ä»¬åå¤ä½¿ç”¨äº†COBYLAä¼˜åŒ–æ–¹æ³•ã€‚æ‰€è¦æœç´¢çš„å‚æ•°ç©ºé—´ç”±$\frac{k}{1000}\text{\ \ }k \in \left\{ 0,3000 \right\}$å®šä¹‰ï¼Œæœ€åˆæ˜¯éšæœºé€‰æ‹©çš„ã€‚æˆ‘ä»¬å°†ä¼šè¿è¡Œè¯¥ä¼˜åŒ–å™¨200æ­¤ï¼Œç„¶åå¯¹æœ€ä½³å‚æ•°åº”ç”¨æ‹Ÿè®¾æ¥è·å–æœ€ä½³çš„æ€å‘é‡ï¼ä¸ºäº†å®ç°è¿™ä¸€æ­¥éª¤ï¼Œæˆ‘ä»¬å°†ä¼šåœ¨æœ€ä½³å‘é‡$|\psi\rangle_{o}$ä¸Šåº”ç”¨$A$æ¥å¯¹å…¶è¿›è¡Œå½’ä¸€åŒ–ï¼Œç„¶åè®¡ç®—è¯¥å‘é‡ä¸è§£å‘é‡$|b\rangle$å†…ç§¯çš„å¹³æ–¹ï¼å°†ä¸Šè¿°æ‰€æœ‰è¿‡ç¨‹æ”¾å…¥ä»£ç ï¼š

> coefficient_set = \[0.55, 0.45\]
>
> gate_set = \[\[0, 0, 0\], \[0, 0, 1\]\]
>
> out = minimize(calculate_cost_function,
> x0=\[float(random.randint(0,3000))/1000 for i in range(0, 9)\],
> method=\"COBYLA\", options={\'maxiter\':200})
>
> print(out)
>
> out_f = \[out\[\'x\'\]\[0:3\], out\[\'x\'\]\[3:6\],
> out\[\'x\'\]\[6:9\]\]
>
> circ = QuantumCircuit(3, 3)
>
> apply_fixed_ansatz(\[0, 1, 2\], out_f)
>
> backend = Aer.get_backend(\'statevector_simulator\')
>
> job = execute(circ, backend)
>
> result = job.result()
>
> o = result.get_statevector(circ, decimals=10)
>
> a1 = coefficient_set\[1\]\*np.array(\[\[1,0,0,0,0,0,0,0\],
> \[0,1,0,0,0,0,0,0\], \[0,0,1,0,0,0,0,0\], \[0,0,0,1,0,0,0,0\],
> \[0,0,0,0,-1,0,0,0\], \[0,0,0,0,0,-1,0,0\], \[0,0,0,0,0,0,-1,0\],
> \[0,0,0,0,0,0,0,-1\]\])
>
> a2 = coefficient_set\[0\]\*np.array(\[\[1,0,0,0,0,0,0,0\],
> \[0,1,0,0,0,0,0,0\], \[0,0,1,0,0,0,0,0\], \[0,0,0,1,0,0,0,0\],
> \[0,0,0,0,1,0,0,0\], \[0,0,0,0,0,1,0,0\], \[0,0,0,0,0,0,1,0\],
> \[0,0,0,0,0,0,0,1\]\])
>
> a3 = np.add(a1, a2)
>
> b =
> np.array(\[float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8))\])
>
> print((b.dot(a3.dot(o)/(np.linalg.norm(a3.dot(o)))))\*\*2)
>
> è¾“å‡ºï¼š
>
> 0.9525017762138146
>
> ...
>
> 0.0017136719460107974
>
> fun: 0.0017136719460107974
>
> maxcv: 0.0
>
> message: \'Maximum number of function evaluations has been exceeded.\'
>
> nfev: 200
>
> status: 2
>
> success: False
>
> x: array(\[3.12960969, 3.25355402, 1.64878693, 2.02209032, 2.15355337,
>
> 1.6535498 , 2.64233591, 2.76727927, 2.93611543\])
>
> (0.9982863280442702-0j)

æ­£å¦‚è¾“å‡ºæ‰€ç¤ºï¼Œä»£ä»·å‡½æ•°å·²è¾¾åˆ°è¾ƒä½å€¼0.03273673575407443ï¼Œå½“è®¡ç®—ç»å…¸ä»£ä»·å‡½æ•°æ—¶æ‰€çš„å€¼ä¸º0.96776862579723ï¼Œå®Œå…¨ç¬¦åˆæˆ‘ä»¬çš„æµ‹é‡ï¼šå‘é‡$|\psi\rangle_{o}$ä¸$|b\rangle$éå¸¸ç›¸è¿‘ï¼

è®©æˆ‘ä»¬å†åšä¸€ä¸ªæµ‹è¯•å§ï¼è¿™ä¸€æ¬¡,æˆ‘ä»¬å°†ä¿æŒ$|b\rangle$ä¸å˜ï¼Œä½†å°†ï¼š

$$A = 0.55\mathbb{I} + 0.225Z_{2} + 0.225Z_{3}$$

å†ä¸€æ¬¡è¿è¡Œä¼˜åŒ–ä»£ç ï¼š

> coefficient_set = \[0.55, 0.225, 0.225\]
>
> gate_set = \[\[0, 0, 0\], \[0, 1, 0\], \[0, 0, 1\]\]
>
> out = minimize(calculate_cost_function,
> x0=\[float(random.randint(0,3000))/1000 for i in range(0, 9)\],
> method=\"COBYLA\", options={\'maxiter\':200})
>
> print(out)
>
> out_f = \[out\[\'x\'\]\[0:3\], out\[\'x\'\]\[3:6\],
> out\[\'x\'\]\[6:9\]\]
>
> circ = QuantumCircuit(3, 3)
>
> apply_fixed_ansatz(\[0, 1, 2\], out_f)
>
> backend = Aer.get_backend(\'statevector_simulator\')
>
> job = execute(circ, backend)
>
> result = job.result()
>
> o = result.get_statevector(circ, decimals=10)
>
> a1 = coefficient_set\[2\]\*np.array(\[\[1,0,0,0,0,0,0,0\],
> \[0,1,0,0,0,0,0,0\], \[0,0,1,0,0,0,0,0\], \[0,0,0,1,0,0,0,0\],
> \[0,0,0,0,-1,0,0,0\], \[0,0,0,0,0,-1,0,0\], \[0,0,0,0,0,0,-1,0\],
> \[0,0,0,0,0,0,0,-1\]\])
>
> a0 = coefficient_set\[1\]\*np.array(\[\[1,0,0,0,0,0,0,0\],
> \[0,1,0,0,0,0,0,0\], \[0,0,-1,0,0,0,0,0\], \[0,0,0,-1,0,0,0,0\],
> \[0,0,0,0,1,0,0,0\], \[0,0,0,0,0,1,0,0\], \[0,0,0,0,0,0,-1,0\],
> \[0,0,0,0,0,0,0,-1\]\])
>
> a2 = coefficient_set\[0\]\*np.array(\[\[1,0,0,0,0,0,0,0\],
> \[0,1,0,0,0,0,0,0\], \[0,0,1,0,0,0,0,0\], \[0,0,0,1,0,0,0,0\],
> \[0,0,0,0,1,0,0,0\], \[0,0,0,0,0,1,0,0\], \[0,0,0,0,0,0,1,0\],
> \[0,0,0,0,0,0,0,1\]\])
>
> a3 = np.add(np.add(a2, a0), a1)
>
> b =
> np.array(\[float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8))\])
>
> print((b.dot(a3.dot(o)/(np.linalg.norm(a3.dot(o)))))\*\*2)
>
> è¾“å‡ºï¼š
>
> 0.9482467948093024
>
> ...
>
> 0.002908980739327327
>
> fun: 0.002908980739327327
>
> maxcv: 0.0
>
> message: \'Maximum number of function evaluations has been exceeded.\'
>
> nfev: 200
>
> status: 2
>
> success: False
>
> x: array(\[3.10826981, 1.46209082, 0.62663923, 2.95395745, 1.91693021,
>
> 0.34911488, 1.60850267, 2.32093243, 3.00529306\])
>
> (0.9970910192620044-0j)

å…¶ç»“æœè¿˜æ˜¯éå¸¸çš„å°ï¼š0.00014718223342624626ï¼Œè€Œç»å…¸ä»£ä»·å‡½æ•°çš„è¾“å‡ºä¸º0.9998563418983931ã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬å‘ç°è¿™ä¸ªç®—æ³•åœ¨**ç†è®ºä¸Š**æ˜¯å¯è¡Œçš„ã€‚æˆ‘ä»¬è¯•ç€ç”¨ä¸€ä¸ªå›è·¯çš„æ¨¡æ‹Ÿæ¥å¯¹å›è·¯è¿›è¡Œé‡‡æ ·ï¼Œè€Œéè®¡ç®—æ•°å€¼æ¦‚ç‡ã€‚ç°åœ¨å¦‚åŒåœ¨çœŸå®çš„é‡å­è®¡ç®—æœºä¸­ä¸€æ ·ï¼Œå°è¯•å¯¹é‡å­å›è·¯è¿›è¡Œ**é‡‡æ ·**!å‡ºäºæŸç§åŸå› ï¼Œè¿™ç§æ¨¡æ‹Ÿåªèƒ½åœ¨ç›¸å½“æ•°é‡çš„"æ¬¡æ•°"ï¼ˆä¸ºäº†è®¡ç®—ç»“æœçš„æ¦‚ç‡åˆ†å¸ƒè€Œè¿è¡Œçš„å›è·¯ï¼‰æƒ…å†µä¸‹æ‰èƒ½å¾ˆå¥½åœ°æ”¶æ•›ã€‚æˆ‘ä»¬è®¤ä¸ºè¿™ä¸»è¦ä¸ç»å…¸ä¼˜åŒ–å™¨ï¼ˆCOBYLAï¼‰çš„å±€é™æ€§æœ‰å…³ï¼Œå› ä¸ºé‡‡æ ·é‡å­ç”µè·¯æ—¶çš„å™ªå£°ç‰¹æ€§ï¼ˆå…·æœ‰ç›¸åŒå‚æ•°çš„æµ‹é‡å¹¶ä¸æ€»æ˜¯äº§ç”Ÿç›¸åŒçš„ç»“æœï¼‰ã€‚å¹¸è¿çš„æ˜¯ï¼Œè¿˜æœ‰å…¶ä»–ä¸ºå™ªå£°å‡½æ•°æ„å»ºçš„ä¼˜åŒ–å™¨ï¼Œæ¯”å¦‚SPSAï¼Œä½†åœ¨æœ¬æ•™ç¨‹ä¸­ä¸ä¼šæ·±å…¥ç ”ç©¶ã€‚æˆ‘ä»¬è¯•ç€ç”¨ç›¸åŒçš„çŸ©é˜µ$U$å¯¹$A$çš„ç¬¬äºŒä¸ªå€¼è¿›è¡Œï¼š

> \#Implements the entire cost function on the quantum circuit
> (sampling, 100000 shots)
>
> def calculate_cost_function(parameters):
>
> global opt
>
> overall_sum_1 = 0
>
> parameters = \[parameters\[0:3\], parameters\[3:6\],
> parameters\[6:9\]\]
>
> for i in range(0, len(gate_set)):
>
> for j in range(0, len(gate_set)):
>
> global circ
>
> qctl = QuantumRegister(5)
>
> qc = ClassicalRegister(1)
>
> circ = QuantumCircuit(qctl, qc)
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> multiply = coefficient_set\[i\]\*coefficient_set\[j\]
>
> had_test(\[gate_set\[i\], gate_set\[j\]\], \[1, 2, 3\], 0, parameters)
>
> circ.measure(0, 0)
>
> job = execute(circ, backend, shots=100000)
>
> result = job.result()
>
> outputstate = result.get_counts(circ)
>
> if (\'1\' in outputstate.keys()):
>
> m_sum = float(outputstate\[\"1\"\])/100000
>
> else:
>
> m_sum = 0
>
> overall_sum_1+=multiply\*(1-2\*m_sum)
>
> overall_sum_2 = 0
>
> for i in range(0, len(gate_set)):
>
> for j in range(0, len(gate_set)):
>
> multiply = coefficient_set\[i\]\*coefficient_set\[j\]
>
> mult = 1
>
> for extra in range(0, 2):
>
> qctl = QuantumRegister(5)
>
> qc = ClassicalRegister(1)
>
> circ = QuantumCircuit(qctl, qc)
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> if (extra == 0):
>
> special_had_test(gate_set\[i\], \[1, 2, 3\], 0, parameters, qctl)
>
> if (extra == 1):
>
> special_had_test(gate_set\[j\], \[1, 2, 3\], 0, parameters, qctl)
>
> circ.measure(0, 0)
>
> job = execute(circ, backend, shots=100000)
>
> result = job.result()
>
> outputstate = result.get_counts(circ)
>
> if (\'1\' in outputstate.keys()):
>
> m_sum = float(outputstate\[\"1\"\])/100000
>
> else:
>
> m_sum = 0
>
> mult = mult\*(1-2\*m_sum)
>
> overall_sum_2+=multiply\*mult
>
> print(1-float(overall_sum_2/overall_sum_1))
>
> return 1-float(overall_sum_2/overall_sum_1)
>
> coefficient_set = \[0.55, 0.225, 0.225\]
>
> gate_set = \[\[0, 0, 0\], \[0, 1, 0\], \[0, 0, 1\]\]
>
> out = minimize(calculate_cost_function,
> x0=\[float(random.randint(0,3000))/1000 for i in range(0, 9)\],
> method=\"COBYLA\", options={\'maxiter\':200})
>
> print(out)
>
> out_f = \[out\[\'x\'\]\[0:3\], out\[\'x\'\]\[3:6\],
> out\[\'x\'\]\[6:9\]\]
>
> circ = QuantumCircuit(3, 3)
>
> apply_fixed_ansatz(\[0, 1, 2\], out_f)
>
> backend = Aer.get_backend(\'statevector_simulator\')
>
> job = execute(circ, backend)
>
> result = job.result()
>
> o = result.get_statevector(circ, decimals=10)
>
> a1 = coefficient_set\[2\]\*np.array(\[\[1,0,0,0,0,0,0,0\],
> \[0,1,0,0,0,0,0,0\], \[0,0,1,0,0,0,0,0\], \[0,0,0,1,0,0,0,0\],
> \[0,0,0,0,-1,0,0,0\], \[0,0,0,0,0,-1,0,0\], \[0,0,0,0,0,0,-1,0\],
> \[0,0,0,0,0,0,0,-1\]\])
>
> a0 = coefficient_set\[1\]\*np.array(\[\[1,0,0,0,0,0,0,0\],
> \[0,1,0,0,0,0,0,0\], \[0,0,-1,0,0,0,0,0\], \[0,0,0,-1,0,0,0,0\],
> \[0,0,0,0,1,0,0,0\], \[0,0,0,0,0,1,0,0\], \[0,0,0,0,0,0,-1,0\],
> \[0,0,0,0,0,0,0,-1\]\])
>
> a2 = coefficient_set\[0\]\*np.array(\[\[1,0,0,0,0,0,0,0\],
> \[0,1,0,0,0,0,0,0\], \[0,0,1,0,0,0,0,0\], \[0,0,0,1,0,0,0,0\],
> \[0,0,0,0,1,0,0,0\], \[0,0,0,0,0,1,0,0\], \[0,0,0,0,0,0,1,0\],
> \[0,0,0,0,0,0,0,1\]\])
>
> a3 = np.add(np.add(a2, a0), a1)
>
> b =
> np.array(\[float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8)),float(1/np.sqrt(8))\])
>
> print((b.dot(a3.dot(o)/(np.linalg.norm(a3.dot(o)))))\*\*2)
>
> è¾“å‡ºï¼š
>
> 0.9514881256868424
>
> ...
>
> 0.2139899222278312
>
> fun: 0.2139899222278312
>
> maxcv: 0.0
>
> message: \'Optimization terminated successfully.\'
>
> nfev: 92
>
> status: 1
>
> success: True
>
> x: array(\[0.73273877, 2.2931889 , 3.0873678 , 0.17167063, 2.89176878,
>
> 2.49081023, 1.23099965, 2.55246703, 1.9982882 \])
>
> (0.7874538692918659+0j)

è¿˜æ˜¯å¦‚è¾“å‡ºæ‰€ç¤ºï¼Œæˆ‘ä»¬çš„è§£ä»æœ‰ç›¸å½“å¤§çš„å·®è·ï¼ˆ3.677ï¼…çš„è¯¯å·®å¹¶ä¸å¯æ€•ï¼Œä½†ç†æƒ³æƒ…å†µä¸‹å…¶åº”æ›´æ¥è¿‘äº0ï¼‰ã€‚åŒæ ·ï¼Œæˆ‘ä»¬è®¤ä¸ºè¿™æ˜¯ç”±äºä¼˜åŒ–å™¨æœ¬èº«è€Œä¸æ˜¯å®é™…çš„é‡å­å›è·¯æ‰€å¼•èµ·çš„ã€‚ä¸€æ—¦å¼„æ¸…æ¥šå¦‚ä½•è§£å†³æ­¤é—®é¢˜ï¼Œæˆ‘ä»¬å°†å¯¹æœ¬èŠ‚ä¸­çš„ä»£ç è¿›è¡Œæ›´æ–°ï¼ˆå¦‚å‰æ‰€è¿°ï¼Œå¯èƒ½å¼•å…¥å™ªå£°ä¼˜åŒ–å™¨ï¼‰ã€‚

#### 4. è‡´è°¢

æ­¤å®ç°åŸºäºç ”ç©¶è®ºæ–‡ã€Š[å¯å˜é‡å­çº¿æ€§æ±‚è§£ç®—æ³•ï¼šçº¿æ€§ç³»ç»Ÿçš„æ··åˆç®—æ³•](https://arxiv.org/abs/1909.05820)ã€‹ä¸­çš„å·¥ä½œï¼Œè¯¥è®ºæ–‡ç”±Carlos
Bravo-Prietoï¼ŒRyan LaRoseï¼ŒMã€‚Cerezoï¼ŒYiÄŸitSubaÅŸÄ±ï¼ŒLukasz
Cincioå’ŒPatrick J. Colesæ’°å†™ã€‚

ç‰¹åˆ«æ„Ÿè°¢Carlos Bravo-Prietoé€šè¿‡å›ç­”æœ‰å…³è®ºæ–‡çš„ä¸€äº›é—®é¢˜äº²è‡ªæä¾›å¸®åŠ©ï¼

5. ä½¿ç”¨é‡å­å›è·¯ç ”ç©¶é‡å­ç¡¬ä»¶
===========================

å³å°†åˆ°æ¥
--------

å½“å‰æ­£åœ¨å¼€å‘ä»¥ä¸‹ä¸»é¢˜ä»¥è¡¥å……æœ¬æ•™ç¨‹ï¼š

1\. å°†Isingæ¨¡å‹æ˜ å°„åˆ°è¶…å¯¼é‡å­è®¡ç®—æœºä¸Š

2\. çŠ¶æ€å’Œè¿‡ç¨‹å±‚ææˆåƒ

5.1 ä½¿ç”¨é‡å¤æ ¡éªŒï¼ˆRepetition Codeï¼‰ä¿®æ­£é‡å­è¯¯å·®çš„å…¥é—¨
-----------------------------------------------------

### ç®€ä»‹

é‡å­è®¡ç®—è¦æ±‚æˆ‘ä»¬ä»¥æ¯”ç‰¹ä¸ºå•ä½å¯¹ä¿¡æ¯è¿›è¡Œç¼–ç ã€‚åœ¨è¿‡å»çš„å‡ åå¹´ä¸­å¼€å‘çš„å¤§å¤šæ•°é‡å­ç®—æ³•éƒ½å‡å®šè¿™äº›é‡å­æ¯”ç‰¹æ˜¯å®Œç¾çš„ï¼šå®ƒä»¬å¯ä»¥åœ¨æˆ‘ä»¬æœŸæœ›çš„ä»»ä½•çŠ¶æ€ä¸‹è¿›è¡Œåˆ¶å¤‡ï¼Œå¹¶ä¸”å¯ä»¥å®Œå…¨ç²¾ç¡®åœ°è¿›è¡Œæ“çºµã€‚éµå¾ªè¿™äº›å‡è®¾çš„é‡å­æ¯”ç‰¹é€šå¸¸è¢«ç§°ä¸ºé€»è¾‘é‡å­æ¯”ç‰¹ï¼ˆlogical
qubitï¼‰ã€‚

åœ¨è¿‡å»çš„å‡ åå¹´ä¸­ï¼Œåœ¨å¯»æ‰¾è¡¨ç°ä¸ºé‡å­æ¯”ç‰¹çš„ç‰©ç†ç³»ç»Ÿæ–¹é¢å–å¾—äº†å·¨å¤§çš„è¿›æ­¥ï¼Œå¹¶ä¸”ä¸€ç›´åœ¨å¼€å‘è´¨é‡æ›´é«˜çš„é‡å­æ¯”ç‰¹ã€‚ä½†æ˜¯ï¼Œè¿™äº›ç¼ºé™·æ°¸è¿œæ— æ³•å®Œå…¨æ¶ˆé™¤ã€‚è¿™äº›é‡å­æ¯”ç‰¹æ€»æ˜¯éå¸¸ä¸ç²¾ç¡®ï¼Œä»¥è‡³äºä¸èƒ½ç›´æ¥ç”¨ä½œé€»è¾‘é‡å­æ¯”ç‰¹ã€‚å› æ­¤æˆ‘ä»¬å°†å…¶ç§°ä¸ºç‰©ç†é‡å­æ¯”ç‰¹ï¼ˆphysical
qubitï¼‰ã€‚

åœ¨å½“å‰çš„é‡å­è®¡ç®—æ—¶ä»£ï¼Œå°½ç®¡æœ‰ç¼ºé™·ï¼Œé€šè¿‡è®¾è®¡è‡ªå®šä¹‰ç®—æ³•å¹¶ä½¿ç”¨è¯¯å·®ç¼“è§£æªæ–½ï¼Œæˆ‘ä»¬ä»è¯•å›¾ä½¿ç”¨ç‰©ç†é‡å­æ¯”ç‰¹ã€‚ç„¶è€Œå¯¹äºæœªæ¥çš„å®¹é”™æ—¶ä»£ï¼Œæˆ‘ä»¬å¿…é¡»æ‰¾åˆ°ä»ç‰©ç†é‡å­æ¯”ç‰¹æ„å»ºé€»è¾‘é‡å­æ¯”ç‰¹çš„æ–¹æ³•ã€‚è¿™ä¸€è¿‡ç¨‹å°†é€šè¿‡é‡å­è¯¯å·®æ ¡æ­£çš„è¿‡ç¨‹æ¥å®Œæˆï¼Œå…¶ä¸­é€»è¾‘é‡å­æ¯”ç‰¹è¢«ç¼–ç åœ¨å¤§é‡ç‰©ç†é‡å­æ¯”ç‰¹ä¸­ã€‚é€šè¿‡ä¸æ–­åœ°å°†ç‰©ç†é‡å­æ¯”ç‰¹é€šè¿‡ä¸€ä¸ªé«˜åº¦çº ç¼ çš„å›è·¯æ¥ç»´æŒç¼–ç ã€‚è¾…åŠ©è‡ªç”±åº¦ä¹ŸæŒç»­åœ°è¢«æµ‹é‡æ¥æ£€æµ‹è¯¯å·®çš„è¿¹è±¡ï¼Œå¹¶å…è®¸ç”±è¯¯å·®å¸¦å‡ºçš„å½±å“ã€‚å®ç°é‡å­è®¡ç®—æ‰€éœ€é€»è¾‘é‡å­æ¯”ç‰¹çš„æ“ä½œå°†é€šè¿‡å¯¹è¿™ä¸€è¿‡ç¨‹è¿›è¡Œå®è´¨çš„å¾®å°æ‰°åŠ¨æ¥å®æ–½ã€‚

ç”±äºè¿™ä¸€è¿‡ç¨‹æ‰€éœ€è¦çš„å¤§é‡èµ„æºï¼Œåœ¨å®¹é”™é‡å­è®¡ç®—æœºä¸­æ‰§è¡Œçš„å¤§å¤šæ•°æ“ä½œå°†ç”¨äºè¯¯å·®çš„æ£€æµ‹å’Œä¿®æ­£ã€‚å› æ­¤ï¼Œå½“æˆ‘ä»¬å¯¹å®¹é”™é‡å­è®¡ç®—çš„è¿›å±•è¿›è¡ŒåŸºå‡†æµ‹è¯•æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»è·Ÿè¸ªæˆ‘ä»¬çš„è®¾å¤‡æ‰§è¡Œè¯¯å·®ä¿®æ­£çš„æƒ…å†µã€‚

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°ä¸€ä¸ªè¯¯å·®ä¿®æ­£çš„ç‰¹æ®Šä¾‹å­ï¼šé‡å¤æ ¡éªŒã€‚è™½ç„¶ä¸æ˜¯é‡å­è¯¯å·®ä¿®æ­£çš„çœŸå®ä¾‹å­------å…¶ä½¿ç”¨ç‰©ç†é‡å­æ¯”ç‰¹ç¼–ç é€»è¾‘æ¯”ç‰¹è€Œéé‡å­æ¯”ç‰¹------ä½†å¯ä»¥ä½œä¸ºæ‰€æœ‰é‡å­è¯¯å·®ä¿®æ­£æ ¡éªŒåŸºæœ¬æ¦‚å¿µçš„ç®€å•æŒ‡å—ã€‚æˆ‘ä»¬è¿˜å°†çœ‹åˆ°å…¶å¦‚ä½•åœ¨ç›®å‰çš„åŸå‹è®¾å¤‡ä¸Šè¿è¡Œã€‚

### é‡å¤æ ¡éªŒç®€ä»‹

#### è¯¯å·®ä¿®æ­£çš„åŸºæœ¬æ¦‚å¿µ

è¯¯å·®ä¿®æ­£çš„åŸºæœ¬æ€æƒ³å¯¹äºé‡å­ä¿¡æ¯å’Œç»å…¸ä¿¡æ¯æ˜¯ä¸€æ ·çš„ã€‚è¿™è®©æˆ‘ä»¬å¯ä»¥ä»ä¸€ä¸ªéå¸¸ç®€å•çš„ä¾‹å­å¼€å§‹ï¼šæ‰“ç”µè¯ã€‚å¦‚æœæœ‰äººé—®æ‚¨ä¸€ä¸ªé—®é¢˜çš„ç­”æ¡ˆæ˜¯"æ˜¯"æˆ–"ä¸æ˜¯"ï¼Œæ‚¨å›ç­”çš„æ–¹å¼å°†å–å†³äºä¸¤ä¸ªå› ç´ ï¼š

-   æ˜¯å¦æ­£ç¡®ç†è§£çš„é‡è¦æ€§ï¼Ÿ

-   ä¸æ‚¨çš„è¿é€šæ€§å¦‚ä½•ï¼Ÿ

ä»¥ä¸Šä¸¤ä¸ªå› ç´ éƒ½å¯ä»¥ç”¨æ¦‚ç‡å‚æ•°åŒ–ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨$P_{a}$è¡¨ç¤ºè¢«è¯¯è§£çš„æœ€å¤§å¯æ¥å—æ¦‚ç‡ã€‚å¦‚æœè¦æ±‚æ‚¨ç¡®è®¤å¯¹å†°æ·‡æ·‹å£å‘³çš„åçˆ±ï¼Œå¹¶ä¸”ä¸ä»‹æ„æ˜¯é¦™è‰æˆ–å·§å…‹åŠ›ï¼Œé‚£ä¹ˆ$P_{a}$å¯èƒ½ä¼šå¾ˆé«˜ã€‚ä½†å¦‚æœæ‚¨è¢«é—®åˆ°ä¸€ä¸ªå…³ä¹æŸäººç”Ÿå‘½çš„é—®é¢˜ï¼Œåˆ™$P_{a}$ä¼šä½å¾ˆå¤šã€‚

å¯¹äºç¬¬äºŒä¸ªï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨$p$è¡¨ç¤ºï¼Œå³æ‚¨çš„ç­”æ¡ˆå› è¿é€šé”™è¯¯è€Œå‡ºç°ä¹±ç çš„å¯èƒ½æ€§ã€‚è®©æˆ‘ä»¬æƒ³è±¡ä»¥ä¸‹æƒ…å†µï¼šä¸€ä¸ªä¹±ç çš„"æ˜¯"ä¸ä»…å¬èµ·æ¥åƒæ˜¯èƒ¡è¯´å…«é“ï¼Œè€Œä¸”å¬èµ·æ¥åƒæ˜¯"å¦"ã€‚åŒæ ·ï¼"å¦"è¢«è½¬æ¢ä¸º"æ˜¯"ã€‚é‚£ä¹ˆ$p$å°±æ˜¯æ‚¨å®Œå…¨è¢«è¯¯è§£çš„æ¦‚ç‡ã€‚

è‰¯å¥½çš„è¿é€šæˆ–ç›¸å¯¹ä¸é‡è¦çš„é—®é¢˜å°†å¯¼è‡´$p < P_{a}$ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæœ€å¥½ä»¥æœ€ç›´æ¥çš„æ–¹å¼ç®€å•å›ç­”ï¼šæ‚¨åªéœ€è¯´"æ˜¯"æˆ–"å¦"ã€‚

ä½†æ˜¯ï¼Œå¦‚æœæ‚¨çš„è¿é€šä¸ç•…å¹¶ä¸”æ‚¨çš„ç­”æ¡ˆå¾ˆé‡è¦ï¼Œæˆ‘ä»¬å°†å¾—åˆ°$p > P_{a}$ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»…"æ˜¯"æˆ–"å¦"æ˜¯ä¸å¤Ÿçš„ã€‚è¢«è¯¯è§£çš„å¯èƒ½æ€§ä¼šå¾ˆé«˜ã€‚å–è€Œä»£ä¹‹çš„æ˜¯ï¼Œæˆ‘ä»¬å¿…é¡»ä»¥æ›´å¤æ‚çš„ç»“æ„å¯¹ç­”æ¡ˆè¿›è¡Œç¼–ç ï¼Œä»è€Œä½¿æ¥æ”¶è€…å¯ä»¥è§£ç æˆ‘ä»¬çš„æ„æ€ï¼Œå°½ç®¡å¯èƒ½ä¼šç ´åæ¶ˆæ¯ã€‚æœ€ç®€å•çš„æ–¹æ³•ï¼ˆè®¸å¤šäººä¸åŠ æ€ç´¢çš„æ–¹æ³•ï¼‰ï¼šåªéœ€å°†ç­”æ¡ˆé‡å¤å¤šæ¬¡ã€‚ä¾‹å¦‚ï¼Œè¯´"æ˜¯ï¼Œæ˜¯ï¼Œæ˜¯"è€Œé"æ˜¯"ï¼Œæˆ–è€…è¯´"å¦ï¼Œå¦ï¼Œå¦"è€Œé"å¦"ã€‚

å¦‚æœåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¥æ”¶æ–¹å¬åˆ°"æ˜¯ï¼Œæ˜¯ï¼Œæ˜¯"ï¼Œåˆ™ä»–ä»¬å½“ç„¶ä¼šå¾—å‡ºç»“è®ºï¼Œå³å‘é€æ–¹çš„å›ç­”æ˜¯"æ˜¯"ã€‚å¦‚æœä»–ä»¬å¬åˆ°"å¦ï¼Œæ˜¯ï¼Œæ˜¯"ï¼Œ"æ˜¯ï¼Œå¦ï¼Œæ˜¯"æˆ–"æ˜¯ï¼Œæ˜¯ï¼Œå¦"ï¼Œä»–ä»¬å¯èƒ½ä¼šå¾—å‡ºç›¸åŒçš„ç»“è®ºï¼Œå› ä¸ºç­”æ¡ˆä¸­çš„è‚¯å®šå¤§äºå¦å®šã€‚ä¸ºäº†åœ¨è¿™ç§æƒ…å†µä¸‹è¢«è¯¯è§£ï¼Œç­”å¤ä¸­è‡³å°‘æœ‰ä¸¤ä¸ªé”™ä¹±ï¼Œ$P$çš„æ¦‚ç‡å°†å°äº$p$ã€‚å› æ­¤å½“ä»¥è¿™ç§æ–¹å¼ç¼–ç æ—¶ï¼Œä¿¡æ¯å°±æ›´å®¹æ˜“è¢«ç†è§£ã€‚ä¸‹é¢çš„ä»£ç æ˜¾ç¤ºäº†è¿™ä¸€çš„ä¸€ä¸ªç¤ºä¾‹ã€‚

> p1 = 0.01
>
> p3 = 3 \* p1\*\*2 \* (1-p1) + p1\*\*3 \# probability of 2 or 3 errors
>
> print(\'Probability of a single reply being garbled: {}\'.format(p1))
>
> print(\'Probability of a the majority of three replies being garbled:
> {:.4f}\'.format(p3))

å¦‚æœ$P < P_{a}$ï¼Œè¿™ä¸€æŠ€æœ¯å°±è§£å†³äº†æˆ‘ä»¬çš„é—®é¢˜ã€‚è‹¥$P > P_{a}$ï¼Œåˆ™æˆ‘ä»¬åªéœ€ç®€å•åœ°æ·»åŠ æ›´å¤šé‡å¤ã€‚ä¸Šè¿°$P < p$æ¥è‡ªä¸€ä¸‹äº‹å®ï¼šæˆ‘ä»¬è‡³å°‘éœ€è¦å¼„ä¹±ä¸¤ä¸ªç­”å¤æ‰èƒ½ä½¿æ€»ä½“é”™ä¹±ã€‚å› è€Œï¼Œå³ä½¿æ˜¯æœ€æœ‰å¯èƒ½çš„æƒ…å†µï¼Œå…¶æ¦‚ç‡ä¹Ÿçº¦ä¸º$p^{2}$ã€‚å¯¹äºäº”æ¬¡é‡å¤çš„æƒ…å†µï¼Œæˆ‘ä»¬è‡³å°‘éœ€è¦å¼„ä¹±ä¸‰ä¸ªç­”å¤æ‰èƒ½ä½¿æ€»ä½“é”™ä¹±ï¼Œè¿™ä¸€æƒ…å†µå‘ç”Ÿçš„æ¦‚ç‡çº¦ä¸º$p^{3}$ã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œ$P$çš„å€¼å°†æ›´ä½ã€‚éšç€æˆ‘ä»¬å¢åŠ é‡å¤æ¬¡æ•°ï¼Œ$P$å°†æˆå€ä¸‹é™ã€‚æ— è®ºè¿é€šå¤šä¹ˆç³Ÿç³•æˆ–æˆ‘ä»¬éœ€è¦ç¡®å®šå¦‚ä½•æ­£ç¡®åœ°ä¼ é€’æ¶ˆæ¯ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥é€šè¿‡é‡å¤å›ç­”è¶³å¤Ÿçš„æ¬¡æ•°æ¥å®ç°ã€‚

å°½ç®¡è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œä½†å…¶åŒ…å«è¯¯å·®ä¿®æ­£çš„å…¨éƒ¨æ¦‚å¿µã€‚

-   æœ‰ä¸€äº›ä¿¡æ¯è¦å‘é€æˆ–å­˜å‚¨ï¼šåœ¨è¿™ç§æƒ…å†µä¸‹çš„å›ç­”ä¸º"æ˜¯"æˆ–"å¦"ã€‚

-   åœ¨è¾ƒå¤§çš„ç³»ç»Ÿä¸­å¯¹ä¿¡æ¯è¿›è¡Œç¼–ç ï¼Œé˜²æ­¢å—åˆ°å™ªå£°çš„å¹²æ‰°ï¼šåœ¨è¿™ç§æƒ…å†µä¸‹å¯ä»¥é€šè¿‡é‡å¤æ¶ˆæ¯å®ç°ã€‚

-   æœ€ç»ˆå¯¹ä¿¡æ¯è¿›è¡Œè§£ç æ¥å‡è½»å™ªå£°çš„å½±å“ï¼šåœ¨è¿™ç§æƒ…å†µä¸‹é€šè¿‡ç¡®è®¤æ‰€ä¼ è¾“ä¿¡æ¯ä¸­çš„å¤§å¤šæ•°æ¥å®ç°ã€‚

é€šè¿‡å°†0å’Œ1åˆ†åˆ«æ›¿æ¢"æ˜¯"å’Œ"å¦"ï¼Œä¹Ÿå¯ä»¥å°†è¿™ç§ç›¸åŒçš„ç¼–ç æ–¹æ¡ˆç”¨äºäºŒè¿›åˆ¶ã€‚å› æ­¤ï¼Œé€šè¿‡ä½¿ç”¨æ€$|0\rangle$å’Œ$|1\rangle$ï¼Œä¹Ÿå¯ä»¥è½»æ¾åœ°å°†å…¶æ¨å¹¿è‡³é‡å­æ¯”ç‰¹ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå…¶è¢«ç§°ä¸ºé‡å¤æ ¡éªŒï¼ˆ*repetition
code*ï¼‰ã€‚åœ¨ç»å…¸è®¡ç®—å’Œé‡å­è®¡ç®—ä¸­ä¹Ÿå­˜åœ¨è®¸å¤šå…¶ä»–å½¢å¼çš„ç¼–ç ï¼Œåœ¨è®¸å¤šæ–¹é¢éƒ½ä¼˜äºé‡å¤æ ¡éªŒã€‚ä½†æ˜¯ï¼Œé‡å¤æ ¡éªŒä½œä¸ºæœ€ç®€å•ç¼–ç çš„æƒ…å†µçš„ç¡®ä½¿å…¶æ›´åŠ é€‚ç”¨äºæŸäº›åº”ç”¨ã€‚ä¸€ä¸ªæ°å½“çš„æƒ…å†µå°±æ˜¯é‡å¤æ ¡éªŒåœ¨Qiskitä¸­çš„ç”¨é€”ï¼šä½œä¸ºé‡å­è¯¯å·®ä¿®æ­£æ€æƒ³çš„ç¬¬ä¸€ä¸ªä¹Ÿæ˜¯æœ€ç®€å•çš„å®ç°ã€‚

#### åœ¨é‡å­æ¯”ç‰¹ä¸Šä¿®æ­£è¯¯å·®

ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨Qiskitæ˜¾å¼åœ°å®ç°è¿™äº›æƒ³æ³•ã€‚è‹¥è¦æŸ¥çœ‹ä¸å®Œç¾é‡å­æ¯”ç‰¹æ‰€å¸¦æ¥åœ°å½±å“ï¼Œåªéœ€ä½¿ç”¨åŸå‹è®¾å¤‡çš„é‡å­æ¯”ç‰¹å³å¯ï¼Œè¿˜å¯ä»¥åœ¨æ¨¡æ‹Ÿä¸­é‡ç°è¿™äº›æ•ˆæœã€‚ä¸ºæ­¤åœ¨ä¸‹é¢çš„å‡½æ•°ä¸­åˆ›å»ºäº†ä¸€ä¸ªç®€å•çš„å™ªå£°æ¨¡å‹ã€‚è¿™äº›æ¦‚å¿µè¶…å‡ºäº†å‰é¢æ‰€è®¨è®ºçš„ç®€å•äº‹ä»¶ï¼Œå³å•ä¸ªå™ªå£°äº‹ä»¶çš„å‘ç”Ÿæ¦‚ç‡ä¸º$p$ã€‚ä¸ä¹‹ç›¸åï¼Œæˆ‘ä»¬è€ƒè™‘å¯èƒ½å‘ç”Ÿçš„ä¸¤ç§è¯¯å·®å½¢å¼ã€‚é‡å­é—¨è¯¯å·®ï¼šæ‰€æ‰§è¡Œä»»ä½•æ“ä½œä¸­çš„è¯¯å·®ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨æ‰€è°“çš„å»æåŒ–å™ªå£°ä»¥ç®€å•çš„æ–¹å¼å¯¹æ­¤è¿›è¡Œå»ºæ¨¡ã€‚è¿™æ ·åšçš„æ•ˆæœä½¿å¾—æ¦‚ç‡$p_{\text{gate}}$ä»¥å®Œå…¨çš„éšæœºæ€æ›¿æ¢ä»»ä¸€é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚å¯¹äºå«æœ‰ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„é‡å­é—¨å°†ä¼šå•ç‹¬åº”ç”¨äºæ¯ä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚å™ªå£°çš„å¦ä¸€ç§æ¥æºæ˜¯æµ‹é‡ã€‚åœ¨ç”¨æ¦‚ç‡$p_{\text{meas}}$è¿›è¡Œæµ‹é‡ä¹‹å‰ï¼Œä»…æ˜¯åœ¨0å’Œ1ä¹‹é—´çš„å³åˆ»ç¿»è½¬ï¼Œåä¹‹äº¦ç„¶ã€‚

> from qiskit.providers.aer.noise import NoiseModel
>
> from qiskit.providers.aer.noise.errors import pauli_error,
> depolarizing_error
>
> def get_noise(p_meas,p_gate):
>
> error_meas = pauli_error(\[(\'X\',p_meas), (\'I\', 1 - p_meas)\])
>
> error_gate1 = depolarizing_error(p_gate, 1)
>
> error_gate2 = error_gate1.tensor(error_gate1)
>
> noise_model = NoiseModel()
>
> noise_model.add_all_qubit_quantum_error(error_meas, \"measure\") \#
> measurement error is applied to measurements
>
> noise_model.add_all_qubit_quantum_error(error_gate1, \[\"x\"\]) \#
> single qubit gate error is applied to x gates
>
> noise_model.add_all_qubit_quantum_error(error_gate2, \[\"cx\"\]) \#
> two qubit gate error is applied to cx gates
>
> return noise_model

ç°åœ¨ï¼Œæˆ‘ä»¬å°†é’ˆå¯¹æ¯ç§è¯¯å·®ç±»å‹åˆ›å»ºä¸€ä¸ªæ¦‚ç‡ä¸º1ï¼…çš„å™ªå£°æ¨¡å‹ã€‚

noise_model = get_noise(0.01,0.01)

åœ¨å°è¯•ä½¿ç”¨æ€$|0\rangle$ä¸­çš„ä¸‰é‡å­æ¯”ç‰¹æ¥å­˜å‚¨0æ—¶æ˜¯ä»€ä¹ˆæ•ˆæœï¼Ÿæˆ‘ä»¬å°†é‡å¤è¿™ä¸€è¿‡ç¨‹shots=1024æ¬¡ï¼Œæ¥æŸ¥çœ‹ä¸åŒç»“æœçš„å¯èƒ½æ€§ã€‚

> from qiskit import QuantumCircuit, execute, Aer
>
> qc0 = QuantumCircuit(3,3,name=\'0\') \# initialize circuit with three
> qubits in the 0 state
>
> qc0.measure(qc0.qregs\[0\],qc0.cregs\[0\]) \# measure the qubits
>
> \# run the circuit with th noise model and extract the counts
>
> counts = execute( qc0,
> Aer.get_backend(\'qasm_simulator\'),noise_model=noise_model).result().get_counts()
>
> print(counts)
>
> è¾“å‡ºï¼š
>
> {\'001\': 14, \'010\': 7, \'000\': 989, \'101\': 1, \'100\': 13}

åœ¨æ­¤å¤„ï¼Œæˆ‘ä»¬çœ‹åˆ°å‡ ä¹æ‰€æœ‰ç»“æœä»æ˜¯\'000\'ï¼Œå°±å¥½åƒå™ªéŸ³ä¸å­˜åœ¨ä¸€æ ·ã€‚åœ¨å…¶ä½™çš„å¯èƒ½ä¸­ï¼Œå¤§éƒ¨åˆ†ä¸º0çš„å¯èƒ½æ€§æœ€å¤§ã€‚æ€»å…±å°‘äº100ä¸ªæ ·æœ¬çš„å¤§éƒ¨åˆ†ä¸º1ã€‚åœ¨ä½¿ç”¨æ­¤å›è·¯ç¼–ç 0æ—¶$P < 1\%$ã€‚

ç°åœ¨å°è¯•ä½¿ç”¨æ€ä¸º$|1\rangle$çš„ä¸‰é‡å­æ¯”ç‰¹æ¥å­˜å‚¨1çš„æ–¹æ³•ã€‚

> qc1 = QuantumCircuit(3,3,name=\'0\') \# initialize circuit with three
> qubits in the 0 state
>
> qc1.x(qc1.qregs\[0\]) \# flip each 0 to 1
>
> qc1.measure(qc1.qregs\[0\],qc1.cregs\[0\]) \# measure the qubits
>
> \# run the circuit with th noise model and extract the counts
>
> counts = execute( qc1,
> Aer.get_backend(\'qasm_simulator\'),noise_model=noise_model).result().get_counts()
>
> print(counts)
>
> è¾“å‡ºï¼š
>
> {\'011\': 12, \'111\': 983, \'110\': 13, \'101\': 16}

å¤§éƒ¨åˆ†é”™è¯¯çŠ¶æ€çš„æ ·æœ¬æ•°é‡å†æ¬¡è¿œè¿œå°‘äº100ï¼Œå› æ­¤$P < 1\%$ã€‚æ— è®ºæˆ‘ä»¬å­˜å‚¨0è¿˜æ˜¯1ï¼Œæˆ‘ä»¬éƒ½èƒ½åœ¨ä»»ä½•å™ªå£°æºä¸‹ä»¥æ›´å°çš„è¯¯å·®æ¦‚ç‡æ£€ç´¢ä¿¡æ¯ã€‚

ä¸Šè¿°è¿‡ç¨‹å­˜åœ¨å¯æ“ä½œæ€§ï¼Œå› ä¸ºæˆ‘ä»¬åŠ å…¥çš„å™ªå£°ç›¸å¯¹è¾ƒå¼±ã€‚å½“æˆ‘ä»¬å¢åŠ $p_{\text{gate}}$å’Œ$p_{\text{meas}}$æ—¶ï¼Œæ¦‚ç‡$P$ä¹Ÿä¼šå¢å¤§ã€‚åœ¨è¿™ä¸€çŠ¶æ€ä¸‹å­˜åœ¨ä¸€ç§æç«¯æƒ…å†µï¼š$p_{\text{gate}}$å’Œ$p_{\text{meas}}$éƒ½ä»¥50/50çš„æœºä¼šäº§ç”Ÿé‡å­æ¯”ç‰¹çš„åè½¬è¯¯å·®xã€‚ä¾‹å¦‚ï¼Œè®¾ç½®$p_{\text{gate}} = 0$ä»¥åŠ$p_{\text{meas}} = 0.5$åé‡æ–°è¿è¡Œè¯¥é‡å­å›è·¯ã€‚

> noise_model = get_noise(0.5,0.0)
>
> counts = execute( qc1,
> Aer.get_backend(\'qasm_simulator\'),noise_model=noise_model).result().get_counts()
>
> print(counts)
>
> è¾“å‡ºï¼š
>
> {\'111\': 133, \'001\': 121, \'010\': 118, \'011\': 105, \'110\': 150,
> \'000\': 126, \'101\': 138, \'100\': 133}

é€šè¿‡è¿™äº›å™ªå£°ï¼Œæ‰€æœ‰è¾“å‡ºéƒ½ä»¥ç›¸åŒçš„æ¦‚ç‡å‡ºç°ï¼Œç»“æœçš„å·®å¼‚ä»…ç”±ç»Ÿè®¡å™ªå£°å¼•èµ·ã€‚è¢«ç¼–ç çŠ¶æ€ä¸å­˜åœ¨ä»»ä½•ç—•è¿¹ã€‚è¿™æ˜¯æ€è€ƒè¯¯å·®ä¿®æ­£çš„é‡è¦è§‚ç‚¹ï¼šæœ‰æ—¶å™ªéŸ³å¤ªå¼ºçƒˆè€Œå¯¼è‡´æ— æ³•ä¿®æ­£ã€‚æœ€ä½³çš„æ–¹æ¡ˆæ˜¯å°†ç¼–ç æ‰€éœ€ä¿¡æ¯çš„å¥½æ–¹æ³•ä¸å™ªå£°ä¸å¤ªå¼ºçš„ç¡¬ä»¶ç»“åˆèµ·æ¥ã€‚

#### å­˜å‚¨é‡å­æ¯”ç‰¹

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»è€ƒè™‘äº†ç¼–ç å’Œè§£ç ä¹‹é—´æ²¡æœ‰å»¶è¿Ÿçš„æƒ…å†µã€‚å¯¹äºé‡å­æ¯”ç‰¹ï¼Œè¿™æ„å‘³ç€åœ¨åˆå§‹åŒ–å›è·¯å’Œè¿›è¡Œæœ€ç»ˆæµ‹é‡ä¹‹é—´ä¸ä¼šå­˜åœ¨å¤§æ®µæ—¶é—´çš„é—´éš”ã€‚

ç„¶è€Œï¼Œåœ¨å¤šæ•°æƒ…å†µä¸‹ä¼šå­˜åœ¨å¾ˆå¤§çš„å»¶è¿Ÿã€‚ä¸€ä¸ªæ˜¾è€Œäº¦ç„¶çš„ä¾‹å­ï¼šäººä»¬å¯èƒ½å¸Œæœ›ç¼–ç ä¸€ä¸ªé‡å­çŠ¶æ€å¹¶å°†å…¶å­˜å‚¨å¾ˆé•¿æ—¶é—´ï¼Œå°±å¦‚åŒä¸€ä¸ªé‡å­ç¡¬ç›˜é©±åŠ¨å™¨ä¸€æ ·ã€‚ä¸€ä¸ªä¸å¤ªæ˜æ˜¾ä½†æ›´é‡è¦çš„ä¾‹å­æ˜¯æ‰§è¡Œå®¹é”™é‡å­è®¡ç®—æœ¬èº«ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å­˜å‚¨é‡å­æ€å¹¶åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¿æŒå…¶çš„å®Œæ•´æ€§ã€‚è¿™ä¸€æ“ä½œè¿˜å¿…é¡»ä»¥æŸç§æ–¹å¼æ¥å®Œæˆï¼Œå³å…è®¸æˆ‘ä»¬ä»¥éœ€è¦çš„ä»»ä½•æ–¹å¼æ¥æ“ä½œå­˜å‚¨çš„ä¿¡æ¯ï¼Œå¹¶ä¿®æ­£åœ¨æ‰§è¡Œæ“ä½œæ—¶å¯èƒ½å¼•å…¥çš„ä»»ä½•è¯¯å·®ã€‚

åœ¨æ‰€æœ‰å¯èƒ½çš„æƒ…å†µä¸‹æˆ‘ä»¬éƒ½éœ€è¦è€ƒè™‘ä¸€ä¸ªäº‹å®ï¼Œå³ï¼šè¯¯å·®ä¸ä»…å‘ç”Ÿåœ¨æŸäº›äº‹æƒ…å‘ç”Ÿæ—¶(å¦‚ç”Ÿæˆé‡å­é—¨æˆ–æµ‹é‡)ï¼Œä¹Ÿå‘ç”Ÿåœ¨é‡å­æ¯”ç‰¹ç©ºé—²æ—¶ã€‚è¿™ç§å™ªå£°çš„ç”Ÿæˆæ˜¯ç”±äºé‡å­æ¯”ç‰¹ä¸å…¶ä»–é‡å­æ¯”ç‰¹åŠå…¶ç¯å¢ƒç›¸äº’ä½œç”¨è€Œäº§ç”Ÿã€‚é‡å­æ¯”ç‰¹é—²ç½®çš„æ—¶é—´è¶Šé•¿ï¼Œè¿™ç§å™ªå£°çš„å½±å“å°±è¶Šå¤§ã€‚å¦‚æœå°†æ”¾ç½®é‡å­æ¯”ç‰¹è¶³å¤Ÿé•¿çš„æ—¶é—´ï¼Œæˆ‘ä»¬å°†ä¼šé‡åˆ°ç±»ä¼¼ä¸Šè¿°$p_{\text{meas}} = 0.5$çš„æƒ…å†µï¼Œåœ¨è¿™ä¸€æƒ…å†µä¸‹ç”±äºå™ªå£°å¤ªå¼ºçƒˆä»¥è‡³äºé”™è¯¯æ— æ³•å¯é åœ°å¾—åˆ°ä¿®æ­£ã€‚

è¿™ä¸€é—®é¢˜çš„è§£å†³æ–¹æ³•æ˜¯åœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­è¿›è¡ŒæŒç»­æµ‹é‡ï¼Œä¿è¯æ²¡æœ‰é‡å­æ¯”ç‰¹ä¼šè¢«é•¿æ—¶é—´é—²ç½®ã€‚ä»è€Œå–ä»£ä¸æ–­ä»ç³»ç»Ÿä¸­æå–ä¿¡æ¯æ¥è·Ÿè¸ªå·²å‘ç”Ÿçš„è¯¯å·®ã€‚

å¯¹äºç»å…¸ä¿¡æ¯ï¼Œæ¯”å¦‚æˆ‘ä»¬åªæƒ³å­˜å‚¨$0$æˆ–$1$ï¼Œå¯ä»¥é€šè¿‡ä¸æ–­åœ°æµ‹é‡æ¯ä¸ªé‡å­æ¯”ç‰¹çš„å€¼æ¥å®Œæˆã€‚é€šè¿‡è·Ÿè¸ªä½•æ—¶å€¼ç”±äºå™ªå£°è€Œå˜åŒ–ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾æ¨æ–­å‡ºä½•æ—¶å‘ç”Ÿè¯¯å·®çš„å†å²è®°å½•ã€‚

ä½†æ˜¯ï¼Œå¯¹äºé‡å­ä¿¡æ¯æ¥è¯´å°±æ²¡æœ‰é‚£ä¹ˆå®¹æ˜“äº†ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘å¸Œæœ›å¯¹é€»è¾‘çŠ¶æ€$| + \rangle$è¿›è¡Œç¼–ç çš„æƒ…å†µï¼š

$$\left| 0 \right\rangle \rightarrow \left| 000 \right\rangle,|1\rangle \rightarrow |111\rangle$$

ä½¿ç”¨ä¸‹å¼ç¼–ç é€»è¾‘æ€$| + \rangle$ï¼š

$$| + \rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \rightarrow \frac{1}{\sqrt{2}}(|000\rangle + |111\rangle)$$

é€šè¿‡æ‰€ä½¿ç”¨çš„é‡å¤æ ¡éªŒï¼Œé€»è¾‘é‡å­æ¯”ç‰¹çš„zæµ‹é‡ï¼ˆç”¨äºåŒºåˆ†æ€$|0\rangle$å’Œæ€$|1\rangle$ï¼‰æ˜¯ä½¿ç”¨æ¯ä¸ªç‰©ç†é‡å­æ¯”ç‰¹çš„zæµ‹é‡æ¥å®Œæˆçš„ã€‚é€»è¾‘æµ‹é‡çš„æœ€ç»ˆç»“æœä»ç‰©ç†é‡å­æ¯”ç‰¹æµ‹é‡ç»“æœä¸­è§£ç å¾—å‡ºï¼Œåªéœ€çœ‹å“ªä¸­è¾“å‡ºå å¤šæ•°ã€‚

å¦‚å‰æ‰€è¿°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹ç‰©ç†é‡å­æ¯”ç‰¹è¿›è¡Œzæµ‹é‡æ¥è·Ÿè¸ªå­˜å‚¨äº†å¾ˆé•¿æ—¶é—´çš„é€»è¾‘é‡å­æ¯”ç‰¹ä¸Šçš„è¯¯å·®ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„è¿™ä¸€æœ‰æ•ˆåœ°å¯¹åº”äºæŒç»­æ‰§è¡Œç‰©ç†é‡å­æ¯”ç‰¹çš„zæµ‹é‡ã€‚å¦‚æœæˆ‘ä»¬åªæ˜¯ç®€å•åœ°å­˜å‚¨0æˆ–1ï¼Œè¿™ä¸€æ–¹æ³•æ˜¯å¯è¡Œçš„ï¼Œä½†å¦‚æœæ‰€å­˜å‚¨çš„æ˜¯å åŠ æ€ï¼Œå°±ä¼šäº§ç”Ÿä¸å¸Œæœ›çœ‹åˆ°çš„æ•ˆæœã€‚å…·ä½“æ¥è¯´ï¼šç¬¬ä¸€æ¬¡æ£€æŸ¥è¯¯å·®æ—¶å°±ä¼šåç¼©å åŠ æ€ã€‚

è¿™å°±ä¸é‚£ä¹ˆç†æƒ³äº†ã€‚å¦‚æœæˆ‘ä»¬æƒ³åœ¨é€»è¾‘é‡å­æ¯”ç‰¹ä¸Šåšä¸€äº›è®¡ç®—ï¼Œæˆ–æƒ³åœ¨æœ€ç»ˆæµ‹é‡ä¹‹å‰åšä¸€ä¸ªåŸºå˜æ¢ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¿æŒé‡å­æ¯”ç‰¹çš„å åŠ æ€ï¼Œé‚£ä¹ˆå°†å…¶ç ´åå°±æ˜¯ä¸€ä¸ªè¯¯å·®ã€‚ä½†è¿™å¹¶ä¸æ˜¯ç”±è®¾å¤‡çš„ç¼ºé™·é€ æˆçš„è¯¯å·®ï¼Œè€Œæ˜¯è¯•å›¾ä¿®æ­£é”™è¯¯æ—¶å¼•å…¥çš„è¯¯å·®ã€‚ç”±äºæˆ‘ä»¬ä¸èƒ½æŒ‡æœ›åœ¨é‡å­è®¡ç®—æœºä¸­é‡ç°ä»»æ„çš„å åŠ æ€ï¼Œè¿™å°±å˜æˆä¸€ä¸ªæ— æ³•ä¿®æ­£çš„è¯¯å·®ã€‚

åŸºäºæ­¤ç¼˜ç”±ï¼Œæˆ‘ä»¬å¿…é¡»æ‰¾åˆ°å¦ä¸€ç§æ–¹æ³•æ¥è·Ÿè¸ªé€»è¾‘é‡å­æ¯”ç‰¹é•¿æ—¶é—´å­˜å‚¨æ—¶å‘ç”Ÿçš„è¯¯å·®ã€‚è¿™å°±ä¸ºæˆ‘ä»¬ç»™å‡ºäº†æ£€æµ‹å’Œä¿®æ­£è¯¯å·®å’Œä»¥é«˜æ¦‚ç‡è§£ç æœ€ç»ˆæµ‹é‡ç»“æœæ‰€éœ€çš„ä¿¡æ¯ã€‚å› è€Œåœ¨è¿™ä¸€è¿‡ç¨‹ä¸­ï¼Œç”±äºæˆ‘ä»¬ä¿æŒå åŠ æ€åç¼©ï¼Œå°±ä¸ä¼šå¯¼è‡´ä¸å¯ä¿®æ­£çš„è¯¯å·®å‘ç”Ÿã€‚

ä½¿ç”¨ä»¥ä¸‹å›è·¯å…ƒç´ å¯ä»¥å®ç°æ­¤ç›®çš„ã€‚

> from qiskit import QuantumRegister, ClassicalRegister
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images look
> nice
>
> cq = QuantumRegister(2,\'code\\ qubit\\ \')
>
> lq = QuantumRegister(1,\'ancilla\\ qubit\\ \')
>
> sb = ClassicalRegister(1,\'syndrome\\ bit\\ \')
>
> qc = QuantumCircuit(cq,lq,sb)
>
> qc.cx(cq\[0\],lq\[0\])
>
> qc.cx(cq\[1\],lq\[0\])
>
> qc.measure(lq,sb)
>
> qc.draw()
>
> è¾“å‡ºï¼š

![](pics/media/image313.png)

æ­¤å¤„æˆ‘ä»¬ä½¿ç”¨äº†ä¸‰ä¸ªç‰©ç†é‡å­æ¯”ç‰¹ã€‚å…¶ä¸­ä¸¤ä¸ªè¢«ç§°ä¸º"ç¼–ç é‡å­æ¯”ç‰¹ï¼ˆcode
qubitï¼‰"ï¼Œå¦ä¸€ä¸ªè¢«ç§°ä¸º"è¾…åŠ©é‡å­æ¯”ç‰¹ï¼ˆancilla
qubitï¼‰"ã€‚æå–è¾“å‡ºçš„æ¯”ç‰¹ç§°ä¸ºæ ¡éªŒæ¯”ç‰¹ï¼ˆsyndrome
bitï¼‰ã€‚è¾…åŠ©é‡å­æ¯”ç‰¹æ€»æ˜¯åˆå§‹åŒ–ä¸ºæ€$|0\rangle$ã€‚ç„¶è€Œï¼Œå¯ä»¥åœ¨ä¸åŒçš„çŠ¶æ€ä¸‹åˆå§‹åŒ–ç¼–ç é‡å­æ¯”ç‰¹ã€‚ä¸ºäº†æŸ¥çœ‹ä¸åŒçš„è¾“å…¥å¯¹è¾“å‡ºæœ‰ä½•å½±å“ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå›è·¯qc_initï¼Œå…¶åœ¨æŸç§çŠ¶æ€ä¸‹å‡†å¤‡ç¼–ç é‡å­æ¯”ç‰¹ï¼Œç„¶åè¿è¡Œå›è·¯qc_init+qcã€‚

é¦–å…ˆ,ç®€å•çš„ä¾‹å­ï¼šqc_initä¸åšä»»ä½•è®¾ç½®,æ‰€ä»¥ç¼–ç é‡å­æ¯”ç‰¹åˆå§‹åŒ–ä¸º$|00\rangle$ã€‚

> qc_init = QuantumCircuit(cq)
>
> (qc_init+qc).draw()
>
> è¾“å‡ºï¼š

![](pics/media/image314.png)

> counts = execute( qc_init+qc,
> Aer.get_backend(\'qasm_simulator\')).result().get_counts()
>
> print(\'Results:\',counts)
>
> è¾“å‡ºï¼š
>
> Results: {\'0\': 1024}

å¯ä»¥çœ‹åˆ°è¾“å‡ºå…¨ä¸º0ã€‚

ç°åœ¨å°è¯•åˆå§‹æ€ä¸º$|11\rangle$ã€‚

> qc_init = QuantumCircuit(cq)
>
> qc_init.x(cq)
>
> (qc_init+qc).draw()
>
> è¾“å‡ºï¼š

![](pics/media/image315.png)

> counts = execute( qc_init+qc,
> Aer.get_backend(\'qasm_simulator\')).result().get_counts()
>
> print(\'Results:\',counts)
>
> è¾“å‡ºï¼š
>
> Results: {\'0\': 1024}

æ­¤æ—¶çš„è¾“å‡ºä»å…¨ä¸º0ã€‚ç”±äºé‡å­åŠ›å­¦çš„çº¿æ€§åº¦,å¯¹äºä»»ä¸€å åŠ æ€$|00\rangle$å’Œ$|11\rangle$ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è®¤ä¸ºè¿™æ˜¯çœŸçš„æƒ…å†µï¼Œæ¯”å¦‚ä¸‹é¢çš„ä¾‹å­ã€‚

> qc_init = QuantumCircuit(cq)
>
> qc_init.h(cq\[0\])
>
> qc_init.cx(cq\[0\],cq\[1\])
>
> (qc_init+qc).draw()
>
> è¾“å‡ºï¼š

![](pics/media/image316.png)

> counts = execute( qc_init+qc,
> Aer.get_backend(\'qasm_simulator\')).result().get_counts()
>
> print(\'Results:\',counts)
>
> è¾“å‡ºï¼š
>
> Results: {\'0\': 1024}

ç›¸åçš„ç»“æœå°†å‡ºç°åœ¨çš„åˆå§‹æ€ä¸º$|01\rangle$ï¼Œ$|10\rangle$æˆ–ä»»æ„å…¶ä»–å åŠ æ€æ—¶ã€‚

> qc_init = QuantumCircuit(cq)
>
> qc_init.h(cq\[0\])
>
> qc_init.cx(cq\[0\],cq\[1\])
>
> qc_init.x(cq\[0\])
>
> (qc_init+qc).draw()
>
> è¾“å‡ºï¼š

![](pics/media/image317.png)

> counts = execute( qc_init+qc,
> Aer.get_backend(\'qasm_simulator\')).result().get_counts()
>
> print(\'Results:\',counts)
>
> è¾“å‡ºï¼š
>
> Results: {\'1\': 1024}

åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œè¾“å‡ºéƒ½ä¸º"1"ã€‚

å› æ­¤ï¼Œè¿™ä¸€æµ‹é‡å‘Šè¯‰æˆ‘ä»¬å¤šä¸ªé‡å­æ¯”ç‰¹çš„é›†ä½“æ€§è´¨ã€‚å…·ä½“æ¥è¯´ï¼Œè¯¥æµ‹é‡æŸ¥çœ‹ä¸¤ä¸ªç¼–ç é‡å­æ¯”ç‰¹ï¼Œå¹¶ç¡®å®šå®ƒä»¬çš„çŠ¶æ€ä¸z-åŸºç›¸åŒè¿˜æ˜¯ä¸åŒã€‚å¯¹äºä¸z-åŸºç›¸åŒçš„åŸºæ€ï¼Œå¦‚$|00\rangle$å’Œ$|11\rangle$ï¼Œæµ‹é‡ä»…è¿”å›0ã€‚å¯¹äºä»»æ„å åŠ æ€éƒ½æ˜¯è¿™æ ·å¤„ç†ã€‚ç”±äºè¿™ä¸€æµ‹é‡ä¸ä¼šä»¥ä»»ä½•æ–¹å¼åŒºåˆ†è¿™äº›çŠ¶æ€ï¼Œå› æ­¤ä¹Ÿä¸ä¼šå¯¼è‡´å åŠ æ€çš„åç¼©ã€‚

ç±»ä¼¼åœ°ï¼Œç›¸å¯¹z-åŸºä¸åŒçš„åŸºæ€ï¼Œè¯¥æµ‹é‡è¿”å›1ã€‚è¿™å¯¹äº$|01\rangle$ï¼Œ$|10\rangle$æˆ–å…¶ä»»æ„å…¶ä»–å åŠ æ€éƒ½ä¸€æ ·ã€‚

ç°åœ¨ï¼Œå‡è®¾æˆ‘ä»¬å¯¹é‡å¤æ ¡éªŒä¸­çš„æ‰€æœ‰ç‰©ç†æ¯”ç‰¹å¯¹éƒ½åº”ç”¨è¿™æ ·çš„"æ ¡éªŒæµ‹é‡ï¼ˆsyndrome
measurementï¼‰"ã€‚å¦‚æœçŠ¶æ€é‡å¤ä¸º$|0\rangle$ã€$|1\rangle$æˆ–å…¶ä»–ä»»æ„å åŠ æ€ï¼Œåˆ™æ‰€æœ‰æ ¡éªŒæµ‹é‡éƒ½å°†è¿”å›0ã€‚é€šè¿‡ç»™å‡ºæ­¤ç»“æœï¼Œæˆ‘ä»¬å°†çŸ¥é“çŠ¶æ€ç¡®å®ä»¥æ‰€å¸Œæœ›çš„é‡å¤çŠ¶æ€ç¼–ç ï¼Œå¹¶å¯ä»¥æ¨æ–­å‡ºæ²¡æœ‰è¯¯å·®å‘ç”Ÿã€‚ä½†å¦‚æœæŸäº›æ ¡éªŒæµ‹é‡ç»“æœè¿”å›1ï¼Œåˆ™è¡¨ç¤ºé”™è¯¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™äº›æµ‹é‡ç»“æœæ¥ç¡®å®šå¦‚ä½•è§£ç å‡ºç»“æœã€‚

#### é‡å­é‡å¤æ ¡éªŒ

ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»æ˜ç¡®äº†é‡å¤æ ¡éªŒé‡å­ç‰ˆæœ¬çš„å®ç°æ–¹å¼äº†ã€‚é€šè¿‡ä»Igniså¯¼å…¥æ‰€éœ€çš„å·¥å…·ï¼Œå°±å¯ä»¥åœ¨Qiskitä¸­ä½¿ç”¨é‡å¤æ ¡éªŒã€‚

> from qiskit.ignis.verification.topological_codes import RepetitionCode
>
> from qiskit.ignis.verification.topological_codes import
> lookuptable_decoding
>
> from qiskit.ignis.verification.topological_codes import GraphDecoder

åœ¨æ­¤å¤„ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªç”±é€‰æ‹©è¦å°†é€»è¾‘é‡å­æ¯”ç‰¹ç¼–ç åˆ°å¤šå°‘ä¸ªç‰©ç†é‡å­æ¯”ç‰¹ä¸Šã€‚æˆ‘ä»¬è¿˜å¯ä»¥é€‰æ‹©åœ¨æœ€ç»ˆè¯»å‡ºæµ‹é‡ç»“æœä¹‹å‰å­˜å‚¨é€»è¾‘é‡å­æ¯”ç‰¹çš„åŒæ—¶åº”ç”¨æ ¡éªŒæµ‹é‡çš„æ¬¡æ•°ã€‚æˆ‘ä»¬ä»æœ€å°çš„éå¹³å‡¡æƒ…å†µå…¥æ‰‹ï¼šä¸‰ä¸ªé‡å¤å’Œä¸€ä¸ªæ ¡éªŒæµ‹é‡ã€‚ç„¶åä½¿ç”¨Qiskit-Ignisä¸­çš„RepetitionCodeå¯¹è±¡è‡ªåŠ¨åˆ›å»ºé‡å¤æ ¡éªŒçš„å›è·¯ã€‚

è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ£€æŸ¥codeçš„å„ç§å±æ€§ï¼Œä¾‹å¦‚ç”¨äºcodeä¸­çš„é‡å­æ¯”ç‰¹å¯„å­˜å™¨åç§°å’Œè¾…åŠ©é‡å­æ¯”ç‰¹ã€‚

> n = 3
>
> T = 1
>
> code = RepetitionCode(n,T)

RepetitionCodeåŒ…å«ä¸¤ä¸ªå®ç°codeçš„é‡å­å›è·¯ï¼šä¸¤ä¸ªå¯èƒ½é€»è¾‘æ¯”ç‰¹å€¼ä¸­çš„æ¯ä¸ªé€»è¾‘æ¯”ç‰¹ï¼Œåˆ†åˆ«æ˜¯é€»è¾‘0å’Œ1ã€‚

> \# this bit is just needed to make the labels look nice
>
> for reg in code.circuit\[\'0\'\].qregs+code.circuit\[\'1\'\].cregs:
>
> reg.name = reg.name.replace(\'\_\',\'\\ \') + \'\\ \'
>
> code.circuit\[\'0\'\].draw()
>
> è¾“å‡ºï¼š

![](pics/media/image318.png)

> code.circuit\[\'1\'\].draw()
>
> è¾“å‡ºï¼š

![](pics/media/image319.png)

åœ¨è¿™äº›é‡å­å›è·¯ä¸­æœ‰ä¸¤ç§ç±»å‹çš„ç‰©ç†é‡å­æ¯”ç‰¹ã€‚åœ¨"ç¼–ç é‡å­æ¯”ç‰¹"ä¸­é€»è¾‘çŠ¶æ€è¢«ç¼–ç åœ¨ä¸‰ä¸ªç‰©ç†é‡å­æ¯”ç‰¹ä¸Šã€‚"è¿æ¥é‡å­æ¯”ç‰¹"ç”¨ä½œæ ¡éªŒæµ‹é‡çš„è¾…åŠ©é‡å­æ¯”ç‰¹ã€‚

åœ¨è¿™äº›å›è·¯ä¸­ï¼Œå•è½®æ ¡éªŒæµ‹é‡ä»…åŒ…å«ä¸¤ä¸ªæ ¡éªŒæµ‹é‡ã€‚ä¸€ä¸ªæ¯”è¾ƒç¼–ç é‡å­æ¯”ç‰¹0å’Œ1ï¼Œå¦ä¸€ä¸ªç”¨äºæ¯”è¾ƒé‡å­æ¯”ç‰¹1å’Œ2ã€‚æˆ‘ä»¬ä¹Ÿè®¸æƒ³è¦è¿›è¡Œè¿›ä¸€æ­¥çš„æµ‹é‡ï¼Œé€šè¿‡æ¯”è¾ƒç¼–ç é‡å­æ¯”ç‰¹0å’Œ2æ¥åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„é›†åˆã€‚ä½†æ˜¯ï¼Œæœ‰è¿™ä¸¤ä¸ªæ ¡éªŒæµ‹é‡å°±è¶³å¤Ÿäº†ã€‚è¿™æ˜¯å› ä¸ºé‡å­æ¯”ç‰¹0å’Œ2æ˜¯å¦ç›¸åŒçš„ä¿¡æ¯å¯ä»¥ä»é‡å­æ¯”ç‰¹0å’Œ1ä»¥åŠé‡å­æ¯”ç‰¹1å’Œ2æ˜¯å¦ä¸z-åŸºç›¸åŒæ¨å¯¼å‡ºã€‚å¯¹äºç¬¬ä¸ªğ‘›é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬å¯ä»¥ä»é‚»è¿‘é‡å­æ¯”ç‰¹å¯¹çš„ğ‘›âˆ’1æ ¡éªŒæµ‹é‡ä¸­è·å¾—æ‰€éœ€çš„ä¿¡æ¯ã€‚

åœ¨æ²¡æœ‰ä»»ä½•å™ªéŸ³çš„æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡Œè¿™äº›å›è·¯ä¼šå¾—åˆ°éå¸¸ç®€å•çš„ç»“æœã€‚

> def get_raw_results(code,noise_model=None):
>
> circuits = code.get_circuit_list()
>
> raw_results = {}
>
> for log in range(2):
>
> job = execute( circuits\[log\], Aer.get_backend(\'qasm_simulator\'),
> noise_model=noise_model)
>
> raw_results\[str(log)\] = job.result().get_counts(str(log))
>
> return raw_results
>
> raw_results = get_raw_results(code)
>
> for log in raw_results:
>
> print(\'Logical\',log,\':\',raw_results\[log\],\'\\n\')
>
> è¾“å‡ºï¼š
>
> Logical 0 : {\'000 00\': 1024}
>
> Logical 1 : {\'111 00\': 1024}

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¾“å‡ºåˆ†ä¸ºä¸¤éƒ¨åˆ†ã€‚å³è¾¹çš„éƒ¨åˆ†æ˜¯ä¸¤ä¸ªæ ¡éªŒæµ‹é‡çš„ç»“æœã€‚å·¦è¾¹çš„æ˜¯ç¼–ç é‡å­æ¯”ç‰¹çš„ä¸‰æ¬¡æœ€ç»ˆæµ‹é‡ç»“æœã€‚

å¯¹äºæ›´å¤šçš„æµ‹é‡æ¬¡æ•°$T = 4$çš„æƒ…å†µï¼Œå°±ä¼šåœ¨è¾“å‡ºçš„å³è¾¹æ˜¾ç¤ºå‡ºæ›´å¤šçš„è¾¹æ ¡éªŒæµ‹é‡çš„ç»“æœã€‚

> code = RepetitionCode(n,4)
>
> raw_results = get_raw_results(code)
>
> for log in raw_results:
>
> print(\'Logical\',log,\':\',raw_results\[log\],\'\\n\')
>
> è¾“å‡ºï¼š
>
> Logical 0 : {\'000 00 00 00 00\': 1024}
>
> Logical 1 : {\'111 00 00 00 00\': 1024}

å¯¹äºæ›´å¤šé‡å¤ï¼Œå¦‚$n = 5$çš„æƒ…å†µï¼Œæ¯ä¸€æµ‹é‡ç»„ï¼ˆåŒ…å«ä¸¤ä¸ªæ ¡éªŒæµ‹é‡ï¼‰ä¼šå˜çš„æ›´å¤§ã€‚åœ¨å·¦ä¾§çš„æœ€ç»ˆæµ‹é‡ä¼šå˜ä¸º$n$ä¸ªé‡å­æ¯”ç‰¹ã€‚ç¬¬$T$æ¬¡æ ¡éªŒæµ‹é‡å°†ä½œç”¨äºæ¯ä¸€ä¸ª$n - 1$çš„å¯èƒ½é‚»è¿‘é‡å­æ¯”ç‰¹å¯¹ä¸Šã€‚

> code = RepetitionCode(5,4)
>
> raw_results = get_raw_results(code)
>
> for log in raw_results:
>
> print(\'Logical\',log,\':\',raw_results\[log\],\'\\n\')
>
> è¾“å‡ºï¼š
>
> Logical 0 : {\'00000 0000 0000 0000 0000\': 1024}
>
> Logical 1 : {\'11111 0000 0000 0000 0000\': 1024}

### æŸ¥æ‰¾è¡¨è§£ç ï¼ˆLookup table decodingï¼‰

ç°åœ¨è®©æˆ‘ä»¬å›åˆ°$n = 3$ä»¥åŠ$T = 1$çš„ç¤ºä¾‹ä¸Šï¼Œå¹¶åœ¨å…¶ä¸­åŠ å…¥ä¸€äº›å™ªå£°ã€‚

> code = RepetitionCode(3,1)
>
> noise_model = get_noise(0.05,0.05)
>
> raw_results = get_raw_results(code,noise_model)
>
> for log in raw_results:
>
> print(\'Logical\',log,\':\',raw_results\[log\],\'\\n\')
>
> è¾“å‡ºï¼š
>
> Logical 0 : {\'100 11\': 1, \'011 10\': 1, \'001 01\': 7, \'100 00\':
> 55, \'101 01\': 1, \'010 11\': 3, \'101 00\': 5, \'110 00\': 4, \'110
> 01\': 2, \'000 10\': 77, \'000 11\': 12, \'001 00\': 46, \'001 10\':
> 2, \'100 01\': 4, \'100 10\': 4, \'111 00\': 1, \'000 00\': 641, \'010
> 00\': 47, \'010 10\': 5, \'011 00\': 4, \'000 01\': 78, \'011 01\': 1,
> \'001 11\': 1, \'010 01\': 22}
>
> Logical 1 : {\'101 10\': 5, \'100 11\': 1, \'111 10\': 73, \'011 10\':
> 22, \'011 11\': 2, \'001 01\': 2, \'101 11\': 18, \'100 00\': 5, \'101
> 01\': 19, \'101 00\': 56, \'110 00\': 52, \'110 10\': 7, \'110 01\':
> 23, \'111 11\': 13, \'001 00\': 6, \'001 10\': 1, \'100 01\': 3, \'111
> 00\': 586, \'110 11\': 1, \'010 00\': 6, \'010 10\': 2, \'011 00\':
> 54, \'011 01\': 5, \'111 01\': 59, \'001 11\': 1, \'010 01\': 2}

æ­¤å¤„æˆ‘ä»¬åˆ›å»ºäº†åä¸ºraw_resultsçš„Pythonå­—å…¸ï¼Œç”¨äºå­˜å‚¨ç¼–ç é€»è¾‘0å’Œé€»è¾‘1å›è·¯çš„è¾“å‡ºã€‚

å½“é¢å¯¹ä»»ä½•å¯èƒ½çš„è¾“å‡ºæ—¶ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡æ˜¯ç¡®å®šå¦‚æœæ²¡æœ‰å™ªå£°åˆ™ç»“æœåº”è¯¥å¦‚ä½•ã€‚å¯¹äºè¾“å‡ºä¸º"000
00"æˆ–"111
11"çš„æƒ…å†µï¼Œç­”æ¡ˆæ˜¾è€Œæ˜“è§ã€‚åœ¨æ²¡æœ‰é”™è¯¯å‘ç”Ÿæ—¶ï¼Œéƒ½æ˜¯åˆšæ‰æ‰€è§é€»è¾‘0å’Œé€»è¾‘1çš„è¾“å‡ºã€‚å‰è€…æ˜¯é€»è¾‘0æœ€å¸¸è§çš„è¾“å‡ºï¼Œè€Œåè€…æ˜¯é€»è¾‘1æœ€å¸¸è§çš„è¾“å‡ºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºè¿™æ ·çš„ä¸€ä¸ªç»“è®ºï¼šå¯¹äºé€»è¾‘0ï¼Œå½“é‡åˆ°"000
00"æ—¶ï¼Œè¾“å‡ºå°±æ˜¯å¦‚æ­¤ï¼›å¯¹äºé€»è¾‘1ï¼Œå½“é‡åˆ°"111 00"æ—¶ï¼Œè¾“å‡ºäº¦ä¸ºå¦‚æ­¤ã€‚

å°½ç®¡è¿™æ˜¯æœ€ä½³ç­–ç•¥ï¼Œä½†ä¹Ÿå¯èƒ½å¤±æ•ˆã€‚å¯ä»¥çœ‹åˆ°ï¼šå¯¹äºç¼–ç 0ï¼Œ"111
00"é€šå¸¸ä¼šåœ¨å°‘æ•°æƒ…å†µä¸‹å‡ºç°ï¼›å¯¹äºç¼–ç 1ï¼Œä¹Ÿä¼šæœ‰ç±»ä¼¼æƒ…å†µã€‚åœ¨æœ¬ç¤ºä¾‹ä¸­ï¼Œè™½ç„¶è¾“å‡ºæ²¡æœ‰é”™è¯¯å‘ç”Ÿï¼Œæˆ‘ä»¬ä¹Ÿä¼šä¸æ­£ç¡®çš„å¤šè¾“å‡ºè¿›è¡Œè§£ç ã€‚åœ¨è¿™æ ·çš„æƒ…å†µä¸‹ï¼Œå¤§é‡çš„é”™è¯¯ä¸²è”èµ·æ¥ï¼Œä½¿å…¶çœ‹èµ·æ¥å°±åƒæˆ‘ä»¬æœ‰ä¸€ä¸ªç›¸åé€»è¾‘å€¼çš„æ— å™ªå£°æƒ…å†µï¼Œå› æ­¤æ ¡æ­£å°±æ— æ³•å®ç°ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»ä¼¼çš„ç­–ç•¥æ¥è§£ç æ‰€æœ‰å…¶ä»–è¾“å‡ºã€‚æ¯”å¦‚è¾“å‡º"111
00"ï¼Œåœ¨é€»è¾‘0ä¸­å‡ºç°çš„æ¬¡æ•°æ¯”åœ¨é€»è¾‘1ä¸­å‡ºç°çš„æ¬¡æ•°å¤šã€‚è¿™æ˜¯å› ä¸ºåœ¨å‰ä¸€ç§æƒ…å†µä¸‹ï¼Œå®ƒå¯èƒ½ä»…ç”±å•ä¸ªæµ‹é‡é”™è¯¯ï¼ˆå°†å•ä¸ª0é”™è¯¯åœ°æŠ¥å‘Šä¸º1ï¼‰å¼•èµ·ï¼Œä½†åœ¨åä¸€ç§æƒ…å†µä¸‹ï¼Œéœ€è¦è‡³å°‘ä¸¤ä¸ªé”™è¯¯ã€‚æ‰€ä»¥æ¯å½“æˆ‘ä»¬çœ‹åˆ°"001
00"ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è§£ç ä¸ºé€»è¾‘0ã€‚

å¯¹æ‰€æœ‰å­—ä¸²åº”ç”¨è¿™ç§ç­–ç•¥å°±æ˜¯æ‰€è°“çš„"æŸ¥æ‰¾è¡¨è§£ç "ã€‚è¿™æ˜¯åˆ†ææ¯ä¸ªå¯èƒ½è¾“å‡ºçš„åœ°æ–¹ï¼Œç”¨äºç¡®å®šæœ€å¯èƒ½è§£ç çš„å€¼ã€‚å¯¹äºå¤§é‡çš„é‡å­æ¯”ç‰¹æ¥è¯´ï¼ŒæŸ¥æ‰¾è¡¨å°±æ— æ³•å¤„ç†äº†ï¼Œå› ä¸ºå¯èƒ½è¾“å‡ºçš„æ•°é‡ä¼šå˜å¾—éå¸¸å·¨å¤§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ä¼šéœ€è¦æ›´å¤šçš„ç®—æ³•è§£ç å™¨ã€‚ä½†æ˜¯ï¼ŒæŸ¥æ‰¾è¡¨è§£ç åœ¨æµ‹è¯•å°ä»£ç æ—¶æ•ˆæœå¾ˆå¥½ã€‚

æˆ‘ä»¬å¯ä»¥åœ¨ä»»æ„ä»£ç ä¸­ä½¿ç”¨Qiskitä¸­çš„å·¥å…·æ¥å®ç°æŸ¥æ‰¾è¡¨è§£ç ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸¤ç»„è¾“å‡ºã€‚å…¶ä¸­çš„ä¸€ä¸ªæ˜¯æƒ³è¦è§£ç çš„è¾“å‡ºé›†åˆï¼Œä¸ºæ­¤éœ€è¦è®¡ç®—é”™è¯¯è§£ç çš„æ¦‚ç‡$P$ã€‚æ­¤å¤„ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å·²åˆ›å»ºçš„raw_resultsã€‚

å¦ä¸€ç»„è¾“å‡ºåˆ™è¢«ç”¨ä½œæŸ¥æ‰¾è¡¨ã€‚è¿™å°†éœ€è¦è¿è¡Œå¤§é‡æ ·æœ¬æ¥ç¡®ä¿å…¶èƒ½å¤Ÿè·å¾—æ¯ä¸ªå¯èƒ½è¾“å‡ºçš„è‰¯å¥½ç»Ÿè®¡æ•°æ®ã€‚æˆ‘ä»¬è®¾ç½®è¿è¡Œæ¬¡æ•°shots=10000ã€‚

> circuits = code.get_circuit_list()
>
> table_results = {}
>
> for log in range(2):
>
> job = execute( circuits\[log\], Aer.get_backend(\'qasm_simulator\'),
> noise_model=noise_model, shots=10000 )
>
> table_results\[str(log)\] = job.result().get_counts(str(log))

å¯¹è¿™ä¸ªç§°ä¸ºtable_resultsçš„æ•°æ®ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥ä½¿ç”¨Qiskitä¸­çš„lookuptable_decodingå‡½æ•°ã€‚è¿™ä¸€å‡½æ•°ä»raw_resultsä¸­è·å–è¾“å‡ºï¼Œå¹¶ä½¿ç”¨table_resultsä¸­çš„ä¿¡æ¯å¯¹å…¶è¿›è¡Œè§£ç ã€‚ç„¶åæ£€æŸ¥å¦‚æœè§£ç æ­£ç¡®åˆ™ä½¿ç”¨è¿™äº›ä¿¡æ¯æ¥è®¡ç®—$P$ã€‚

> P = lookuptable_decoding(raw_results,table_results)
>
> print(\'P =\',P)
>
> è¾“å‡ºï¼š
>
> P = {\'0\': 0.0247, \'1\': 0.0217}

æ­¤å¤„çš„$P$å€¼è¿œä½äº$p_{\text{meas}}$å’Œ$p_{\text{gate}}$ï¼Œå› æ­¤æˆ‘ä»¬åœ¨å­˜å‚¨æ¯”ç‰¹å€¼çš„å¯é æ€§æ–¹é¢å¾—åˆ°äº†æ”¹è¿›ã€‚è¿˜è¦æ³¨æ„ç¼–ç 1çš„$P$å€¼éƒ½é«˜äº0ã€‚è¿™æ˜¯å› ä¸ºç¼–ç 1éœ€è¦åº”ç”¨xé—¨------è¿™å›å¼•å…¥é¢å¤–çš„å™ªå£°æºã€‚

### å›¾è®ºè¯‘ç ï¼ˆGraph theoretic decodingï¼‰

ä¸ŠèŠ‚ä¸­æ‰€è€ƒè™‘çš„è§£ç æ–¹å¼èƒ½å¤Ÿç”Ÿæˆæœ€æœ‰å¯èƒ½çš„ç»“æœä¸”æ— é¡»ä»»ä½•ç¼–ç ç»†èŠ‚ã€‚ç„¶è€Œï¼Œå…¶ä¸€ä¸ªä¸»è¦ç¼ºç‚¹æŠµæ¶ˆäº†æ‰€æœ‰è¿™äº›ä¼˜ç‚¹ï¼šæŸ¥æ‰¾è¡¨ä¼šéšç€ç¼–ç å¤§å°çš„å¢åŠ å‘ˆç°æŒ‡æ•°å¢é•¿ã€‚ç”±äºè¿™ä¸€åŸå› ä¸”è€ƒè™‘åˆ°ç¼–ç çš„ç»“æ„ä»¥åŠæ‰€ç”Ÿæˆçš„æ ¡éªŒï¼Œè§£ç é€šå¸¸ä»¥ä¸€ç§æ›´åŠ ç®—æ³•çš„æ–¹å¼è¿›è¡Œã€‚

topological_codesä¸­çš„ä»£ç é€šè¿‡å¯¹æ ¡éªŒå­ï¼ˆsyndromeï¼‰çš„åå¤„ç†ï¼ˆpost-processingï¼‰æ­ç¤ºäº†è¿™ä¸€ç»“æ„ã€‚æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨ä¸ŠèŠ‚ä¸­æ‰€ç¤ºçš„å½¢å¼ï¼Œè€Œä½¿ç”¨ç¼–ç å¯¹è±¡çš„process_resultsæ–¹æ³•å°†ä¸”é‡å†™ä¸ºå¦ä¸€ç§å½¢å¼ï¼Œå·¦ä¾§æ˜¯ç¼–ç é‡å­æ¯”ç‰¹çš„æœ€ç»ˆæµ‹é‡ç»“æœï¼Œå³ä¾§æ˜¯ä¼´éšæµ‹é‡å¤„çš„è¾“å‡ºã€‚

ä¾‹å¦‚ï¼Œä¸‹é¢æ˜¯raw_resultså­—å…¸ç»è¿‡å¤„ç†çš„å½¢å¼ï¼Œæ­¤å¤„$n = 3$ã€$T = 2$ã€‚ä¸ºæ¸…æ¥šèµ·è§ï¼Œä»…æ˜¾ç¤º50æˆ–æ›´å¤šæ ·æœ¬çš„ç»“æœã€‚

> code = RepetitionCode(3,2)
>
> raw_results = get_raw_results(code,noise_model)
>
> results = code.process_results( raw_results )
>
> for log in \[\'0\',\'1\'\]:
>
> print(\'\\nLogical \' + log + \':\')
>
> print(\'raw results \', {string:raw_results\[log\]\[string\] for
> string in raw_results\[log\] if raw_results\[log\]\[string\]\>=50 })
>
> print(\'processed results \', {string:results\[log\]\[string\] for
> string in results\[log\] if results\[log\]\[string\]\>=50
> })measurement
>
> è¾“å‡ºï¼š
>
> Logical 0:
>
> raw results {\'000 00 00\': 495, \'000 10 00\': 53}
>
> processed results {\'0 0 00 00 00\': 495, \'0 0 00 10 10\': 53}
>
> Logical 1:
>
> raw results {\'111 00 00\': 429, \'111 00 10\': 52, \'111 01 00\': 61,
> \'111 10 00\': 51}
>
> processed results {\'1 1 00 00 00\': 429, \'1 1 10 10 00\': 52, \'1 1
> 00 01 01\': 61, \'1 1 00 10 10\': 51}

åœ¨ä¸Šé¢çš„è¾“å‡ºä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°"000 00 00"è¢«è½¬æ¢ä¸º"0 0 00 00 00"ï¼Œ"111 00
00"è¢«è½¬æ¢ä¸º"1 1 00 00 00"ç­‰ç­‰ã€‚

åœ¨è¿™äº›æ–°çš„å­—ä¸²ä¸­ï¼Œé€»è¾‘0ä¸­æœ€å·¦ä¾§çš„"0 0"å’Œé€»è¾‘1æœ€å·¦ä¾§çš„"1
1"éƒ½ä¸ºé€»è¾‘è¯»å‡ºï¼ˆlogical
readoutï¼‰ã€‚ç”±äºç¼–ç é‡å­æ¯”ç‰¹éƒ½ç›¸åŒï¼ˆæ²¡æœ‰é”™è¯¯ï¼‰ï¼Œä»»ä¸€ç¼–ç é‡å­æ¯”ç‰¹éƒ½å¯ç”¨äºè¿™ä¸€è¯»å‡ºã€‚å› æ­¤åœ¨è¿™ä¸€ä½ç½®ä»…æœ‰å•ä¸ª0æˆ–å•ä¸ª1åœ¨åŸåˆ™ä¸Šå¯èƒ½ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹ç»“æœåŸå§‹å½¢å¼ä¸­æ¯ä¸ªé‡å­éƒ½è¿›è¡Œè¿™æ ·çš„è¿ç®—å¹¶è·å¾—$n$ã€‚ä»è€Œå–ä»£æˆ‘ä»¬æ‰€ä½¿ç”¨çš„å­—ä¸²å°¾éƒ¨çš„ä¸¤ä¸ªé‡å­æ¯”ç‰¹ã€‚å…¶åŸå› å°†åœ¨åæ–‡ä¸­è¯´æ˜ã€‚åœ¨æ²¡æœ‰é”™è¯¯çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸¤ä¸ªå€¼å°†æ€»æ˜¯ç›¸ç­‰ï¼Œå› ä¸ºå®ƒä»¬è¡¨ç¤ºç›¸åŒçš„ç¼–ç æ¯”ç‰¹å€¼ã€‚

åœ¨é€»è¾‘å€¼è·Ÿéšç¬¬ä¸€è½®æ ¡éªŒæµ‹é‡çš„$n - 1$ä¸ªç»“æœä¹‹åã€‚0è¡¨ç¤ºå¯¹åº”çš„*é‡å­æ¯”ç‰¹å¯¹*å…·æœ‰ç›¸åŒçš„å€¼ï¼Œè€Œ1è¡¨ç¤ºé‡å­æ¯”ç‰¹ä¹‹é—´å½¼æ­¤ä¸åŒã€‚ç”±äºç¬¬$d$ä¸ªç¼–ç é‡å­æ¯”ç‰¹çš„è¡Œå…·æœ‰$n - 1$ä¸ªå¯èƒ½çš„ç›¸é‚»å¯¹ï¼Œå› æ­¤æœ‰$n - 1$ä¸ªç»“æœã€‚åœ¨æ²¡æœ‰é”™è¯¯çš„æƒ…å†µä¸‹ï¼Œå…¶éƒ½å°†ä¸º0ã€‚è¿™ä¸åŸå§‹ç»“æœå½¢å¼çš„ç¬¬ä¸€ä¸ªæ­¤ç±»æ ¡éªŒç»“æœå®Œå…¨ç›¸åŒã€‚

ä¸‹ä¸ªå—æ˜¯ä¸‹ä¸€è½®æ ¡éªŒç»“æœã€‚ä½†æ˜¯ï¼Œä¸å…¶ç›´æ¥å‘ˆç°è¿™äº›ç»“æœï¼Œä¸å¦‚è¯´å®ƒä½¿æˆ‘ä»¬åœ¨ç¬¬ä¸€è½®å’Œç¬¬äºŒè½®ä¹‹é—´å‡ºç°äº†æ ¡éªŒå­å˜åŒ–ã€‚å› æ­¤ï¼Œå…¶æ˜¯ç¬¬äºŒè½®ä¸ç¬¬ä¸€è½®çš„æ ¡éªŒæµ‹é‡ç»“æœçš„*é€ä½æˆ–*ï¼ˆbitwise
ORï¼‰ åœ¨æ²¡æœ‰é”™è¯¯çš„æƒ…å†µä¸‹éƒ½å°†ä¸º0ã€‚

æ‰€æœ‰åç»­å—éƒ½éµå¾ªç›¸åŒçš„æ–¹å¼ï¼Œå°½ç®¡æœ€åä¸€ä¸ªéœ€è¦è¿›è¡Œæ³¨é‡Šã€‚è¿™ä¸æ˜¯å¯¹è¿æ¥é‡å­æ¯”ç‰¹çš„æ ‡å‡†æµ‹é‡æ–¹å¼ã€‚ç›¸åï¼Œå…¶æ˜¯æ ¹æ®æ‰€æœ‰ç¼–ç é‡å­æ¯”ç‰¹çš„æœ€ç»ˆè¯»å‡ºæµ‹é‡å¾—å‡ºçš„ç»“æœã€‚å†æ¬¡å¼ºè°ƒï¼Œæ­¤å¤„å°†å…¶è¡¨ç¤ºä¸ºæ ¡éªŒå­æ›´æ”¹ï¼Œåœ¨æ²¡æœ‰é”™è¯¯çš„æƒ…å†µä¸‹å°†å…¨ä¸º0ã€‚è¿™æ˜¯ç¬¬$T + 1$ä¸ªå—çš„æ ¡éªŒæµ‹é‡ï¼Œå› ä¸ºç”±äºå®ƒçš„å¤„ç†æ–¹å¼ä¸å…¶ä»–æ–¹æ³•ä¸åŒï¼Œå› æ­¤ä¸åœ¨ç¬¬$T$ä¸ªæ ¡éªŒæµ‹é‡å›åˆä¸­è¿›è¡Œè®¡æ•°ã€‚

ä»¥ä¸‹ç¤ºä¾‹è¿›ä¸€æ­¥è¯´æ˜æ­¤çº¦å®šã€‚

**ç¤ºä¾‹1**ï¼š0 0 0110 0000
0000è¡¨ç¤º$d = 5$ï¼Œ$T = 2$å¯¹0è¿›è¡Œç¼–ç çš„é‡å¤æ ¡éªŒã€‚è¯¥æ ¡éªŒå­å¾ˆå¯èƒ½è¡¨æ˜åœ¨ç¬¬ä¸€æ¬¡æµ‹é‡å›åˆä¹‹å‰ï¼Œä¸­é—´çš„ç¼–ç é‡å­æ¯”ç‰¹å› è¯¯å·®è€Œç¿»è½¬ã€‚è¿™å°±å¯¼è‡´å…¶ä¸å›è·¯ä¸­å…¶ä½™éƒ¨åˆ†çš„ä¸¤ä¸ªç›¸é‚»ç¼–ç é‡å­æ¯”ç‰¹ä¸åŒã€‚è¿™åœ¨ç¬¬ä¸€è½®æ ¡éªŒä¸­æ˜¾ç¤ºå‡ºæ¥ï¼Œä½†æ˜¯åœ¨åç»­çš„å—ä¸­ä¸å¯¹å…¶è¿›è¡ŒæŠ¥å‘Šï¼Œç”±äºå…¶ä¸å†ä»£è¡¨æ›´æ”¹ã€‚å…¶ä»–ç±»å‹çš„é”™è¯¯ä¹Ÿå¯èƒ½å¯¼è‡´è¿™ç§æ ¡éªŒå­ï¼Œä½†æ˜¯ç”±äºå®ƒä»¬æ›´å¤æ‚ï¼Œå› æ­¤å¯èƒ½æ€§æ›´ä½ã€‚

**ç¤ºä¾‹2**ï¼š0 0 0010 0010
0000è¡¨ç¤º$d = 5$ï¼Œ$T = 2$å¯¹0è¿›è¡Œç¼–ç çš„é‡å¤æ ¡éªŒã€‚æ­¤å¤„ï¼Œå…¶ä¸­çš„ä¸€ä¸ªæ ¡éªŒæµ‹é‡ç»“æœæŠ¥å‘Šäº†ç¬¬ä¸€è½®ä¸­ä¸¤ä¸ªç¼–ç é‡å­æ¯”ç‰¹ä¹‹é—´çš„å·®å¼‚ï¼Œå…¶ä¸º1ã€‚åœ¨ä¸‹ä¸€è½®ä¸­æœªçœ‹åˆ°ç›¸åŒçš„æ•ˆæœï¼Œå› æ­¤ç»“æœä¸º0ã€‚ä½†æ˜¯ï¼Œç”±äºä¸ä¹‹å‰çš„æ ¡éªŒæµ‹é‡ç»“æœä¸åŒï¼Œä¸”ç”±äºæˆ‘ä»¬è·Ÿè¸ªæ ¡éªŒå­çš„å˜åŒ–ï¼Œå› æ­¤è¯¥å˜åŒ–ä¼šå¯¼è‡´å¦ä¸€ä¸ª1ã€‚åœ¨éšåçš„å›åˆä¹Ÿä¸ä¼šæ£€æµ‹åˆ°ä»»ä½•å˜åŒ–ï¼Œä½†è¿™ä¸å†è¡¨ç¤ºå˜åŒ–ï¼Œå› æ­¤åœ¨ç›¸åŒä½ç½®äº§ç”Ÿ0ã€‚ç¬¬ä¸€ä¸ª1çš„æµ‹é‡ç»“æœå¾ˆå¯èƒ½æ˜¯ç”±é”™è¯¯å¼•èµ·çš„ã€‚

**ç¤ºä¾‹3**ï¼š0 1 0000 0001
0000è¡¨ç¤º$d = 5$ï¼Œ$T = 2$å¯¹1è¿›è¡Œç¼–ç çš„é‡å¤æ ¡éªŒã€‚åœ¨ç¬¬äºŒè½®æ ¡éªŒæµ‹é‡ä¹‹å‰ï¼Œç¿»è½¬è¡Œå°¾çš„ç¼–ç é‡å­æ¯”ç‰¹ã€‚ç”±äºå…¶åœ¨è¡Œçš„æœ«å°¾ï¼Œå› æ­¤åªèƒ½é€šè¿‡ä¸€æ¬¡æ ¡éªŒæµ‹é‡æ£€æµ‹å‡ºæ¥ã€‚å‡ºäºç›¸åŒçš„åŸå› ï¼Œå…¶ä¹Ÿå¹²æ‰°äº†é€»è¾‘è¯»å‡ºä¹‹ä¸€ã€‚

æˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°åœ¨ä¸Šé¢çš„ä¸‰ä¸ªç¤ºä¾‹ä¸­å•ä¸ªè¯¯å·®å®é™…ä¸Šå¯¼è‡´äº†å­—ä¸²ä¸­ä¸åº”è¯¥å‘ç”Ÿè¯¯å·®çš„ä¸¤ä¸ªå­—ç¬¦æ”¹å˜ã€‚è¿™åœ¨topological_codesä¸­ç”¨äºè¡¨ç¤ºç¨³å®šå­ï¼ˆstabilizerï¼‰çš„ç‰¹æ€§ï¼Œé€šå¸¸ç”¨äºå®šä¹‰åœ¨å…¶ä¸Šå®šä¹‰è§£ç é—®é¢˜çš„å›¾ã€‚

å…·ä½“æ¥è¯´ï¼Œè¯¥å›¾æ˜¯é€šè¿‡é¦–å…ˆå°†å›è·¯ç¼–ç ä¸ºé€»è¾‘0æ„é€ ï¼Œå¯¹äºè¯¥å›¾è¾“å‡ºå­—ä¸²ä¸­çš„æ‰€æœ‰æ¯”ç‰¹å€¼éƒ½åº”ä¸º0ã€‚ç„¶åå°†å…¶å¤åˆ¶ååœ¨æ¨¡æ‹Ÿå™¨ä¸Šåˆ›å»ºå¹¶è¿è¡Œï¼Œå¹¶åœ¨æ¯ä¸ªæ¨¡æ‹Ÿå™¨ä¸­æ’å…¥ä¸åŒçš„Pauliç®—å­ã€‚åœ¨æ¯ä¸€ä¸ªé‡å­æ¯”ç‰¹å’Œå›è·¯æ·±åº¦ä¸Šï¼Œå¯¹ä¸‰ç§Pauliç®—å­ä¸­çš„æ¯ä¸€ç§éƒ½è¿›è¡Œäº†è¿™æ ·çš„è¿ç®—ã€‚è¿™äº›å›è·¯ä¸­æ¯ä¸ªå›è·¯çš„è¾“å‡ºéƒ½å¯ç”¨äºç¡®å®šæ¯ä¸€ä¸ªå¯èƒ½å•ä¸ªè¯¯å·®çš„å½±å“ã€‚ç”±äºå›è·¯ä»…åŒ…å«Cliffordè¿ç®—ï¼Œå› æ­¤å¯ä»¥æœ‰æ•ˆåœ°æ‰§è¡Œä»¿çœŸã€‚

æ¯ä¸€æ¬¡è¯¯å·®éƒ½ä¼šå‡†ç¡®åœ°æ”¹å˜ä¸¤ä¸ªå­—ç¬¦ï¼Œé™¤éæ²¡æœ‰äº§ç”Ÿå½±å“ã€‚ç„¶åæ„é€ ä¸€ä¸ªå›¾ï¼Œå…¶è¾“å‡ºå­—ä¸²çš„æ¯ä¸€æ¯”ç‰¹å¯¹åº”ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå—åŒä¸€è¯¯å·®å½±å“çš„æ¯”ç‰¹å¯¹å¯¹åº”ä¸€æ¡è¾¹ã€‚

æ ¹æ®è¾“å‡ºå­—ä¸²ä¸­å‘ç°çš„æ ¡éªŒå­ï¼Œè§£ç ç‰¹å®šè¾“å‡ºå­—ä¸²çš„è¿‡ç¨‹é€šå¸¸éœ€è¦ç®—æ³•æ¨æ–­å‡ºç”±å“ªä¸€ç»„å¼•èµ·äº†é”™è¯¯ã€‚è¿™ä¸ªè¿‡ç¨‹å¯ä»¥é€šè¿‡æ„é€ ç¬¬äºŒä¸ªå›¾æ¥å®ç°ï¼Œè¯¥å›¾åªåŒ…å«ä¸è¾“å‡ºä¸­çš„éå¹³å‡¡æ ¡éªŒæ¯”ç‰¹ç›¸å¯¹åº”çš„èŠ‚ç‚¹ã€‚ç„¶ååœ¨æ¯å¯¹èŠ‚ç‚¹ä¹‹é—´æ”¾ç½®ä¸€æ¡è¾¹ï¼Œç›¸åº”çš„æƒå€¼ç­‰äºåŸå§‹å›¾ä¸­è¿™äº›èŠ‚ç‚¹ä¹‹é—´æœ€å°è·¯å¾„çš„é•¿åº¦ã€‚ç„¶åé€šè¿‡ä¸è¯¥æ ¡éªŒå­ä¸€è‡´çš„ä¸€ç»„è¯¯å·®å¯¹åº”åœ°æ‰¾å‡ºè¯¥ä¸ä¹‹å®Œç¾åŒ¹é…çš„å›¾ã€‚è‹¥è¦æ¨æ–­å‡ºæœ€å¯èƒ½å‘ç”Ÿè¯¯å·®çš„ç»„ï¼Œä¸€ä¸ªè¾ƒå¥½çš„ç­–ç•¥æ˜¯æ‰¾å‡ºä¸€ä¸ªè¯¯å·®æœ€å°‘ä¸”ä¸æ‰€è§‚å¯Ÿåˆ°çš„æ ¡éªŒå­ç›¸ä¸€è‡´çš„ç»„ã€‚è¿™ä¸æ‰€å¯¹åº”äºå›¾ä¸­çš„æœ€å°æƒå€¼å®Œç¾åŒ¹é…ã€‚

ä½¿ç”¨æœ€å°æƒé‡å®Œç¾åŒ¹é…æ˜¯é‡å¤æ ¡éªŒå’Œè¡¨å±‚ç¼–ç ï¼ˆsurface
codeï¼‰çš„æ ‡å‡†è§£ç æŠ€æœ¯ï¼Œå…¶å·²åœ¨Qiskit
Ignisä¸­å®ç°ã€‚å½“ç„¶è¿˜å¯ç”¨äºå…¶ä»–æƒ…å†µï¼Œä¾‹å¦‚é¢œè‰²ç¼–ç ï¼ˆcolor
codeï¼‰ã€‚ä½†å¯¹äºæ¯ä¸€ä¸ªç¼–ç å’Œå™ªå£°æ¨¡å‹éƒ½æ— æ³•æ‰¾åˆ°æœ€å¯èƒ½å‘ç”Ÿè¯¯å·®ç»„çš„æœ€ä½³è¿‘ä¼¼å€¼ã€‚å› æ­¤ï¼Œå¯ä»¥ä½¿ç”¨åŸºäºç›¸åŒå›¾çš„å…¶ä»–è§£ç æŠ€æœ¯ã€‚Qiskit
Ignisçš„GraphDecoderå¯ç”¨äºè®¡ç®—ç»™å®šç¼–ç çš„å›¾å¹¶ä¸”ç»™å‡ºäº†å¤šç§åˆ†ææ–¹æ³•ã€‚åœ¨æ’°å†™æœ¬æ–‡æ—¶ï¼Œä»…å®ç°äº†æœ€å°æƒé‡å®Œç¾åŒ¹é…ã€‚

è¯·æ³¨æ„ï¼å¯¹äºè¯¸å¦‚è¡¨å±‚ç¼–ç ä¹‹ç±»çš„ä»£ç ï¼Œä¸¥æ ¼æ„ä¹‰ä¸Šè¯´æ¯ä¸ªè¯¯å·®åªä¼šæ”¹å˜è¾“å‡ºå­—ä¸²ä¸­ä¸¤ä¸ªæ¯”ç‰¹çš„å€¼ã€‚ä¾‹å¦‚ä¸€ä¸ª$\sigma^{y}$é”™è¯¯å°†ä¼šç¿»è½¬ä¸¤ä¸ªä¸åŒç±»å‹ç¨³å®šå­æ‰€å¯¹åº”çš„ä¸€å¯¹å€¼ï¼Œé€šå¸¸ä¸ºç‹¬ç«‹è§£ç ã€‚å› æ­¤è¿™äº›ç¼–ç çš„è¾“å‡ºå°†ä»¥æ­¤æ–¹å¼å‘ˆç°ï¼Œå¯¹è¿™äº›æ ¡éªŒå­çš„åˆ†æå°†ç›¸åº”åœ°åˆ›å»ºå¤šä¸ªç‹¬ç«‹çš„å›¾æ¥è¡¨ç¤ºä¸åŒçš„æ ¡éªŒç±»å‹ã€‚

### è¿è¡Œé‡å¤æ ¡éªŒåŸºå‡†æµ‹è¯•

åœ¨æœ¬å°ç»“ä¸­æˆ‘ä»¬å°†åœ¨çœŸå®çš„é‡å­è®¾å¤‡ä¸Šè¿è¡Œé‡å¤æ ¡éªŒï¼Œå¹¶ä½¿ç”¨è¯¥è¾“å‡ºä½œä¸ºåŸºå‡†ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†ä¼šç®€è¦åœ°æ¦‚è¿°è¿™ä¸€è¿‡ç¨‹ã€‚è¿™ä¸€è¿‡ç¨‹é€‚ç”¨äºå³å°†å±•ç¤ºçš„é‡å¤æ ¡éªŒçš„ç¤ºä¾‹ï¼ŒåŒæ—¶ä¹Ÿé€‚ç”¨äºtopological_codesä¸­çš„å…¶ä»–åŸºå‡†æµ‹è¯•ï¼Œé€šå¸¸ä¹Ÿé€‚ç”¨äºQiskit
Ignisã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒåŸºå‡†æµ‹è¯•è¿‡ç¨‹ç”±ä»¥ä¸‹ä¸‰æ­¥ç»„æˆã€‚

1\. å®šä¹‰ä»»åŠ¡ã€‚ç”¨Qiskit Igniså®šä¹‰å¹¶åˆ›å»ºä¸€ç»„å°†ä¼šè¿è¡Œçš„å›è·¯ã€‚

2\. è¿è¡Œå›è·¯ã€‚é€šå¸¸ç”±Qiskitå®Œæˆï¼Œç„¶åˆ™ä»»ä½•ä¼ºæœå’Œå®éªŒè®¾å¤‡éƒ½å¯æ¥å…¥ã€‚

3\. ç”±Qiskit Igniså¤„ç†å›è·¯çš„ç»“æœï¼Œä»¥ä¾¿ç”Ÿæˆç»™å®šä»»åŠ¡æ‰€éœ€çš„è¾“å‡ºã€‚

å¯¹äºtopological_codesï¼Œæ­¥éª¤1è¦æ±‚é€‰æ‹©é‡å­è¯¯å·®ä¿®æ­£ç¼–ç çš„ç±»å‹å’Œå¤§å°ã€‚å…¶ä¸­ï¼Œæ¯ç§ç±»å‹çš„ç¼–ç éƒ½æœ‰ä¸€ä¸ªä¸“ç”¨çš„Pythonç±»ã€‚é€šè¿‡ç»™å‡ºæ‰€éœ€çš„å‚æ•°æ¥åˆå§‹åŒ–å¯¹åº”çš„å¯¹è±¡ï¼Œä¾‹å¦‚RepetitionCodeå¯¹è±¡çš„nå’ŒTã€‚ç„¶åï¼Œç”Ÿæˆçš„å¯¹è±¡åŒ…å«å›è·¯å¯¹åº”ç»™å®šä»£ç æ‰€ç¼–ç çš„ç®€å•é€»è¾‘é‡å­æ€ï¼ˆ$|0\rangle$ï¼Œ$|1\rangle$ï¼‰ï¼Œå¹¶åœ¨æœ€åè¯»å‡ºä¸€ä¸ªæ˜ç¡®é€»è¾‘åŸºçŸ¢ï¼ˆé€šå¸¸æ˜¯æ ‡å‡†$|0\rangle/|1\rangle$æµ‹é‡ï¼‰ä¹‹å‰ï¼Œè¿è¡Œç¨‹åºä¸­æ‰€æŒ‡å®šæ¬¡æ•°çš„é”™è¯¯æ£€æµ‹ã€‚

å¯¹äºtopological_codesï¼Œæ­¥éª¤3çš„ä¸»è¦è¿‡ç¨‹æ˜¯è§£ç ï¼Œå…¶ç›®çš„æ˜¯åˆ©ç”¨ä»è¯¯å·®æ£€æµ‹ä¸­è·å¾—çš„ä¿¡æ¯æ¥å‡å°‘æœ€ç»ˆè¯»å‡ºä¸­çš„ä»»ä½•é”™è¯¯ã€‚è§£ç çš„æœ€ä½³ç®—æ³•é€šå¸¸å› ç¼–ç è€Œå¼‚ï¼Œç„¶åˆ™ç»“æ„ç±»ä¼¼çš„ç¼–ç é€šå¸¸ä½¿ç”¨ç›¸ä¼¼çš„æ–¹æ³•ã€‚

topological_codesçš„ç›®çš„æ˜¯ç»™å‡ºå„ç§è§£ç æ–¹æ³•ï¼Œä¾æ­¤å®ç°çš„æ‰€æœ‰ç±»ä¼¼è§£ç å™¨éƒ½å¯ç”¨äºç¼–ç ã€‚å…¶ä¸­çš„è¿‡ç¨‹é€šè¿‡é™åˆ¶è§£ç çš„ä»£ç æ¥å®ç°ï¼Œå¯è¢«æè¿°ä¸ºä¸€ä¸ªå›¾è®ºçš„æœ€å°åŒ–é—®é¢˜ã€‚è¿™ç§ç¼–ç æ–¹å¼çš„å…¸å‹ä¾‹å­æ˜¯ç¯æ›²é¢ç¼–ç ï¼ˆtoric
codeï¼‰å’Œè¡¨å±‚ç¼–ç ã€‚2Dé¢œè‰²ç¼–ç å’ŒåŒ¹é…ç¼–ç ä¹Ÿå…·æœ‰è¿™ä¸€æ€§è´¨ã€‚æ‰€æœ‰è¿™äº›ç¼–ç ç±»å‹éƒ½æ˜¯æ‰€è°“æ‹“æ‰‘é‡å­è¯¯å·®ä¿®æ­£ç¼–ç çš„çªå‡ºç¤ºä¾‹ï¼Œä»è€Œå¯¼å‡ºäº†å­ç¨‹åºåŒ…çš„åç§°ã€‚ä½†è¯·æ³¨æ„ï¼å¹¶éæ‰€æœ‰æ‹“æ‰‘ç¼–ç éƒ½ä¸æ­¤è§£ç å™¨å…¼å®¹ï¼Œè€ŒæŸäº›éæ‹“æ‰‘ç¼–ç ä¸ä¹‹å…¼å®¹ï¼Œå¦‚é‡å¤æ ¡éªŒã€‚

è§£ç è¿‡ç¨‹ç”±GraphDecoderç±»å®Œæˆã€‚é€šè¿‡ç»™å‡ºå°†ä¸ºå…¶æ‰§è¡Œè§£ç çš„å·²ç¼–ç å¯¹è±¡æ¥åˆå§‹åŒ–ç›¸åº”çš„GraphDecoderå¯¹è±¡ï¼Œæ¥ç€ä»¥ä¹‹ç¡®å®šå°†è¢«ç”¨äºå®šä¹‰è§£ç é—®é¢˜çš„å›¾ã€‚ç„¶åå°±å¯ä»¥ä½¿ç”¨è§£ç å™¨å¯¹è±¡çš„å„ç§æ–¹æ³•å¯¹ç»“æœè¿›è¡Œå¤„ç†ã€‚

åœ¨ä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šçœ‹åˆ°å°†ä¸Šè¿°æ€æƒ³ç”¨äºé‡å¤æ ¡éªŒçš„å®é™…è¿‡ç¨‹ã€‚åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸¤ä¸ªå¸ƒå°”å˜é‡step_2å’Œstep_3ã€‚å˜é‡step_2ç”¨äºæ˜¾ç¤ºä»è®¾å¤‡è·å–æ•°æ®æ—¶æ‰€éœ€è¿è¡Œç¨‹åºçš„éƒ¨åˆ†ï¼Œå˜é‡step_3ç”¨äºæ˜¾ç¤ºå¤„ç†ç»“æœæ•°æ®çš„éƒ¨åˆ†ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªå˜é‡éƒ½è®¾ç½®ä¸ºfalseï¼Œä»¥ä¾¿ç¡®ä¿ä»…ä½¿ç”¨å…ˆå‰æ”¶é›†å’Œå¤„ç†çš„æ•°æ®å³å¯è¿è¡Œä»¥ä¸‹æ‰€æœ‰ç¨‹åºçš„ç‰‡æ®µã€‚ä½†è‹¥è¦è·å–æ–°æ•°æ®æ—¶åªéœ€step_2
= Trueï¼Œè€Œå¯¹ä»»ä½•æ•°æ®æ‰§è¡Œè§£ç æ—¶ä»…éœ€step_3 = Trueã€‚

> step_2 = False
>
> step_3 = False

è‹¥è¦å¯¹ä¸€å°çœŸå®é‡å­è®¾å¤‡è¿›è¡ŒåŸºå‡†æµ‹è¯•ï¼Œéœ€è¦æœ‰é€šè¿‡ç½‘ç»œè®¿é—®è¯¥è®¾å¤‡æ‰€éœ€çš„å·¥å…·ï¼Œå¹¶ç¼–è¯‘é€‚åˆåœ¨å…¶ä¸Šè¿è¡Œçš„å›è·¯ã€‚

> from qiskit import IBMQ
>
> from qiskit.compiler import transpile
>
> from qiskit.transpiler import PassManager

ç°åœ¨æˆ‘ä»¬å¯ä»¥åˆ›å»ºç”¨äºè¿è¡Œé‡å­å›è·¯çš„åç«¯å¯¹è±¡ï¼Œè¿™ä¸€è¿‡ç¨‹æ˜¯é€šè¿‡ç»™å‡ºç”¨äºæŒ‡å®šè®¾å¤‡çš„å­—ä¸²å®ç°ã€‚è¿™é‡Œä½¿ç”¨äº†\'ibmq_16_melbourne\'ï¼Œå®ƒåœ¨å†™å…¥æ—¶æœ‰15ä¸ªæ¿€æ´»çš„é‡å­æ¯”ç‰¹ã€‚æˆ‘ä»¬è¿˜å°†è€ƒè™‘ä½äºç½—åˆ‡æ–¯ç‰¹ï¼ˆRochesterï¼‰å¤§å­¦å«æœ‰53é‡å­æ¯”ç‰¹çš„é‡å­è®¾å¤‡ï¼Œå…¶ç”±'ibmq_rochester'æŒ‡å®šã€‚

> device_name = \'ibmq_16_melbourne\'
>
> if step_2:
>
> IBMQ.load_account()
>
> for provider in IBMQ.providers():
>
> for potential_backend in provider.backends():
>
> if potential_backend.name()==device_name:
>
> backend = potential_backend
>
> coupling_map = backend.configuration().coupling_map

å½“åœ¨çœŸå®çš„é‡å­è®¾å¤‡ä¸Šè¿è¡Œå›è·¯æ—¶ï¼Œé¦–å…ˆéœ€è¦å®ç°ä¸€ä¸ªè½¬è¯‘ï¼ˆtranspilationï¼‰è¿‡ç¨‹ã€‚è¿™ä¸€è¿‡ç¨‹ä¼šå°†å›è·¯ä¸­çš„é‡å­é—¨è½¬æ¢ä¸ºç”±çœŸå®è®¾å¤‡æ‰€å®ç°çš„åŸç”Ÿé‡å­é—¨é›†ã€‚åœ¨æŸäº›æƒ…å†µä¸‹è¿™äº›è½¬æ¢ä¸ä¼šå¼•èµ·è¾ƒå¤§çš„æ”¹å˜ï¼Œä¾‹å¦‚ç”¨ç›¸åº”çš„æ¬§æ‹‰è§’åº¦å°†æ¯ä¸ªHadamardé—¨è¡¨ç¤ºä¸ºå•ä¸ªé‡å­æ¯”ç‰¹çš„æ—‹è½¬ã€‚ç„¶è€Œï¼Œå¦‚æœå›è·¯ä¸éµå®ˆçœŸå®è®¾å¤‡çš„è¿æ¥æ€§ï¼Œåˆ™å˜åŒ–å¯èƒ½ä¼šå¾ˆå¤§ï¼Œå¦‚å›è·¯ä¸­çš„å—æ§éé—¨æ— æ³•ç”±çœŸå®è®¾å¤‡ç›´æ¥å®ç°ã€‚ç„¶åï¼Œå¿…é¡»é€šè¿‡ä¾‹å¦‚ä½¿ç”¨é¢å¤–çš„å—æ§éé—¨åœ¨å‘¨å›´ç§»åŠ¨é‡å­æ¯”ç‰¹çŠ¶æ€ç­‰æŠ€æœ¯åœ¨çœŸå®çš„è®¾å¤‡ä¸­é‡ç°å›è·¯ã€‚é™¤äº†å¼•å…¥é¢å¤–çš„å™ªå£°å¤–ï¼Œè¿˜ä¼šä½¿å·²ç»å­˜åœ¨çš„å™ªå£°æ‰©å¤§ã€‚åŸå§‹å›è·¯ä¸­å•ä¸€é‡å­æ¯”ç‰¹çš„è¯¯å·®åœ¨é™„åŠ è½¬è¯‘çš„ä½œç”¨ä¸‹ä¼šå½±å“åˆ°å¤šä¸ªé‡å­æ¯”ç‰¹ã€‚å› æ­¤åœ¨è¿è¡Œé‡å­è¯¯å·®æ ¡æ­£å›è·¯æ—¶ï¼Œå¿…é¡»é˜²æ­¢è¿™ç§éå¹³å‡¡çš„è½¬è¯‘ã€‚

æµ‹è¯•é‡å¤æ ¡éªŒè¦æ±‚é‡å­æ¯”ç‰¹æœ‰æ•ˆåœ°æ²¿ä¸€æ¡çº¿æ’åˆ—ï¼Œå…¶ä¸­å”¯ä¸€çš„å—æ§éé—¨è¦æ±‚ç›¸é‚»äºè¿™ä¸€æ¡çº¿ã€‚å› æ­¤ï¼Œé¦–è¦ä»»åŠ¡æ˜¯ç ”ç©¶çœŸå®è®¾å¤‡çš„è€¦åˆæ˜ å°„å¹¶æ‰¾å‡ºä¸€æ¡çº¿ã€‚

![Fig. 1. The coupling map of the IBM Q Melbourne
device.](pics/media/image320.png)

å¯¹äºåœ¨IBMå¢¨å°”æœ¬çš„é‡å­è®¾å¤‡ï¼Œæœ‰å¯èƒ½æ‰¾åˆ°ä¸€æ¡æ¶µç›–æ‰€æœ‰15ä¸ªé‡å­æ¯”ç‰¹çš„çº¿ã€‚åœ¨ä¸‹é¢çš„åˆ—è¡¨è¡Œä¸­è¢«è®¾è®¡ä¸ºé¿å…æœ€å®¹æ˜“å‡ºé”™å—æ§éé—¨ã€‚å¯¹äºç½—åˆ‡æ–¯ç‰¹å¤§å­¦å«æœ‰53é‡å­æ¯”ç‰¹çš„é‡å­è®¾å¤‡ï¼Œæ²¡æœ‰ä¸€æ¡çº¿èƒ½å¤Ÿè¦†ç›–å…¨éƒ¨53ä¸ªé‡å­æ¯”ç‰¹ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æ–¹æ³•æ¥è¦†ç›–å…¶ä¸­çš„43ä¸ªé‡å­æ¯”ç‰¹ã€‚

> if device_name==\'ibmq_16_melbourne\':
>
> line = \[13,14,0,1,2,12,11,3,4,10,9,5,6,8,7\]
>
> elif device_name==\'ibmq_rochester\':
>
> line =
> \[10,11,17,23,22,21,20,19,16,7,8,9,5\]\#,0,1,2,3,4,6,13,14,15,18,27,26,25,29,36,37,38,41,50,49,48,47,46,45,44,43,42,39,30,31\]

è‡³æ­¤æˆ‘ä»¬æ˜ç¡®äº†æœ‰å¤šå°‘ä¸ªé‡å­æ¯”ç‰¹å¯ç”¨äºæ„å»ºæ‰€éœ€è¿è¡Œçš„é‡å¤æ ¡éªŒç¼–ç ã€‚å¯ä»¥çœ‹å‡ºå…·æœ‰nä½é‡å¤æ ¡éªŒçš„ç¼–ç ä¼šç”¨åˆ°nä¸ªç¼–ç é‡å­æ¯”ç‰¹ä»¥åŠn-1ä¸ªé“¾æ¥é‡å­æ¯”ç‰¹ï¼Œæ•…å…¨éƒ¨éœ€è¦2n-1ä¸ªé‡å­æ¯”ç‰¹ã€‚

> n_min = 3
>
> n_max = int((len(line)+1)/2)
>
> code = {}
>
> for n in range(n_min,n_max+1):
>
> code\[n\] = RepetitionCode(n,1)

åœ¨è¿è¡Œè¿™äº›ä»£ç æ‰€æ„å»ºçš„é‡å­å›è·¯ä¹‹å‰ï¼Œéœ€è¦ç¡®è®¤è½¬è¯‘å™¨çŸ¥é“è®¾å¤‡ä¸Šå“ªäº›ç‰©ç†é‡å­æ¯”ç‰¹å°†ä¼šè¢«ä½¿ç”¨ã€‚è¿™æ„å‘³ç€ä½äºline\[0\]çš„é‡å­æ¯”ç‰¹ä¸ºç¬¬ä¸€ä¸ªç¼–ç é‡å­æ¯”ï¼Œä½äºline\[1\]çš„é‡å­æ¯”ç‰¹ä¸ºç¬¬ä¸€ä¸ªé“¾æ¥é‡å­æ¯”ç‰¹ï¼Œä¾æ­¤ç±»æ¨ã€‚è¿™ä¸€è®¾å®šé€šè¿‡ä»¥ä¸‹å‡½æ•°å®Œæˆï¼Œè¯¥å‡½æ•°æ¥æ”¶é‡å¤æ ¡éªŒå¯¹è±¡ï¼ˆcodeï¼‰å’Œlineä½œä¸ºå‚æ•°ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªPythonå­—å…¸æ¥æŒ‡å®šcodeä¸­çš„é‡å­æ¯”ç‰¹æ‰€å¯¹åº”çš„lineå…ƒç´ ã€‚

> def get_initial_layout(code,line):
>
> initial_layout = {}
>
> for j in range(n):
>
> initial_layout\[code.code_qubit\[j\]\] = line\[2\*j\]
>
> for j in range(n-1):
>
> initial_layout\[code.link_qubit\[j\]\] = line\[2\*j+1\]
>
> return initial_layout

ç°åœ¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡å¯¹è¿™äº›å›è·¯è¿›è¡Œè½¬è¯‘æ¥åˆ›å»ºåœ¨çœŸå®è®¾å¤‡ä¸Šè¿è¡Œçš„é‡å­å›è·¯ã€‚åŒæ—¶é€šè¿‡æ£€æŸ¥ç¡®ä¿è½¬è¯‘è¿‡ç¨‹ç¡®å®æ²¡æœ‰å¼•å…¥éå¹³å‡¡æ•ˆåº”è€Œå¢åŠ é‡å­æ¯”ç‰¹çš„æ•°é‡ã€‚æ­¤å¤–ï¼Œå·²ç¼–è¯‘å›è·¯è¢«æ”¶é›†è‡³å•ä¸ªåˆ—è¡¨ä¸­ï¼Œä»¥ä¾¿å…è®¸å…¶åœ¨åŒæ‰¹ä½œä¸šä¸­è¢«åŒæ—¶æäº¤ã€‚

> if step_2:
>
> circuits = \[\]
>
> for n in range(n_min,n_max+1):
>
> initial_layout = get_initial_layout(code\[n\],line)
>
> for log in \[\'0\',\'1\'\]:
>
> circuits.append( transpile(code\[n\].circuit\[log\], backend=backend,
> initial_layout=initial_layout) )
>
> num_cx = dict(circuits\[-1\].count_ops())\[\'cx\'\]
>
> assert num_cx==2\*(n-1), str(num_cx) + \' instead of \' +
> str(2\*(n-1)) + \' cx gates for n = \' + str(n)

è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»ä¸ºåœ¨çœŸå®è®¾å¤‡ä¸Šè¿è¡Œé‡å¤æ ¡éªŒæœ€å¥½äº†å‡†å¤‡å·¥ä½œã€‚ä¸å‰æ–‡ä¸­æ‰€è®¨è®ºåœ¨æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡Œæ—¶ä¸€æ ·ï¼Œè¿è¡Œç»“æœå°†ä¼šè¢«æå–è‡³åä¸ºaw_resultsçš„å­—å…¸ä¸­ã€‚ç„¶è€Œåœ¨çœŸå®è®¾å¤‡ä¸Šè¿è¡Œæ—¶ï¼Œè¿™ä¸€å­—å…¸è¢«æ‰©å±•ä¸ºå¯ä¿å­˜ä¸åŒç¼–ç å¤§å°çš„ç»“æœï¼Œæ„ä¸ºå¯¹äºç»™å®šnï¼Œraw_results\[n\]ç­‰ä»·äºå‰æ–‡ä¸­çš„ä¸€ä¸ªraw_resultså­—å…¸ã€‚

> if step_2:
>
> job = execute(circuits,backend,shots=8192)
>
> raw_results = {}
>
> j = 0
>
> for d in range(n_min,n_max+1):
>
> raw_results\[d\] = {}
>
> for log in \[\'0\',\'1\'\]:
>
> raw_results\[d\]\[log\] = job.result().get_counts(j)

j += 1

æ­£å¦‚ä¸å…ˆå‰æ‰€è§ç›¸åŒï¼Œè§£ç è¿‡ç¨‹çš„ç¬¬ä¸€æ­¥éœ€è¦å°†ç»“æœæ”¹å†™ä¸ºèƒ½å¤Ÿè¡¨è¾¾æ ¡éªŒï¼ˆsyndromeï¼‰çš„æ­£ç¡®å½¢å¼ã€‚å› æ­¤ï¼Œä½¿ç”¨æ¯ä¸ªé‡å¤ç¼–ç å¯¹è±¡code\[n\]çš„process_resultsæ–¹æ³•ä»æ¯ä¸ªraw_results\[n\]åˆ›å»ºä¸€ä¸ªç»“æœå­—å…¸results\[n\]ã€‚

> if step_3:
>
> results = {}
>
> for n in range(n_min,n_max+1):
>
> results\[n\] = code\[n\].process_results( raw_results\[n\] )

è§£ç è¿‡ç¨‹è¿˜éœ€è¦æˆ‘ä»¬ä¸ºæ¯ä¸ªç¼–ç è®¾ç½®GraphDecoderå¯¹è±¡ã€‚å¦‚ä¸Šä¸€èŠ‚æ‰€è¿°ï¼Œè¿™äº›åˆå§‹åŒ–åŒ…æ‹¬æ„é€ å¯¹åº”äºä¼´éšå­çš„å›¾å½¢ã€‚

> if step_3:
>
> dec = {}
>
> for n in range(n_min,n_max+1):
>
> dec\[n\] = GraphDecoder(code\[n\])

æœ€åï¼Œè§£ç å™¨å¯¹è±¡å°±èƒ½å¤„ç†è¿™äº›ç»“æœã€‚æ­¤å¤„é»˜è®¤ä½¿ç”¨äº†æœ€å°æƒå€¼å®Œç¾åŒ¹é…ç®—æ³•ã€‚æœ€åçš„è¾“å‡ºæ˜¯é€»è¾‘è¯¯å·®æ¦‚ç‡è®¡ç®—çš„ç»“æœã€‚åœ¨è¿è¡Œæ­¥éª¤3æ—¶ï¼Œä¸‹é¢çš„ä»£ç ç‰‡æ®µè¿˜è¿˜å¯¹é€»è¾‘è¯¯å·®æ¦‚ç‡è¿›è¡Œäº†ä¿å­˜ï¼Œå¦åˆ™å°±ä¼šè¯»å–å…ˆå‰ä¿å­˜çš„æ¦‚ç‡å€¼ã€‚

> if step_3:
>
> logical_prob_match = {}
>
> for n in range(n_min,n_max+1):
>
> logical_prob_match\[n\] = dec\[n\].get_logical_prob(results\[n\])
>
> with open(\'results/logical_prob_match\_\'+device_name+\'.txt\',
> \'w\') as file:
>
> file.write(str(logical_prob_match))
>
> else:
>
> with open(\'results/logical_prob_match\_\'+device_name+\'.txt\',
> \'r\') as file:
>
> logical_prob_match = eval(file.read())

æ‰€äº§ç”Ÿçš„é€»è¾‘è¯¯å·®æ¦‚ç‡å±•ç¤ºåœ¨ä¸‹é¢çš„å›¾ä¸­ï¼Œè¯¥å›¾åœ¨yè½´ä¸Šä½¿ç”¨äº†å¯¹æ•°æ ‡å°ºã€‚æˆ‘ä»¬æœŸæœ›é€»è¾‘è¯¯å·®æ¦‚ç‡éš$n$çš„å¢åŠ å‘ˆç°æŒ‡æ•°è¡°å‡ã€‚å¦‚è‹¥ç¬¦åˆæœŸæœ›ï¼Œå°±è¯å®äº†è¯¥çœŸå®é‡å­è®¾å¤‡ä¸é‡å­è¯¯å·®æ ¡æ­£çš„åŸºå‡†æµ‹è¯•ç›¸å®¹ã€‚å¦åˆ™å°±è¡¨æ˜çœŸå®è®¾å¤‡ä¸­çš„é‡å­æ¯”ç‰¹å’Œé‡å­é—¨ä¸å¤Ÿå¯é ã€‚

å¹¸è¿çš„æ˜¯ï¼ŒIBM
QåŸå‹è®¾å¤‡çš„è¾“å‡ºç»“æœé€šå¸¸æ˜¾ç¤ºäº†æ‰€é¢„æœŸçš„æŒ‡æ•°è¡°å‡ã€‚åœ¨ä¸‹é¢æ‰€ç¤ºçš„ç»“æœä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºè¾ƒå°çš„ç¼–ç ç»™å‡ºäº†è¿™ä¸€è§„åˆ™çš„ä¸€ä¸ªä¾‹å¤–ã€‚å…¶ä»–åå·®ä¹Ÿæ˜¯èƒ½å¤Ÿé¢„è®¡çš„ï¼Œä¾‹å¦‚å½“åŒ…å«ä¸€ç»„å…·æœ‰æä½æˆ–æé«˜å™ªå£°é‡å­æ¯”ç‰¹çš„ç¼–ç å¤§å°å¢åŠ æ—¶ã€‚

> import matplotlib.pyplot as plt
>
> import numpy as np
>
> x_axis = range(n_min,n_max+1)
>
> P = { log: \[logical_prob_match\[n\]\[log\] for n in x_axis\] for log
> in \[\'0\', \'1\'\] }
>
> ax = plt.gca()
>
> plt.xlabel(\'Code distance, n\')
>
> plt.ylabel(\'ln(Logical error probability)\')
>
> ax.scatter( x_axis, P\[\'0\'\], label=\"logical 0\")
>
> ax.scatter( x_axis, P\[\'1\'\], label=\"logical 1\")
>
> ax.set_yscale(\'log\')
>
> ax.set_ylim(ymax=1.5\*max(P\[\'0\'\]+P\[\'1\'\]),ymin=0.75\*min(P\[\'0\'\]+P\[\'1\'\]))
>
> plt.legend()
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image321.png)

åœ¨å…¶ä¸­æˆ‘ä»¬å¯ä»¥è·å¾—çš„å¦ä¸€ä¸ªè§è§£æ˜¯åˆ©ç”¨è¿™äº›ç»“æœæ¥ç¡®å®šæŸäº›è¯¯å·®è¿‡ç¨‹å‘ç”Ÿçš„å¯èƒ½æ€§æœ‰å¤šå¤§ã€‚

ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ ¡éªŒå›¾ä¸­çš„æ¯æ¡è¾¹ä»£è¡¨ä¸€ç§ç‰¹æ®Šå½¢å¼çš„è¯¯å·®ï¼Œè¿™ç§è¯¯å·®å‘ç”Ÿåœ¨å›è·¯ä¸­ç‰¹å®šç‚¹çš„ç‰¹å®šé‡å­æ¯”ç‰¹ä¸Šã€‚è¿™å°±æ˜¯å¯¼è‡´ç›¸é‚»ä¸¤ä¸ªèŠ‚ç‚¹æ‰€å¯¹åº”æ ¡éªŒå­çš„å€¼å‘ç”Ÿå˜åŒ–çš„å”¯ä¸€å•ä¸ªè¯¯å·®ã€‚å› æ­¤åˆ©ç”¨è¿™äº›ç»“æœæ¥ä¼°è®¡å‡ºç°è¿™ç§æ ¡éªŒçš„æ¦‚ç‡ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¼°è®¡å‡ºç°è¿™ç§è¯¯å·®äº‹ä»¶çš„æ¦‚ç‡ã€‚å…·ä½“æ¥è¯´ï¼Œç¬¬ä¸€çº§æ˜¯å¾ˆæ˜æ˜¾ï¼š

$$\frac{p}{1 - p} \approx \frac{C_{11}}{C_{00}}$$

å…¶ä¸­$p$è¯¯å·®æ¦‚ç‡æ‰€å¯¹åº”çš„ç‰¹æ®Šè¾¹ã€‚$C_{11}$æ˜¯results\[n\]\[\'0\'\]ä¸­å¯¹åº”ä¸¤ä¸ªç›¸é‚»èŠ‚ç‚¹çš„æ ¡éªŒå­å€¼éƒ½ä¸º1çš„æ•°é‡ï¼Œ$C_{00}$æ˜¯éƒ½ä¸º0çš„æ•°é‡ã€‚

è§£ç å™¨å¯¹è±¡å…·æœ‰æ–¹æ³•weight_syndrome_graphï¼Œè¯¥æ–¹æ³•å¯ç”¨äºç¡®å®šè¿™äº›æ¯”ç‡ï¼Œå¹¶ä¸ºæ¯ä¸ªè¾¹åˆ†é…æƒé‡$- ln(p/(1 - p))$ã€‚é€šè¿‡ä½¿ç”¨è¿™ä¸€æ–¹æ³•å¹¶æ£€éªŒæƒé‡ï¼Œå°±å¯ä»¥è½»æ˜“åœ°æ£€ç´¢å‡ºè¿™äº›æ¦‚ç‡ã€‚

> if step_3:
>
> dec\[n_max\].weight_syndrome_graph(results=results\[n_max\])
>
> probs = \[\]
>
> for edge in dec\[n_max\].S.edges:
>
> ratio =
> np.exp(-dec\[n_max\].S.get_edge_data(edge\[0\],edge\[1\])\[\'distance\'\])
>
> probs.append( ratio/(1+ratio) )
>
> with open(\'results/probs\_\'+device_name+\'.txt\', \'w\') as file:
>
> file.write(str(probs))
>
> else:
>
> with open(\'results/probs\_\'+device_name+\'.txt\', \'r\') as file:
>
> probs = eval(file.read())

ä¸å…¶æ˜¾ç¤ºæ•´ä¸ªçš„åˆ—è¡¨ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å‡å€¼ã€æ ‡å‡†å·®ã€æœ€å¤§/æœ€å°å€¼å’Œå››åˆ†ä½æ•°æ¥è·å–è¯¥åˆ—è¡¨çš„æ‘˜è¦ã€‚

> import pandas as pd
>
> pd.Series(probs).describe().to_dict()
>
> è¾“å‡ºï¼š
>
> {\'count\': 29.0,
>
> \'mean\': 0.18570187935383514,
>
> \'std\': 0.12966061187100625,
>
> \'min\': 0.014967523298503253,
>
> \'25%\': 0.05383187483426147,
>
> \'50%\': 0.1799797775530839,
>
> \'75%\': 0.2753350576063955,
>
> \'max\': 0.4345054945054945}

å¯¹çœŸå®é‡å­è®¾å¤‡è¿›è¡ŒåŸºå‡†æµ‹è¯•ä¸ä¼šäº§ç”Ÿå®Œå…¨ç›¸åŒçš„è¯¯å·®æ¦‚ç‡é›†ã€‚ç„¶è€Œï¼Œè¯»å‡ºé”™è¯¯å’Œå—æ§éé—¨é”™è¯¯çš„æ¦‚ç‡å¯ç”¨ä½œè¾ƒå¥½çš„æ¯”è¾ƒã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨åç«¯å¯¹è±¡ä»åŸºå‡†æµ‹è¯•ä¸­è·å–è¿™äº›å€¼ã€‚

> if step_3:
>
> gate_probs = \[\]
>
> for j,qubit in enumerate(line):
>
> gate_probs.append( backend.properties().readout_error(qubit) )
>
> cx1,cx2 = 0,0
>
> if j\>0:
>
> gate_probs(
> backend.properties().gate_error(\'cx\',\[qubit,line\[j-1\]\]) )
>
> if j\<len(line)-1:
>
> gate_probs(
> backend.properties().gate_error(\'cx\',\[qubit,line\[j+1\]\]) )
>
> with open(\'results/gate_probs\_\'+device_name+\'.txt\', \'w\') as
> file:
>
> file.write(str(gate_probs))
>
> else:
>
> with open(\'results/gate_probs\_\'+device_name+\'.txt\', \'r\') as
> file:
>
> gate_probs = eval(file.read())
>
> pd.Series(gate_probs).describe().to_dict()
>
> è¾“å‡ºï¼š
>
> {\'count\': 15.0,
>
> \'mean\': 0.08386929848831581,
>
> \'std\': 0.06860851140104485,
>
> \'min\': 0.02134613228239715,
>
> \'25%\': 0.050219500857068944,
>
> \'50%\': 0.05460651866864599,
>
> \'75%\': 0.09450000000000003,
>
> \'max\': 0.28}

5.2 æµ‹é‡è¯¯å·®ç¼“è§£
----------------

> \#from qiskit import \*
>
> from qiskit import QuantumCircuit, QuantumRegister, Aer, execute

### ç®€ä»‹

å™ªå£°çš„å½±å“æ˜¯å¯¼è‡´ä¸å¤ªæ­£ç¡®çš„è¾“å‡ºã€‚é€šå¸¸æ¥è¯´ï¼Œåœ¨æ•´ä¸ªè®¡ç®—çš„è¿‡ç¨‹ä¸­å‡ºç°çš„å™ªå£°æ‰€äº§ç”Ÿçš„å½±å“ç›¸å½“å¤æ‚ï¼Œå› ä¸ºå¿…é¡»è€ƒè™‘æ¯ä¸€ä¸ªé‡å­é—¨å¯¹æ¯ä¸ªè¯¯å·®çš„å½±å“ã€‚

å…¶ä¸­ä¸€ç§ç®€å•çš„å™ªå£°å½¢å¼å‡ºç°åœ¨æœ€ç»ˆçš„æµ‹é‡ä¸­ï¼Œæ­¤æ—¶å›è·¯æ‰€éœ€è¿›è¡Œçš„å”¯ä¸€å·¥ä½œå°±æ˜¯æå–ä¸€ä½å­—ä¸²ä½œä¸ºè¾“å‡ºã€‚å¯¹äºå…·æœ‰$n$é‡å­æ¯”ç‰¹çš„æœ€ç»ˆæµ‹é‡ï¼Œåˆ™å°±éœ€è¦æå–$2^{n}$ä¸ªå¯èƒ½çš„$n$ä½å­—ä¸²ã€‚å°†å…¶æƒ³è±¡æˆä¸ºè¿™ä¸€è¿‡ç¨‹ä¸­å™ªå£°çš„ç®€å•æ¨¡å‹ï¼Œæµ‹é‡é¦–å…ˆä¼šç»™è¾“å‡ºä¸­å®Œç¾/æ— å™ªå£°çš„ä¸€ç±»ï¼Œç„¶åå™ªå£°ä¼šå¯¼è‡´è¿™ç±»å®Œç¾çš„è¾“å‡ºåœ¨è¿”å›ç»™ç”¨æˆ·ä¹‹å‰è¢«éšæœºå¹²æ‰°ã€‚

æœ‰äº†è¿™æ ·ä¸€ä¸ªæ¨¡å‹ï¼Œå°±å¾ˆå®¹æ˜“å‡†ç¡®åœ°ç¡®å®šæµ‹é‡è¯¯å·®çš„å½±å“æ˜¯ä»€ä¹ˆã€‚æˆ‘ä»¬å¯ä»¥ç®€å•åœ°å‡†å¤‡$2^{n}$ç§å¯èƒ½çš„åŸºæ€å¹¶ç«‹å³å¯¹å…¶æµ‹é‡ï¼Œçœ‹ä¸€çœ‹æ¯ç§è¾“å‡ºå‘ç”Ÿçš„æ¦‚ç‡ã€‚

ä¾‹å¦‚ï¼Œåˆ›å»ºä¸€ä¸ªç®€å•çš„å™ªå£°æ¨¡å‹ï¼Œè¯¥æ¨¡å‹ä»¥æ¦‚ç‡$p$éšæœºç¿»è½¬è¾“å‡ºä¸­çš„æ¯ä¸€æ¯”ç‰¹ã€‚

> from qiskit.providers.aer.noise import NoiseModel
>
> from qiskit.providers.aer.noise.errors import pauli_error,
> depolarizing_error
>
> def get_noise(p):
>
> error_meas = pauli_error(\[(\'X\',p), (\'I\', 1 - p)\])
>
> noise_model = NoiseModel()
>
> noise_model.add_all_qubit_quantum_error(error_meas, \"measure\") \#
> measurement error is applied to measurements
>
> return noise_model

æˆ‘ä»¬ä»æ¯ä¸€ä¸ªæ¯”ç‰¹ä»¥1%çš„æœºç‡è¢«ç¿»è½¬çš„å®åˆ—å¼€å§‹ã€‚

noise_model = get_noise(0.01)

ç°åœ¨å¯¹å…¶æ•ˆæœè¿›è¡Œæµ‹è¯•ã€‚å…·ä½“è¿‡ç¨‹ä¸ºï¼šå®šä¹‰ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„å›è·¯å¹¶è®¾ç½®å…¶çŠ¶æ€åˆ†åˆ«ä¸º$|00\rangle$ã€$|01\rangle$ã€$|10\rangle$å’Œ$|11\rangle$ã€‚åœ¨æ²¡æœ‰å™ªå£°çš„æƒ…å†µä¸‹å°†åˆ†åˆ«äº§ç”Ÿç¡®å®šçš„è¾“å‡º"00"ã€"01"ã€"10"å’Œ"11"ã€‚ç°åœ¨çœ‹çœ‹æœ‰å™ªå£°æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚åœ¨è¿™é‡Œä»¥åŠæœ¬èŠ‚çš„å…¶ä½™éƒ¨åˆ†ä¸­ï¼Œä¸ºæ¯ä¸ªå›è·¯é‡‡é›†çš„æ ·æœ¬æ¬¡æ•°ä¸ºshots=10000ã€‚

> for state in \[\'00\',\'01\',\'10\',\'11\'\]:
>
> qc = QuantumCircuit(2,2)
>
> if state\[0\]==\'1\':
>
> qc.x(1)
>
> if state\[1\]==\'1\':
>
> qc.x(0)
>
> qc.measure(qc.qregs\[0\],qc.cregs\[0\])
>
> print(state+\' becomes\',
>
> execute(qc,Aer.get_backend(\'qasm_simulator\'),noise_model=noise_model,shots=10000).result().get_counts())
>
> è¾“å‡ºï¼š
>
> 00 becomes {\'10\': 109, \'01\': 100, \'00\': 9791}
>
> 01 becomes {\'10\': 2, \'01\': 9798, \'11\': 93, \'00\': 107}
>
> 10 becomes {\'10\': 9796, \'01\': 1, \'11\': 98, \'00\': 105}
>
> 11 becomes {\'10\': 82, \'01\': 96, \'11\': 9820, \'00\': 2}

ä»è¾“å‡ºä¸­å¯ä»¥çœ‹å‡ºæ­£ç¡®çš„ç»“æœå ç»å¤§å¤šæ•°ã€‚åªæœ‰ä¸€ä¸ªé‡å­æ¯”ç‰¹æœ‰å¤§çº¦1%çš„å‡ ç‡å‘ç”Ÿç¿»è½¬ï¼Œä¾‹å¦‚åœ¨æ­£ç¡®çš„è¾“å‡ºæ˜¯00æˆ–11çš„æƒ…å†µä¸‹æ˜¯æœ‰å¤§çº¦1%çš„å‡ ç‡ç»“æœ01ã€10ã€‚åœ¨10000ä¸ªæ ·æœ¬ä¸­ï¼Œåœ¨ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¸ŠåŒæ—¶å‘ç”Ÿç¿»è½¬åªå‡ºç°äº†å¾ˆå°‘çš„å‡ æ¬¡ã€‚

é‚£ä¹ˆå¦‚æœæˆ‘ä»¬è¿è¡Œå…·æœ‰ç›¸åŒå™ªå£°å¾·æ¨¡å‹ä¼šå‘ç”Ÿä»€ä¹ˆæ ·çš„ç»“æœå‘¢ï¼Ÿ

{\'10\': 98, \'11\': 4884, \'01\': 111, \'00\': 4907}

ä¸Šé¢çš„"01"å’Œ"10"å æ‰€æœ‰æ ·æœ¬çš„1%å·¦å³ã€‚ä»å¯¹åŸºæ€çš„åˆ†æä¸­æˆ‘ä»¬çŸ¥é“ï¼Œå½“è¿™äº›ç»“æœå®é™…ä¸Šæ°¸è¿œä¸ä¼šå‘ç”Ÿæ—¶ï¼Œè¿™æ ·çš„ç»“æœæ˜¯å¯é¢„è®¡çš„ï¼Œä½†å½“åº”ä¸åªæœ‰ä¸€ä¸ªæ¯”ç‰¹çš„ä¸åŒç»“æœç›¸åæ—¶å°±ä¼šå‘ç”Ÿ00æˆ–11ã€‚å½“æˆ‘ä»¬çœ‹è¿™ä¸¤ä¸ªç»“æœçš„ç»“æœæ—¶ï¼Œå¯ä»¥çœ‹å‡ºå‘ç”Ÿçš„æ¦‚ç‡å¤§è‡´ç›¸åŒã€‚å› æ­¤å¾—å‡ºè¿™æ ·çš„ç»“è®ºï¼šåˆå§‹çŠ¶æ€ä¸ä»…ä»…æ˜¯$|00\rangle$æˆ–$|11\rangle$ï¼ŒäºŒåä¸¤è€…çš„å‡ç­‰å åŠ ã€‚å¦‚æœæ˜¯æƒ…å†µå±å®ï¼Œè¡¨æ˜ç»“æœåº”ä¸ºï¼š

{\'11\': 4977, \'00\': 5023}

ä»¥ä¸‹æ˜¯äº§ç”Ÿç±»ä¼¼ç»“æœçš„é‡å­å›è·¯ï¼ˆç›´è‡³å‘ç”Ÿç»Ÿè®¡è„‰åŠ¨ï¼‰ã€‚

> qc = QuantumCircuit(2,2)
>
> qc.h(0)
>
> qc.cx(0,1)
>
> qc.measure(qc.qregs\[0\],qc.cregs\[0\])
>
> print(execute(qc,Aer.get_backend(\'qasm_simulator\'),noise_model=noise_model,shots=10000).result().get_counts())
>
> è¾“å‡ºï¼š
>
> {\'10\': 82, \'01\': 98, \'11\': 4925, \'00\': 4895}

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆæŸ¥çœ‹äº†æ¯ä¸ªç¡®å®šåŸºæ€çš„ç»“æœï¼Œå¹¶ä½¿ç”¨è¿™äº›ç»“æœæ¥å‡è½»è¯¯å·®å¯¹æ›´ä¸€èˆ¬çŠ¶æ€å½¢å¼çš„å½±å“ã€‚è¿™å°±æ˜¯ç¼“è§£æµ‹é‡è¯¯å·®çš„åŸºæœ¬åŸåˆ™ã€‚

### çº¿æ€§ä»£æ•°ä¸è¯¯å·®ç¼“è§£

ç°åœ¨æˆ‘ä»¬åªéœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹æ³•æ¥æ‰§è¡Œç¼“è§£ç®—æ³•æ¥ä»£æ›¿æ‰‹åŠ¨è¿ç®—ã€‚æˆ‘ä»¬å°†ä¼šä½¿ç”¨çŸ©é˜µæ¥æè¿°éšæœºè¿‡ç¨‹ï¼Œä¸ºæ­¤éœ€è¦æ”¹å†™è®¡æ•°å­—å…¸ä¸ºåˆ—å‘é‡ã€‚æ¯”å¦‚ï¼Œå°†å­—å…¸{\'10\':
96, \'11\': 1, \'01\': 95, \'00\': 9808}æ”¹å†™ä¸ºï¼š

$$C = \begin{pmatrix}
9808 \\
95 \\
96 \\
1 \\
\end{pmatrix}$$

å…¶ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä»£è¡¨"00"çš„æ•°é‡ï¼Œä¸‹é¢çš„ä»£è¡¨"01"çš„æ•°é‡ï¼Œä»¥æ­¤ç±»æ¨ã€‚

ä»åŸºæ€$|00\rangle$ï¼Œ$|01\rangle$ï¼Œ$|10\rangle$å’Œ$|11\rangle$è·å¾—ä¿¡æ¯è¢«ç”¨äºå®šä¹‰ä¸€ä¸ªçŸ©é˜µï¼Œè¯¥çŸ©é˜µè¡¨ç¤ºä»ä¸€ç»„ç†æƒ³çš„è®¡æ•°æ—‹è½¬ä¸ºä¸€ç»„å—åˆ°å™ªå£°å½±å“çš„è®¡æ•°ã€‚è¿™ä¸€è¿‡ç¨‹ä»…æ˜¯ç®€å•çš„ä½¿ç”¨å­—å…¸ä¸­$|00\rangle$æ‰€å¯¹åº”çš„è®¡æ•°æ¥å®Œæˆï¼Œå¯¹å…¶è¿›è¡Œå½’ä¸€åŒ–ï¼ˆæ‰€æœ‰å…ƒç´ æ±‚å’Œä¸º1ï¼‰ï¼Œç„¶åå°†å…¶ç”¨ä½œçŸ©é˜µçš„ç¬¬ä¸€åˆ—ã€‚æ¥ä¸‹æ¥ä¸€åˆ—çš„å®šä¹‰ä¸å€¼ç›¸åŒï¼Œç”±$|00\rangle$æ‰€å¯¹åº”çš„è®¡æ•°å½’ä¸€åŒ–åç”Ÿæˆï¼Œä»¥æ­¤ç±»æ¨ã€‚

**00** {\'10\': 96, \'11\': 1, \'01\': 95, \'00\': 9808}

**01** {\'10\': 2, \'11\': 103, \'01\': 9788, \'00\': 107 }

**10** {\'10\': 9814, \'11\': 90, \'01\': 1, \'00\': 95 }

**11** {\'10\': 87, \'11\': 9805, \'01\': 107, \'00\': 1 }

è¿™å°±ç»™å‡ºäº†ä¸€ä¸‹çŸ©é˜µã€‚

$$M = \begin{pmatrix}
0.9808 & 0.0107 & 0.0095 & 0.0001 \\
0.0095 & 0.9788 & 0.0001 & 0.0107 \\
0.0096 & 0.0002 & 0.9814 & 0.0087 \\
0.0001 & 0.0103 & 0.0090 & 0.9805 \\
\end{pmatrix}$$

å¦‚æœæˆ‘ä»¬ç°åœ¨é‡‡ç”¨å‘é‡æ¥æè¿°ä¸€ä¸ªç»™å®šçŠ¶æ€çš„ç†æƒ³ç»“æœï¼Œé‚£ä¹ˆå½“æµ‹é‡å™ªå£°å­˜åœ¨æ—¶åº”ç”¨è¿™ä¸€çŸ©é˜µèƒ½å¤Ÿç»™å‡ºä¸€ä¸ªå¾ˆå¥½çš„è¿‘ä¼¼ç»“æœã€‚

$$C_{\text{noisy}} = MC_{\text{ideal}}$$

æ¯”å¦‚ï¼Œå°†è¿™ä¸€è¿‡ç¨‹åº”ç”¨äºæ€$(|00\rangle + |11\rangle)/\sqrt{2}$ï¼Œ

$$\begin{pmatrix}
0.9808 & 0.0107 & 0.0095 & 0.0001 \\
0.0095 & 0.9788 & 0.0001 & 0.0107 \\
0.0096 & 0.0002 & 0.9814 & 0.0087 \\
0.0001 & 0.0103 & 0.0090 & 0.9805 \\
\end{pmatrix}\begin{pmatrix}
0 \\
5000 \\
5000 \\
0 \\
\end{pmatrix} = \begin{pmatrix}
101 \\
4895.5 \\
4908 \\
96.5 \\
\end{pmatrix}$$

æˆ‘ä»¬å¯ä»¥ç”¨ä»¥ä¸‹ä»£ç è¡¨ç¤ºè¿™ä¸ªè¿‡ç¨‹ã€‚

> import numpy as np
>
> M = \[\[0.9808,0.0107,0.0095,0.0001\],
>
> \[0.0095,0.9788,0.0001,0.0107\],
>
> \[0.0096,0.0002,0.9814,0.0087\],
>
> \[0.0001,0.0103,0.0090,0.9805\]\]
>
> Cideal = \[\[0\],
>
> \[5000\],
>
> \[5000\],
>
> \[0\]\]
>
> Cnoisy = np.dot( M, Cideal)
>
> print(\'C_noisy =\\n\',Cnoisy)
>
> è¾“å‡ºï¼š
>
> C_noisy =
>
> \[\[ 101. \]
>
> \[4894.5\]
>
> \[4908. \]
>
> \[ 96.5\]\]

æ— è®ºä»¥å“ªç§æ–¹å¼æµ‹é‡ï¼Œå¯¹$C_{\text{noisy}}$ç»“æœçš„è®¡æ•°å‘ç°ï¼Œå¯¹æ€$(|00\rangle + |11\rangle)/\sqrt{2}$è¿›è¡ŒåŒ…å«å™ªå£°çš„æµ‹é‡ç»“æœè®¡æ•°éƒ½éå¸¸æ¥è¿‘äºæˆ‘ä»¬å…ˆå‰å‘ç°çš„å®é™…æ•°æ®ã€‚å› æ­¤å¦‚æœçŸ¥é“ç»“æœï¼Œé‚£ä¹ˆè¿™ç§çŸ©é˜µæ–¹æ³•ç¡®å®æ˜¯é¢„æµ‹å«æœ‰å™ªå£°ç»“æœçš„å¥½æ–¹æ³•ã€‚

ä½†ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸æˆ‘ä»¬æ‰€éœ€çš„å®Œå…¨ç›¸åã€‚æˆ‘ä»¬éœ€è¦çš„ä¸æ˜¯å°†ç†æƒ³è®¡æ•°æ•°æ®è½¬æ¢ä¸ºå™ªå£°æ•°æ®çš„æ–¹æ³•ï¼Œè€Œæ˜¯å°†å™ªå£°æ•°æ®è½¬æ¢ä¸ºç†æƒ³æ•°æ®çš„æ–¹æ³•ã€‚åœ¨çº¿æ€§ä»£æ•°ä¸­ï¼Œæˆ‘ä¹ˆå¯ä»¥é€šè¿‡æ‰¾å‡ºçŸ©é˜µ$M$çš„é€†çŸ©é˜µ$M^{- 1}$æ¥å®ç°ã€‚

$$C_{\text{ideal}} = M^{- 1}C_{\text{noisy}}$$

> import scipy.linalg as la
>
> M = \[\[0.9808,0.0107,0.0095,0.0001\],
>
> \[0.0095,0.9788,0.0001,0.0107\],
>
> \[0.0096,0.0002,0.9814,0.0087\],
>
> \[0.0001,0.0103,0.0090,0.9805\]\]
>
> Minv = la.inv(M)
>
> print(Minv)
>
> è¾“å‡ºï¼š
>
> \[\[ 1.01978044e+00 -1.11470783e-02 -9.87135367e-03 1.05228426e-04\]
>
> \[-9.89772783e-03 1.02188470e+00 9.39504466e-05 -1.11514471e-02\]
>
> \[-9.97422955e-03 -4.05845410e-06 1.01913199e+00 -9.04172099e-03\]
>
> \[ 9.15212840e-05 -1.07335657e-02 -9.35458279e-03 1.02008794e+00\]\]

å°†è¿™ä¸ªé€†çŸ©é˜µåº”ç”¨äº$C_{\text{noisy}}$å°±èƒ½è·å¾—çœŸå®è®¡æ•°çš„è®¡æ•°ã€‚

> Cmitigated = np.dot( Minv, Cnoisy)
>
> print(\'C_mitigated =\\n\',Cmitigated)
>
> è¾“å‡ºï¼š
>
> C_mitigated =
>
> \[\[-2.69429661e-15\]
>
> \[ 5.00000000e+03\]
>
> \[ 5.00000000e+03\]
>
> \[-1.44328993e-15\]\]

è®¡æ•°å½“ç„¶åº”è¯¥æ˜¯æ•´æ•°ï¼Œæ‰€ä»¥C_mitigatedä¸­çš„å€¼éƒ½éœ€å–æ•´ï¼Œè¿™å°±ç»™å‡ºéå¸¸å¥½çš„ç»“æœã€‚

$$C_{\text{mitigated}} = \begin{pmatrix}
0 \\
5000 \\
5000 \\
0 \\
\end{pmatrix}$$

è¿™æ­£æ˜¯æ‰€æœŸæœ›çš„ç»“æœï¼Œç¼“è§£çš„æ•ˆæœéå¸¸å¥½!

### åœ¨Qiskitä¸­è¿›è¡Œè¯¯å·®ç¼“è§£

> from qiskit.ignis.mitigation.measurement import
> (complete_meas_cal,CompleteMeasFitter)

è¿™ä¸€æµ‹é‡è¯¯å·®ç¼“è§£çš„è¿‡ç¨‹ä¹Ÿå¯ä»¥ä½¿ç”¨Qiskitä¸­çš„å·¥å…·æ¥å®Œæˆã€‚è¿™ä¸€å·¥å…·å¯ä»¥å¤„ç†åŸºæ€çš„æ•°æ®æ”¶é›†ï¼ŒçŸ©é˜µçš„æ„é€ å’Œé€†çš„è®¡ç®—ã€‚å¦‚ä¸Šæ‰€è¿°ï¼Œå¯ä»¥ä½¿ç”¨ä¼ªé€†æ¥å®Œæˆåè€…ã€‚ä½†æ˜¯ï¼Œé»˜è®¤è®¾ç½®æ˜¯ä½¿ç”¨æœ€å°äºŒä¹˜æ‹Ÿåˆè¿™ä¸€æ›´ä¸ºç²¾å·§çš„æ–¹æ³•ã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¸ºä¸€å¯¹é‡å­æ¯”ç‰¹åšè¯¯å·®ç¼“è§£ã€‚ä¸ºæ­¤æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªåŒé‡å­æ¯”ç‰¹é‡å­å¯„å­˜å™¨ï¼Œå¹¶å°†å…¶å¯¼å…¥å‡½æ•°complete_meas_calä¸­ã€‚

> qr = qiskit.QuantumRegister(2)
>
> meas_calibs, state_labels = complete_meas_cal(qr=qr,
> circlabel=\'mcal\')

è¿™ä¸€æ­¥éª¤ç”Ÿæˆäº†ç”¨äºæµ‹é‡æ­¤å¯¹é‡å­æ¯”ç‰¹å››ä¸ªåŸºæ€ï¼ˆ$|00\rangle$ï¼Œ$|01\rangle$ï¼Œ$|10\rangle$å’Œ$|11\rangle$ï¼‰çš„é‡å­å›è·¯ã€‚

> for circuit in meas_calibs:
>
> print(\'Circuit\',circuit.name)
>
> print(circuit)
>
> print()
>
> è¾“å‡ºï¼š

![](pics/media/image322.png)

![](pics/media/image323.png)

ç»­ï¼š

![](pics/media/image324.png)

![](pics/media/image325.png)

æˆ‘ä»¬ç°åœ¨ä»¥æ— å™ªå£°çš„æƒ…å†µè¿è¡Œè¿™äº›å›è·¯ã€‚

> \# Execute the calibration circuits without noise
>
> backend = qiskit.Aer.get_backend(\'qasm_simulator\')
>
> job = qiskit.execute(meas_calibs, backend=backend, shots=1000)
>
> cal_results = job.result()

é€šè¿‡è¿™äº›ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ å‡ºæ ‡å®šçŸ©é˜µ$M$ï¼ˆcalibration matrixï¼‰ã€‚

> meas_fitter = CompleteMeasFitter(cal_results, state_labels,
> circlabel=\'mcal\')
>
> print(meas_fitter.cal_matrix)
>
> è¾“å‡ºï¼š
>
> \[\[1. 0. 0. 0.\]
>
> \[0. 1. 0. 0.\]
>
> \[0. 0. 1. 0.\]
>
> \[0. 0. 0. 1.\]\]

å¯ä»¥çœ‹åˆ°åœ¨æ²¡æœ‰å™ªå£°çš„æƒ…å†µä¸‹ï¼Œè¯¥æ ‡å®šçŸ©é˜µ$M$å³ä¸ºå•ä½çŸ©é˜µï¼ˆidentity matrixï¼‰

ç°åœ¨æ¥åˆ›å»ºä¸€ä¸ªåŒ…å«å™ªå£°çš„æ¨¡å‹ã€‚ä¸ºäº†è®©äº‹æƒ…æ›´æœ‰è¶£ï¼Œæˆ‘ä»¬è®¾å®šè¯¯å·®æ¯”ä»¥å‰å¤§åå€ã€‚

noise_model = get_noise(0.1)

å†æ¬¡è¿è¡Œä¸Šè¿°å›è·¯ï¼Œå¹¶æ‰“å°å‡ºæ ‡å®šçŸ©é˜µ$M$ã€‚

> backend = qiskit.Aer.get_backend(\'qasm_simulator\')
>
> job = qiskit.execute(meas_calibs, backend=backend, shots=1000,
> noise_model=noise_model)
>
> cal_results = job.result()
>
> meas_fitter = CompleteMeasFitter(cal_results, state_labels,
> circlabel=\'mcal\')
>
> print(meas_fitter.cal_matrix)
>
> è¾“å‡ºï¼š
>
> \[\[0.823 0.083 0.083 0.007\]
>
> \[0.089 0.819 0.01 0.099\]
>
> \[0.082 0.008 0.816 0.093\]
>
> \[0.006 0.09 0.091 0.801\]\]

è¿™æ¬¡æ‰¾åˆ°äº†ä¸€ä¸ªæ›´æœ‰è¶£çš„çŸ©é˜µï¼Œä¸€ä¸ªä¸å¯é€†çš„çŸ©é˜µã€‚çœ‹çœ‹æˆ‘ä»¬èƒ½å¯¹è¿™ä¸€å™ªå£°ç¼“è§£å¤šå°‘ï¼Ÿå†æ¬¡ä½¿ç”¨Bellæ€$(|00\rangle + |11\rangle)/\sqrt{2}$è¿›è¡Œæµ‹è¯•ã€‚

> qc = QuantumCircuit(2,2)
>
> qc.h(0)
>
> qc.cx(0,1)
>
> qc.measure(qc.qregs\[0\],qc.cregs\[0\])
>
> results = qiskit.execute(qc, backend=backend, shots=10000,
> noise_model=noise_model).result()
>
> noisy_counts = results.get_counts()
>
> print(noisy_counts)
>
> è¾“å‡ºï¼š
>
> {\'10\': 953, \'01\': 889, \'11\': 4109, \'00\': 4049}

åœ¨Qiskitä¸­æˆ‘ä»¬é€šè¿‡æµ‹é‡è¿‡æ»¤å™¨å¯¹è±¡æ¥ç¼“è§£å™ªå£°ã€‚ç„¶ååˆ©ç”¨ä¸Šé¢çš„ç»“æœæ¥è®¡ç®—ä¸€ç»„ç¼“è§£çš„è®¡æ•°ã€‚Qiskitä¼šå°†å…¶è¾“å‡ºä¸ºä¸€ä¸ªå­—å…¸ï¼Œå› æ­¤ç”¨æˆ·ä¸éœ€è¦ä½¿ç”¨å‘é‡æ¥è·å¾—ç»“æœã€‚

> \# Get the filter object
>
> meas_filter = meas_fitter.filter
>
> \# Results with mitigation
>
> mitigated_results = meas_filter.apply(results)
>
> mitigated_counts = mitigated_results.get_counts(0)

ä¸ºä½¿ç»“æœæ›´åŠ æ¸…æ™°ï¼Œæˆ‘ä»¬æŠŠåŒ…å«å™ªå£°ä»¥åŠç¼“è§£åçš„ç»“æœæ¢å‡ºæ¥ã€‚

> \#from qiskit.visualization import \*
>
> from qiskit.visualization import plot_histogram
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images look
> nice
>
> plot_histogram(\[noisy_counts, mitigated_counts\], legend=\[\'noisy\',
> \'mitigated\'\])
>
> è¾“å‡ºï¼š

![](pics/media/image326.png)

å¯ä»¥çœ‹åˆ°ç»“æœä¸­è¿‘ä¹20%çš„æ ·æœ¬å¤„äºé”™è¯¯çš„çŠ¶æ€ï¼Œå›¾ä¸­å°†å…¶è½¬åŒ–ä¸ºçœŸå®ç»“æœçš„ç²¾ç¡®è¡¨ç¤ºã€‚ç„¶è€Œï¼Œè¿™ä¸€ç¤ºä¾‹ä»…åŒ…å«ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä»¥åŠä¸€ä¸ªç®€å•çš„å™ªå£°æ¨¡å‹ã€‚å¯¹äºæ›´å¤šçš„é‡å­æ¯”ç‰¹å’Œæ›´å¤æ‚çš„å™ªéŸ³æ¨¡å‹æˆ–æ¥è‡ªçœŸå®è®¾å¤‡çš„æ•°æ®ï¼Œç¼“è§£è¿‡ç¨‹å°†é¢å¯¹æ›´åŠ ä¸¥å³»çš„æŒ‘æˆ˜ã€‚ä¹Ÿè®¸æ‚¨ä¼šæ‰¾åˆ°æ¯”Qiskitä¸­æ‰€ä½¿ç”¨çš„æ›´å¥½æ–¹æ³•!

5.3 éšæœºåŸºå‡†ï¼ˆRandomized Benchmarkingï¼‰
---------------------------------------

### å†…å®¹

1\. ç®€ä»‹

2\. éšæœºåŸºå‡†åè®®

3\. éšæœºåŸºå‡†ï¼ˆRBï¼‰èƒŒåçš„ç›´è§‰

4\. åŒæ­¥éšæœºåŸºå‡†

5\. é¢„æµ‹é‡å­é—¨ä¿çœŸåº¦

6\. å‚è€ƒæ–‡çŒ®

### 1. ç®€ä»‹

æ„å»ºé‡å­ä¿¡æ¯å¤„ç†å™¨çš„ä¸»è¦æŒ‘æˆ˜ä¹‹ä¸€æ˜¯æ— æ³•é€šè¿‡è¿‡ç¨‹å±‚æå®Œå…¨è¡¨å¾å½±å“é‡å­ç³»ç»Ÿçš„å™ªå£°ã€‚æ­¤å¤–ï¼Œè¿‡ç¨‹å±‚æå¯¹æ—‹è½¬å‰åé‡å­é—¨çš„å™ªå£°ä»¥åŠæµ‹é‡å™ªå£°éƒ½å¾ˆæ•æ„Ÿã€‚Gatesetå±‚æå¯ä»¥è€ƒè™‘è¿™äº›è¯¯å·®ï¼Œä½†ç¼©æ”¾æ›´ç³Ÿã€‚å¯¹å™ªå£°çš„å®Œæ•´æè¿°èƒ½å¤Ÿç”¨äºç¡®å®šå‡ºè¾ƒå¥½çš„æ ¡æ­£æ–¹æ¡ˆï¼Œä»è€Œå®ç°å¯é åœ°ä¼ è¾“é‡å­ä¿¡æ¯ã€‚

ç”±äºå®Œæ•´è¿‡ç¨‹å±‚æåœ¨å¤§å‹ç³»ç»Ÿä¸­ä¸å¯è¡Œï¼Œå› æ­¤äººä»¬è¶Šæ¥è¶Šå…³æ³¨å¯æ‰©å±•çš„æ–¹æ³•ï¼Œä»¥éƒ¨åˆ†è¡¨å¾å½±å“é‡å­ç³»ç»Ÿçš„å™ªå£°ã€‚åœ¨å‚è€ƒæ–‡çŒ®\[1\]ä¸­ç»™å‡ºäº†ä¸€ç§å¯æ‰©å±•é²æ£’çš„ç®—æ³•ï¼ˆç”±$n$ä¸ªé‡å­æ¯”ç‰¹ç»„æˆçš„ç³»ç»Ÿï¼‰ï¼Œè¯¥ç®—æ³•é€šè¿‡ä½¿ç”¨éšæœºåŒ–æŠ€æœ¯çš„å•å‚æ•°å¯¹æ•´ä¸ªCliffordé—¨è¿›è¡ŒåŸºå‡†æµ‹è¯•ã€‚ä½¿ç”¨éšæœºæ–¹æ³•å¯¹é‡å­é—¨è¿›è¡ŒåŸºå‡†æµ‹è¯•çš„æ¦‚å¿µé€šå¸¸ç§°ä¸º**éšæœºåŸºå‡†**ï¼ˆ**RBï¼šRandomized
Benchmarking**ï¼‰ã€‚

### 2. éšæœºåŸºå‡†åè®®

é¦–å…ˆå¯¼å…¥ç›¸å…³çš„Qiskitä¸­çš„ç±»ã€‚

> \#Import general libraries (needed for functions)
>
> import numpy as np
>
> import matplotlib.pyplot as plt
>
> from IPython import display
>
> \#Import the RB Functions
>
> import qiskit.ignis.verification.randomized_benchmarking as rb
>
> \#Import Qiskit classes
>
> import qiskit
>
> from qiskit.providers.aer.noise import NoiseModel
>
> from qiskit.providers.aer.noise.errors.standard_errors import
> depolarizing_error, thermal_relaxation_error

éšæœºåŸºå‡†åè®®ç”±ä»¥ä¸‹æ­¥éª¤ç»„æˆï¼ˆè§å‚è€ƒæ–‡çŒ®\[1\]å’Œ\[2\]ï¼‰:

#### æ­¥éª¤1ï¼šç”ŸæˆéšæœºåŸºå‡†åºåˆ—

éšæœºåŸºå‡†åºåˆ—ç”±ä»Cliffordç¾¤ä¸­å‡åŒ€é€‰æ‹©çš„$\mathbf{n}$**-é‡å­æ¯”ç‰¹**ä¸Šçš„éšæœºCliffordå…ƒç´ ç»„æˆï¼ŒåŒ…æ‹¬ä¸€ä¸ªç»è®¡ç®—çš„åè½¬å…ƒç´ ï¼Œå…¶ä½œç”¨æ˜¯å°†é‡å­æ¯”ç‰¹è¿”å›åˆå§‹çŠ¶æ€ã€‚

æ›´å‡†ç¡®åœ°è¯´ï¼Œå¯¹äºæ¯ä¸€é•¿åº¦$m$ï¼Œæˆ‘ä»¬é€‰å‡º$K_{m}$ä¸ªéšæœºåŸºå‡†åºåˆ—ã€‚æ¯ä¸€ä¸ªåºåˆ—éƒ½åŒ…å«$m$ä¸ªéšæœºå…ƒç´ $C_{i_{j}}$ï¼Œå…¶ç”±ä»$\mathbf{n}$**-é‡å­æ¯”ç‰¹**çš„Cliffordç¾¤ä¸­ç»Ÿä¸€é€‰å‡ºï¼Œç„¶åç¬¬$m + 1$ä¸ªå…ƒç´ è¢«å®šä¹‰ä¸ºï¼š$C_{i_{m + 1}} = (C_{i_{1}}\text{...}C_{i_{m}})^{- 1}$ï¼Œå¯é€šè¿‡Gottesmann-Knillå®šç†æœ‰æ•ˆåœ°æ‰¾å‡ºã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬ç”Ÿæˆä»¥ä¸‹å‡ ä¸ªåŒé‡å­æ¯”ç‰¹çš„Cliffordå›è·¯åºåˆ—ã€‚

> \#Generate RB circuits (2Q RB)
>
> ????????????????????ï¼ˆæ­¤å¤„æ²¡æœ‰ç»™å‡ºå®ä¾‹ï¼‰
>
> \#number of qubits
>
> nQ=2
>
> rb_opts = {}
>
> \#Number of Cliffords in the sequence
>
> rb_opts\[\'length_vector\'\] = \[1, 10, 20, 50, 75, 100, 125, 150,
> 175, 200\]
>
> \#Number of seeds (random sequences)
>
> rb_opts\[\'nseeds\'\] = 5
>
> \#Default pattern
>
> rb_opts\[\'rb_pattern\'\] = \[\[0, 1\]\]
>
> rb_circs, xdata = rb.randomized_benchmarking_seq(\*\*rb_opts)

æ‰“å°å‡ºå¯¹åº”äºç¬¬ä¸€ä¸ªRBåºåˆ—çš„å›è·¯ã€‚

> rb_circs\[0\]\[0\].draw()
>
> è¾“å‡ºï¼š

![](pics/media/image327.png)

å¯ä»¥éªŒè¯è¡¨ç¤ºæ¯ä¸ªRBå›è·¯çš„å¹ºæ­£çŸ©é˜µåº”æ˜¯å…·æœ‰å…¨å±€ç›¸ä½çš„å•ä½çŸ©é˜µã€‚æˆ‘ä»¬ä½¿ç”¨Aerä¸­çš„å¹ºæ­£æ¨¡æ‹Ÿå™¨è¿›è¡Œæ¨¡æ‹Ÿã€‚

> \# Create a new circuit without the measurement
>
> qregs = rb_circs\[0\]\[-1\].qregs
>
> cregs = rb_circs\[0\]\[-1\].cregs
>
> qc = qiskit.QuantumCircuit(\*qregs, \*cregs)
>
> for i in rb_circs\[0\]\[-1\]\[0:-nQ\]:
>
> qc.data.append(i)
>
> \# The Unitary is an identity (with a global phase)
>
> backend = qiskit.Aer.get_backend(\'unitary_simulator\')
>
> basis_gates = \[\'u1\',\'u2\',\'u3\',\'cx\'\] \# use U,CX for now
>
> job = qiskit.execute(qc, backend=backend, basis_gates=basis_gates)
>
> from qiskit_textbook.tools import array_to_latex
>
> array_to_latex(np.around(job.result().get_unitary(),3),
> pretext=\"\\\\text{Unitary} = \")

$$\text{Unitary} = \begin{bmatrix}
0.707\left( - 1 + i \right) & 0 & 0 & 0 \\
0 & 0.707\left( - 1 + i \right) & 0 & 0 \\
0 & 0 & 0.707\left( - 1 + i \right) & 0 \\
0 & 0 & 0 & 0.707\left( - 1 + i \right) \\
\end{bmatrix}$$

#### æ­¥éª¤2ï¼šè¿è¡Œå«æœ‰å™ªå£°çš„RBåºåˆ—

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨Qiskitçš„Aceræ¨¡æ‹Ÿå™¨ï¼ˆå«æœ‰å™ªå£°ï¼‰æˆ–IBMQä¸­çš„provideræ¥è¿è¡ŒRBåºåˆ—ï¼Œå¹¶è·å–ä¸€åˆ—è¾“å‡ºã€‚

é€šè¿‡å‡å®šå…è®¸ç”±$\Lambda_{i_{j},j}$ä»£è¡¨çš„æ¯ä¸€è¿ç®—$C_{i_{j}}$éƒ½åŒ…å«è¯¯å·®ï¼Œåˆ™æ¯ä¸ªåºåˆ—éƒ½å¯ä»¥é€šè¿‡è¿ç®—å»ºæ¨¡ï¼š

$$\text{S}_{\text{i}_{\text{m}}} = â—¯_{j = 1}^{m + 1}\left( \Lambda_{i_{j},j} \circ C_{i_{j}} \right)$$

å…¶ä¸­$\text{i}_{\text{m}} = \left( i_{1},...,i_{m} \right)$å’Œ$i_{m + 1}$ç”±$\text{i}_{\text{m}}$å”¯ä¸€ç¡®å®šã€‚

> \# Run on a noisy simulator
>
> noise_model = NoiseModel()
>
> \# Depolarizing error on the gates u2, u3 and cx (assuming the u1 is
> virtual-Z gate and no error)
>
> p1Q = 0.002
>
> p2Q = 0.01
>
> noise_model.add_all_qubit_quantum_error(depolarizing_error(p1Q, 1),
> \'u2\')
>
> noise_model.add_all_qubit_quantum_error(depolarizing_error(2 \* p1Q,
> 1), \'u3\')
>
> noise_model.add_all_qubit_quantum_error(depolarizing_error(p2Q, 2),
> \'cx\')
>
> backend = qiskit.Aer.get_backend(\'qasm_simulator\')

#### æ­¥éª¤3ï¼šè·å¾—æ®‹å­˜å‡ ç‡çš„ç»Ÿè®¡æ•°æ®

å¯¹äºæ¯ä¸ªåºåˆ—$K_{m}$éƒ½æµ‹é‡å…¶æ®‹å­˜å‡ ç‡$Tr\lbrack E_{\psi}\text{S}_{\text{i}_{\text{m}}}(\rho_{\psi})\rbrack$ã€‚æ­¤å¤„çš„$\rho_{\psi}$æ˜¯è€ƒè™‘äº†åˆ¶å¤‡è¯¯å·®çš„åˆå§‹çŠ¶æ€ï¼Œ$E_{\psi}$æ˜¯è€ƒè™‘äº†æµ‹é‡è¯¯å·®çš„POVMå…ƒç´ ã€‚åœ¨æ— å™ªå£°çš„ç†æƒ³æƒ…å†µä¸‹$\rho_{\psi} = E_{\psi} = |\psi\rangle\langle\psi|$ã€‚

åœ¨å®é™…æƒ…å†µä¸­ï¼Œå¯ä»¥æµ‹é‡è¿”å›ç²¾ç¡®åˆå§‹çŠ¶æ€çš„æ¦‚ç‡ï¼Œå³æ‰€æœ‰å¤„äºåŸºæ€$|00...0\rangle$çš„é‡å­æ¯”ç‰¹ï¼Œæˆ–è€…ä»…æµ‹é‡å…¶ä¸­ä¸€ä¸ªé‡å­æ¯”ç‰¹è¿”å›åŸºæ€çš„æ¦‚ç‡ã€‚å¦‚æœæ— æ³•ä½¿ç”¨ç›¸å…³çš„æµ‹é‡æ–¹æ¡ˆï¼Œåˆ™ç‹¬ç«‹æµ‹é‡é‡å­æ¯”ç‰¹ä¼šæ›´æ–¹ä¾¿ã€‚ä¸¤ç§æµ‹é‡éƒ½å°†ä¾æ®*æ—‹è½¬*ï¼ˆ*twirl*ï¼‰ç‰¹æ€§é…åˆç›¸åŒçš„è¡°å‡å‚æ•°ã€‚

#### æ­¥éª¤4ï¼šæ±‚å¹³å‡åºåˆ—ä¿çœŸåº¦

å¯¹åºåˆ—$K_{m}$éšæœºå®ç°çš„å¹³å‡å€¼æ±‚åºåˆ—çš„å¹³å‡ä¿çœŸåº¦ï¼š

$$F_{\text{seq}}(m,|\psi\rangle) = Tr\lbrack E_{\psi}\text{S}_{K_{m}}(\rho_{\psi})\rbrack$$

å…¶ä¸­

$$\text{S}_{K_{m}} = \frac{1}{K_{m}}\sum_{\text{i}_{\text{m}}}^{}\text{S}_{\text{i}_{\text{m}}}$$

ä¸ºå¹³å‡åºåˆ—è¿ç®—ã€‚

#### æ­¥éª¤5ï¼šæ‹Ÿåˆç»“æœ

å¯¹ä¸åŒçš„må€¼é‡å¤æ­¥éª¤1åˆ°4ï¼Œæ‹Ÿåˆåºåˆ—å¹³å‡ä¿çœŸåº¦çš„ç»“æœåˆ°æ¨¡å‹ï¼š

$$\text{F}_{\text{seq}}^{\left( 0 \right)}(m,|\psi\rangle) = A_{0}\alpha^{m} + B_{0}$$

å…¶ä¸­$A_{0}$å’Œ$B_{0}$ç”¨äºå¸æ”¶æ¥è‡ªåˆ¶å¤‡çŠ¶æ€å’Œæµ‹é‡çš„è¯¯å·®ï¼Œä»¥åŠæœ€ç»ˆé‡å­é—¨çš„è¾¹ç¼˜æ•ˆåº”ï¼ˆedge
effectï¼‰ã€‚

$\alpha$ç”¨äºç¡®å®šå¹³å‡è¯¯å·®ç‡$r$ï¼Œè¯¥è¯¯å·®ç‡ä¾æ®ä¸‹å¼çš„å…³ç³»ä¹Ÿè¢«ç§°ä¸º**Error per
Cliffordï¼ˆEPCï¼‰**ï¼š

$$r = 1 - \alpha - \frac{1 - \alpha}{2^{n}} = \frac{2^{n} - 1}{2^{n}}\left( 1 - \alpha \right)$$

å…¶ä¸­$n = nQ$æ˜¯é‡å­æ¯”ç‰¹çš„æ•°é‡ã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬è®¡ç®—äº†æ¯ä¸ªRBåºåˆ—çš„å¹³å‡åºåˆ—ä¿çœŸåº¦ï¼Œå¹¶å°†ç»“æœæ‹Ÿåˆåˆ°æŒ‡æ•°æ›²çº¿ä¸Šï¼Œä»¥åŠè®¡ç®—å¤„å‚æ•°$\alpha$å’Œ**EPC**ã€‚

> \# Create the RB fitter
>
> backend = qiskit.Aer.get_backend(\'qasm_simulator\')
>
> basis_gates = \[\'u1\',\'u2\',\'u3\',\'cx\'\]
>
> shots = 200
>
> transpiled_circs_list = \[\]
>
> rb_fit = rb.RBFitter(None, xdata, rb_opts\[\'rb_pattern\'\])
>
> for rb_seed, rb_circ_seed in enumerate(rb_circs):
>
> print(\'Compiling seed %d\'%rb_seed)
>
> new_rb_circ_seed = qiskit.compiler.transpile(rb_circ_seed,
> basis_gates=basis_gates)
>
> transpiled_circs_list.append(new_rb_circ_seed)
>
> print(\'Simulating seed %d\'%rb_seed)
>
> job = qiskit.execute(new_rb_circ_seed, backend, shots=shots,
>
> noise_model=noise_model,
>
> backend_options={\'max_parallel_experiments\': 0})
>
> \# Add data to the fitter
>
> rb_fit.add_data(job.result())
>
> print(\'After seed %d, alpha: %f, EPC:
> %f\'%(rb_seed,rb_fit.fit\[0\]\[\'params\'\]\[1\],
> rb_fit.fit\[0\]\[\'epc\'\]))
>
> è¾“å‡ºï¼š
>
> Compiling seed 0
>
> Simulating seed 0
>
> After seed 0, alpha: 0.981127, EPC: 0.014155
>
> Compiling seed 1
>
> Simulating seed 1
>
> After seed 1, alpha: 0.977603, EPC: 0.016798
>
> Compiling seed 2
>
> Simulating seed 2
>
> After seed 2, alpha: 0.980842, EPC: 0.014369
>
> Compiling seed 3
>
> Simulating seed 3
>
> After seed 3, alpha: 0.980397, EPC: 0.014702
>
> Compiling seed 4
>
> Simulating seed 4
>
> After seed 4, alpha: 0.980321, EPC: 0.014759

#### é™„åŠ æ­¥éª¤ï¼šç”»å‡ºç»“æœ

> plt.figure(figsize=(8, 6))
>
> ax = plt.subplot(1, 1, 1)
>
> \# Plot the essence by calling plot_rb_data
>
> rb_fit.plot_rb_data(0, ax=ax, add_label=True, show_plt=False)
>
> \# Add title and label
>
> ax.set_title(\'%d Qubit RB\'%(nQ), fontsize=18)
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image328.png)

### 3.RBèƒŒåçš„ç›´è§‰

å»æåŒ–çš„é‡å­é€šé“å…·å¤‡å‚æ•°$\alpha$ï¼Œç±»ä¼¼äºï¼šé‡å­æ¯”ç‰¹æœ‰$\alpha$çš„æ¦‚ç‡ä¿æŒå…¶çŠ¶æ€ï¼›æœ‰1-$\alpha$çš„æ¦‚ç‡çŠ¶æ€å˜ä¸ºå®Œå…¨æ··åˆæ€ï¼Œå³ï¼š

$$\rho_{f} = \alpha\rho_{i} + \frac{1 - \alpha}{2^{n}}*\mathbf{I}$$

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåŒ…å«$m$ä¸ªä¸ä¸€å®šéƒ½æ˜¯Cliffordé—¨çš„é‡å­é—¨åºåˆ—ï¼Œå…¶ä¸­å„ä¸ªé‡å­é—¨è¯¯å·®é€šé“æ˜¯å…·æœ‰å‚æ•°$\alpha$çš„å»æåŒ–é€šé“ï¼ˆæ‰€æœ‰é‡å­é—¨çš„å‚æ•°éƒ½æ˜¯$\alpha$ï¼‰ã€‚é‚£ä¹ˆï¼Œåœ¨å•ä¸ªåºåˆ—è¿è¡Œç»“æŸæ—¶å…ƒç´ çŠ¶æ€æœ‰$\alpha^{m}$çš„æ¦‚ç‡æ­£ç¡®ï¼Œæœ‰$1 - \alpha^{m}$ä¼šå˜ä¸ºå®Œå…¨æ··åˆæ€ï¼Œå› æ­¤ï¼š

$$\rho_{f}^{m} = \alpha^{m}\rho_{i} + \frac{1 - \alpha^{m}}{2^{n}}*\mathbf{I}$$

ç°åœ¨å‡è®¾ä»åŸºæ€å¼€å§‹ï¼›å…¨éƒ¨åºåˆ—ç­‰åŒäºå•ä½çŸ©é˜µï¼›å¹¶åœ¨å•ä¸ªåºåˆ—è¿è¡Œç»“æŸæ—¶ä»¥æ ‡å‡†åŸºçŸ¢æµ‹é‡å…¶çŠ¶æ€ã€‚æˆ‘ä»¬å¾—åˆ°åœ¨å•ä¸ªåºåˆ—ç»“æŸæ—¶çš„æˆåŠŸçš„æ¦‚ç‡ä¸ºï¼š

$$\alpha^{m} + \frac{1 - \alpha^{m}}{2^{n}} = \frac{2^{n} - 1}{2^{n}}\alpha^{m} + \frac{1}{2^{n}} = A_{0}\alpha^{m} + B_{0}$$

ç”±æ­¤å¯è§ï¼ŒæˆåŠŸçš„æ¦‚ç‡ï¼ˆå³ä¿çœŸåº¦ï¼‰éšç€åºåˆ—é•¿åº¦éšæŒ‡æ•°$\alpha$å‘ˆæŒ‡æ•°è¡°å‡ã€‚

å½“é€šé“ä¸æ˜¯å»æåŒ–é€šé“æ—¶ï¼Œæœ€åé‚£ä¸ªå¼å­ä¸ä¸€å®šæ­£ç¡®ã€‚ç„¶è€Œç»“æœè¡¨æ˜ï¼šå¦‚æœé‡å­é—¨æ˜¯å‡åŒ€ä¸”éšæœºçš„Cliffordé—¨ï¼Œåˆ™æ¯ä¸ªé‡å­é—¨çš„å™ªå£°å¹³å‡è¡¨ç°ä¸ºå»æåŒ–é€šé“ï¼Œå¹¶å¯ç”±è¿™äº›é€šé“è®¡ç®—å‡ºä¸€äº›å‚æ•°ï¼Œç„¶åå°±è·å–äº†ä¿çœŸåº¦çš„æŒ‡æ•°è¡°å‡ã€‚

æ­£è§„çš„è¯´æ³•ä¸ºï¼šå–ä¸€ä¸ªé‡å­é€šé“$\overline{\Lambda}$çš„æœ‰é™ç¾¤$G$ï¼ˆå¦‚Cliffordç¾¤ï¼‰å¹³å‡å€¼ä¹Ÿç§°ä¸ºæ‰­è½¬ï¼ˆtwirlï¼‰ï¼š

$$W_{G}(\overline{\Lambda})\frac{1}{|G|}\sum_{u \in G}^{}{U^{\dagger} \circ \overline{\Lambda} \circ U}$$

åœ¨æ•´ä¸ªå¹ºæ­£ç¾¤ä¸Šæ‰­è½¬ä¼šäº§ç”Ÿä¸Cliffordç¾¤å®Œå…¨ç›¸åŒçš„ç»“æœã€‚Cliffordç¾¤æ˜¯ä¸€ä¸ª*2-design*çš„å¹ºæ­£ç¾¤ã€‚

### 4. åŒæ­¥éšæœºåŸºå‡†

RBæ—¨åœ¨é€šè¿‡ä¸¤ç§æ–¹å¼è§£å†³å¤šé‡å­æ¯”ç‰¹ç³»ç»Ÿä¸­çš„ä¿çœŸåº¦ã€‚é¦–å…ˆï¼Œå¯ä»¥é€šè¿‡æ„é€ $n -$é‡å­æ¯”ç‰¹Cliffordç¾¤çš„åºåˆ—æ¥æ‰§è¡Œæ•´ä¸ª$n -$é‡å­æ¯”ç‰¹ç©ºé—´ä¸Šçš„RBã€‚æ­¤å¤–ï¼Œå¯ä»¥å°†$n -$é‡å­æ¯”ç‰¹ç©ºé—´ç»†åˆ†ä¸ºåœ¨æ¯ä¸ªå­é›†ä¸­åŒæ—¶æ‰§è¡Œçš„é‡å­æ¯”ç‰¹$\{ n_{i}\}$å’Œ$n_{i} -$é‡å­æ¯”ç‰¹çš„RB\[4\]ã€‚ä¸¤ç§æ–¹æ³•éƒ½ç»™å‡ºäº†$n -$é‡å­æ¯”ç‰¹ç©ºé—´ä¸­ä¿çœŸåº¦çš„åº¦é‡ã€‚

ä¾‹å¦‚ï¼Œé€šå¸¸åœ¨å®šä¹‰CNOTé—¨çš„ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„å­é›†ä¸Šæ‰§è¡Œ2Q
RBï¼Œè€Œå…¶ä»–é‡å­æ¯”ç‰¹æ˜¯é™æ€çš„ã€‚å¦‚å‚è€ƒæ–‡çŒ®\[4\]ä¸­æ‰€è¿°ï¼Œæ­¤æ—¶çš„RBæ•°æ®ä¸ä¸€å®šä¼šå‘ˆæŒ‡æ•°è¡°å‡ï¼Œå› ä¸ºå…¶ä»–é‡å­æ¯”ç‰¹å­ç©ºé—´ä¸ä¼šå‘ç”Ÿæ‰­è½¬ã€‚å­é›†é€šè¿‡åŒæ—¶RBè¿›è¡Œæ›´ä¸¥æ ¼çš„ç‰¹å¾åŒ–ï¼Œç”±äºæ‰€æœ‰é‡å­æ¯”ç‰¹å‡å¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œå› æ­¤å®ƒè¿˜å¯ä»¥æµ‹é‡ä¸€å®šç¨‹åº¦çš„ä¸²æ‰°è¯¯å·®ã€‚

å¹¶è¡ŒRBï¼ˆ1Q RBå’Œ2Q RBï¼‰çš„ç¤ºä¾‹ï¼š

https://github.com/Qiskit/qiskit-tutorials/blob/master/qiskit/ignis/randomized_benchmarking.ipynb

### 5. é¢„æµ‹é‡å­é—¨ä¿çœŸåº¦

å¦‚æœçŸ¥é“äº†åº•å±‚é‡å­é—¨ï¼ˆé‡å­é—¨é›†ï¼‰ä¸Šçš„è¯¯å·®ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨ä¸è¿è¡ŒRBå®éªŒçš„æƒ…å†µä¸‹é¢„æµ‹EPCã€‚æ­¤è®¡ç®—å¯éªŒè¯RBå®éªŒï¼Œéšåçš„æ‹Ÿåˆä¼šäº§ç”Ÿæ­£ç¡®çš„EPCå€¼ã€‚é¦–å…ˆæˆ‘ä»¬éœ€è¦è®¡ç®—æ¯ä¸ªCliffordæœ‰å¤šå°‘ä¸ªé‡å­é—¨ã€‚

ç„¶åï¼Œå«æœ‰ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„Cliffordé—¨çš„è¯¯å·®å‡½æ•°calculate_2q_epcç»™å‡ºæ¯ä¸ª2Q
Cliffordçš„è¯¯å·®ã€‚å…¶å‡å®šåº•å±‚é‡å­é—¨ä¸­çš„è¯¯å·®æ­£åœ¨å»æåŒ–ã€‚è¿™ä¸€å‡½æ•°æ´¾ç”Ÿäº\[5\]ã€‚

> \# count the number of single and 2Q gates in the 2Q Cliffords
>
> qubits = rb_opts\[\'rb_pattern\'\]\[0\]
>
> gate_per_cliff = rb.rb_utils.gates_per_clifford(
>
> transpiled_circuits_list=transpiled_circs_list,
>
> clifford_lengths=xdata\[0\],
>
> basis=basis_gates,
>
> qubits=qubits)
>
> for basis_gate in basis_gates:
>
> print(\"Number of %s gates per Clifford: %f\"%(
>
> basis_gate,
>
> np.mean(\[gate_per_cliff\[qubit\]\[basis_gate\] for qubit in
> qubits\])))
>
> è¾“å‡ºï¼š
>
> Number of u1 gates per Clifford: 0.254694
>
> Number of u2 gates per Clifford: 1.282751
>
> Number of u3 gates per Clifford: 0.180022
>
> Number of cx gates per Clifford: 1.498253
>
> \# convert from depolarizing error to epg (1Q)
>
> epg_q0 = {\'u1\': 0, \'u2\': p1Q/2, \'u3\': 2 \* p1Q/2}
>
> epg_q1 = {\'u1\': 0, \'u2\': p1Q/2, \'u3\': 2 \* p1Q/2}
>
> \# convert from depolarizing error to epg (2Q)
>
> epg_q01 = 3/4 \* p2Q
>
> \# calculate the predicted epc from underlying gate errors
>
> pred_epc = rb.rb_utils.calculate_2q_epc(
>
> gate_per_cliff=gate_per_cliff,
>
> epg_2q=epg_q01,
>
> qubit_pair=qubits,
>
> list_epgs_1q=\[epg_q0, epg_q1\])
>
> print(\"Predicted 2Q Error per Clifford: %e (qasm simulator result:
> %e)\" % (pred_epc, rb_fit.fit\[0\]\[\'epc\'\]))
>
> è¾“å‡ºï¼š
>
> Predicted 2Q Error per Clifford: 1.508622e-02 (qasm simulator result:
> 1.475925e-02)

å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®å®éªŒè·å¾—çš„EPCè®¡ç®—åº•å±‚é‡å­é—¨ï¼ˆé‡å­é—¨é›†ï¼‰ä¸Šçš„è¯¯å·®ã€‚å‡è®¾æˆ‘ä»¬çŸ¥é“RBåºåˆ—ä¸­æ¯ä¸ªå•é‡å­æ¯”ç‰¹é—¨çš„è¯¯å·®ï¼Œå°±å¯ä»¥ä»ä¸¤ä¸ªé‡å­æ¯”ç‰¹RBå®éªŒçš„EPCé¢„æµ‹2Qé‡å­é—¨è¯¯å·®ã€‚

åŒé‡å­æ¯”ç‰¹é—¨è¯¯å·®å‡½æ•°calculate_2q_epgç»™å‡ºäº†æ¯ä¸ª2Qé‡å­é—¨çš„è¯¯å·®ä¼°è®¡ã€‚åœ¨è¿™ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨éå¯¹ç§°è¯¯å·®æ¨¡å‹æ¥åˆ¶å¤‡å•é‡å­æ¯”ç‰¹è¯¯å·®ã€‚åœ¨è¯¯å·®æ¨¡å‹æœªçŸ¥çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥ç”¨å®ç”¨å‡½æ•°calculate_1q_epgå•ç‹¬è¿›è¡Œ1Q
RBå®éªŒæ¥ä¼°è®¡è¿™äº›é—¨çš„EPGå€¼ï¼Œå¦‚\[u1, u2, u3\]ã€‚

> \# use 2Q EPC from qasm simulator result and 1Q EPGs from depolarizing
> error model
>
> pred_epg = rb.rb_utils.calculate_2q_epg(
>
> gate_per_cliff=gate_per_cliff,
>
> epc_2q=rb_fit.fit\[0\]\[\'epc\'\],
>
> qubit_pair=qubits,
>
> list_epgs_1q=\[epg_q0, epg_q1\])
>
> print(\"Predicted 2Q Error per gate: %e (gate error model: %e)\" %
> (pred_epg, epg_q01))
>
> è¾“å‡ºï¼š
>
> Predicted 2Q Error per gate: 7.261899e-03 (gate error model:
> 7.500000e-03)

### 6. å‚è€ƒæ–‡çŒ®

1\. Easwar Magesan, J. M. Gambetta, and Joseph Emerson, Robust
randomized benchmarking of quantum processes,
https://arxiv.org/pdf/1009.3639

2\. Easwar Magesan, Jay M. Gambetta, and Joseph Emerson, Characterizing
Quantum Gates via Randomized Benchmarking,
https://arxiv.org/pdf/1109.6887

3\. A. D. C\'orcoles, Jay M. Gambetta, Jerry M. Chow, John A. Smolin,
Matthew Ware, J. D. Strand, B. L. T. Plourde, and M. Steffen, Process
verification of two-qubit quantum gates by randomized benchmarking,
https://arxiv.org/pdf/1210.7011

4\. Jay M. Gambetta, A. D. CÂ´orcoles, S. T. Merkel, B. R. Johnson, John
A. Smolin, Jerry M. Chow, Colm A. Ryan, Chad Rigetti, S. Poletto, Thomas
A. Ohki, Mark B. Ketchen, and M. Steffen, Characterization of
addressability by simultaneous randomized benchmarking,
https://arxiv.org/pdf/1204.6308

5\. David C. McKay, Sarah Sheldon, John A. Smolin, Jerry M. Chow, and
Jay M. Gambetta, Three Qubit Randomized Benchmarking,
https://arxiv.org/pdf/1712.06550

5.4 æµ‹é‡é‡å­ä½“ç§¯
----------------

### ç®€ä»‹

é‡å­ä½“ç§¯ï¼ˆ**Quantum Volume
QV**ï¼‰æ˜¯ä¸€ä¸ªå•æ•°å­—åº¦é‡æ ‡å‡†ï¼Œå…¶ä¾æ®å…·ä½“åè®®åœ¨ä¸­ç­‰å¤§å°çš„è¿‘æœŸé‡å­è®¡ç®—æœºä¸Šæµ‹å¾—ã€‚QVæ–¹æ³•é‡åŒ–ä¸é‡å­è®¡ç®—æœºæ‰€èƒ½æˆåŠŸå®ç°çš„å®½åº¦å’Œæ·±åº¦ç›¸ç­‰çš„æœ€å¤§éšæœºå›è·¯ã€‚å…·æœ‰é«˜ä¿çœŸæ“ä½œã€é«˜è¿æ¥æ€§ã€å¤§å‹æ ¡å‡†é‡å­é—¨ç»„å’Œå›è·¯é‡å†™å·¥å…·é“¾çš„é‡å­è®¡ç®—ç³»ç»Ÿæœ‰æœ›å…·æœ‰æ›´é«˜çš„é‡å­ä½“ç§¯ã€‚

### é‡å­ä½“ç§¯åè®®

é‡å­ä½“ç§¯åè®®ï¼ˆå‚è€ƒæ–‡çŒ®\[1\]ï¼‰ç”±ä»¥ä¸‹æ­¥éª¤ç»„æˆï¼š

ï¼ˆä¸ºäº†è¯æ˜éœ€è¦å¯¼å…¥ç›¸å…³Qiskitä¸­çš„ç±»ã€‚ï¼‰

> %matplotlib inline
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images look
> nice
>
> import matplotlib.pyplot as plt
>
> \#Import Qiskit classes
>
> import qiskit
>
> from qiskit.providers.aer.noise import NoiseModel
>
> from qiskit.providers.aer.noise.errors.standard_errors import
> depolarizing_error, thermal_relaxation_error
>
> \#Import the qv function
>
> import qiskit.ignis.verification.quantum_volume as qv

#### æ­¥éª¤1ï¼šç”ŸæˆQVåºåˆ—

ä¼—æ‰€å‘¨çŸ¥ï¼Œé‡å­ç®—æ³•å¯ä»¥è¡¨ç¤ºä¸ºç”±åŒé‡å­æ¯”ç‰¹å¹ºæ­£é‡å­é—¨æ„å»ºçš„å¤šé¡¹å¼å¤§å°çš„é‡å­å›è·¯ã€‚å› æ­¤ï¼Œæ¨¡å‹å›è·¯ç”±$d$å±‚è¢«è¡¨æ ‡è®°é‡å­æ¯”ç‰¹çš„éšæœºæ’åˆ—ä»¥åŠæ˜¯éšæœºåŒé‡å­æ¯”ç‰¹é—¨ï¼ˆè‡ª$\text{SU}(4)$ï¼‰ç»„æˆã€‚å½“å›è·¯å®½åº¦$m$ä¸ºå¥‡æ•°æ—¶ï¼Œæ¯ä¸€å±‚ä¸­çš„ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¸å·¥ä½œã€‚

æ›´åŠ ç²¾ç¡®çš„è¡¨è¿°ä¸ºï¼šä¸€ä¸ªå…·æœ‰**æ·±åº¦**$d$**å®½åº¦**$m$çš„**QVå›è·¯**æ˜¯å…·æœ‰$d$å±‚çš„åºåˆ—$U = U^{(d)}\text{...}U^{(2)}U^{(1)}$ï¼š

$$U^{(t)} = U_{\pi_{t}(m^{'} - 1),\pi_{t}(m)}^{(t)} \otimes ... \otimes U_{\pi_{t}\left( 1 \right),\pi_{t}\left( 2 \right)}^{\left( t \right)}$$

æ¯ä¸ªéƒ½ç”¨æ—¶é—´t = 1 \...
dæ ‡è®°å¹¶ä½œç”¨äº$m^{'} = 2\left\lfloor \frac{n}{2} \right\rfloor$ä¸ªé‡å­æ¯”ç‰¹ä¸Šã€‚é€šè¿‡é€‰æ‹©ç¬¬$m$ä¸ªé‡å­æ¯”ç‰¹æ‰€æ ‡è®°çš„å‡åŒ€éšæœºæ’åˆ—$\pi_{t} \in S_{m}$å¹¶ä»$\text{SU}(4)$ä¸Šçš„å“ˆå°”æµ‹åº¦ï¼ˆHaar
measureï¼‰ä¸­é‡‡æ ·ä½œç”¨äºé‡å­æ¯”ç‰¹$a$å’Œ$b$æ¯ä¸€$U_{a,b}^{(t)}$æ¥æŒ‡å®šæ¯ä¸€ä¸ªå±‚ã€‚

åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­æœ‰6ä¸ªé‡å­æ¯”ç‰¹Q0ï¼ŒQ1ï¼ŒQ3ï¼ŒQ5ï¼ŒQ7ï¼ŒQ10ã€‚æˆ‘ä»¬å°†ç ”ç©¶å®Œæ•´çš„å­é›†ï¼ˆæ¯ä¸ªå›è·¯ç”µè·¯çš„æ·±åº¦å°†ç­‰äºå­é›†ä¸­çš„é‡å­æ¯”ç‰¹çš„æ•°é‡ï¼‰ã€‚

> \# qubit_lists: list of list of qubit subsets to generate QV circuits
>
> qubit_lists = \[\[0,1,3\],\[0,1,3,5\],\[0,1,3,5,7\],\[0,1,3,5,7,10\]\]
>
> \# ntrials: Number of random circuits to create for each subset
>
> ntrials = 50

æˆ‘ä»¬ä»ä¸€ä¸ªå°ä¾‹å­å¼€å§‹ç”Ÿæˆé‡å­ä½“ç§¯åºåˆ—ï¼Œå› æ­¤è¿è¡Œæ—¶é—´ä¸ä¼šå¤ªé•¿ã€‚

qv_circs, qv_circs_nomeas = qv.qv_circuits(qubit_lists, ntrials)

ä¾‹å¦‚ï¼Œæ‰“å°å‡ºä¸ç¬¬ä¸€ä¸ªQVåºåˆ—ç›¸å¯¹åº”çš„å›è·¯ã€‚è¯·æ³¨æ„ï¼Œç†æƒ³çš„å›è·¯åœ¨å‰nä¸ªé‡å­æ¯”ç‰¹ä¸Šè¿è¡Œï¼ˆå…¶ä¸­næ˜¯å­é›†ä¸­çš„é‡å­æ¯”ç‰¹çš„æ•°é‡ï¼‰ã€‚

> \#pass the first trial of the nomeas through the transpiler to
> illustrate the circuit
>
> qv_circs_nomeas\[0\] = qiskit.compiler.transpile(qv_circs_nomeas\[0\],
> basis_gates=\[\'u1\',\'u2\',\'u3\',\'cx\'\])

print(qv_circs_nomeas\[0\]\[0\])

![](pics/media/image329.png)

#### æ­¥éª¤2ï¼šæ¨¡æ‹Ÿç†æƒ³çš„QVå›è·¯

é‡å­ä½“ç§¯æ–¹æ³•è¦æ±‚æˆ‘ä»¬çŸ¥é“æ¯ä¸ªå›è·¯çš„ç†æƒ³è¾“å‡ºï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨Acerä¸­çš„æ€å‘é‡æ¨¡æ‹Ÿæ¥è·å–ç†æƒ³ç»“æœã€‚

> \#The Unitary is an identity (with a global phase)
>
> backend = qiskit.Aer.get_backend(\'statevector_simulator\')
>
> ideal_results = \[\]
>
> for trial in range(ntrials):
>
> print(\'Simulating trial %d\'%trial)
>
> ideal_results.append(qiskit.execute(qv_circs_nomeas\[trial\],
> backend=backend).result())ã€‚
>
> è¾“å‡ºï¼š
>
> Simulating trial 0
>
> Simulating trial 1
>
> Simulating trial 2
>
> Simulating trial 3
>
> Simulating trial 4
>
> Simulating trial 5
>
> Simulating trial 6
>
> Simulating trial 7
>
> Simulating trial 8
>
> Simulating trial 9
>
> ...
>
> Simulating trial 39
>
> Simulating trial 40
>
> Simulating trial 41
>
> Simulating trial 42
>
> Simulating trial 43
>
> Simulating trial 44
>
> Simulating trial 45
>
> Simulating trial 46
>
> Simulating trial 47
>
> Simulating trial 48
>
> Simulating trial 49

ä¸‹ä¸€æ­¥åŠ è½½ç†æƒ³ç»“æœè‡³é‡å­ä½“ç§¯æ‹Ÿåˆå™¨ä¸­ï¼š

> qv_fitter = qv.QVFitter(qubit_lists=qubit_lists)
>
> qv_fitter.add_statevectors(ideal_results)

#### æ­¥éª¤3ï¼šè®¡ç®—å¤§è¾“å‡º

ä¸ºäº†å®šä¹‰äº‹å®ä¸ŠæˆåŠŸå®ç°äº†æ¨¡å‹å›è·¯$U$ï¼Œæˆ‘ä»¬ä½¿ç”¨å¤§è¾“å‡ºï¼ˆheavy
outputï¼‰ç”Ÿæˆé—®é¢˜ã€‚ç†æƒ³è¾“å‡ºçš„åˆ†å¸ƒä¸º$p_{U}(x) = |\left\langle x\left| U \right|0 \right\rangle|^{2}$ï¼Œå…¶ä¸­$x \in \{ 0,1\}^{m}$æ˜¯ä¸€ä¸ªå¯è§‚æµ‹çš„ä½-å­—ä¸²ï¼ˆbit-stringï¼‰ã€‚

é‰´äºè¾“å‡ºæ¦‚ç‡é›†ç”±å‡åºæ’åˆ—$p_{0} \leq p_{1} \leq \cdots \leq p_{2^{m} - 1}$çš„åŒºé—´$p_{U}\left( x \right)$ç»™å‡ºã€‚æ¦‚ç‡é›†çš„ä¸­ä½æ•°ä¸º$p_{\text{med}} = (p_{2^{m - 1}} + p_{2^{m - 1} - 1})/2$ï¼Œåˆ™å¤§é‡è¾“å‡ºä¸ºï¼š

$$H_{U} = \{ x \in \left\{ 0,1\}^{m}\text{\ such\ that\ }p_{U}\left( x \right) > p_{\text{med}} \right\}$$

å¤§è¾“å‡ºï¼ˆheavy
outputï¼‰ç”Ÿæˆé—®é¢˜äº§ç”Ÿä¸€ç»„è¾“å‡ºå­—ä¸²ï¼Œä½¿å¾—ä¸‰åˆ†ä¹‹äºŒä»¥ä¸Šçš„å­—ä¸²å¾ˆå·¨å¤§ã€‚

ä½œä¸ºä¾‹è¯ï¼Œæˆ‘ä»¬å°†ä»å„ä¸ªæ·±åº¦å’Œæ¦‚ç‡ï¼ˆå¯¹äºè¯•éªŒ0ï¼‰æ‰“å°å¤§è¾“å‡ºã€‚

> for qubit_list in qubit_lists:
>
> l = len(qubit_list)
>
> print (\'qv_depth\_\'+str(l)+\'\_trial_0:\',
> qv_fitter.\_heavy_outputs\[\'qv_depth\_\'+str(l)+\'\_trial_0\'\])
>
> è¾“å‡ºï¼š
>
> qv_depth_3\_trial_0: \[\'001\', \'010\', \'101\', \'110\'\]
>
> qv_depth_4\_trial_0: \[\'0000\', \'0001\', \'0010\', \'0011\',
> \'0111\', \'1010\', \'1101\', \'1110\'\]
>
> qv_depth_5\_trial_0: \[\'00000\', \'00011\', \'00101\', \'01000\',
> \'01001\', \'10000\', \'10001\', \'10010\', \'10011\', \'10100\',
> \'10101\', \'10110\', \'11001\', \'11011\', \'11100\', \'11101\'\]
>
> qv_depth_6\_trial_0: \[\'000000\', \'000100\', \'001000\', \'001001\',
> \'001011\', \'001100\', \'001111\', \'010000\', \'010010\',
> \'010100\', \'010101\', \'010111\', \'011000\', \'011001\',
> \'011010\', \'011011\', \'100000\', \'100001\', \'100010\',
> \'100100\', \'100101\', \'101100\', \'101101\', \'101111\',
> \'110001\', \'110011\', \'110101\', \'110110\', \'110111\',
> \'111001\', \'111011\', \'111100\'\]
>
> for qubit_list in qubit_lists:
>
> l = len(qubit_list)
>
> print (\'qv_depth\_\'+str(l)+\'\_trial_0:\',
> qv_fitter.\_heavy_output_prob_ideal\[\'qv_depth\_\'+str(l)+\'\_trial_0\'\])
>
> è¾“å‡ºï¼š
>
> qv_depth_3\_trial_0: 0.8767167718108534
>
> qv_depth_4\_trial_0: 0.7579879384625499
>
> qv_depth_5\_trial_0: 0.7494374821348169
>
> qv_depth_6\_trial_0: 0.8363454481453244

#### æ­¥éª¤4ï¼šå®šä¹‰å™ªå£°æ¨¡å‹

æˆ‘ä»¬ä¸ºæ¨¡æ‹Ÿå™¨å®šä¹‰äº†ä¸€ä¸ªå™ªå£°æ¨¡å‹ã€‚ä¸ºäº†æ¨¡æ‹Ÿè¡°å‡ï¼Œåœ¨CNOTå’ŒUé—¨ä¸­åŠ å…¥å»æåŒ–è¯¯å·®æ¦‚ç‡ã€‚

> noise_model = NoiseModel()
>
> p1Q = 0.002
>
> p2Q = 0.02
>
> noise_model.add_all_qubit_quantum_error(depolarizing_error(p1Q, 1),
> \'u2\')
>
> noise_model.add_all_qubit_quantum_error(depolarizing_error(2\*p1Q, 1),
> \'u3\')
>
> noise_model.add_all_qubit_quantum_error(depolarizing_error(p2Q, 2),
> \'cx\')
>
> \#noise_model = None

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨Qiskitä¸­Aeræ¨¡æ‹Ÿå™¨(å¸¦æœ‰ä¸€äº›å™ªå£°æ¨¡å‹)æˆ–ä½¿ç”¨IBMQ
provideræ‰§è¡ŒQVåºåˆ—å¹¶è·å–exp_resultsåˆ—è¡¨ã€‚

> backend = qiskit.Aer.get_backend(\'qasm_simulator\')
>
> basis_gates = \[\'u1\',\'u2\',\'u3\',\'cx\'\] \# use U,CX for now
>
> shots = 1024
>
> exp_results = \[\]
>
> for trial in range(ntrials):
>
> print(\'Running trial %d\'%trial)
>
> exp_results.append(qiskit.execute(qv_circs\[trial\],
> basis_gates=basis_gates, backend=backend, noise_model=noise_model,
> backend_options={\'max_parallel_experiments\': 0}).result())
>
> è¾“å‡ºï¼š
>
> Running trial 0
>
> Running trial 1
>
> ...
>
> Running trial 48
>
> Running trial 49

#### æ­¥éª¤5ï¼šè®¡ç®—å¹³å‡é‡å­é—¨ä¿çœŸåº¦

$m$-é‡å­æ¯”ç‰¹ç†æƒ³å¹ºæ­£$U$ä¸æ‰€æ‰§è¡Œçš„$U^{'}$é—´çš„å¹³å‡é‡å­é—¨ä¿çœŸåº¦ä¸ºï¼š

$$F_{\text{avg}}\left( U,U^{'} \right) = \frac{|Tr(U^{\dagger}U^{'})|^{2}/2^{m} + 1}{2^{m} + 1}$$

å¯¹äºæ¨¡å‹å›è·¯$U$æ‰€å®ç°çš„$U^{'}$è§‚å¯Ÿåˆ°çš„åˆ†å¸ƒä¸º$q_{U}(x)$ï¼Œé‡‡æ ·å¤§é‡è¾“å‡ºçš„æ¦‚ç‡ä¸ºï¼š

$$h_{U} = \sum_{x \in H_{U}}^{}{q_{U}(x)}$$

å¯¹äºtrial 0ï¼Œä»å›è·¯çš„å„ä¸ªæ·±åº¦æ‰“å°å¤§é‡è¾“å‡ºï¼š

> qv_fitter.add_data(exp_results)
>
> for qubit_list in qubit_lists:
>
> l = len(qubit_list)
>
> \#print (qv_fitter.\_heavy_output_counts)
>
> print (\'qv_depth\_\'+str(l)+\'\_trial_0:\',
> qv_fitter.\_heavy_output_counts\[\'qv_depth\_\'+str(l)+\'\_trial_0\'\])
>
> è¾“å‡ºï¼š
>
> qv_depth_3\_trial_0: 825
>
> qv_depth_4\_trial_0: 684
>
> qv_depth_5\_trial_0: 674
>
> qv_depth_6\_trial_0: 631

#### æ­¥éª¤6ï¼šè®¡ç®—å¯è¾¾æ·±åº¦

ä¸€ä¸ªéšæœºé€‰å–æ·±åº¦$d$çš„æ¨¡å‹å›è·¯çš„è§‚æµ‹å¤§è¾“å‡ºçš„æ¦‚ç‡ä¸ºï¼š

$$h_{d} = \int_{U}^{}{h_{U}\text{dU}}$$

å¯è¾¾æ·±åº¦ï¼ˆachievable
depthï¼‰$d(m)$æ˜¯å…¶ä¸­æœ€å¤§çš„$d$ï¼Œå› æ­¤æˆ‘ä»¬ç¡®ä¿¡$h_{d} > 2/3$ã€‚æ„ä¸ºï¼š

$$h_{1},h_{2},\ldots,h_{d(m)} > 2/3\text{\ }\text{å’Œ}\text{\ }h_{d(m) + 1} \leq 2/3$$

ç°åœ¨ï¼Œæˆ‘ä»¬è½¬æ¢ä¸åŒè¯•éªŒä¸­çš„å¤§è¾“å‡ºï¼Œè®¡ç®—å¹³å‡$h_{d}$å’Œè¯¯å·®å¹¶ç»˜åˆ¶æˆå›¾ã€‚

> plt.figure(figsize=(10, 6))
>
> ax = plt.gca()
>
> \# Plot the essence by calling plot_rb_data
>
> qv_fitter.plot_qv_data(ax=ax, show_plt=False)
>
> \# Add title and label
>
> ax.set_title(\'Quantum Volume for up to %d Qubits \\n and %d
> Trials\'%(len(qubit_lists\[-1\]), ntrials), fontsize=18)
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image330.png)

#### æ­¥éª¤7ï¼šè®¡ç®—é‡å­ä½“ç§¯

é‡å­ä½“ç§¯å°†æ¨¡å‹å›è·¯çš„å®½åº¦å’Œæ·±åº¦è§†ä¸ºåŒç­‰é‡è¦ï¼Œé€šå¸¸è€Œè¨€é‡å­è®¡ç®—æœºå¯æˆåŠŸå®ç°çš„æœ€å¤§æ­£æ–¹å½¢ï¼ˆ$m = d$ï¼‰æ¨¡å‹å›è·¯çš„æµ‹é‡------é‡å­ä½“ç§¯$V_{Q}$ï¼š

$$\log_{2}V_{Q} = \arg{\max_{m}\min\left( m,d\left( m \right) \right)}$$

æˆ‘ä»¬åˆ—å‡ºäº†æ¯ä¸ªæ·±åº¦çš„ç»Ÿè®¡ä¿¡æ¯ã€‚å¯¹äºæ‰€åˆ—å‡ºçš„æ¯ä¸€ä¸ªæ·±åº¦ï¼Œæˆ‘ä»¬éƒ½ä¼šåˆ—å‡ºæ·±åº¦æ˜¯å¦æœ‰æ•ˆä»¥åŠç½®ä¿¡åŒºé—´ä¸ºå¤šå°‘ã€‚æ·±åº¦æ˜¯å¦æœ‰æ•ˆçš„åˆ¤æ–­ä¸€å¥ä¸ºå…¶ç½®ä¿¡åŒºé—´å¿…é¡»\>
97.5ï¼…ã€‚

> qv_success_list = qv_fitter.qv_success()
>
> qv_list = qv_fitter.ydata
>
> QV = 1
>
> for qidx, qubit_list in enumerate(qubit_lists):
>
> if qv_list\[0\]\[qidx\]\>2/3:
>
> if qv_success_list\[qidx\]\[0\]:
>
> print(\"Width/depth %d greater than 2/3 (%f) with confidence %f
> (successful). Quantum volume %d\"%
>
> (len(qubit_list),qv_list\[0\]\[qidx\],qv_success_list\[qidx\]\[1\],qv_fitter.quantum_volume()\[qidx\]))
>
> QV = qv_fitter.quantum_volume()\[qidx\]
>
> else:
>
> print(\"Width/depth %d greater than 2/3 (%f) with confidence %f
> (unsuccessful).\"%
>
> (len(qubit_list),qv_list\[0\]\[qidx\],qv_success_list\[qidx\]\[1\]))
>
> else:
>
> print(\"Width/depth %d less than 2/3
> (unsuccessful).\"%len(qubit_list))
>
> è¾“å‡ºï¼š
>
> Width/depth 3 greater than 2/3 (0.788105) with confidence 0.982193
> (successful). Quantum volume 8
>
> Width/depth 4 greater than 2/3 (0.711211) with confidence 0.756474
> (unsuccessful).
>
> Width/depth 5 greater than 2/3 (0.714434) with confidence 0.772706
> (unsuccessful).
>
> Width/depth 6 less than 2/3 (unsuccessful).
>
> print (\"The Quantum Volume is:\", QV)
>
> è¾“å‡ºï¼š
>
> The Quantum Volume is: 8

### å‚è€ƒæ–‡çŒ®

\[1\] Andrew W. Cross, Lev S. Bishop, Sarah Sheldon, Paul D. Nation, and
Jay M. Gambetta, Validating quantum computers using randomized model
circuits, Phys. Rev. A 100, 032328 (2019).
https://arxiv.org/pdf/1811.12926

6 åˆ©ç”¨å¾®æ³¢è„‰å†²ç ”ç©¶é‡å­ç¡¬ä»¶
==========================

å³å°†æ¥ä¸´
--------

ä»¥ä¸‹ä¸»é¢˜ç›®å‰æ­£å¤„äºå¼€å‘é˜¶æ®µï¼Œå³å°†è¢«æ·»åŠ åˆ°æœ¬æ•™ç¨‹ä¸­ï¼š

1\. é€€ç›¸å¹²å’Œèƒ½é‡å¼›è±«ï¼šæµ‹é‡T2å’ŒT1

2\. ä¼˜åŒ–å¾®æ³¢è„‰å†²çš„é«˜ä¿çœŸé‡å­æ¯”ç‰¹æ“ä½œ

6.1 ç”¨Qiskit Pulseæ ¡å‡†é‡å­æ¯”ç‰¹
------------------------------

Qiskitæ˜¯ä¸€ä¸ªç”¨äºé‡å­è®¡ç®—æœºç¼–ç¨‹çš„å¼€æºæ¡†æ¶\[1\]ã€‚é€šè¿‡Qiskitå¯ä»¥åœ¨é‡å­è®¾å¤‡ä¸Šæ„å»ºã€æ¨¡æ‹Ÿå’Œè¿è¡Œé‡å­å›è·¯ã€‚

Qiskit
Pulseæä¾›äº†ç”¨äºæŒ‡å®šç‹¬ç«‹äºç‰¹å®šç¡¬ä»¶å®ç°çš„é€šç”¨é‡å­è®¾å¤‡çš„è„‰å†²ç™»è®°æ§åˆ¶ï¼ˆå¦‚ï¼šè¾“å…¥ä¿¡å·çš„è¿ç»­æ—¶é—´åŠ¨æ€æ§åˆ¶ï¼‰çš„è¯­è¨€\[2\]ã€‚

åœ¨æœ¬èŠ‚çš„æ•™ç¨‹å°†ä¼šå±•ç¤ºå¦‚ä½•é€šè¿‡Qiskitå’ŒQiskit
Pulseå®ç°å…¸å‹çš„å•é‡å­æ¯”ç‰¹æ ¡å‡†ä»¥åŠå¯¹è¯•éªŒè¿›è¡Œç‰¹æ€§æè¿°ã€‚é€šå¸¸ï¼Œè¿™äº›æ˜¯åœ¨å°†è®¾å¤‡åˆ¶é€ å¹¶å®‰è£…åˆ°ç³»ç»Ÿä¸­åç«‹å³åœ¨å®éªŒå®¤ä¸­è¿›è¡Œçš„ç¬¬ä¸€è½®å®éªŒã€‚è¯¥æ¼”ç¤ºå°†ä¼šä»¥å…¸å‹çš„å­¦æ ¡æ–¹å¼è¿›è¡Œï¼Œå…è®¸æ‚¨å®éªŒæ€§åœ°æ¢ç´¢åŒèƒ½çº§ç³»ç»ŸåŠ¨åŠ›å­¦ï¼ˆtwo-level-system
dynamicï¼‰ã€‚åœ¨æ¼”ç¤ºä¸­æ‰€æ¶‰åŠçš„æ‰€æœ‰è®¡é‡å•ä½å‡ä»¥æ ‡å‡†SIè¿”å›ï¼Œå¦‚ï¼šHzã€secç­‰ç­‰ã€‚

æ¼”ç¤ºä¸­çš„æ¯æ¬¡è¯•éªŒéƒ½ä¼šç»™äºˆæˆ‘ä»¬æœ‰å…³ç³»ç»Ÿçš„æ›´å¤šä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯é€šå¸¸ä¼šç”¨äºåç»­çš„è¯•éªŒä¸­ã€‚å› æ­¤ï¼Œæ­¤notebookå†…çš„ä»£ç åŸºæœ¬ä¸Šæ˜¯æŒ‰å…ˆåé¡ºåºæ‰§è¡Œã€‚

### å†…å®¹

1\. å…¥é—¨æŒ‡å—

2\. ä½¿ç”¨é¢‘ç‡æ‰«ææ‰¾å‡ºé‡å­æ¯”ç‰¹çš„é¢‘ç‡

3\. æ ¡å‡†ä¸ä½¿ç”¨$\pi$è„‰å†²

3.1 ä½¿ç”¨Rabiå®éªŒæ ¡å‡†$\pi$è„‰å†²

3.2 ç¡®å®š0è¿˜æ˜¯1

3.3 ä½¿ç”¨åè½¬æ¢å¤æµ‹é‡$T_{1}$

4\. ç¡®å®šé‡å­æ¯”ç‰¹çš„ç›¸å¹²æ€§

4.1 ä½¿ç”¨Ramseyå®éªŒç²¾ç¡®æµ‹é‡é‡å­æ¯”ç‰¹çš„é¢‘ç‡

4.2 ä½¿ç”¨å“ˆæ©å›æ³¢ï¼ˆHahn Echoesï¼‰æµ‹é‡$T_{2}$

5\. å‚è€ƒæ–‡çŒ®

### 1. å…¥é—¨æŒ‡å—

é¦–å…ˆå¯¼å…¥å°†ä¼šä½¿ç”¨åˆ°çš„Pythonåº“ã€‚ç”±äºæˆ‘ä»¬ä¼šåœ¨æ ¡å‡†å®éªŒä¸­ä½¿ç”¨çœŸå®ä¸”åŒ…å«å™ªå£°çš„è®¾å¤‡ï¼Œæ‰€ä»¥éœ€è¦ç”¨åˆ°IBMQè´¦æˆ·ä»¥åŠè®¾ç½®ç›¸åº”çš„åç«¯ã€‚

> from qiskit.tools.jupyter import \*
>
> from qiskit import IBMQ
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\', group=\'open\',
> project=\'main\')
>
> backend = provider.get_backend(\'ibmq_armonk\')

æˆ‘ä»¬å¯ä»¥é€šè¿‡æ£€æŸ¥åç«¯é…ç½®æ¥éªŒè¯æ‰€æ”¯æ’‘çš„è„‰å†²ç‰¹æ€§ã€‚è¿™ä¸€é…ç½®ç»™å‡ºäº†åç«¯è®¾ç½®ç»“æ„çš„ä¸€èˆ¬ä¿¡æ¯ã€‚

> backend_config = backend.configuration()
>
> assert backend_config.open_pulse, \"Backend doesn\'t support Pulse\"
>
> ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åç«¯é…ç½®ä¸­æ‰¾åˆ°åç«¯è„‰å†²çš„å–æ ·æ—¶é—´ã€‚è¿™ä¸€å‚æ•°åœ¨æ„å»ºå’Œæ‰§è¡Œæ ¡å‡†æ—¶éå¸¸æœ‰ç”¨ã€‚
>
> dt = backend_config.dt
>
> print(f\"Sampling time: {dt\*1e9} ns\") \# The configuration returns
> dt in seconds, so multiply by
>
> \# 1e9 to get nanoseconds

åç«¯ä¼šé»˜è®¤ç»™å‡ºå¦‚ä½•ä½¿ç”¨åç«¯çš„èµ·å§‹ç‚¹ã€‚å…¶ä¸­å«æœ‰é‡å­æ¯”ç‰¹é¢‘ç‡çš„ä¼°è®¡å’Œæ‰®æ¼”åŸºç¡€é‡å­ç®—å­çš„ç¨‹åºã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤å¯¹å…¶è¿›è¡Œè®¿é—®ï¼š

backend_defaults = backend.defaults()

### 2. ä½¿ç”¨é¢‘ç‡æ‰«ææ‰¾å‡ºé‡å­æ¯”ç‰¹çš„é¢‘ç‡

æˆ‘ä»¬ä»æœç´¢é‡å­æ¯”ç‰¹çš„é¢‘ç‡å¼€å§‹ã€‚é‡å­ä½çš„é¢‘ç‡æ˜¯åŸºæ€$|0\rangle$å’Œæ¿€å‘æ€$|1\rangle$ä¹‹é—´çš„èƒ½é‡å·®ã€‚è¿™ä¸€é¢‘ç‡å¯¹äºäº§ç”Ÿè„‰å†²è‡³å…³é‡è¦ï¼Œè„‰å†²å¯ä»¥åœ¨é‡å­æ¯”ä¸Šäº§ç”Ÿç‰¹å®šçš„é‡å­ç®—å­------è¿™ä¹Ÿæ˜¯æ ¡å‡†çš„æœ€ç»ˆç›®æ ‡!

åœ¨è¶…å¯¼çš„é‡å­æ¯”ç‰¹ä¸Šé«˜èƒ½çº§æ˜¯å¯ä»¥è¢«å®ç°çš„ï¼Œä½†æ˜¯æˆ‘ä»¬é€šè¿‡åˆ¶é€ éåç³»ç»Ÿæ¥æ§åˆ¶æ¿€å‘çš„è½¬æ¢------æ„ä¸ºï¼šæˆ‘ä»¬é€šè¿‡éš”ç¦»ä¸¤ä¸ªèƒ½çº§çš„é‡å­æ¯”ç‰¹å¹¶å°†æ¯ä¸ªé‡å­æ¯”ç‰¹è§†ä¸ºåŸºç¡€åŒèƒ½çº§ç³»ç»Ÿæ¥å¿½ç•¥å…¶ä¸­çš„é«˜èƒ½æ€ã€‚

åœ¨å…¸å‹çš„å®éªŒè®¾ç½®ä¸­ï¼Œé‡å­æ¯”ç‰¹çš„é¢‘ç‡å¯ä»¥é€šè¿‡æ‰«æä¸€æ®µé¢‘ç‡çš„èŒƒå›´æ‰¾å‡ºå¹¶ä½¿ç”¨ä¸€ç§å«åšç½‘ç»œåˆ†æä»ªï¼ˆNetwork
Analyerï¼‰çš„å·¥å…·æ¥å¯»æ‰¾è¢«å¸æ”¶çš„è¿¹è±¡ã€‚ä¹‹åï¼Œæˆ‘ä»¬å°†ä¼šçœ‹åˆ°å¦‚ä½•ä½¿ç”¨Ramseyè„‰å†²åºåˆ—è¿›è¡Œæ›´åŠ ç²¾ç¡®çš„æµ‹é‡ã€‚\
é¦–å…ˆï¼Œå®šä¹‰ç”¨äºåœ¨é‡å­æ¯”ç‰¹ä¸Šæ‰«æçš„é¢‘ç‡èŒƒå›´ã€‚ç”±äºè¿™ä¸€èŒƒå›´å¯ä»¥æ˜¯ä»»æ„å¤§å°ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨backend_defaultsä¸­å°†è¿™ä¸€èŒƒå›´é™åˆ¶åœ¨é‡å­æ¯”ç‰¹çš„ä¼°è®¡é¢‘ç‡40mhzå·¦å³ã€‚

> import numpy as np
>
> \# unit conversion factors -\> all backend properties returned in SI
> (Hz, sec, etc)
>
> GHz = 1.0e9 \# Gigahertz
>
> MHz = 1.0e6 \# Megahertz
>
> us = 1.0e-6 \# Microseconds
>
> ns = 1.0e-9 \# Nanoseconds
>
> \# We will find the qubit frequency for the following qubit.
>
> qubit = 0
>
> \# The sweep will be centered around the estimated qubit frequency.
>
> center_frequency_Hz = backend_defaults.qubit_freq_est\[qubit\] \# The
> default frequency is given in Hz
>
> \# warning: this will change in a future release
>
> print(f\"Qubit {qubit} has an estimated frequency of
> {center_frequency_Hz / GHz} GHz.\")
>
> \# scale factor to remove factors of 10 from the data
>
> scale_factor = 1e-14
>
> \# We will sweep 40 MHz around the estimated frequency
>
> frequency_span_Hz = 40 \* MHz
>
> \# in steps of 1 MHz.
>
> frequency_step_Hz = 1 \* MHz
>
> \# We will sweep 20 MHz above and 20 MHz below the estimated frequency
>
> frequency_min = center_frequency_Hz - frequency_span_Hz / 2
>
> frequency_max = center_frequency_Hz + frequency_span_Hz / 2
>
> \# Construct an np array of the frequencies for our experiment
>
> frequencies_GHz = np.arange(frequency_min / GHz,
>
> frequency_max / GHz,
>
> frequency_step_Hz / GHz)
>
> print(f\"The sweep will go from {frequency_min / GHz} GHz to
> {frequency_max / GHz} GHz \\
>
> in steps of {frequency_step_Hz / MHz} MHz.\")
>
> è¾“å‡ºï¼š
>
> Qubit 0 has an estimated frequency of 4.974449465550582 GHz.
>
> The sweep will go from 4.9544494655505815 GHz to 4.994449465550582 GHz
> in steps of 1.0 MHz.

æ¥ä¸‹æ¥å®šä¹‰å°†ä¼šåœ¨å®éªŒä¸­è¦ç”¨åˆ°çš„è„‰å†²ã€‚æˆ‘ä»¬ä»ç§°ä¸ºé«˜æ–¯è„‰å†²çš„é©±åŠ¨è„‰å†²å¼€å§‹ã€‚

æ˜¯å¦è¿˜è®°å¾—ä¸Šé—®ä¸­çš„å€¼dtï¼Ÿæ‰€æœ‰è„‰å†²çš„æ—¶é•¿éƒ½ç”¨dtè¡¨ç¤ºã€‚åœ¨ä¸‹ä¸€å•å…ƒä¸­ï¼Œæˆ‘ä»¬ç”¨dtæ¥å®šä¹‰é©±åŠ¨è„‰å†²çš„é•¿åº¦ã€‚

> \# samples need to be multiples of 16
>
> def get_closest_multiple_of_16(num):
>
> return int(num + 8 ) - (int(num + 8 ) % 16)
>
> from qiskit import pulse \# This is where we access all of our Pulse
> features!
>
> from qiskit.pulse import Play
>
> from qiskit.pulse import pulse_lib \# This Pulse module helps us build
> sampled pulses for common pulse shapes
>
> \# Drive pulse parameters (us = microseconds)
>
> drive_sigma_us = 0.075 \# This determines the actual width of the
> gaussian
>
> drive_samples_us = drive_sigma_us\*8 \# This is a truncating
> parameter, because gaussians don\'t have
>
> \# a natural finite length
>
> drive_sigma = get_closest_multiple_of_16(drive_sigma_us \* us /dt) \#
> The width of the gaussian in units of dt
>
> drive_samples = get_closest_multiple_of_16(drive_samples_us \* us /dt)
> \# The truncating parameter in units of dt
>
> drive_amp = 0.3
>
> \# Drive pulse samples
>
> drive_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> sigma=drive_sigma,
>
> amp=drive_amp,
>
> name=\'freq_sweep_excitation_pulse\')

ä¸ºäº†æ­£ç¡®çš„æµ‹é‡é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬éœ€è¦æ ¸å¯¹æµ‹é‡æ˜ å°„ã€‚è¿™æ˜¯ä¸€ç§å¼ºåˆ¶çº¦æŸï¼Œå› ä¸ºå½“å¯¹ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„æµ‹é‡ç»“æŸåï¼Œå¯¹å…¶ä»–é‡å­æ¯”ç‰¹çš„æµ‹é‡ä¹ŸåŒæ—¶ç»“æŸã€‚å½“åœ¨Pulseä¸­åˆ›å»ºç¨‹åºæ—¶éœ€è¦å°Šé‡è¿™ä¸€çº¦æŸã€‚è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹é‡å­æ¯”ç‰¹å±äºå“ªä¸€ç»„é‡å­æ¯”ç‰¹ï¼š

> \# Find out which group of qubits need to be acquired with this qubit
>
> meas_map_idx = None
>
> for i, measure_group in enumerate(backend_config.meas_map):
>
> if qubit in measure_group:
>
> meas_map_idx = i
>
> break
>
> assert meas_map_idx is not None, f\"Couldn\'t find qubit {qubit} in
> the meas_map!\"

ç°åœ¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰æµ‹é‡è„‰å†²äº†ã€‚ä¸å…¶ç¡¬ç¼–ç è„‰å†²ç¨‹åºï¼Œä¸å¦‚ç›´æ¥ä»Qiskitåç«¯çš„é»˜è®¤æŒ‡ä»¤è¡¨ä¸­è°ƒå–ä¸€ä¸ªå·²æ ¡å‡†çš„æµ‹é‡è„‰å†²ã€‚å› ä¸ºè¿™æ ·çš„è„‰å†²ç»å¸¸è¢«æ ¡å‡†ï¼Œè€Œä¸”æ¯”æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„æµ‹é‡è„‰å†²æ›´åŠ ç²¾ç¡®ã€‚å¹¶ä¸”è¿™æ ·çš„æµ‹é‡è„‰å†²åŒ…å«æ•è·ï¼Œå¦‚æ­¤æˆ‘ä»¬å°±æ— é¡»æ‰‹å·¥å®šä¹‰äº†ã€‚

> inst_sched_map = backend_defaults.instruction_schedule_map
>
> measure = inst_sched_map.get(\'measure\',
> qubits=backend_config.meas_map\[meas_map_idx\])

æ¥ç€ï¼ŒæŒ‡å®šæ–½åŠ è„‰å†²çš„ä¿¡é“ã€‚é©±åŠ¨ã€æµ‹é‡å’Œæ•è·ä¿¡é“ç”±é‡å­æ¯”ç‰¹çš„é¡ºåºå®šä¹‰ã€‚

> \#\#\# Collect the necessary channels
>
> drive_chan = pulse.DriveChannel(qubit)
>
> meas_chan = pulse.MeasureChannel(qubit)
>
> acq_chan = pulse.AcquireChannel(qubit)

è‡³æ­¤è„‰å†²çš„å‚æ•°å®šä¹‰å®Œæˆï¼Œè€Œä¸”è¿˜ä¸ºå®éªŒåˆ›å»ºäº†è„‰å†²æ³¢å½¢ï¼Œæ¥ç€æˆ‘ä»¬å°±å¯ä»¥åˆ›å»ºè„‰å†²è°ƒåº¦äº†ã€‚

åœ¨æ¯ä¸€é¢‘ç‡ä¸Šï¼Œæˆ‘ä»¬å°†ä¼šå‘é‡å­æ¯”ç‰¹ä¼ é€ä¸€ä¸ªè¯¥é¢‘ç‡çš„é©±åŠ¨è„‰å†²å¹¶åœ¨è„‰å†²ä¹‹åé©¬ä¸Šæµ‹é‡ã€‚è„‰å†²åŒ…ä¸é¢‘ç‡æ— å…³ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå¯é‡ç”¨çš„è°ƒåº¦ï¼ˆscheduleï¼‰ï¼Œå¹¶é€šè¿‡é¢‘ç‡æ•°ç»„æ¥æŒ‡å®šé©±åŠ¨è„‰å†²çš„é¢‘ç‡ã€‚

> \# Create the base schedule
>
> \# Start with drive pulse acting on the drive channel
>
> schedule = pulse.Schedule(name=\'Frequency sweep\')
>
> schedule += Play(drive_pulse, drive_chan)
>
> \# The left shift \`\<\<\` is special syntax meaning to shift the
> start time of the schedule by some duration
>
> schedule += measure \<\< schedule.duration
>
> \# Create the frequency settings for the sweep (MUST BE IN HZ)
>
> frequencies_Hz = frequencies_GHz\*GHz
>
> schedule_frequencies = \[{drive_chan: freq} for freq in
> frequencies_Hz\]

å¯¹è„‰å†²è°ƒåº¦è¿›è¡Œæ£€æŸ¥æ˜¯æ˜æ™ºçš„ä¸¾åŠ¨ï¼Œä½¿ç”¨schedule.draw()å®Œæˆï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

> schedule.draw(label=True)
>
> æ•°ç»„ï¼š

![](pics/media/image331.png)

æˆ‘ä»¬å°†ä¸Šé¢çš„scheduleå’Œschedule_frequenciesç»„åˆæˆä¸€ä¸ªå¯ä»¥å‘é€åˆ°é‡å­è®¾å¤‡ç¨‹åºå¯¹è±¡Qobjã€‚æˆ‘ä»¬åœ¨å…¶ä¸­è¯·æ±‚å¯¹æ¯ä¸ªè°ƒåº¦ï¼ˆé¢‘ç‡æ‰«æä¸­çš„æ¯ä¸ªç‚¹ï¼‰é‡å¤num_shots_per_frequencyæ¬¡ï¼Œä»¥è·å¾—å¯¹é‡å­æ¯”ç‰¹å“åº”çš„è‰¯å¥½ä¼°è®¡ã€‚

æˆ‘ä»¬è¿˜æŒ‡å®šäº†æµ‹é‡è®¾ç½®ã€‚meas_level=0è¿”å›åŸå§‹æ•°æ®ï¼ˆæ¯ä¸ªæ¬¡æµ‹é‡è¿”å›ä¸€ä¸ªå¤æ•°å€¼çš„æ•°ç»„ï¼‰ï¼Œmeas_level=1è¿”å›æ ¸å¿ƒæ•°æ®ï¼ˆæ¯æ¬¡æµ‹é‡è¿”å›ä¸€ä¸ªå¤æ•°å€¼ï¼‰ï¼Œè€Œmeas_level=2è¿”å›åˆ†ç±»æ•°æ®ï¼ˆæ¯æ¬¡æµ‹é‡è¿”å›æ¯”ç‰¹0æˆ–æ¯”ç‰¹1ï¼‰ã€‚å¦‚æœæˆ‘ä»¬è¿˜æ²¡æœ‰å·²æ ¡å‡†çš„é‰´åˆ«å™¨æ¥åŒºåˆ†0å’Œ1çš„è¯ï¼Œå¯ä»¥é€šè¿‡æŒ‡å®šmeas_level=1æ¥å¤åˆ¶åœ¨å®éªŒå®¤é‡Œè¦ä½¿ç”¨çš„ä¸œè¥¿ã€‚æˆ‘ä»¬æƒ³è¦çš„ç»“æœæ˜¯"avgï¼ˆå¹³å‡å€¼ï¼‰"è€Œéæ¯ä¸€æ¬¡çš„æµ‹é‡å€¼ã€‚

> from qiskit import assemble
>
> num_shots_per_frequency = 1024
>
> frequency_sweep_program = assemble(schedule,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots_per_frequency,
>
> schedule_los=schedule_frequencies)

æ‚¨å¯èƒ½ä¼šçœ‹åˆ°å¦ä¸€ä¸ªè®¡é‡å•ä½æ›´æ”¹è­¦å‘Šï¼Œæˆ‘ä»¬å¯ä»¥å®‰å…¨åœ°å¿½ç•¥è¯¥è­¦å‘Šã€‚æœ€åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åç«¯ä¸Šè¿è¡Œè¯¥ç»„åˆç¨‹åºï¼š

job = backend.run(frequency_sweep_program)

æ­¤å¤„æœ‰ä¸€ä¸ªå¥½ä¹ æƒ¯ï¼šå°†æœ€åæ£€ç´¢çš„job_idæ‰“å°å‡ºæ¥ï¼Œå¹¶é€šè¿‡job_monitor()ç›‘æ§ä½œä¸šçš„çŠ¶æ€ã€‚

> \# print(job.job_id())
>
> from qiskit.tools.monitor import job_monitor
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run

ä¸€æ—¦ä½œä¸šå¼€å§‹è¿è¡Œï¼Œç»“æœå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„ä»£ç å¯¹å…¶æ£€ç´¢ï¼š

> frequency_sweep_results = job.result(timeout=120) \# timeout parameter
> set to 120 seconds

æˆ‘ä»¬ä¼šé€šè¿‡mateplotlibå°†æ‰€æå–çš„ç»“æœç»˜åˆ¶æˆå›¾ï¼š

> import matplotlib.pyplot as plt
>
> sweep_values = \[\]
>
> for i in range(len(frequency_sweep_results.results)):
>
> \# Get the results from the ith experiment
>
> res = frequency_sweep_results.get_memory(i)\*scale_factor
>
> \# Get the results for \`qubit\` from this experiment
>
> sweep_values.append(res\[qubit\])
>
> plt.scatter(frequencies_GHz, np.real(sweep_values), color=\'black\')
> \# plot real part of sweep values
>
> plt.xlim(\[min(frequencies_GHz), max(frequencies_GHz)\])
>
> plt.xlabel(\"Frequency \[GHz\]\")
>
> plt.ylabel(\"Measured signal \[a.u.\]\")
>
> plt.show()

![](pics/media/image332.png)

æ­£å¦‚ä¸Šé¢çš„å›¾å½¢æ‰€ç¤ºï¼Œå³°å€¼å¤„äºé‡å­æ¯”ç‰¹é¢‘ç‡æ‰€å¯¹åº”çš„ä¸­å¿ƒå¤„ã€‚è¿™äº›ä¿¡å·å±•ç¤ºäº†åŠŸç‡å±•å®½ï¼ˆpower-broadeningï¼‰ï¼Œå³å½“æ¥è¿‘ä¸­å¿ƒé¢‘ç‡æ—¶æˆ‘ä»¬èƒ½å¤Ÿé©±åŠ¨é‡å­æ¯”ç‰¹è„±ç¦»å…±æŒ¯çš„ä¿¡å·ã€‚ä¸ºäº†å¾—åˆ°å³°å€¼é¢‘ç‡çš„å€¼ï¼Œæˆ‘ä»¬å°†æŠŠè¿™äº›å€¼æ‹Ÿåˆåˆ°ä¸€ä¸ªå…¸å‹æ´›ä¼¦å…¹å½¢çŠ¶çš„å…±æŒ¯å“åº”æ›²çº¿ä¸Šã€‚

> from scipy.optimize import curve_fit
>
> def fit_function(x_values, y_values, function, init_params):
>
> fitparams, conv = curve_fit(function, x_values, y_values, init_params)
>
> y_fit = function(x_values, \*fitparams)
>
> return fitparams, y_fit
>
> fit_params, y_fit = fit_function(frequencies_GHz,
>
> np.real(sweep_values),
>
> lambda x, A, q_freq, B, C: (A / np.pi) \* (B / ((x - q_freq)\*\*2 +
> B\*\*2)) + C,
>
> \[5, 4.975, 1, 3\] \# initial parameters for curve_fit
>
> )
>
> plt.scatter(frequencies_GHz, np.real(sweep_values), color=\'black\')
>
> plt.plot(frequencies_GHz, y_fit, color=\'red\')
>
> plt.xlim(\[min(frequencies_GHz), max(frequencies_GHz)\])
>
> plt.xlabel(\"Frequency \[GHz\]\")
>
> plt.ylabel(\"Measured Signal \[a.u.\]\")
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image333.png)

> A, rough_qubit_frequency, B, C = fit_params
>
> rough_qubit_frequency = rough_qubit_frequency\*GHz \# make sure qubit
> freq is in Hz
>
> print(f\"We\'ve updated our qubit frequency estimate from \"
>
> f\"{round(backend_defaults.qubit_freq_est\[qubit\] / GHz, 5)} GHz to
> {round(rough_qubit_frequency/GHz, 5)} GHz.\")
>
> è¾“å‡ºï¼š
>
> We\'ve updated our qubit frequency estimate from 4.97444 GHz to
> 4.97467 GHz.

### 3. æ ¡å‡†ä¸ä½¿ç”¨$\mathbf{\pi}$è„‰å†²

#### 3.1 ä½¿ç”¨Rabiå®éªŒæ ¡å‡†$\mathbf{\pi}$è„‰å†²

å½“æˆ‘ä»¬çŸ¥é“é‡å­æ¯”ç‰¹çš„é¢‘ç‡ä¹‹åï¼Œä¸‹ä¸€æ­¥å°±æ˜¯ç¡®å®š$\pi$è„‰å†²çš„å¼ºåº¦ã€‚å°†é‡å­æ¯”ç‰¹çœ‹ä½œåŒèƒ½çº§ç³»ç»Ÿæ—¶ï¼Œä¸¥æ ¼åœ°è®²ä¸€ä¸ª$\pi$è„‰å†²ä½œç”¨å°±æ˜¯æŠŠé‡å­æ¯”ç‰¹çš„çŠ¶æ€ä»$|0\rangle$è½¬æ¢ä¸º$\left| 1 \right\rangle$ï¼Œåä¹‹äº¦ç„¶ã€‚$\pi$è„‰å†²ä¹Ÿç§°ä¸º$X$æˆ–$X180$é—¨ï¼Œæˆ–ä½ç¿»è½¬ç®—å­ã€‚æˆ‘ä»¬å·²ç»ä»ä¸Šé¢çš„é¢‘ç‡æ‰«é¢‘å®éªŒä¸­çŸ¥é“äº†é©±åŠ¨è¿™ç§è½¬å˜æ‰€éœ€çš„å¾®æ³¢é¢‘ç‡ï¼Œç°åœ¨å¯»æ‰¾å®ç°ä»æ€$|0\rangle$åˆ°æ€$|1\rangle$çš„ğœ‹æ—‹è½¬æ‰€éœ€æŒ¯å¹…ã€‚æ‰€éœ€çš„æ—‹è½¬åœ¨å¸ƒæ´›èµ«çƒä½“ä¸‹å›¾æ‰€ç¤ºï¼Œæ‚¨å¯ä»¥çœ‹åˆ°ğœ‹è„‰å†²å› å…¶åœ¨å¸ƒæ´›èµ«çƒä¸­æ‰«è¿‡çš„è§’åº¦è€Œå¾—åã€‚

![](pics/media/image334.png)

æˆ‘ä»¬å°†ä¼šé€šè¿‡å°å¹…åº¦çš„å¢åŠ æ¥æ”¹å˜é©±åŠ¨å¹…å€¼å¹¶åœ¨æ¯æ¬¡æ”¹åŠ¨åæµ‹é‡é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚æˆ‘ä»¬æœŸæœ›èƒ½å¤Ÿçœ‹åˆ°é€šå¸¸ç§°ä¸ºRabiæŒ¯åŠ¨çš„æŒ¯åŠ¨ï¼Œå¦‚åŒé‡å­æ¯”ç‰¹ä»æ€$|0\rangle$å˜ä¸ºæ€$|1\rangle$ï¼Œç„¶åå†å˜å›æ€$|0\rangle$ã€‚

> \# This experiment uses these values from the previous experiment:
>
> \# \`qubit\`,
>
> \# \`measure\`, and
>
> \# \`rough_qubit_frequency\`.
>
> \# Rabi experiment parameters
>
> num_rabi_points = 50
>
> \# Drive amplitude values to iterate over: 50 amplitudes evenly spaced
> from 0 to 0.75
>
> drive_amp_min = 0
>
> drive_amp_max = 0.75
>
> drive_amps = np.linspace(drive_amp_min, drive_amp_max,
> num_rabi_points)
>
> \# Build the Rabi experiments:
>
> \# A drive pulse at the qubit frequency, followed by a measurement,
>
> \# where we vary the drive amplitude each time.
>
> rabi_schedules = \[\]
>
> for drive_amp in drive_amps:
>
> rabi_pulse = pulse_lib.gaussian(duration=drive_samples, amp=drive_amp,
>
> sigma=drive_sigma, name=f\"Rabi drive amplitude = {drive_amp}\")
>
> this_schedule = pulse.Schedule(name=f\"Rabi drive amplitude =
> {drive_amp}\")
>
> this_schedule += Play(rabi_pulse, drive_chan)
>
> \# Reuse the measure instruction from the frequency sweep experiment
>
> this_schedule += measure \<\< this_schedule.duration
>
> rabi_schedules.append(this_schedule)

ä¸Šé¢ä»£ç æ‰€å®šä¹‰çš„è°ƒåº¦æœ¬è´¨ä¸Šä¸é¢‘ç‡æ‰«æå®éªŒç›¸åŒã€‚å…¶å”¯ä¸€çš„åŒºåˆ«æ˜¯ç›¸å¯¹äºè°ƒåˆ¶é¢‘ç‡è¿™ä¸€æ¬¡æˆ‘ä»¬æ‰€è¿è¡Œçš„æ˜¯å…·æœ‰ä¸åŒé©±åŠ¨è„‰å†²å¹…å€¼çš„ä¸€ç»„å®éªŒã€‚

> rabi_schedules\[-1\].draw(label=True)
>
> è¾“å‡ºï¼š

![](pics/media/image335.png)

> \# Assemble the schedules into a Qobj
>
> num_shots_per_point = 1024
>
> rabi_experiment_program = assemble(rabi_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots_per_point,
>
> schedule_los=\[{drive_chan: rough_qubit_frequency}\]
>
> \* num_rabi_points)
>
> \# print(job.job_id())
>
> job = backend.run(rabi_experiment_program)
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> rabi_results = job.result(timeout=120)

è‡³æ­¤å°±å¾—åˆ°äº†ç»“æœï¼Œæˆ‘ä»¬å°†ä¼šæå–å¹¶æ‹Ÿåˆè¿™äº›ç»“æœè‡³ä¸€ä¸ªæ­£å¼¦æ›²çº¿ã€‚å¯¹äºæ‰€é€‰çš„é©±åŠ¨å¹…å€¼çš„èŒƒå›´ï¼Œæˆ‘ä»¬å¸Œæœ›ä»æ€$|0\rangle$å¼€å§‹å›´ç»•å¸ƒæ´›èµ«çƒå®Œå…¨æ—‹è½¬é‡å­æ¯”ç‰¹å¤šæ¬¡ã€‚è¿™ç§æ­£å¼¦æ³¢çš„å¹…å€¼å‘Šè¯‰æˆ‘ä»¬è„‰å†²æ¬¡æ•°ä¸­çš„ä¸€å°éƒ¨åˆ†çš„Rabié©±åŠ¨å¹…å€¼ä¼šç”Ÿæˆæ€$|1\rangle$ã€‚æˆ‘ä»¬æƒ³è¦æ‰¾å‡ºä½¿å¾—ä¿¡å·ä»æœ€å¤§ï¼ˆæ‰€æœ‰é‡å­æ¯”ç‰¹çš„çŠ¶æ€ä¸º$|0\rangle$ï¼‰åˆ°æœ€å°ï¼ˆæ‰€æœ‰çš„é‡å­æ¯”ç‰¹çŠ¶æ€ä¸º$|1\rangle$ï¼‰çš„æŒ¯è¡æ‰€éœ€çš„é©±åŠ¨å¹…å€¼------è¿™ä¸€è¿‡ç¨‹ç»™å‡ºäº†æ‰®æ¼”ğœ‹è„‰å†²çš„å·²æ ¡å‡†å¹…å€¼ã€‚

> \# center data around 0
>
> def baseline_remove(values):
>
> return np.array(values) - np.mean(values)
>
> rabi_values = \[\]
>
> for i in range(num_rabi_points):
>
> \# Get the results for \`qubit\` from the ith experiment
>
> rabi_values.append(rabi_results.get_memory(i)\[qubit\]\*scale_factor)
>
> rabi_values = np.real(baseline_remove(rabi_values))
>
> plt.xlabel(\"Drive amp \[a.u.\]\")
>
> plt.ylabel(\"Measured signal \[a.u.\]\")
>
> plt.scatter(drive_amps, rabi_values, color=\'black\') \# plot real
> part of Rabi values
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image336.png)

> fit_params, y_fit = fit_function(drive_amps,
>
> rabi_values,
>
> lambda x, A, B, drive_period, phi: (A\*np.cos(2\*np.pi\*x/drive_period
> - phi) + B),
>
> \[3, 0.1, 0.5, 0\])
>
> plt.scatter(drive_amps, rabi_values, color=\'black\')
>
> plt.plot(drive_amps, y_fit, color=\'red\')
>
> drive_period = fit_params\[2\] \# get period of rabi oscillation
>
> plt.axvline(drive_period/2, color=\'red\', linestyle=\'\--\')
>
> plt.axvline(drive_period, color=\'red\', linestyle=\'\--\')
>
> plt.annotate(\"\", xy=(drive_period, 0), xytext=(drive_period/2,0),
> arrowprops=dict(arrowstyle=\"\<-\>\", color=\'red\'))
>
> plt.annotate(\"\$\\pi\$\", xy=(drive_period/2-0.03, 0.1),
> color=\'red\')
>
> plt.xlabel(\"Drive amp \[a.u.\]\", fontsize=15)
>
> plt.ylabel(\"Measured signal \[a.u.\]\", fontsize=15)
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image337.png)

> pi_amp = abs(drive_period / 2)
>
> print(f\"Pi Amplitude = {pi_amp}\")
>
> è¾“å‡ºï¼š
>
> Pi Amplitude = 0.23772202140312107

##### $\mathbf{\pi}$è„‰å†²

ç°åœ¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨åˆšæ‰æ‰¾åˆ°çš„å¹…å€¼å®šä¹‰è„‰å†²äº†ï¼Œå¹¶å¯åœ¨ä¹‹åçš„å®éªŒä¸­ä½¿ç”¨ã€‚

> pi_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> amp=pi_amp,
>
> sigma=drive_sigma,
>
> name=\'pi_pulse\')

#### 3.2 ç¡®å®š0è¿˜æ˜¯1

ä¸€æ—¦$\pi$è„‰å†²ç»è¿‡æ ¡å‡†ï¼Œå°±èƒ½ä»¥é«˜æ¦‚ç‡åˆ›å»ºæ€$|1\rangle$ã€‚æˆ‘ä»¬é€šè¿‡é‡å¤åˆ¶å¤‡ä»¥åŠç»˜åˆ¶æµ‹é‡ä¿¡å·æ¥æ‰¾å‡ºæ€$|0\rangle$å’Œæ€$|1\rangle$åœ¨æµ‹é‡æ—¶æ‰€å‘ˆç°çŠ¶æ€ã€‚è¿™å°±æ˜¯åˆ›å»ºé‰´é¢‘å™¨ï¼ˆdiscriminatorï¼‰çš„è¿‡ç¨‹ï¼Œå…¶ä¸ºæ¥å—ä¸€ä¸ªå·²æµ‹é‡çš„æ ¸å¿ƒè´Ÿæ•°ï¼ˆmeas_level=1ï¼‰ä»¥åŠå°†å…¶åˆ†ç±»ä¸º0æˆ–1ï¼ˆmeas_level=2ï¼‰çš„ç®€å•å‡½æ•°ã€‚

> \# Create two schedules
>
> \# Ground state schedule
>
> gnd_schedule = pulse.Schedule(name=\"ground state\")
>
> gnd_schedule += measure
>
> \# Excited state schedule
>
> exc_schedule = pulse.Schedule(name=\"excited state\")
>
> exc_schedule += Play(pi_pulse, drive_chan) \# We found this in Part 2A
> above
>
> exc_schedule += measure \<\< exc_schedule.duration
>
> gnd_schedule.draw(label=True)
>
> è¾“å‡ºï¼š

![](pics/media/image338.png)

> exc_schedule.draw(label=True)
>
> è¾“å‡ºï¼š

![](pics/media/image339.png)

æˆ‘ä»¬å°†åŸºæ€å’Œæ¿€å‘æ€å‡†å¤‡è°ƒåº¦æ±‡æ€»åˆ°ä¸€ä¸ªQobjä¸­ã€‚å…¶ä¸­çš„æ¯ä¸€ä¸ªéƒ½è¦è¿è¡Œnum_shotsæ¬¡ã€‚åœ¨æœ¬æ¬¡å®éªŒä¸­æˆ‘ä»¬è®¾ç½®å‚æ•°meas_level=1ï¼Œå› ä¸ºæ— éœ€å·²åˆ†ç±»ä¸ºæ€$\left| 0 \right\rangle$å’Œæ€$|1\rangle$çš„ç»“æœã€‚ç›¸åæœ¬æ¬¡å®éªŒæˆ‘ä»¬æƒ³è¦æ ¸å¿ƒæ•°æ®ï¼šæ‰€é‡‡é›†çš„åŸå§‹æ•°æ®å·²é€šè¿‡æ ¸å‡½æ•°æ¯æ¬¡éƒ½ç”Ÿæˆå•ä¸€å¤æ•°å€¼ã€‚æ‚¨å¯ä»¥å°†æ ¸å‡½æ•°æƒ³è±¡ä¸ºåº”ç”¨äºåŸå§‹æµ‹é‡æ•°æ®çš„ç‚¹ç§¯ã€‚æˆ‘ä»¬ä¼šä¸ºä¸¤ä¸ªè°ƒåº¦ä¼ é€’åŒä¸€é¢‘ç‡ï¼Œå°½ç®¡è¿™ä¸€é¢‘ç‡ä»…ç”±å‡½æ•°exc_scheduleä½¿ç”¨ã€‚

> \# Execution settings
>
> num_shots = 1024
>
> gnd_exc_program = assemble(\[gnd_schedule, exc_schedule\],
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'single\',
>
> shots=num_shots,
>
> schedule_los=\[{drive_chan: rough_qubit_frequency}\] \* 2)
>
> \# print(job.job_id())
>
> job = backend.run(gnd_exc_program)
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> gnd_exc_results = job.result(timeout=120)

è‡³æ­¤å°±è·å¾—äº†ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ªç®€å•çš„æ•£ç‚¹å›¾ä¸Šå¯è§†åŒ–æ‰€å‡†å¤‡çš„ä¸¤ä¸ªæ€»ä½“ï¼Œè“è‰²æ˜¾ç¤ºåŸºæ€ç¨‹åºçš„ç»“æœï¼Œçº¢è‰²æ˜¾ç¤ºæ¿€å‘æ€å‡†å¤‡ç¨‹åºçš„ç»“æœã€‚

> gnd_results = gnd_exc_results.get_memory(0)\[:, qubit\]\*scale_factor
>
> exc_results = gnd_exc_results.get_memory(1)\[:, qubit\]\*scale_factor
>
> plt.figure(figsize=\[4,4\])
>
> \# Plot all the results
>
> \# All results from the gnd_schedule are plotted in blue
>
> plt.scatter(np.real(gnd_results), np.imag(gnd_results),
>
> s=5, cmap=\'viridis\', c=\'blue\', alpha=0.5, label=\'state_0\')
>
> \# All results from the exc_schedule are plotted in red
>
> plt.scatter(np.real(exc_results), np.imag(exc_results),
>
> s=5, cmap=\'viridis\', c=\'red\', alpha=0.5, label=\'state_1\')
>
> \# Plot a large dot for the average result of the 0 and 1 states.
>
> mean_gnd = np.mean(gnd_results) \# takes mean of both real and
> imaginary parts
>
> mean_exc = np.mean(exc_results)
>
> plt.scatter(np.real(mean_gnd), np.imag(mean_gnd),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0,
> label=\'state_0\_mean\')
>
> plt.scatter(np.real(mean_exc), np.imag(mean_exc),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0,
> label=\'state_1\_mean\')
>
> plt.ylabel(\'I \[a.u.\]\', fontsize=15)
>
> plt.xlabel(\'Q \[a.u.\]\', fontsize=15)
>
> plt.title(\"0-1 discrimination\", fontsize=15)
>
> plt.show()

![](pics/media/image340.png)

ä»ä¸Šå›¾ä¸­å¯ä»¥æ¸…æ¥šåœ°çœ‹å‡ºç»“æœåˆ†ä¸ºä¸¤ä¸ª$\left| 0 \right\rangle$å’Œ$|1\rangle$çš„ä¸¤ä¸ªç°‡ã€‚æ ¸æµ‹é‡ç»“æœé€šè¿‡èƒ½å¤Ÿæœ€ä½³åŒºåˆ†è¿™ä¸¤ä¸ªç°‡çš„é‰´é¢‘å™¨åˆ†ç±»ï¼Œä½¿ç”¨meas_levelä½¿å¾—0å˜ä¸º1ã€‚æœ€ä½³åŒºåˆ†ä»…æ˜¯åœ¨IQå¹³é¢ä¸Šçš„ä¸€æ¡çº¿ï¼Œè¯¥çº¿ä¸ä¸Šå›¾ä¸­çš„ä¸¤ä¸ªé»‘ç‚¹çš„å¹³å‡ç»“æœç­‰è·ï¼Œå¹¶ä¸”å‚ç›´äºè¿æ¥ä¸¤é»‘ç‚¹çš„çº¿ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡è‹¥ä¸€ä¸ªç»™å®šçš„ç‚¹æ¥è¿‘äºåŸºæ€ç»“æœçš„å‡å€¼è¿”å›0ï¼Œæ¥è¿‘äºæ¿€å‘æ€ç»“æœçš„å‡å€¼åˆ™è¿”å›1æ¥è®¾ç½®ä¸€ä¸ªå¿«é€Ÿçš„åˆ†ç±»å‡½æ•°ã€‚

> import math
>
> def classify(point: complex):
>
> \"\"\"Classify the given state as \|0\> or \|1\>.\"\"\"
>
> def distance(a, b):
>
> return math.sqrt((np.real(a) - np.real(b))\*\*2 + (np.imag(a) -
> np.imag(b))\*\*2)
>
> return int(distance(point, mean_exc) \< distance(point, mean_gnd))

#### 3.3 ä½¿ç”¨åè½¬æ¢å¤æµ‹é‡$\mathbf{T}_{\mathbf{1}}$

ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„$T_{1}$æ—¶é—´æ˜¯å…¶ä»æ¿€å‘æ€å˜ä¸ºåŸºæ€çš„å»¶è¿Ÿæ—¶é—´ã€‚è¿™ä¸€æ—¶é—´éå¸¸é‡è¦ï¼Œå› å…¶é™åˆ¶äº†æˆ‘ä»¬å¯åœ¨é‡å­è®¡ç®—æœºä¸Šè¿è¡Œç¨‹åºçš„å¯ç”¨æŒç»­æ—¶é—´ã€‚

å¯¹$T_{1}$æ—¶é—´çš„æµ‹é‡ä¸ä¹‹å‰çš„å®éªŒç›¸ä¼¼ï¼Œä½¿ç”¨å·²æ ¡å‡†çš„$\pi$è„‰å†²ã€‚æˆ‘ä»¬ä¼šå†æ¬¡ä½¿ç”¨å•ä¸ªé©±åŠ¨è„‰å†²ï¼ˆ$\pi$è„‰å†²ï¼‰ï¼Œç„¶åæ–½åŠ ä¸€ä¸ªæµ‹é‡è„‰å†²ã€‚ç„¶è€Œï¼Œæ­¤æ—¶å¹¶éå¦‚åŒå…ˆå‰é‚£æ ·ç›´æ¥å¯¹å…¶æµ‹é‡ï¼Œæˆ‘ä»¬ä¼šå…ˆæ’å…¥ä¸€ä¸ªå»¶è¿Ÿå¹¶åœ¨ä¸åŒçš„å®éªŒä¹‹é—´æ›´æ”¹å»¶è¿Ÿçš„æ—¶é—´ã€‚å½“ç”»å‡ºæµ‹å¾—ä¿¡å·ä¸å»¶è¿Ÿæ—¶é—´çš„å›¾å½¢æ—¶ï¼Œå°†ä¼šçœ‹åˆ°åœ¨é‡å­æ¯”ç‰¹é‡Šæ”¾èƒ½é‡æ—¶ä¿¡å·å‘ˆç°æŒ‡æ•°å½¢å¼çš„è¡°å‡ã€‚è¿™ä¸€å»¶è¿Ÿæ—¶é—´å°±æ˜¯é‡å­æ¯”ç‰¹çš„é©°è±«æ—¶é—´$T_{1}$ã€‚

> \# T1 experiment parameters
>
> time_max_us = 450
>
> time_step_us = 6
>
> times_us = np.arange(1, time_max_us, time_step_us)
>
> \# Convert to units of dt
>
> delay_times_dt = times_us \* us / dt
>
> \# We will use the same \`pi_pulse\` and qubit frequency that we
> calibrated and used before
>
> \# Create schedules for the experiment
>
> t1_schedules = \[\]
>
> for delay in delay_times_dt:
>
> this_schedule = pulse.Schedule(name=f\"T1 delay = {delay \* dt/us}
> us\")
>
> this_schedule += Play(pi_pulse, drive_chan)
>
> this_schedule \|= measure \<\< int(delay)
>
> t1_schedules.append(this_schedule)

æˆ‘ä»¬ä¹Ÿå¯ä»¥æ£€æŸ¥$T_{1}$è°ƒåº¦ã€‚ä¸ºäº†èƒ½å¤ŸçœŸæ­£ç†è§£è¿™ä¸ªå®éªŒçš„æ„ä¹‰ï¼Œå¯ä»¥æ›´æ”¹sched_idxçš„å€¼åè¿è¡Œä¸‹é¢çš„ä»£ç æ¥å°è¯•ä¸åŒçš„è°ƒåº¦ã€‚åœ¨å¢å¤§sched_idxæ—¶ï¼Œæ‚¨å°†ä¼šçœ‹åˆ°æµ‹é‡è„‰å†²å¼€å§‹ã€‚

> sched_idx = 0
>
> t1_schedules\[sched_idx\].draw(label=True)

![](pics/media/image341.png)

> \# Execution settings
>
> num_shots = 256
>
> t1_experiment = assemble(t1_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots,
>
> schedule_los=\[{drive_chan: rough_qubit_frequency}\] \*
> len(t1_schedules))
>
> job = backend.run(t1_experiment)
>
> \# print(job.job_id())
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> t1_results = job.result(timeout=120)
>
> t1_values = \[\]
>
> for i in range(len(times_us)):
>
> t1_values.append(t1_results.get_memory(i)\[qubit\]\*scale_factor)
>
> t1_values = np.real(t1_values)
>
> plt.scatter(times_us, t1_values, color=\'black\')
>
> plt.title(\"\$T_1\$ Experiment\", fontsize=15)
>
> plt.xlabel(\'Delay before measurement \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Signal \[a.u.\]\', fontsize=15)
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image342.png)

ç„¶åï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†æ•°æ®ä¸è¡°å‡æŒ‡æ•°è¿›è¡Œæ‹Ÿåˆï¼Œä»è€Œå¾—åˆ°$T_{1}$ï¼

> \# Fit the data
>
> fit_params, y_fit = fit_function(times_us, t1_values,
>
> lambda x, A, C, T1: (A \* np.exp(-x / T1) + C),
>
> \[-3, 3, 100\]
>
> )
>
> \_, \_, T1 = fit_params
>
> plt.scatter(times_us, t1_values, color=\'black\')
>
> plt.plot(times_us, y_fit, color=\'red\', label=f\"T1 = {T1:.2f} us\")
>
> plt.xlim(0, np.max(times_us))
>
> plt.title(\"\$T_1\$ Experiment\", fontsize=15)
>
> plt.xlabel(\'Delay before measurement \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Signal \[a.u.\]\', fontsize=15)
>
> plt.legend()
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image343.png)

### 4.ç¡®å®šé‡å­æ¯”ç‰¹çš„ç›¸å¹²æ€§ï¼ˆCoherenceï¼‰

#### 4.1 ä½¿ç”¨Ramseyå®éªŒç²¾ç¡®æµ‹é‡é‡å­æ¯”ç‰¹çš„é¢‘ç‡

ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä¼šåœ¨æ›´ä½³çš„ç²¾åº¦ä¸Šç¡®å®šé‡å­æ¯”ç‰¹çš„é¢‘ç‡ï¼Œè¿™ä¸€è¿‡ç¨‹ä½¿ç”¨Ramseyè„‰å†²åºåˆ—æ¥å®Œæˆã€‚åœ¨è¿™ä¸ªè„‰å†²åºåˆ—ä¸­ï¼Œæˆ‘ä»¬ä¼šå…ˆæ–½åŠ ä¸€ä¸ª$\pi/2$çš„è„‰å†²å¹¶ç­‰å¾…$\Delta t$çš„æ—¶é—´ï¼Œä½œç”¨å¦ä¸€ä¸ª$\pi/2$è„‰å†²ã€‚ç”±äºæ‰€æµ‹é‡çš„ä¿¡å·æ¥è‡ªä¸è„‰å†²é¢‘ç‡ç›¸åŒçš„é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿè§‚å¯Ÿåˆ°æ‰€æ–½åŠ è„‰å†²å’Œé‡å­æ¯”ç‰¹ä¹‹é—´é¢‘ç‡å·®å¤„çš„æ³¢åŠ¨ã€‚

![](pics/media/image344.png)

> \# Ramsey experiment parameters
>
> time_max_us = 1.8
>
> time_step_us = 0.025
>
> times_us = np.arange(0.1, time_max_us, time_step_us)
>
> \# Convert to units of dt
>
> delay_times_dt = times_us \* us / dt
>
> \# Drive parameters
>
> \# The drive amplitude for pi/2 is simply half the amplitude of the pi
> pulse
>
> drive_amp = pi_amp / 2
>
> \# x_90 is a concise way to say pi_over_2; i.e., an X rotation of 90
> degrees
>
> x90_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> amp=drive_amp,
>
> sigma=drive_sigma,
>
> name=\'x90_pulse\')
>
> \# create schedules for Ramsey experiment
>
> ramsey_schedules = \[\]
>
> for delay in delay_times_dt:
>
> this_schedule = pulse.Schedule(name=f\"Ramsey delay = {delay \* dt /
> us} us\")
>
> this_schedule \|= Play(x90_pulse, drive_chan)
>
> this_schedule \|= Play(x90_pulse, drive_chan) \<\<
> int(this_schedule.duration + delay)
>
> this_schedule \|= measure \<\< int(this_schedule.duration)
>
> ramsey_schedules.append(this_schedule)

ä¸$T_{1}$è°ƒåº¦ä¸€æ ·ï¼Œå¯å¤šæ¬¡æ‰§è¡Œä¸‹é¢çš„ä»£ç æ¥æ£€æŸ¥å·²ç»åˆ¶å®šçš„ä¸€äº›è°ƒåº¦ä¼šç»™å‡ºå¯ç¤ºã€‚å½“æ‚¨è§‚å¯Ÿramsey_scheduleæŒ‡æ•°å¢é•¿æ—¶ï¼Œä¸¤ä¸ª$\pi/2$è„‰å†²ä¹‹é—´çš„å»¶è¿Ÿå°†ä¼šå¢å¤§ã€‚

ramsey_schedules\[0\].draw(label=True)

![](pics/media/image345.png)

æ­¤å¤„ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªå¸¸ç”¨çš„å®éªŒæŠ€å·§ã€‚æˆ‘ä»¬å°†ä½¿è„‰å†²ä¸ä¸€ä¸ªå·²çŸ¥çš„é‡åå…±æŒ¯ï¼Œç§°ä¹‹ä¸ºå¤±è°å…†èµ«ï¼ˆdetuning_MHzï¼‰ã€‚æ‰€æµ‹å¾—Ramseyä¿¡å·æ‰€æ˜¾ç¤ºçš„é¢‘ç‡åº”æ¥è¿‘å¤±è°å…†èµ«ï¼Œä¸ä¹‹æœ‰å°çš„åç§»ã€‚è¿™ä¸€å°åç§»å°±æ˜¯rough_qubit_frequencyä¸é‡å­æ¯”ç‰¹é¢‘ç‡ä¹‹é—´çš„ç¡®åˆ‡è·ç¦»ã€‚

> \# Execution settings
>
> num_shots = 256
>
> detuning_MHz = 2
>
> ramsey_frequency = round(rough_qubit_frequency + detuning_MHz \* MHz,
> 6) \# need ramsey freq in Hz
>
> ramsey_program = assemble(ramsey_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots,
>
> schedule_los=\[{drive_chan: ramsey_frequency}\]\*len(ramsey_schedules)
>
> )
>
> job = backend.run(ramsey_program)
>
> \# print(job.job_id())
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> ramsey_results = job.result(timeout=120)
>
> ramsey_values = \[\]
>
> for i in range(len(times_us)):
>
> ramsey_values.append(ramsey_results.get_memory(i)\[qubit\]\*scale_factor)
>
> plt.scatter(times_us, np.real(ramsey_values), color=\'black\')
>
> plt.xlim(0, np.max(times_us))
>
> plt.title(\"Ramsey Experiment\", fontsize=15)
>
> plt.xlabel(\'Delay between X90 pulses \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.show()

![](pics/media/image346.png)

æˆ‘ä»¬å°†ä¼šæ‹Ÿåˆæ•°æ®è‡³ä¸ä¸€ä¸ªæ­£å¼¦æ³¢å¹¶æå–æ‰€æ„Ÿå…´è¶£$\Delta f$çš„ä¿¡æ¯ã€‚

> fit_params, y_fit = fit_function(times_us, np.real(ramsey_values),
>
> lambda x, A, del_f\_MHz, C, B: (
>
> A \* np.cos(2\*np.pi\*del_f\_MHz\*x - C) + B
>
> ),
>
> \[5, 1./0.4, 0, 0.25\]
>
> )
>
> \# Off-resonance component
>
> \_, del_f\_MHz, \_, \_, = fit_params \# freq is MHz since times in us
>
> plt.scatter(times_us, np.real(ramsey_values), color=\'black\')
>
> plt.plot(times_us, y_fit, color=\'red\', label=f\"df =
> {del_f\_MHz:.2f} MHz\")
>
> plt.xlim(0, np.max(times_us))
>
> plt.xlabel(\'Delay between X90 pulses \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Ramsey Experiment\', fontsize=15)
>
> plt.legend()
>
> plt.show()

![](pics/media/image347.png)

è‡³æ­¤ï¼Œæˆ‘ä»¬çŸ¥é“del_f\_Mhzåå°±å¯ä»¥æ›´æ–°å¯¹é‡å­æ¯”ç‰¹é¢‘ç‡çš„ä¼°è®¡äº†ã€‚

> precise_qubit_freq = rough_qubit_frequency + (del_f\_MHz -
> detuning_MHz) \* MHz \# get new freq in Hz
>
> print(f\"Our updated qubit frequency is now
> {round(precise_qubit_freq/GHz, 6)} GHz. \"
>
> f\"It used to be {round(rough_qubit_frequency / GHz, 6)} GHz\")
>
> è¾“å‡ºï¼š
>
> Our updated qubit frequency is now 4.974897 GHz. It used to be 4.97467
> GHz

#### ä½¿ç”¨å“ˆæ©å›æ³¢ï¼ˆHahn Echoesï¼‰æµ‹é‡$\mathbf{T}_{\mathbf{2}}$

æ¥ç€ï¼Œæˆ‘ä»¬å°±å¯ä»¥æµ‹é‡é‡å­æ¯”ç‰¹çš„ç›¸å¹²æ—¶é—´$T_{2}$äº†ã€‚æœ¬æ¬¡å®éªŒä¸­æ‰€ä½¿ç”¨çš„è„‰å†²åºåˆ—ç§°ä¹‹ä¸ºå“ˆæ©å›æ³¢ï¼ˆHahn
Echoï¼‰ï¼Œè¿™ã€ä¸€æœ¯è¯­æ¥è‡ªæ ¸ç£å…±æŒ¯ï¼ˆNMRï¼‰å­¦ç•Œã€‚å“ˆæ©å›æ³¢å®éªŒä¸ä¸Šæ–‡ä¸­æ‰€è®²è¯‰çš„Ramseyå®éªŒéå¸¸ç›¸è¯†ï¼Œéƒ½æ˜¯åœ¨ä¸¤ä¸ª$\pi/2$è„‰å†²ä¹‹é—´å¢åŠ ä¸€ä¸ª$\pi$è„‰å†²ã€‚åœ¨æ—¶é—´$\tau$å¤„çš„$\pi$è„‰å†²ä½¿ç´¯ç§¯ç›¸ä½åå‘ï¼Œå¹¶åœ¨æ—¶é—´$2\tau$å¤„äº§ç”Ÿå›æ³¢ï¼Œåœ¨æ­¤æ—¶æ–½åŠ æœ€åçš„$\pi/2$è„‰å†²è¿›è¡Œæµ‹é‡ã€‚

å“ˆæ©å›æ³¢å®éªŒçš„è¡°å‡æ—¶é—´ç»™å‡ºäº†ç›¸å¹²æ—¶é—´$T_{2}$ã€‚

> \# T2 experiment parameters
>
> tau_max_us = 200
>
> tau_step_us = 4
>
> taus_us = np.arange(2, tau_max_us, tau_step_us)
>
> \# Convert to units of dt
>
> delay_times_dt = taus_us \* us / dt
>
> \# We will use the pi_pulse and x90_pulse from previous experiments
>
> t2_schedules = \[\]
>
> for tau in delay_times_dt:
>
> this_schedule = pulse.Schedule(name=f\"T2 delay = {tau \*dt/us} us\")
>
> this_schedule \|= Play(x90_pulse, drive_chan)
>
> this_schedule \|= Play(pi_pulse, drive_chan) \<\<
> int(this_schedule.duration + tau)
>
> this_schedule \|= Play(x90_pulse, drive_chan) \<\<
> int(this_schedule.duration + tau)
>
> this_schedule \|= measure \<\< int(this_schedule.duration)
>
> t2_schedules.append(this_schedule)
>
> t2_schedules\[0\].draw(label=True)

![](pics/media/image348.png)

> \# Execution settings
>
> num_shots_per_point = 512
>
> t2_experiment = assemble(t2_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots_per_point,
>
> schedule_los=\[{drive_chan: precise_qubit_freq}\]
>
> \* len(t2_schedules))
>
> job = backend.run(t2_experiment)
>
> \# print(job.job_id())
>
> job_monitor(job)
>
> t2_results = job.result(timeout=120)
>
> t2_values = \[\]
>
> for i in range(len(taus_us)):
>
> t2_values.append(t2_results.get_memory(i)\[qubit\]\*scale_factor)
>
> plt.scatter(2\*taus_us, np.real(t2_values), color=\'black\')
>
> plt.xlabel(\'Delay between X90 pulse and \$\\pi\$ pulse
> \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Hahn Echo Experiment\', fontsize=15)
>
> plt.show()

![](pics/media/image349.png)

> fit_params, y_fit = fit_function(2\*taus_us, np.real(t2_values),
>
> lambda x, A, B, T2: (A \* np.exp(-x / T2) + B),
>
> \[-3, 0, 100\])
>
> \_, \_, T2 = fit_params
>
> print()
>
> plt.scatter(2\*taus_us, np.real(t2_values), color=\'black\')
>
> plt.plot(2\*taus_us, y_fit, color=\'red\', label=f\"T2 = {T2:.2f}
> us\")
>
> plt.xlim(0, np.max(2\*taus_us))
>
> plt.xlabel(\'Delay between X90 pulse and \$\\pi\$ pulse
> \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Hahn Echo Experiment\', fontsize=15)
>
> plt.legend()
>
> plt.show()

![](pics/media/image350.png)

##### çº§è”åŠ¨æ€è§£è€¦ï¼ˆConcatenated Dynamical Decouplingï¼‰

å•ä¸ª$\pi$è„‰å†²èƒ½å¤Ÿæ¶ˆé™¤ç”±äºåè½¬ç›¸ä½ç´¯ç§¯è€Œäº§ç”Ÿçš„å‡†é™æ€å™ªå£°ã€‚é€šè¿‡è¿ç»­æ–½åŠ å‡ ä¸ª$\pi$è„‰å†²ï¼Œå¯ä»¥å°†æ­¤æ¦‚å¿µæ‰©å±•åˆ°æ— æ³•è¿‘ä¼¼ä¸ºå‡†é™æ€çš„å™ªå£°ã€‚è¿™ä¸€æŠ€æœ¯é€šå¸¸ç§°ä¸ºåŠ¨æ€å»è€¦ï¼ˆdynamical
decouplingï¼‰ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥æ¶ˆé™¤ä¸åŒé¢‘ç‡çš„å™ªå£°ï¼Œå¹¶å¯ä»é‡å­æ¯”ç‰¹ä¸­æå–æ›´é•¿çš„ç›¸å¹²æ—¶é—´ã€‚

> \# DD experiment parameters
>
> tau_us_min = 1
>
> tau_us_max = 40
>
> tau_step_us = 1.5
>
> taus_us = np.arange(tau_us_min, tau_us_max, tau_step_us)
>
> \# Convert to units of dt
>
> taus_dt = taus_us \* us / dt
>
> num_pi_pulses = 6 \# apply 6 pi pulses
>
> print(f\"Total time ranges from {2.\*num_pi_pulses\*taus_us\[0\]} to
> {2.\*num_pi_pulses\*taus_us\[-1\]} us\")
>
> è¾“å‡ºï¼š
>
> Total time ranges from 12.0 to 462.0 us
>
> T2DD_schedules = \[\]
>
> for delay in taus_dt:
>
> this_schedule = pulse.Schedule(name=f\"T2DD delay = {delay \* dt/us}
> us\")
>
> this_schedule \|= Play(x90_pulse, drive_chan)
>
> this_schedule \|= Play(pi_pulse, drive_chan) \<\<
> int(this_schedule.duration + delay)
>
> for \_ in range(num_pi_pulses - 1):
>
> this_schedule \|= Play(pi_pulse, drive_chan) \<\<
> int(this_schedule.duration + 2\*delay)
>
> this_schedule \|= Play(x90_pulse, drive_chan) \<\<
> int(this_schedule.duration + delay)
>
> this_schedule \|= measure \<\< int(this_schedule.duration)
>
> T2DD_schedules.append(this_schedule)
>
> T2DD_schedules\[0\].draw(label=True)

![](pics/media/image351.png)

> num_shots_per_point = 1024
>
> T2DD_experiment = assemble(T2DD_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots_per_point,
>
> schedule_los=\[{drive_chan: precise_qubit_freq}\]
>
> \* len(T2DD_schedules))
>
> job = backend.run(T2DD_experiment)
>
> \# print(job.job_id())
>
> job_monitor(job)
>
> T2DD_results = job.result(timeout=120)
>
> times_us = 2.\*num_pi_pulses\*taus_us
>
> DD_values = \[\]
>
> for i in range(len(taus_us)):
>
> DD_values.append(T2DD_results.get_memory(i)\[qubit\]\*scale_factor)
>
> plt.scatter(times_us, np.real(DD_values), color=\'black\')
>
> plt.xlim(0, np.max(times_us))
>
> plt.xlabel(\'Total time before measurement \[\$\\mu\$s\]\',
> fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Dynamical Decoupling Experiment\', fontsize=15)
>
> plt.show()

![](pics/media/image352.png)

> \# Fit the data
>
> fit_func = lambda x, A, B, T2DD: (A \* np.exp(-x / T2DD) + B)
>
> fitparams, conv = curve_fit(fit_func, times_us, np.real(DD_values),
> \[3.5, 0.8, 150\])
>
> \_, \_, T2DD = fitparams
>
> plt.scatter(times_us, np.real(DD_values), color=\'black\')
>
> plt.plot(times_us, fit_func(times_us, \*fitparams), color=\'red\',
> label=f\"T2DD = {T2DD:.2f} us\")
>
> plt.xlim(\[0, np.max(times_us)\])
>
> plt.xlabel(\'Total time before measurement \[\$\\mu\$s\]\',
> fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Dynamical Decoupling Experiment\', fontsize=15)
>
> plt.legend()
>
> plt.show()

![](pics/media/image353.png)

### 5. å‚è€ƒæ–‡çŒ®

1.  H. Abraham, I. Y. Akhalwaya, G. Aleksandrowicz, T. Alexander, G.
    Alexandrowics, E. Arbel, A. Asfaw, C. Azaustre, P. Barkoutsos, G.
    Barron, L. Bello, Y. Ben-Haim, L. S. Bishop, S. Bosch, D. Bucher,
    CZ, F. Cabrera, P. Calpin, L. Capelluto, J. Carballo, C.-F. Chen, A.
    Chen, R. Chen, J. M. Chow, C. Claus, A. W. Cross, A. J. Cross, J.
    Cruz- Benito, C. Culver, A. D. C Ìorcoles-Gonzales, S. Dague, M.
    Dartiailh, A. R. Davila, D. Ding, E. Dumitrescu, K. Dumon, I.
    Duran, P. Eendebak, D. Egger, M. Everitt, P. M. Fern Ìandez, A.
    Frisch, A. Fuhrer, J. Gacon, Gadi, B. G. Gago, J. M. Gambetta, L.
    Garcia, S. Garion, Gawel-Kus, L. Gil, J. Gomez-Mosquera, S. de la
    Puente Gonz Ìalez, D. Green-
    berg,J.A.Gunnels,I.Haide,I.Hamamura,V.Havlicek,J.Hellmers,Lô°€.Herok,H.Horii, C.
    Howington, W. Hu, S. Hu, H. Imai, T. Imamichi, R. Iten, T. Itoko, A.
    Javadi-Abhari, Jessica, K. Johns, N. Kanazawa, A. Karazeev, P.
    Kassebaum, V. Krishnan, K. Kr- sulich, G. Kus, R. LaRose, R.
    Lambert, J. Latone, S. Lawrence, P. Liu, P. B. Z. Mac, Y. Maeng, A.
    Malyshev, J. Marecek, M. Marques, D. Mathews, A. Matsuo, D. T. Mc-
    Clure, C. McGarry, D. McKay, S. Meesala, A. Mezzacapo, R. Midha, Z.
    Minev, P. Mu- rali, J. Mu Ìˆggenburg, D. Nadlinger, G. Nannicini, P.
    Nation, Y. Naveh, Nick-Singstock, P. Niroula, H. Norlen, L. J.
    O'Riordan, S. Oud, D. Padilha, H. Paik, S. Perriello, A. Phan, M.
    Pistoia, A. Pozas-iKerstjens, V. Prutyanov, J. P Ìerez, Quintiii, R.
    Raymond, R. M.-C. Redondo, M. Reuter, D. M. Rodr ÌÄ±guez, M. Ryu, M.
    Sandberg, N. Sathaye, B. Schmitt, C. Schnabel, T. L. Scholten, E.
    Schoute, I. F. Sertage, Y. Shi, A. Silva, Y. Siraichi, S.
    Sivarajah, J. A. Smolin, M. Soeken, D. Steenken, M. Stypulkoski, H.
    Takahashi, C. Taylor, P. Taylour, S. Thomas, M. Tillet, M. Tod, E.
    de la Torre, K. Trabing, M. Treinish, TrishaPe, W. Turner, Y.
    Vaknin, C. R. Valcarce, F. Varchon, D. Vogt- Lee, C. Vuillot, J.
    Weaver, R. Wieczorek, J. A. Wildstrom, R. Wille, E. Winston, J. J.
    Woehr, S. Woerner, R. Woo, C. J. Wood, R. Wood, S. Wood, J.
    Wootton, D. Yeralin, J. Yu, L. Zdanski, Zoufalc, azulehner,
    drholmie, fanizzamarco, kanejess, klinvill, merav aharoni, ordmoj,
    tigerjack, yang.luh, and yotamvakninibm, "Qiskit: An open-source
    framework for quantum computing," 2019.

2.  D. C. McKay, T. Alexander, L. Bello, M. J. Biercuk, L. Bishop, J.
    Chen, J. M. Chow, A. D. C Ìorcoles, D. Egger, S. Filipp, J.
    Gomez, M. Hush, A. Javadi-Abhari, D. Moreda, P. Nation, B.
    Paulovicks, E. Winston, C. J. Wood, J. Wootton, and J. M. Gambetta,
    "Qiskit backend specifications for OpenQASM and OpenPulse
    experiments," 2018.

æ³¨ï¼š"Qiskit Pulse"ä»¥å‰ç§°ä¸º"OpenPulse"ã€‚

6.2 è®¿é—®æ›´é«˜çš„èƒ½æ€
------------------

åœ¨å¤§éƒ¨åˆ†çš„é‡å­ç®—æ³•/åº”ç”¨ä¸­ï¼Œè®¡ç®—æ˜¯åœ¨ç”±$|0\rangle$å’Œ$|1\rangle$å¼ æˆçš„äºŒç»´ç©ºé—´ä¸Šè¿›è¡Œã€‚ç„¶è€Œï¼Œåœ¨IBMç¡¬ä»¶ä¸­è¿˜å­˜åœ¨ä¸å¸¸ç”¨åˆ°çš„æ›´é«˜èƒ½æ€ã€‚æœ¬èŠ‚çš„é‡ç‚¹æ˜¯ä½¿ç”¨Qiskit
Pulseæ¢ç´¢è¿™äº›çŠ¶æ€ã€‚å…¶ä¸­æ¼”ç¤ºäº†å¦‚ä½•æ¿€å‘æ€$|2\rangle$ï¼Œå¹¶æ„å»ºé‰´åˆ«å™¨æ¥å¯¹æ€$|0\rangle$ã€$|1\rangle$å’Œ$|2\rangle$è¿›è¡Œè¯†åˆ«ã€‚

å»ºè®®æ‚¨å…ˆé˜…è¯»ä¸Šä¸€ç« ï¼Œç„¶åå†é˜…è¯»æœ¬èŠ‚ã€‚è¿˜å»ºè®®æ‚¨é˜…è¯»Qiskit Pulseè¯´æ˜\[1\]ã€‚

### ç‰©ç†èƒŒæ™¯

ç°åœ¨ï¼Œæˆ‘ä»¬æä¾›æœ‰å…³transmoné‡å­æ¯”ç‰¹ï¼ˆtransmission line shunted plasma
oscillation
qubitï¼‰ç‰©ç†å­¦çš„èƒŒæ™¯çŸ¥è¯†ï¼Œå…¶ä¸ºå¤§é‡IBMé‡å­ç¡¬ä»¶çš„åŸºç¡€ã€‚è¿™äº›ç³»ç»ŸåŒ…å«ç”±çº¦ç‘Ÿå¤«æ£®ç»“ï¼ˆJosephson
Junctionï¼ŒJJï¼‰å’Œç”µå®¹å™¨ç»„æˆçš„è¶…å¯¼ç”µè·¯ã€‚å¯¹äºé‚£äº›ä¸ç†Ÿæ‚‰è¶…å¯¼ç”µè·¯çš„äººï¼Œè¯·å‚è§\[2\]çš„è¯„è®ºã€‚è¯¥ç³»ç»Ÿçš„å“ˆå¯†é¡¿é‡ä¸ºï¼š

$$H = 4E_{C}n^{2} - E_{J}\cos(\phi)$$

å…¶ä¸­$E_{C}$å’Œ$E_{J}$è¡¨ç¤ºç”µå®¹å™¨å’Œçº¦ç‘Ÿå¤«æ£®èƒ½é‡ï¼Œ$n$æ˜¯ç®—å­çš„ç¼©å‡ç”µè·æ•°ï¼Œ$\phi$æ˜¯é€šè¿‡çº¦ç‘Ÿå¤«æ£®ç»“æ‰€å‡å°‘çš„é€šé‡ã€‚æˆ‘ä»¬ä»¥$\hslash = 1$ä¸ºå•ä½ã€‚

Transmoné‡å­æ¯”ç‰¹åœ¨å°$\phi$çš„çŠ¶æ€ä¸‹å®šä¹‰ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨æ³°å‹’çº§æ•°ä¸­æ‰©å±•$E_{J}\cos(\phi)$ï¼ˆå¿½ç•¥å¸¸æ•°é¡¹ï¼‰

$$E_{J}\cos(\phi) \approx \frac{1}{2}E_{J}\phi^{2} - \frac{1}{24}E_{J}\phi^{4}\mathcal{+ O(}\phi^{6})$$

äºŒæ¬¡é¡¹$\phi^{2}$å®šä¹‰äº†æ ‡å‡†è°æ³¢æŒ¯è¡å™¨ã€‚æ¯å¢åŠ ä¸€é¡¹å°±ä¼šå¯¼è‡´å¤±è°ã€‚

ä½¿ç”¨å…³ç³»å¼$n \sim (a - a^{\dagger}),\phi \sim (a + a^{\dagger})$ï¼ˆfor
raising, lowering operators
$a^{\dagger},a$ï¼‰ï¼Œå¯ä»¥è¯æ˜è¯¥ç³»ç»Ÿç±»ä¼¼äºå…·æœ‰å“ˆå¯†é¡¿é‡çš„DuffingæŒ¯è¡å™¨ã€‚

$$H = \omega a^{\dagger}a + \frac{\alpha}{2}a^{\dagger}a^{\dagger}\text{aa}$$

å…¶ä¸­$\omega$ç»™å‡ºäº†$0 \rightarrow 1$æ¿€åŠ±é¢‘ç‡ï¼ˆ$\omega \equiv \omega 0 \rightarrow 1$ï¼‰ï¼Œ$\alpha$æ˜¯$0 \rightarrow 1$å’Œ$1 \rightarrow 2$é¢‘ç‡ï¼ˆ$\alpha \equiv \omega 1 \rightarrow 2 - - \omega 0 \rightarrow 1$ï¼‰ä¹‹é—´çš„éè°æ€§ã€‚å¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ é©±åŠ¨é¡¹ã€‚

å¦‚æœé€‰æ‹©æŒ‡å®šçš„æ ‡å‡†äºŒç»´å­ç©ºé—´ï¼Œåˆ™å¯ä½¿$|\alpha|$è¶³å¤Ÿå¤§æˆ–ä½¿ç”¨ç‰¹æ®Šçš„æ§åˆ¶æŠ€æœ¯æ¥æŠ‘åˆ¶æ›´é«˜çš„èƒ½æ€ã€‚

### å†…å®¹

1.  å¼€å§‹

2.  åŒºåˆ†æ€0å’Œæ€1

    1.  æ€0-\>æ€1 é¢‘ç‡æ‰«æ

    2.  æ€0-\>æ€1 Rabiå®éªŒ

    3.  æ„å»ºåŒºåˆ†0ã€1çš„é‰´é¢‘å™¨

3.  åŒºåˆ†æ€0ã€æ€1å’Œæ€2

> 2.1 è®¡ç®—ä½¿å¾—$1 \rightarrow 2$çš„é¢‘ç‡
>
> 2.1.1 ä½¿ç”¨è¾¹å¸¦æ³•å¯¹$1 \rightarrow 2$è¿‡ç¨‹è¿›è¡Œé¢‘ç‡æ‰«æ
>
> 2.2 æ€1-\>æ€2 Rabiå®éªŒ
>
> 2.3 æ„å»ºåŒºåˆ†0ã€1åŠ2çš„é‰´é¢‘å™¨

3\. å‚è€ƒæ–‡çŒ®

### å¼€å§‹

æˆ‘ä»¬ç”±å¯¼å…¥ç›¸å…³çš„åº“ä»¥åŠå®šä¹‰ä¸€ä¸‹é»˜è®¤å˜é‡å€¼å¼€å§‹ã€‚æ­¤å¤„é€‰æ‹©é‡å­æ¯”ç‰¹0å¹¶åœ¨å…¬ç”¨å•é‡å­æ¯”ç‰¹è®¾å¤‡ibmq_armonkä¸Šè¿›è¡Œå®éªŒã€‚

> import numpy as np
>
> import matplotlib.pyplot as plt
>
> from scipy.optimize import curve_fit
>
> from scipy.signal import find_peaks
>
> from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
>
> from sklearn.model_selection import train_test_split
>
> import qiskit.pulse as pulse
>
> import qiskit.pulse.pulse_lib as pulse_lib
>
> from qiskit.compiler import assemble
>
> from qiskit.pulse.commands import SamplePulse
>
> from qiskit.tools.monitor import job_monitor
>
> import warnings
>
> warnings.filterwarnings(\'ignore\')
>
> from qiskit.tools.jupyter import \*
>
> %matplotlib inline
>
> from qiskit import IBMQ
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\', group=\'open\',
> project=\'main\')
>
> backend = provider.get_backend(\'ibmq_armonk\')
>
> backend_config = backend.configuration()
>
> assert backend_config.open_pulse, \"Backend doesn\'t support Pulse\"
>
> dt = backend_config.dt
>
> backend_defaults = backend.defaults()
>
> \# unit conversion factors -\> all backend properties returned in SI
> (Hz, sec, etc)
>
> GHz = 1.0e9 \# Gigahertz
>
> MHz = 1.0e6 \# Megahertz
>
> us = 1.0e-6 \# Microseconds
>
> ns = 1.0e-9 \# Nanoseconds
>
> qubit = 0 \# qubit we will analyze
>
> default_qubit_freq = backend_defaults.qubit_freq_est\[qubit\] \#
> Default qubit frequency in Hz.
>
> print(f\"Qubit {qubit} has an estimated frequency of
> {default_qubit_freq/ GHz} GHz.\")
>
> \# scale data (specific to each device)
>
> scale_factor = 1e-14
>
> \# number of shots for our experiments
>
> NUM_SHOTS = 1024
>
> \#\#\# Collect the necessary channels
>
> drive_chan = pulse.DriveChannel(qubit)
>
> meas_chan = pulse.MeasureChannel(qubit)
>
> acq_chan = pulse.AcquireChannel(qubit)
>
> è¾“å‡ºï¼š
>
> Qubit 0 has an estimated frequency of 4.974291768298264 GHz.

ä¸‹é¢çš„ä»£ç å®šäº†ä¸€äº›è¾…åŠ©å‡½æ•°ï¼š

> def get_job_data(job, average):
>
> \"\"\"Retrieve data from a job that has already run.
>
> Args:
>
> job (Job): The job whose data you want.
>
> average (bool): If True, gets the data assuming data is an average.
>
> If False, gets the data assuming it is for single shots.
>
> Return:
>
> list: List containing job result data.
>
> \"\"\"
>
> job_results = job.result(timeout=120) \# timeout parameter set to 120
> s
>
> result_data = \[\]
>
> for i in range(len(job_results.results)):
>
> if average: \# get avg data
>
> result_data.append(job_results.get_memory(i)\[qubit\]\*scale_factor)
>
> else: \# get single data
>
> result_data.append(job_results.get_memory(i)\[:,
> qubit\]\*scale_factor)
>
> return result_data
>
> def get_closest_multiple_of_16(num):
>
> \"\"\"Compute the nearest multiple of 16. Needed because pulse enabled
> devices require
>
> durations which are multiples of 16 samples.
>
> \"\"\"
>
> return (int(num) - (int(num)%16))

è®¾ç½®ä¸€äº›é©±åŠ¨è„‰å†²å’Œæµ‹é‡çš„é»˜è®¤å‚æ•°ã€‚ä½¿ç”¨æŒ‡ä»¤è°ƒåº¦æ˜ å°„ï¼ˆåç«¯é»˜è®¤å€¼ï¼‰ä¸­çš„measureå‘½ä»¤ï¼Œä»¥ä¾¿ä½¿ç”¨æ–°æ ¡å‡†å¯¹å…¶è¿›è¡Œæ›´æ–°ã€‚

> \# Drive pulse parameters (us = microseconds)
>
> drive_sigma_us = 0.075 \# This determines the actual width of the
> gaussian
>
> drive_samples_us = drive_sigma_us\*8 \# This is a truncating
> parameter, because gaussians don\'t have
>
> \# a natural finite length
>
> drive_sigma = get_closest_multiple_of_16(drive_sigma_us \* us /dt) \#
> The width of the gaussian in units of dt
>
> drive_samples = get_closest_multiple_of_16(drive_samples_us \* us /dt)
> \# The truncating parameter in units of dt
>
> \# Find out which measurement map index is needed for this qubit
>
> meas_map_idx = None
>
> for i, measure_group in enumerate(backend_config.meas_map):
>
> if qubit in measure_group:
>
> meas_map_idx = i
>
> break
>
> assert meas_map_idx is not None, f\"Couldn\'t find qubit {qubit} in
> the meas_map!\"
>
> \# Get default measurement pulse from instruction schedule map
>
> inst_sched_map = backend_defaults.instruction_schedule_map
>
> measure = inst_sched_map.get(\'measure\',
> qubits=backend_config.meas_map\[meas_map_idx\])

### åŒºåˆ†æ€$\mathbf{|0}\mathbf{\rangle}$å’Œæ€$\mathbf{|1}\mathbf{\rangle}$

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šæ„å»ºä¸€ä¸ªåŒºåˆ†æ ‡å‡†æ€$|0\rangle$å’Œ$|1\rangle$çš„é‰´é¢‘å™¨ã€‚è¯¥é‰´é¢‘å™¨çš„ä»»åŠ¡æ˜¯æ¥å—meas_level=1æ—¶çš„å¤æ•°æ•°æ®å¹¶å°†å…¶åˆ†ç±»ä¸ºmeas_level=2çš„æ ‡å‡†æ€$|0\rangle$å’Œ$|1\rangle$ï¼Œæ­¤å¤„ä¼šåˆ©ç”¨åˆ°ä¸Šä¸€ç« ä¸­çš„å†…å®¹ã€‚æ‰€äº§ç”Ÿçš„ç»“æœåœ¨æ¿€å‘æ›´é«˜çš„èƒ½æ€æ—¶å¿…ä¼šè¢«ä½¿ç”¨åˆ°ï¼Œè€Œæ›´é«˜çš„èƒ½æ€æ˜¯æœ¬notebookçš„é‡ç‚¹ã€‚

#### 1.1 æ€0-\>æ€1 é¢‘ç‡æ‰«æ

æ­£å¦‚ä¸Šä¸€ç« ä¸­æ‰€è¿°ï¼Œæ ¡å‡†é‡å­æ¯”ç‰¹é¢‘ç‡çš„ç¬¬ä¸€æ­¥æ˜¯æ„å»ºé‰´é¢‘å™¨ã€‚

> def create_ground_freq_sweep_program(freqs, drive_power):
>
> \"\"\"Builds a program that does a freq sweep by exciting the ground
> state.
>
> Depending on drive power this can reveal the 0-\>1 frequency or the
> 0-\>2 frequency.
>
> Args:
>
> freqs (np.ndarray(dtype=float)): Numpy array of frequencies to sweep.
>
> drive_power (float) : Value of drive amplitude.
>
> Raises:
>
> ValueError: Raised if use more than 75 frequencies; currently, an
> error will be thrown on the backend
>
> if you try to do this.
>
> Returns:
>
> Qobj: Program for ground freq sweep experiment.
>
> \"\"\"
>
> if len(freqs) \> 75:
>
> raise ValueError(\"You can only run 75 schedules at a time.\")
>
> \# print information on the sweep
>
> print(f\"The frequency sweep will go from {freqs\[0\] / GHz} GHz to
> {freqs\[-1\]/ GHz} GHz using {len(freqs)} frequencies. The drive power
> is {drive_power}.\")
>
> \# Define the drive pulse
>
> ground_sweep_drive_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> sigma=drive_sigma,
>
> amp=drive_power,
>
> name=\'ground_sweep_drive_pulse\')
>
> \# Create the base schedule
>
> schedule = pulse.Schedule(name=\'Frequency sweep starting from ground
> state.\')
>
> schedule \|= ground_sweep_drive_pulse(drive_chan)
>
> schedule \|= measure \<\< schedule.duration
>
> \# define frequencies for the sweep
>
> schedule_freqs = \[{drive_chan: freq} for freq in freqs\]
>
> \# assemble the program
>
> \# Note: we only require a single schedule since each does the same
> thing;
>
> \# for each schedule, the LO frequency that mixes down the drive
> changes
>
> \# this enables our frequency sweep
>
> ground_freq_sweep_program = assemble(schedule,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=NUM_SHOTS,
>
> schedule_los=schedule_freqs)
>
> return ground_freq_sweep_program
>
> \# We will sweep 40 MHz around the estimated frequency, with 75
> frequencies
>
> num_freqs = 75
>
> ground_sweep_freqs = default_qubit_freq + np.linspace(-20\*MHz,
> 20\*MHz, num_freqs)
>
> ground_freq_sweep_program =
> create_ground_freq_sweep_program(ground_sweep_freqs, drive_power=0.3)
>
> è¾“å‡ºï¼š
>
> The frequency sweep will go from 4.954291768298265 GHz to
> 4.994291768298265
>
> ground_freq_sweep_job = backend.run(ground_freq_sweep_program)
>
> print(ground_freq_sweep_job.job_id())
>
> job_monitor(ground_freq_sweep_job)
>
> è¾“å‡ºï¼š
>
> 5e8d9cfaff553c0012179aa4
>
> Job Status: job has successfully run
>
> \# Get the job data (average)
>
> ground_freq_sweep_data = get_job_data(ground_freq_sweep_job,
> average=True)

å°†æ•°æ®æ•°æ®æ‹Ÿåˆè‡³ä¸€æ¡æ´›ä¼¦å…¹æ›²çº¿å¹¶æå–æ ¡å‡†é¢‘ç‡ã€‚

> def fit_function(x_values, y_values, function, init_params):
>
> \"\"\"Fit a function using scipy curve_fit.\"\"\"
>
> fitparams, conv = curve_fit(function, x_values, y_values, init_params)
>
> y_fit = function(x_values, \*fitparams)
>
> return fitparams, y_fit
>
> \# do fit in Hz
>
> (ground_sweep_fit_params,
>
> ground_sweep_y\_fit) = fit_function(ground_sweep_freqs,
>
> ground_freq_sweep_data,
>
> lambda x, A, q_freq, B, C: (A / np.pi) \* (B / ((x - q_freq)\*\*2 +
> B\*\*2)) + C,
>
> \[7, 4.975\*GHz, 1\*GHz, 3\*GHz\] \# initial parameters for curve_fit
>
> )
>
> \# Note: we are only plotting the real part of the signal
>
> plt.scatter(ground_sweep_freqs/GHz, ground_freq_sweep_data,
> color=\'black\')
>
> plt.plot(ground_sweep_freqs/GHz, ground_sweep_y\_fit, color=\'red\')
>
> plt.xlim(\[min(ground_sweep_freqs/GHz), max(ground_sweep_freqs/GHz)\])
>
> plt.xlabel(\"Frequency \[GHz\]\", fontsize=15)
>
> plt.ylabel(\"Measured Signal \[a.u.\]\", fontsize=15)
>
> plt.title(\"0-\>1 Frequency Sweep\", fontsize=15)
>
> plt.show()

![](pics/media/image354.png)

> \_, cal_qubit_freq, \_, \_ = ground_sweep_fit_params
>
> print(f\"We\'ve updated our qubit frequency estimate from \"
>
> f\"{round(default_qubit_freq/GHz, 7)} GHz to
> {round(cal_qubit_freq/GHz, 7)} GHz.\")
>
> è¾“å‡ºï¼š
>
> We\'ve updated our qubit frequency estimate from 4.9742918 GHz to
> 4.9743098 GHz.

#### 1.2 æ€0-\>æ€1 Rabiå®éªŒ

ç„¶åï¼Œè¿è¡ŒRabiå®éªŒè®¡ç®—$0 \rightarrow 1$æ—¶çš„$\pi$è„‰å†²çš„å¹…å€¼ã€‚ä¸€ä¸ª$\pi$è„‰å†²æ˜¯å°†æ€$|0\rangle$è½¬æ¢ä¸ºæ€$|1\rangle$çš„è„‰å†²ï¼ˆåœ¨å¸ƒæ´›èµ«çƒä¸­çš„ä¸€ä¸ª$\pi$æ—‹è½¬ï¼‰ã€‚

> \# experimental configuration
>
> num_rabi_points = 50 \# number of experiments (ie amplitudes to sweep
> out)
>
> \# Drive amplitude values to iterate over: 50 amplitudes evenly spaced
> from 0 to 0.75
>
> drive_amp_min = 0
>
> drive_amp_max = 0.75
>
> drive_amps = np.linspace(drive_amp_min, drive_amp_max,
> num_rabi_points)
>
> \# Create schedule
>
> rabi_01_schedules = \[\]
>
> \# loop over all drive amplitudes
>
> for ii, drive_amp in enumerate(drive_amps):
>
> \# drive pulse
>
> rabi_01_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> amp=drive_amp,
>
> sigma=drive_sigma,
>
> name=\'rabi_01_pulse\_%d\' % ii)
>
> \# add commands to schedule
>
> schedule = pulse.Schedule(name=\'Rabi Experiment at drive amp = %s\' %
> drive_amp)
>
> schedule \|= rabi_01_pulse(drive_chan)
>
> schedule \|= measure \<\< schedule.duration \# shift measurement to
> after drive pulse
>
> rabi_01_schedules.append(schedule)
>
> \# Assemble the schedules into a program
>
> \# Note: We drive at the calibrated frequency.
>
> rabi_01_expt_program = assemble(rabi_01_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\]
>
> \* num_rabi_points)
>
> rabi_01_job = backend.run(rabi_01_expt_program)
>
> print(rabi_01_job.job_id())
>
> job_monitor(rabi_01_job)
>
> è¾“å‡ºï¼š
>
> 5e8d9d8c76f61000120ff6ca
>
> Job Status: job has successfully run
>
> \# Get the job data (average)
>
> rabi_01_data = get_job_data(rabi_01_job, average=True)
>
> def baseline_remove(values):
>
> \"\"\"Center data around 0.\"\"\"
>
> return np.array(values) - np.mean(values)
>
> \# Note: Only real part of data is plotted
>
> rabi_01_data = np.real(baseline_remove(rabi_01_data))
>
> (rabi_01_fit_params,
>
> rabi_01_y\_fit) = fit_function(drive_amps,
>
> rabi_01_data,
>
> lambda x, A, B, drive_01_period, phi:
> (A\*np.cos(2\*np.pi\*x/drive_01_period - phi) + B),
>
> \[4, -4, 0.5, 0\])
>
> plt.scatter(drive_amps, rabi_01_data, color=\'black\')
>
> plt.plot(drive_amps, rabi_01_y\_fit, color=\'red\')
>
> drive_01_period = rabi_01_fit_params\[2\]
>
> \# account for phi in computing pi amp
>
> pi_amp_01 = (drive_01_period/2/np.pi)
> \*(np.pi+rabi_01_fit_params\[3\])
>
> plt.axvline(pi_amp_01, color=\'red\', linestyle=\'\--\')
>
> plt.axvline(pi_amp_01+drive_01_period/2, color=\'red\',
> linestyle=\'\--\')
>
> plt.annotate(\"\", xy=(pi_amp_01+drive_01_period/2, 0),
> xytext=(pi_amp_01,0), arrowprops=dict(arrowstyle=\"\<-\>\",
> color=\'red\'))
>
> plt.annotate(\"\$\\pi\$\", xy=(pi_amp_01-0.03, 0.1), color=\'red\')
>
> plt.xlabel(\"Drive amp \[a.u.\]\", fontsize=15)
>
> plt.ylabel(\"Measured signal \[a.u.\]\", fontsize=15)
>
> plt.title(\'0-\>1 Rabi Experiment\', fontsize=15)
>
> plt.show()

![](pics/media/image4.png)

> print(f\"Pi Amplitude (0-\>1) = {pi_amp_01}\")
>
> è¾“å‡ºï¼š
>
> Pi Amplitude (0-\>1) = 0.24347362693346655

ä½¿ç”¨ä¸Šè¿°ç»“æœå°±å¯ä»¥å®šä¹‰$0 \rightarrow 1$çš„$\pi$è„‰å†²äº†ã€‚

> pi_pulse_01 = pulse_lib.gaussian(duration=drive_samples,
>
> amp=pi_amp_01,
>
> sigma=drive_sigma,
>
> name=\'pi_pulse_01\')

#### 1.3 æ„å»ºåŒºåˆ†0ã€1çš„é‰´é¢‘å™¨

ç»è¿‡ä¸Šè¿°çš„å‡†å¤‡å·¥ä½œï¼Œæˆ‘ä»¬å·²ç»è·å¾—äº†æ ¡å‡†çš„é¢‘ç‡ä»¥åŠ$\pi$è„‰å†²ï¼Œæ¥ç€å°±æ˜¯æ„å»ºåŒºåˆ†æ€$|0\rangle$å’Œæ€$|1\rangle$çš„é‰´é¢‘å™¨äº†ã€‚è¯¥é‰´é¢‘å™¨æ¥å—åœ¨IQå¹³é¢ä¸­meas_level=1æ—¶çš„æ•°æ®å¹¶å°†å…¶åˆ†ç±»ä¸ºæ€$|0\rangle$å’Œæ€$|1\rangle$ã€‚

æ€$|0\rangle$å’Œæ€$|1\rangle$åœ¨IQå¹³é¢ä¸­æ‰€å½¢æˆçš„ç›¸å¹²åœ†å½¢"æ–‘ç‚¹"ç§°ä¸ºè´¨å¿ƒï¼ˆcentroidï¼‰ã€‚è´¨å¿ƒçš„ä¸­å¿ƒå®šä¹‰äº†æ¯ä¸ªçŠ¶æ€çš„ç²¾ç¡®ä¸”æ— å™ªå£°çš„IQç‚¹ã€‚å›´ç»•åœ¨å‘¨å›´çš„äº‘ç»™å‡ºäº†æ•°æ®çš„æ–¹å·®ï¼Œè¯¥æ–¹å·®æ˜¯ç”±å„ç§å™ªå£°æºæ‰€ç”Ÿæˆã€‚

æˆ‘ä»¬å°†ä¼šåº”ç”¨ä¸€ç§æœºå™¨å­¦ä¹ çš„æŠ€æœ¯------çº¿æ€§åˆ¤åˆ«åˆ†æï¼ˆLinear Discriminant
Analysisï¼ŒLDAï¼‰æ¥åŒºåˆ†æ€$|0\rangle$å’Œæ€$|1\rangle$ã€‚

é¦–å…ˆéœ€è¦è·å–è´¨å¿ƒçš„æ•°æ®ï¼Œä¸ºæ­¤æˆ‘ä»¬å®šäº†ä¸¤ä¸ªè°ƒåº¦ï¼ˆå›æƒ³ä¸€ä¸‹ä»æ€$|0\rangle$å¼€å§‹çš„ç³»ç»Ÿï¼‰ï¼š

1\. ç›´æ¥æµ‹é‡æ€$|0\rangle$ï¼Œè·å–æ€$|0\rangle$çš„è´¨å¿ƒã€‚

2\. æ–½åŠ ä¸€ä¸ª$\pi$è„‰å†²åæµ‹é‡å¹¶è·å–æ€$|1\rangle$çš„è´¨å¿ƒã€‚

> \# Create the two schedules
>
> \# Ground state schedule
>
> zero_schedule = pulse.Schedule(name=\"zero schedule\")
>
> zero_schedule \|= measure
>
> \# Excited state schedule
>
> one_schedule = pulse.Schedule(name=\"one schedule\")
>
> one_schedule \|= pi_pulse_01(drive_chan)
>
> one_schedule \|= measure \<\< one_schedule.duration
>
> \# Assemble the schedules into a program
>
> IQ_01_program = assemble(\[zero_schedule, one_schedule\],
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'single\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\] \* 2)
>
> IQ_01_job = backend.run(IQ_01_program)
>
> print(IQ_01_job.job_id())
>
> job_monitor(IQ_01_job)
>
> è¾“å‡ºï¼š
>
> 5e8d9dffff553c0012179aae
>
> Job Status: job has successfully run
>
> \# Get job data (single); split for zero and one
>
> IQ_01_data = get_job_data(IQ_01_job, average=False)
>
> zero_data = IQ_01_data\[0\]
>
> one_data = IQ_01_data\[1\]
>
> def IQ_01_plot(x_min, x_max, y_min, y_max):
>
> \"\"\"Helper function for plotting IQ plane for \|0\>, \|1\>. Limits
> of plot given
>
> as arguments.\"\"\"
>
> \# zero data plotted in blue
>
> plt.scatter(np.real(zero_data), np.imag(zero_data),
>
> s=5, cmap=\'viridis\', c=\'blue\', alpha=0.5,
> label=r\'\$\|0\\rangle\$\')
>
> \# one data plotted in red
>
> plt.scatter(np.real(one_data), np.imag(one_data),
>
> s=5, cmap=\'viridis\', c=\'red\', alpha=0.5,
> label=r\'\$\|1\\rangle\$\')
>
> \# Plot a large dot for the average result of the zero and one states.
>
> mean_zero = np.mean(zero_data) \# takes mean of both real and
> imaginary parts
>
> mean_one = np.mean(one_data)
>
> plt.scatter(np.real(mean_zero), np.imag(mean_zero),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.scatter(np.real(mean_one), np.imag(mean_one),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.xlim(x_min, x_max)
>
> plt.ylim(y_min,y_max)
>
> plt.legend()
>
> plt.ylabel(\'I \[a.u.\]\', fontsize=15)
>
> plt.xlabel(\'Q \[a.u.\]\', fontsize=15)
>
> plt.title(\"0-1 discrimination\", fontsize=15)
>
> x_min = -5
>
> x_max = 15
>
> y_min = -5
>
> y_max = 10
>
> IQ_01_plot(x_min, x_max, y_min, y_max)

æ‰€æ˜¾ç¤ºçš„IQå›¾ä¸­è“è‰²è´¨å¿ƒä¸ºæ€$|0\rangle$ï¼Œçº¢è‰²è´¨å¿ƒä¸ºæ€$|1\rangle$ã€‚

**æ³¨ï¼šå¦‚æœç»˜å›¾ä¸æ­£ç¡®ï¼Œè¯·é‡æ–°è¿è¡Œè¯¥notebookã€‚**

![](pics/media/image355.png)

è‡³æ­¤ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç²¾ç¡®çš„æ„å»ºé‰´é¢‘å™¨äº†ã€‚æ­£å¦‚ä¸Šæ–‡ä¸­æ‰€è¿°ï¼Œæˆ‘ä»¬å°†ä¼šç”¨åˆ°ä¸€ç§åä¸º"çº¿æ€§åˆ¤åˆ«åˆ†æï¼ˆLDAï¼‰"çš„æœºå™¨å­¦ä¹ æŠ€æœ¯ã€‚é€šè¿‡æœ€å¤§åŒ–æ¯ä¸ªç±»åˆ«çš„å‡å€¼ä¹‹é—´çš„è·ç¦»å¹¶æœ€å°åŒ–æ¯ä¸ªç±»åˆ«å†…çš„æ–¹å·®ï¼ŒLDAå¯å°†ä»»æ„æ•°æ®é›†åˆ’åˆ†ä¸ºä¸€ç»„ç±»åˆ«ï¼Œæ­¤å¤„ä¸ºæ€$|0\rangle$å’Œ$|1\rangle$ã€‚è¯¦ç»†ä¿¡æ¯è¯·å‚é˜…\[3\]ã€‚

LDAä¼šç”Ÿæˆç§°ä¸ºåˆ†ç•Œçº¿çš„ä¸€æ¡çº¿ã€‚ä¾æ®ç»™å®šæ•°æ®ç‚¹åœ¨åˆ†ç•Œçº¿çš„å“ªä¸€ä¾§ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šå…¶å±äºå“ªä¸ªç±»åˆ«ã€‚åœ¨æœ¬ç¤ºä¾‹ä¸­ï¼Œåˆ†éš”çº¿çš„ä¸€ä¾§å¯¹åº”äºæ€$|0\rangle$ï¼Œå¦ä¸€ä¾§å¯¹åº”äºæ€$|1\rangle$ã€‚

æˆ‘ä»¬å°†ä¼šä½¿ç”¨æ‰€å¾—çš„ä¸€åŠæ•°æ®æ¥è®­ç»ƒæ¨¡å‹ï¼Œç„¶åç”¨å¦ä¸€åŠè¿›è¡Œæµ‹è¯•ã€‚æ­¤å¤„ä½¿ç”¨scikit.learnæ¥å®ç°LDAï¼›åœ¨ä»¥åçš„Qiskitç‰ˆæœ¬ä¸­æ­¤åŠŸèƒ½å°†ç›´æ¥æ·»åŠ åˆ°æ¨¡å—[Qiskit-Ignis](https://github.com/Qiskit/qiskit-ignis/tree/master/qiskit/ignis/measurement/discriminator)ã€‚

é¦–å…ˆï¼Œå°†ç»“æœæ•°æ®é‡å¡‘ä¸ºé€‚åˆåŒºåˆ†çš„æ ¼å¼ã€‚

> def reshape_complex_vec(vec):
>
> \"\"\"Take in complex vector vec and return 2d array w/ real, imag
> entries. This is needed for the learning.
>
> Args:
>
> vec (list): complex vector of data
>
> Returns:
>
> list: vector w/ entries given by (real(vec\], imag(vec))
>
> \"\"\"
>
> length = len(vec)
>
> vec_reshaped = np.zeros((length, 2))
>
> for i in range(len(vec)):
>
> vec_reshaped\[i\]=\[np.real(vec\[i\]), np.imag(vec\[i\])\]
>
> return vec_reshaped
>
> \# Create IQ vector (split real, imag parts)
>
> zero_data_reshaped = reshape_complex_vec(zero_data)
>
> one_data_reshaped = reshape_complex_vec(one_data)
>
> IQ_01_data = np.concatenate((zero_data_reshaped, one_data_reshaped))
>
> print(IQ_01_data.shape) \# verify IQ data shape
>
> è¾“å‡ºï¼š
>
> ï¼ˆ2048ï¼Œ2ï¼‰

ç„¶åï¼Œå°†é‡å¡‘åçš„æ•°æ®åˆ†ä¸ºè®­ç»ƒé›†å’Œæµ‹è¯•é›†ã€‚ä¸ºäº†å¾—åˆ°é¢„æœŸçš„æ•ˆæœï¼Œæ­¤å¤„ä½¿ç”¨æ€å‘é‡è¿›è¡Œæµ‹è¯•ï¼Œæ•°ç»„ä¸­çš„0ä¸ºåŸºæ€è°ƒåº¦ï¼Œ1ä¸ºæ¿€å‘è°ƒåº¦ã€‚

> \# construct vector w/ 0\'s and 1\'s (for testing)
>
> state_01 = np.zeros(NUM_SHOTS) \# shots gives number of experiments
>
> state_01 = np.concatenate((state_01, np.ones(NUM_SHOTS)))
>
> print(len(state_01))
>
> \# Shuffle and split data into training and test sets
>
> IQ_01_train, IQ_01_test, state_01_train, state_01_test =
> train_test_split(IQ_01_data, state_01, test_size=0.5)
>
> è¾“å‡ºï¼š
>
> 2048

æœ€åï¼Œå»ºç«‹æ¨¡å‹å¹¶è¿›è¡Œè®­ç»ƒã€‚ä¸‹é¢çš„ä»£ç ç”¨äºæ‰“å°å‡ºæ‹Ÿåˆç²¾åº¦ã€‚

> \# Set up the LDA
>
> LDA_01 = LinearDiscriminantAnalysis()
>
> LDA_01.fit(IQ_01_train, state_01_train)
>
> è¾“å‡ºï¼š
>
> LinearDiscriminantAnalysis(n_components=None, priors=None,
> shrinkage=None,
>
> solver=\'svd\', store_covariance=False, tol=0.0001)
>
> \# test on some simple data
>
> print(LDA_01.predict(\[\[0,0\], \[10, 0\]\]))
>
> è¾“å‡ºï¼š
>
> \[0. 1.\]
>
> \# Compute accuracy
>
> score_01 = LDA_01.score(IQ_01_test, state_01_test)
>
> print(score_01)
>
> è¾“å‡ºï¼š
>
> 0.927734375

æœ€åä¸€æ­¥æ˜¯ç”»å‡ºåˆ†ç•Œçº¿ã€‚

> \# Plot separatrix on top of scatter
>
> def separatrixPlot(lda, x_min, x_max, y_min, y_max, shots):
>
> nx, ny = shots, shots
>
> xx, yy = np.meshgrid(np.linspace(x_min, x_max, nx),
>
> np.linspace(y_min, y_max, ny))
>
> Z = lda.predict_proba(np.c\_\[xx.ravel(), yy.ravel()\])
>
> Z = Z\[:, 1\].reshape(xx.shape)
>
> plt.contour(xx, yy, Z, \[0.5\], linewidths=2., colors=\'black\')
>
> IQ_01_plot(x_min, x_max, y_min, y_max)
>
> separatrixPlot(LDA_01, x_min, x_max, y_min, y_max, NUM_SHOTS)

![](pics/media/image356.png)

å¯ä»¥çœ‹åˆ°åˆ†éš”çº¿çš„æ¯ä¸€ä¾§å¯¹åº”äºæŸä¸€çŠ¶æ€çš„è´¨å¿ƒã€‚ç»™å®šIQå¹³é¢ä¸­çš„ä¸€ä¸ªç‚¹ï¼Œè¯¥æ¨¡å‹å°†æ£€æŸ¥å…¶ä½äºåˆ†éš”çº¿çš„å“ªä¸€ä¾§å¹¶è¿”å›ç›¸åº”çš„çŠ¶æ€ã€‚

### åŒºåˆ†æ€0ã€æ€1å’Œæ€2

ç»è¿‡ä¸Šè¿°çš„æ­¥éª¤ï¼Œæˆ‘ä»¬å·²ç»æ ¡å‡†äº†$0/1$é‰´é¢‘å™¨ï¼Œæ¥ç€å°±éœ€è¦æ¿€å‘æ›´é«˜çš„èƒ½æ€äº†ã€‚å…·ä½“ä¸ºï¼šæ¿€å‘æ€$|2\rangle$å¹¶ä¾æ®æ€$|0\rangle$ã€$|1\rangle$å’Œ$|2\rangle$æ‰€å¯¹åº”çš„IQæ•°æ®æ„å»ºé‰´é¢‘å™¨ã€‚å¯¹äºæ›´é«˜çš„èƒ½æ€å¦‚$|3\rangle$ç­‰è¿™ä¸€è¿‡ç¨‹åŒæ ·é€‚ç”¨ï¼Œæœ¬æ–‡ä¸­å°±ä¸å†ç´¯è¿°ã€‚

æ„å»ºæ›´é«˜èƒ½æ€é‰´é¢‘å™¨çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š

1.  è®¡ç®—$1 \rightarrow 2$çš„é¢‘ç‡

2.  å®æ–½Rabiå®éªŒæ¥è·å–$1 \rightarrow 2$çš„$\pi$è„‰å†²å¹…å€¼ã€‚ä¸ºäº†å®ç°è¿™ä¸€æ­¥éª¤ï¼Œé¦–å…ˆéœ€è¦æ–½åŠ ä¸€ä¸ª$0 \rightarrow 1$çš„$\pi$è„‰å†²ï¼Œä½¿å¾—æ€$|0\rangle$è½¬æ¢ä¸ºæ€$|1\rangle$ã€‚ç„¶åï¼Œé€šè¿‡é¢‘ç‡æ‰«æè·å–ä½¿å¾—$1 \rightarrow 2$é¢‘ç‡çš„é©±åŠ¨å¹…

3.  å®æ–½3ä¸ªè°ƒåº¦ï¼š

    a.  0è°ƒåº¦ï¼ˆZero scheduleï¼‰ï¼šä»…æµ‹é‡åŸºæ€ã€‚

    b.  1è°ƒåº¦ï¼ˆOne
        > scheduleï¼‰ï¼šæ–½åŠ ä¸€ä¸ª$\pi$è„‰å†²ä½¿å¾—$0 \rightarrow 1$å¹¶æµ‹é‡ã€‚

    c.  2è°ƒåº¦ï¼ˆTwo
        > scheduleï¼‰ï¼šæ–½åŠ ä¸€ä¸ª$\pi$è„‰å†²ä½¿å¾—$0 \rightarrow 1$åæ–½åŠ å¦ä¸€ä¸ª$\pi$è„‰å†²ä½¿å¾—$1 \rightarrow 2$ï¼Œç„¶åæµ‹é‡ã€‚

4.  å°†æ¯ä¸ªè°ƒåº¦çš„æ•°æ®åˆ’åˆ†ä¸ºè®­ç»ƒé›†å’Œæµ‹è¯•é›†ï¼Œç„¶åä¸ºé‰´é¢‘å™¨åˆ›å»ºä¸€ä¸ªLDAæ¨¡å‹ã€‚

#### 2.1 è®¡ç®—ä½¿å¾—$\mathbf{1 \rightarrow 2}$çš„é¢‘ç‡

æ ¡å‡†çš„ç¬¬ä¸€æ­¥æ˜¯è®¡ç®—ä»$1 \rightarrow 2$æ‰€éœ€çš„é¢‘ç‡ã€‚æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼š

1.  æ–½åŠ å¾ˆé«˜çš„åŠŸç‡ä»åŸºæ€è¿›è¡Œé¢‘ç‡æ‰«æã€‚å¦‚æœæ–½åŠ çš„åŠŸç‡è¶³å¤Ÿå¤§ï¼Œåˆ™åº”è§‚å¯Ÿåˆ°ä¸¤ä¸ªå³°å€¼ã€‚å…¶ä¸­çš„ä¸€ä¸ªæ˜¯åœ¨ç¬¬1èŠ‚ä¸­ä½¿å¾—$0 \rightarrow 1$çš„é¢‘ç‡ï¼Œå¦ä¸€ä¸ªæ˜¯ä½¿å¾—$0 \rightarrow 2$çš„é¢‘ç‡ã€‚å–ä¸¤è€…ä¹‹å·®å³å¯å¾—åˆ°ä½¿å¾—$1 \rightarrow 2$çš„é¢‘ç‡ã€‚ä½†ç”±äºibmq_armonkçš„æœ€å¤§é©±åŠ¨åŠŸç‡ä¸º$1.0$ï¼Œä¸è¶³ä»¥çœ‹åˆ°è¿™ä¸€å˜æ¢ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨ç¬¬äºŒç§æ–¹æ³•ã€‚

2.  é€šè¿‡æ–½åŠ ä¸€ä¸ªä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²æ¥æ¿€å‘æ€$|1\rangle$ã€‚ç„¶ååœ¨å·²æ¿€å‘çš„æ€$|1\rangle$ç†µè¿›è¡Œé¢‘ç‡æ‰«æã€‚åº”èƒ½åœ¨ä½äºä½¿å¾—$0 \rightarrow 1$çš„é¢‘ç‡ä¸‹è§‚å¯Ÿåˆ°ä½¿å¾—$1 \rightarrow 2$é¢‘ç‡çš„ä¸€ä¸ªå³°å€¼ã€‚

##### 2.1.1 ä½¿ç”¨è¾¹å¸¦æ³•å¯¹$\mathbf{1 \rightarrow 2}$è¿‡ç¨‹è¿›è¡Œé¢‘ç‡æ‰«æ

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¦ä½¿ç”¨ä¸Šè¿°çš„ç¬¬äºŒç§æ–¹æ³•ã€‚ä¸ºäº†é©±åŠ¨ä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²ï¼Œéœ€è¦æœ¬åœ°æŒ¯è¡å™¨(Local
Oscillator
ï¼ŒLO)çš„é¢‘ç‡ç”±æ ¡å‡†$0 \rightarrow 1$é¢‘ç‡çš„cal_qubit_freqç»™å‡ºï¼ˆå¯åœ¨ç¬¬ä¸€èŠ‚ä¸­çœ‹åˆ°Rabi
$\pi$è„‰å†²çš„æ„å»ºè¿‡ç¨‹ï¼‰ã€‚è‹¥è¦æ‰«æ$1 \rightarrow 2$é¢‘ç‡èŒƒå›´å°±éœ€è¦æ”¹å˜LOé¢‘ç‡ã€‚ä½†æ˜¯ï¼Œè„‰å†²è§„èŒƒè¦æ±‚æ¯ä¸€è°ƒåº¦åªæœ‰ä¸€ä¸ªLOé¢‘ç‡ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å°†LOé¢‘ç‡è®¾ç½®ä¸ºcal_qubit_freqï¼Œå¹¶å°†æ­£å¼¦å‡½æ•°ä¹˜ä»¥freq-cal_qubit_freqçš„$1 \rightarrow 2$è„‰å†²ï¼Œå…¶ä¸­freqæ˜¯æ‰€éœ€çš„æ‰«æé¢‘ç‡ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œæ–½åŠ æ­£å¼¦è¾¹å¸¦ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ›´æ”¹LOé¢‘ç‡ï¼Œè€Œæ— éœ€åœ¨å°è£…ç¨‹åºæ—¶æ‰‹åŠ¨è®¾ç½®ã€‚

> def apply_sideband(pulse, freq):
>
> \"\"\"Apply a sinusoidal sideband to this pulse at frequency freq.
>
> Args:
>
> pulse (SamplePulse): The pulse of interest.
>
> freq (float): LO frequency for which we want to apply the sweep.
>
> Return:
>
> SamplePulse: Pulse with a sideband applied (oscillates at difference
> between freq and cal_qubit_freq).
>
> \"\"\"
>
> \# time goes from 0 to dt\*drive_samples, sine arg of form 2\*pi\*f\*t
>
> t_samples = np.linspace(0, dt\*drive_samples, drive_samples)
>
> sine_pulse = np.sin(2\*np.pi\*(freq-cal_qubit_freq)\*t_samples) \# no
> amp for the sine
>
> \# create sample pulse w/ sideband applied
>
> \# Note: need to make sq_pulse.samples real, multiply elementwise
>
> sideband_pulse = SamplePulse(np.multiply(np.real(pulse.samples),
> sine_pulse), name=\'sideband_pulse\')
>
> return sideband_pulse

æŠŠä¸Šè¿°é€»è¾‘è¿‡ç¨‹å°è£…åœ¨ä¸€ä¸ªæ–¹æ³•ä¸­ï¼Œç„¶åè¿è¡Œè¯¥ç¨‹åºã€‚

> def create_excited_freq_sweep_program(freqs, drive_power):
>
> \"\"\"Builds a program that does a freq sweep by exciting the \|1\>
> state.
>
> This allows us to obtain the 1-\>2 frequency. We get from the \|0\> to
> \|1\>
>
> state via a pi pulse using the calibrated qubit frequency. To do the
>
> frequency sweep from \|1\> to \|2\>, we use a sideband method by
> tacking
>
> a sine factor onto the sweep drive pulse.
>
> Args:
>
> freqs (np.ndarray(dtype=float)): Numpy array of frequencies to sweep.
>
> drive_power (float) : Value of drive amplitude.
>
> Raises:
>
> ValueError: Thrown if use more than 75 frequencies; currently, an
> error will be thrown on the backend
>
> if you try more than 75 frequencies.
>
> Returns:
>
> Qobj: Program for freq sweep experiment.
>
> \"\"\"
>
> if len(freqs) \> 75:
>
> raise ValueError(\"You can only run 75 schedules at a time.\")
>
> print(f\"The frequency sweep will go from {freqs\[0\] / GHz} GHz to
> {freqs\[-1\]/ GHz} GHz \\
>
> using {len(freqs)} frequencies. The drive power is {drive_power}.\")
>
> base_12_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> sigma=drive_sigma,
>
> amp=drive_power,
>
> name=\'base_12_pulse\')
>
> schedules = \[\]
>
> for jj, freq in enumerate(freqs):
>
> \# add sideband to gaussian pulse
>
> freq_sweep_12_pulse = apply_sideband(base_12_pulse, freq)
>
> \# add commands to schedule
>
> schedule = pulse.Schedule(name=\"Frequency = {}\".format(freq))
>
> \# Add 0-\>1 pulse, freq sweep pulse and measure
>
> schedule \|= pi_pulse_01(drive_chan)
>
> schedule \|= freq_sweep_12_pulse(drive_chan) \<\< schedule.duration
>
> schedule \|= measure \<\< schedule.duration \# shift measurement to
> after drive pulses
>
> schedules.append(schedule)
>
> num_freqs = len(freqs)
>
> \# draw a schedule
>
> display(schedules\[-1\].draw(channels_to_plot=\[drive_chan,
> meas_chan\], label=True, scaling=1.0))
>
> \# assemble freq sweep program
>
> \# Note: LO is at cal_qubit_freq for each schedule; accounted for by
> sideband
>
> excited_freq_sweep_program = assemble(schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\]
>
> \* num_freqs)
>
> return excited_freq_sweep_program
>
> \# sweep 400 MHz below 0-\>1 frequency to catch the 1-\>2 frequency
>
> num_freqs = 75
>
> excited_sweep_freqs = cal_qubit_freq + np.linspace(-400\*MHz, 30\*MHz,
> num_freqs)
>
> excited_freq_sweep_program =
> create_excited_freq_sweep_program(excited_sweep_freqs,
> drive_power=0.3)
>
> \# Plot an example schedule to make sure it\'s valid
>
> è¾“å‡ºï¼š
>
> The frequency sweep will go from 4.574309813098239 GHz to
> 5.004309813098239 GHz using 75 frequencies. The drive power is 0.3.

![](pics/media/image357.png)

> excited_freq_sweep_job = backend.run(excited_freq_sweep_program)
>
> print(excited_freq_sweep_job.job_id())
>
> job_monitor(excited_freq_sweep_job)
>
> è¾“å‡ºï¼š
>
> 5e8da0965c27d000137e9587
>
> Job Status: job has successfully run
>
> \# Get job data (avg)
>
> excited_freq_sweep_data = get_job_data(excited_freq_sweep_job,
> average=True)
>
> \# Note: we are only plotting the real part of the signal
>
> plt.scatter(excited_sweep_freqs/GHz, excited_freq_sweep_data,
> color=\'black\')
>
> plt.xlim(\[min(excited_sweep_freqs/GHz)+0.01,
> max(excited_sweep_freqs/GHz)\]) \# ignore min point (is off)
>
> plt.xlabel(\"Frequency \[GHz\]\", fontsize=15)
>
> plt.ylabel(\"Measured Signal \[a.u.\]\", fontsize=15)
>
> plt.title(\"1-\>2 Frequency Sweep (first pass)\", fontsize=15)
>
> plt.show()

![](pics/media/image358.png)

å¯ä»¥çœ‹åˆ°æœ€å°å€¼åœ¨4.64GHzé™„è¿‘ã€‚æœ‰ä¸€äº›è™šå‡æœ€å¤§å€¼ï¼Œä½†å› å…¶è¿‡å¤§ï¼Œæ— æ³•è¾¾åˆ°ä½¿å¾—$1 \rightarrow 2$çš„é¢‘ç‡ã€‚æœ€å°å€¼å¯¹åº”äº$1 \rightarrow 2$é¢‘ç‡ã€‚

é€šè¿‡ç›¸å¯¹æå°ï¼ˆrelative
minimaï¼‰å‡½æ•°å¯ä»¥ç²¾ç¡®è®¡ç®—è¯¥ç‚¹çš„å€¼ã€‚è¿™æ ·å°±å¯ä»¥ä¼°ç®—å‡º$1 \rightarrow 2$çš„é¢‘ç‡ã€‚

> \# Prints out relative minima frequencies in output_data; height gives
> lower bound (abs val)
>
> def rel_minima(freqs, output_data, height):
>
> \"\"\"
>
> Prints out relative minima frequencies in output_data (can see peaks);
> height gives upper bound (abs val).
>
> Be sure to set the height properly or the peak will be ignored!
>
> Args:
>
> freqs (list): frequency list
>
> output_data (list): list of resulting signals
>
> height (float): upper bound (abs val) on a peak
>
> Returns:
>
> list: List containing relative minima frequencies
>
> \"\"\"
>
> peaks, \_ = find_peaks(-1\*output_data, height)
>
> print(\"Freq. dips: \", freqs\[peaks\])
>
> return freqs\[peaks\]
>
> minima = rel_minima(excited_sweep_freqs,
> np.real(excited_freq_sweep_data), 10)
>
> approx_12_freq = minima\[0\]
>
> è¾“å‡ºï¼š
>
> Freq. dips: \[4.62660711e+09\]

ç°åœ¨ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸Šé¢è·å¾—çš„ä¼°è®¡å€¼ï¼ˆè¾ƒå°çš„èŒƒå›´ï¼‰è¿›è¡Œç²¾ç¡®æ‰«æã€‚è¿™å°†è®©æˆ‘ä»¬è·å¾—ä½¿å¾—$1 \rightarrow 2$æ›´å‡†ç¡®çš„é¢‘ç‡å€¼ã€‚åœ¨æ¯ä¸ªæ–¹å‘ä¸Šä»¥20MHzæ‰«æã€‚

> \# smaller range refined sweep
>
> num_freqs = 75
>
> refined_excited_sweep_freqs = approx_12_freq + np.linspace(-20\*MHz,
> 20\*MHz, num_freqs)
>
> refined_excited_freq_sweep_program =
> create_excited_freq_sweep_program(refined_excited_sweep_freqs,
> drive_power=0.3)
>
> è¾“å‡ºï¼š
>
> The frequency sweep will go from 4.606607110395537 GHz to
> 4.646607110395537 GHz using 75 frequencies. The drive power is 0.3.

![](pics/media/image359.png)

> refined_excited_freq_sweep_job =
> backend.run(refined_excited_freq_sweep_program)
>
> print(refined_excited_freq_sweep_job.job_id())
>
> job_monitor(refined_excited_freq_sweep_job)
>
> è¾“å‡ºï¼š
>
> 5e8da1283ab1aa0011fd1772
>
> Job Status: job has successfully run
>
> \# Get the refined data (average)
>
> refined_excited_freq_sweep_data =
> get_job_data(refined_excited_freq_sweep_job, average=True)

ä½¿ç”¨æ ‡å‡†æ´›ä¼¦å…¹æ›²çº¿æ‹Ÿåˆç²¾ç¡®ä¿¡å·ã€‚

> \# do fit in Hz
>
> (refined_excited_sweep_fit_params,
>
> refined_excited_sweep_y\_fit) =
> fit_function(refined_excited_sweep_freqs,
>
> refined_excited_freq_sweep_data,
>
> lambda x, A, q_freq, B, C: (A / np.pi) \* (B / ((x - q_freq)\*\*2 +
> B\*\*2)) + C,
>
> \[-12, 4.625\*GHz, 0.05\*GHz, 3\*GHz\] \# initial parameters for
> curve_fit
>
> )
>
> \# Note: we are only plotting the real part of the signal
>
> plt.scatter(refined_excited_sweep_freqs/GHz,
> refined_excited_freq_sweep_data, color=\'black\')
>
> plt.plot(refined_excited_sweep_freqs/GHz,
> refined_excited_sweep_y\_fit, color=\'red\')
>
> plt.xlim(\[min(refined_excited_sweep_freqs/GHz),
> max(refined_excited_sweep_freqs/GHz)\])
>
> plt.xlabel(\"Frequency \[GHz\]\", fontsize=15)
>
> plt.ylabel(\"Measured Signal \[a.u.\]\", fontsize=15)
>
> plt.title(\"1-\>2 Frequency Sweep (refined pass)\", fontsize=15)
>
> plt.show()

![](pics/media/image360.png)

> \_, qubit_12_freq, \_, \_ = refined_excited_sweep_fit_params
>
> print(f\"Our updated estimate for the 1-\>2 transition frequency is \"
>
> f\"{round(qubit_12_freq/GHz, 7)} GHz.\")
>
> è¾“å‡ºï¼š
>
> Our updated estimate for the 1-\>2 transition frequency is 4.6261106
> GHz.

#### 2.2 æ€1-\>æ€2 Rabiå®éªŒ

ç»è¿‡ä¸Šè¿°çš„æ­¥éª¤ï¼Œæˆ‘ä»¬å¯¹ä½¿å¾—$1 \rightarrow 2$çš„é¢‘ç‡æœ‰äº†ä¸€ä¸ªå¾ˆå¥½çš„ä¼°è®¡ï¼Œç°åœ¨å®æ–½Rabiå®éªŒæ¥è·å¾—ä½¿å¾—$1 \rightarrow 2$çš„$\pi$è„‰å†²å¹…å€¼ã€‚ä¸ºæ­¤ï¼Œéœ€è¦æ–½åŠ ä¸€ä¸ªä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²ï¼Œç„¶åè¿ç”¨è¾¹å¸¦æ–¹æ³•ä»¥ä½¿å¾—$1 \rightarrow 2$çš„é¢‘ç‡æ‰«æé©±åŠ¨å¹…å€¼ã€‚

> \# experimental configuration
>
> num_rabi_points = 75 \# number of experiments (ie amplitudes to sweep
> out)
>
> \# Drive amplitude values to iterate over: 75 amplitudes evenly spaced
> from 0 to 1.0
>
> drive_amp_min = 0
>
> drive_amp_max = 1.0
>
> drive_amps = np.linspace(drive_amp_min, drive_amp_max,
> num_rabi_points)
>
> \# Create schedule
>
> rabi_12_schedules = \[\]
>
> \# loop over all drive amplitudes
>
> for ii, drive_amp in enumerate(drive_amps):
>
> base_12_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> sigma=drive_sigma,
>
> amp=drive_amp,
>
> name=\'base_12_pulse\')
>
> \# apply sideband at the 1-\>2 frequency
>
> rabi_12_pulse = apply_sideband(base_12_pulse, qubit_12_freq)
>
> \# add commands to schedule
>
> schedule = pulse.Schedule(name=\'Rabi Experiment at drive amp = %s\' %
> drive_amp)
>
> schedule \|= pi_pulse_01(drive_chan) \# 0-\>1
>
> schedule \|= rabi_12_pulse(drive_chan) \<\< schedule.duration \# 1-\>2
> Rabi pulse
>
> schedule \|= measure \<\< schedule.duration \# shift measurement to
> after drive pulse
>
> rabi_12_schedules.append(schedule)
>
> \# Assemble the schedules into a program
>
> \# Note: The LO frequency is at cal_qubit_freq to support the 0-\>1 pi
> pulse;
>
> \# it is modified for the 1-\>2 pulse using sidebanding
>
> rabi_12_expt_program = assemble(rabi_12_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\]
>
> \* num_rabi_points)
>
> rabi_12_job = backend.run(rabi_12_expt_program)
>
> print(rabi_12_job.job_id())
>
> job_monitor(rabi_12_job)
>
> è¾“å‡ºï¼š
>
> 5e8da3a1ff553c0012179ade
>
> Job Status: job has successfully run
>
> \# Get the job data (average)
>
> rabi_12_data = get_job_data(rabi_12_job, average=True)

ç»˜åˆ¶å¹¶æ‹Ÿåˆæ•°æ®ã€‚

> \# Note: We only plot the real part of the signal.
>
> rabi_12_data = np.real(baseline_remove(rabi_12_data))
>
> (rabi_12_fit_params,
>
> rabi_12_y\_fit) = fit_function(drive_amps,
>
> rabi_12_data,
>
> lambda x, A, B, drive_12_period, phi:
> (A\*np.cos(2\*np.pi\*x/drive_12_period - phi) + B),
>
> \[3, 0.5, 0.9, 0\])
>
> plt.scatter(drive_amps, rabi_12_data, color=\'black\')
>
> plt.plot(drive_amps, rabi_12_y\_fit, color=\'red\')
>
> drive_12_period = rabi_12_fit_params\[2\]
>
> \# account for phi in computing pi amp
>
> pi_amp_12 = (drive_12_period/2/np.pi)
> \*(np.pi+rabi_12_fit_params\[3\])
>
> plt.axvline(pi_amp_12, color=\'red\', linestyle=\'\--\')
>
> plt.axvline(pi_amp_12+drive_12_period/2, color=\'red\',
> linestyle=\'\--\')
>
> plt.annotate(\"\", xy=(pi_amp_12+drive_12_period/2, 0),
> xytext=(pi_amp_12,0), arrowprops=dict(arrowstyle=\"\<-\>\",
> color=\'red\'))
>
> plt.annotate(\"\$\\pi\$\", xy=(pi_amp_12-0.03, 0.1), color=\'red\')
>
> plt.xlabel(\"Drive amp \[a.u.\]\", fontsize=15)
>
> plt.ylabel(\"Measured signal \[a.u.\]\", fontsize=15)
>
> plt.title(\'Rabi Experiment (1-\>2)\', fontsize=20)
>
> plt.show()

![](pics/media/image361.png)

> print(f\"Our updated estimate for the 1-\>2 transition frequency is \"
>
> f\"{round(qubit_12_freq/GHz, 7)} GHz.\")
>
> print(f\"Pi Amplitude (1-\>2) = {pi_amp_12}\")
>
> è¾“å‡ºï¼š
>
> Our updated estimate for the 1-\>2 transition frequency is 4.6263002
> GHz.
>
> Pi Amplitude (1-\>2) = 0.37256049920143336

é€šè¿‡æ­¤ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä½¿å¾—$1 \rightarrow 2$çš„$\pi$è„‰å†²ï¼ˆç¡®ä¿åœ¨ä½¿å¾—$1 \rightarrow 2$çš„é¢‘ç‡ä¸Šæ·»åŠ è¾¹å¸¦ï¼‰ã€‚

> pi_pulse_12 = pulse_lib.gaussian(duration=drive_samples,
>
> amp=pi_amp_12,
>
> sigma=drive_sigma,
>
> name=\'pi_pulse_12\')
>
> \# make sure this pulse is sidebanded
>
> pi_pulse_12 = apply_sideband(pi_pulse_12, qubit_12_freq)

#### 2.3 æ„å»ºåŒºæ€0ã€1åŠ2çš„é‰´é¢‘å™¨

æœ€åï¼Œä¸ºåŒºåˆ†$|0\rangle$ã€$|1\rangle$å’Œ$|2\rangle$æ„å»ºé‰´é¢‘å™¨ã€‚è¯¥è¿‡ç¨‹ä¸ç¬¬1èŠ‚ä¸­æ‰€è¿°é¡¹ç±»ä¼¼ï¼Œä½†æ­¤å¤„æˆ‘ä»¬ä¸º$|2\rangle$æ·»åŠ äº†ä¸€ä¸ªé™„åŠ è°ƒåº¦ã€‚

å›é¡¾ä¸€ä¸‹ä¸‰ä¸ªè°ƒåº¦ï¼ˆä»$|0\rangle$å¼€å§‹ï¼‰ï¼š

1\. é€šè¿‡ç›´æ¥æµ‹é‡$|0\rangle$è·å–$|0\rangle$çš„è´¨å¿ƒã€‚

2\.
æ–½åŠ ä¸€ä¸ªä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²ï¼Œç„¶åé€šè¿‡æµ‹é‡æ¥è·å–$|1\rangle$çš„è´¨å¿ƒã€‚

3\.
æ–½åŠ ä¸€ä¸ªä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²åå†æ–½åŠ ä¸€ä¸ªä½¿å¾—$1 \rightarrow 2$çš„$\pi$è„‰å†²ï¼Œç„¶åé€šè¿‡æµ‹é‡æ¥è·å–$|2\rangle$çš„è´¨å¿ƒã€‚

> \# Create the three schedules
>
> \# Ground state schedule
>
> zero_schedule = pulse.Schedule(name=\"zero schedule\")
>
> zero_schedule \|= measure
>
> \# Excited state schedule
>
> one_schedule = pulse.Schedule(name=\"one schedule\")
>
> one_schedule \|= pi_pulse_01(drive_chan)
>
> one_schedule \|= measure \<\< one_schedule.duration
>
> \# Excited state schedule
>
> two_schedule = pulse.Schedule(name=\"two schedule\")
>
> two_schedule \|= pi_pulse_01(drive_chan)
>
> two_schedule \|= pi_pulse_12(drive_chan) \<\< two_schedule.duration
>
> two_schedule \|= measure \<\< two_schedule.duration

æ„å»ºç¨‹åºå¹¶åœ¨IQå¹³é¢ä¸Šç»˜åˆ¶è´¨å¿ƒã€‚

> \# Assemble the schedules into a program
>
> IQ_012_program = assemble(\[zero_schedule, one_schedule,
> two_schedule\],
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'single\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\] \* 3)
>
> IQ_012_job = backend.run(IQ_012_program)
>
> print(IQ_012_job.job_id())
>
> job_monitor(IQ_012_job)
>
> è¾“å‡ºï¼š
>
> 5e8da7dfecce7e0011fb14a5
>
> Job Status: job has successfully run
>
> \# Get job data (single); split for zero, one and two
>
> IQ_012_data = get_job_data(IQ_012_job, average=False)
>
> zero_data = IQ_012_data\[0\]
>
> one_data = IQ_012_data\[1\]
>
> two_data = IQ_012_data\[2\]
>
> def IQ_012_plot(x_min, x_max, y_min, y_max):
>
> \"\"\"Helper function for plotting IQ plane for 0, 1, 2. Limits of
> plot given
>
> as arguments.\"\"\"
>
> \# zero data plotted in blue
>
> plt.scatter(np.real(zero_data), np.imag(zero_data),
>
> s=5, cmap=\'viridis\', c=\'blue\', alpha=0.5,
> label=r\'\$\|0\\rangle\$\')
>
> \# one data plotted in red
>
> plt.scatter(np.real(one_data), np.imag(one_data),
>
> s=5, cmap=\'viridis\', c=\'red\', alpha=0.5,
> label=r\'\$\|1\\rangle\$\')
>
> \# two data plotted in green
>
> plt.scatter(np.real(two_data), np.imag(two_data),
>
> s=5, cmap=\'viridis\', c=\'green\', alpha=0.5,
> label=r\'\$\|2\\rangle\$\')
>
> \# Plot a large dot for the average result of the 0, 1 and 2 states.
>
> mean_zero = np.mean(zero_data) \# takes mean of both real and
> imaginary parts
>
> mean_one = np.mean(one_data)
>
> mean_two = np.mean(two_data)
>
> plt.scatter(np.real(mean_zero), np.imag(mean_zero),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.scatter(np.real(mean_one), np.imag(mean_one),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.scatter(np.real(mean_two), np.imag(mean_two),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.xlim(x_min, x_max)
>
> plt.ylim(y_min,y_max)
>
> plt.legend()
>
> plt.ylabel(\'I \[a.u.\]\', fontsize=15)
>
> plt.xlabel(\'Q \[a.u.\]\', fontsize=15)
>
> plt.title(\"0-1-2 discrimination\", fontsize=15)
>
> x_min = -20
>
> x_max = 10
>
> y_min = -10
>
> y_max = 5
>
> IQ_012_plot(x_min, x_max, y_min, y_max)

![](pics/media/image362.png)

ç°åœ¨æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°å¯¹åº”äº$|2\rangle$çš„ç¬¬ä¸‰ä¸ªè´¨å¿ƒäº†ã€‚ï¼ˆæ³¨ï¼šå¦‚æœç»˜å›¾ä¸æ­£ç¡®ï¼Œè¯·é‡æ–°è¿è¡Œnotbookï¼‰

æœ‰äº†è¿™äº›æ•°æ®ï¼Œæˆ‘ä»¬å°±å¯ä»¥å»ºç«‹é‰´é¢‘å™¨äº†ã€‚ä¸ä¸Šæ–‡ä¸­æ‰€è¿°çš„æ­¥éª¤ä¸€æ ·ï¼Œæ­¤å¤„è¿˜æ˜¯ä½¿ç”¨scikit.learnä»¥åŠçº¿æ€§åˆ¤åˆ«åˆ†æï¼ˆLDAï¼‰ã€‚

é¦–å…ˆå¯¹éœ€è¦LDAçš„æ•°æ®é‡å¡‘ã€‚

> \# Create IQ vector (split real, imag parts)
>
> zero_data_reshaped = reshape_complex_vec(zero_data)
>
> one_data_reshaped = reshape_complex_vec(one_data)
>
> two_data_reshaped = reshape_complex_vec(two_data)
>
> IQ_012_data = np.concatenate((zero_data_reshaped, one_data_reshaped,
> two_data_reshaped))
>
> print(IQ_012_data.shape) \# verify IQ data shape
>
> æ•°æ®ï¼š
>
> (3072, 2)

ç„¶åï¼Œåˆ†å‰²è®­ç»ƒå’Œæµ‹è¯•æ•°æ®ï¼ˆä¸€åŠå¯¹ä¸€åŠï¼‰ã€‚æµ‹è¯•æ•°æ®æ˜¯ä¸€ä¸ªåŒ…å«0ï¼ˆ0è°ƒåº¦ï¼‰ï¼Œ1ï¼ˆ1è°ƒåº¦ï¼‰å’Œ2ï¼ˆ2è°ƒåº¦ï¼‰ï¼‰çš„æ•°ç»„ã€‚

> \# construct vector w/ 0\'s, 1\'s and 2\'s (for testing)
>
> state_012 = np.zeros(NUM_SHOTS) \# shots gives number of experiments
>
> state_012 = np.concatenate((state_012, np.ones(NUM_SHOTS)))
>
> state_012 = np.concatenate((state_012, 2\*np.ones(NUM_SHOTS)))
>
> print(len(state_012))
>
> \# Shuffle and split data into training and test sets
>
> IQ_012_train, IQ_012_test, state_012_train, state_012_test =
> train_test_split(IQ_012_data, state_012, test_size=0.5)
>
> è¾“å‡ºï¼š
>
> 3072

æœ€åï¼Œå»ºç«‹æ¨¡å‹ã€è®­ç»ƒå¹¶æ‰“å°å‡ºæ‹Ÿåˆç²¾åº¦ã€‚

> \# Set up the LDA
>
> LDA_012 = LinearDiscriminantAnalysis()
>
> LDA_012.fit(IQ_012_train, state_012_train)
>
> è¾“å‡ºï¼š
>
> LinearDiscriminantAnalysis(n_components=None, priors=None,
> shrinkage=None,
>
> solver=\'svd\', store_covariance=False, tol=0.0001)
>
> \# test on some simple data
>
> print(LDA_012.predict(\[\[0, 0\], \[-10, 0\], \[-15, -5\]\]))
>
> è¾“å‡ºï¼š
>
> \[0. 1. 2.\]
>
> \# Compute accuracy
>
> score_012 = LDA_012.score(IQ_012_test, state_012_test)
>
> print(score_012)
>
> è¾“å‡ºï¼š
>
> 0.818359375

æœ€åä¸€æ­¥æ˜¯ç»˜åˆ¶åˆ†éš”çº¿ã€‚

> IQ_012_plot(x_min, x_max, y_min, y_max)
>
> separatrixPlot(LDA_012, x_min, x_max, y_min, y_max, NUM_SHOTS)

![](pics/media/image363.png)

å› ä¸ºæœ‰äº†3ä¸ªè´¨å¿ƒï¼Œæ‰€ä»¥åˆ†éš”çº¿ä¸æ˜¯ä¸€æ¡çº¿ï¼Œè€Œæ˜¯ä¸€æ¡åŒ…å«ä¸¤çº¿ç»„åˆçš„æ›²çº¿ã€‚ä¸ºäº†åŒºåˆ†$|0\rangle$ã€$|1\rangle$å’Œ$|2\rangle$ï¼Œæ¨¡å‹ä¼šæ£€æŸ¥æŒ‡å®šIQç‚¹ç›¸å¯¹äºåˆ†éš”çº¿çš„ä½ç½®ï¼Œå¹¶ç›¸åº”åœ°å¯¹è¯¥ç‚¹è¿›è¡Œåˆ†ç±»ã€‚

### 3. å‚è€ƒæ–‡çŒ®

1.  D. C. McKay, T. Alexander, L. Bello, M. J. Biercuk, L. Bishop, J.
    Chen, J. M. Chow, A. D. C Ìorcoles, D. Egger, S. Filipp, J.
    Gomez, M. Hush, A. Javadi-Abhari, D. Moreda, P. Nation, B.
    Paulovicks, E. Winston, C. J. Wood, J. Wootton, and J. M. Gambetta,
    "Qiskit backend specifications for OpenQASM and OpenPulse
    experiments," 2018, <https://arxiv.org/abs/1809.03452>.

2.  Krantz, P. et al. "A Quantum Engineer's Guide to Superconducting
    Qubits." Applied Physics Reviews 6.2 (2019): 021318,
    <https://arxiv.org/abs/1904.06560>.

3.  Scikit-learn: Machine Learning in Python, Pedregosa et al., JMLR 12,
    pp. 2825-2830, 2011,
    <https://scikit-learn.org/stable/modules/lda_qda.html#id4>.

> import qiskit.tools.jupyter
>
> %qiskit_version_table

6.3 Transmonç‰©ç†ç†è®ºç®€ä»‹
------------------------

### å†…å®¹

1\. å°†å¤šèƒ½çº§é‡å­ç³»ç»Ÿä½œä¸ºé‡å­æ¯”ç‰¹

2\. é‡å­å›è·¯çš„å“ˆå¯†é¡¿é‡

3\. é‡åŒ–å“ˆå¯†é¡¿é‡

4\. é‡åŒ–Transmon

5\. Transmonä¸é‡å­è°æŒ¯å­çš„æ¯”è¾ƒ

6\. é‡å­æ¯”ç‰¹é©±åŠ¨ä¸æ—‹è½¬æ³¢è¿‘ä¼¼

### 1. å°†å¤šèƒ½çº§é‡å­ç³»ç»Ÿä½œä¸ºé‡å­æ¯”ç‰¹

ç ”ç©¶é‡å­æ¯”ç‰¹æœ¬è´¨ä¸Šæ˜¯å­¦ä¹ åŒèƒ½çº§ç³»ç»Ÿç‰©ç†ã€‚åŒèƒ½çº§ç³»ç»Ÿçš„å…¸å‹ç¤ºä¾‹å°±æ˜¯ç”µå­çš„è‡ªæ—‹ï¼ˆæˆ–å…¶ä»–"è‡ªæ—‹-1/2"çš„ç²’å­ï¼‰ï¼šå…¶å¯æŒ‡å‘ä¸Šæˆ–æŒ‡å‘ä¸‹ï¼Œæˆ‘ä»¬å°†å…¶åˆ†åˆ«æ ‡è®°ä¸ºæ€$|0\rangle$å’Œæ€$|1\rangle$ã€‚æ€$|0\rangle$åœ¨å†å²ä¸Šè¢«å®šä¹‰ä¸ºå¸ƒæ´›èµ«çƒçš„åŒ—æï¼ˆnorth
poleï¼‰ï¼Œå…¶åŸå› ä¸ºï¼šå½“ç£åœºæ–½åŠ åœ¨$+ \overset{\hat{}}{z}$æ–¹å‘ä¸Šæ—¶ï¼Œè¯¥å¤„å¤„äºä½èƒ½æ€ã€‚

å¦ä¸€ç§ç±»ä¼¼çš„åŒèƒ½çº§ç³»ç»Ÿè¢«å‘ç°äºç¬¬ä¸€ç§è¶…å¯¼é‡å­æ¯”ç‰¹------ç”µå­åº“ç€å¯¹ç®±ï¼ˆ[Cooper
Pair
Box](https://arxiv.org/pdf/cond-mat/9904003v1.pdf)ï¼‰ä¸­ã€‚è¶…å¯¼ä½“ä¸­æ²¡æœ‰ç”µé˜»çš„åŸå› æ˜¯ç”µå­ä»¥åº“ç€å¯¹çš„å½¢å¼ç»“åˆåœ¨ä¸€èµ·ï¼Œå…¶å¯é€šè¿‡å¸æ”¶èƒ½é‡è€Œåˆ†ç¦»å¹¶ä¸”è¿™ç§èƒ½é‡åœ¨ä½æ¸©ä¸‹æ— æ³•å˜ä¸ºçƒ­èƒ½ï¼Œå› æ­¤ç”µå­ä¹‹é—´èƒ½å¤Ÿæœ‰æ•ˆåœ°ç›¸äº’å¸å¼•ã€‚è¿™ä¸€æƒ…å†µæœ‰äº›è¿èƒŒç›´è§‰ï¼Œå› ä¸ºç”µå­éƒ½å¸¦è´Ÿç”µï¼Œå› è€Œä¹‹é—´åº”è¯¥äº’ç›¸æ’æ–¥ï¼ç„¶è€Œï¼Œåœ¨è®¸å¤šç‰©è´¨ç³»ç»Ÿä¸­æœ‰æ•ˆçš„ç›¸äº’ä½œç”¨å¯ä»¥é€šè¿‡ç¾¤ä½“æ•ˆåº”ï¼ˆcollective
effectï¼‰æ¥è°ƒèŠ‚ï¼šäººä»¬å¯ä»¥å°†ç”µå­è§†ä¸ºè¢«æ­£ç”µè·æ™¶æ ¼ä¸­çš„å…¶ä»–ç”µå­æ‰€å¸å¼•ã€‚ç”µå­åº“ç€å¯¹ç®±ç”±ä¸€ä¸ªè¶…å¯¼å²›ç»„æˆï¼Œè¯¥å²›å æ®ä¸€ä¸ªé¢å¤–çš„åº“ç€å¯¹ç”µè·$2e$ï¼ˆæ€$|0\rangle$ï¼‰æˆ–ä¸å æ®ï¼ˆæ€$|1\rangle$ï¼‰ã€‚è¿™äº›çŠ¶æ€å¯ä»¥é€šè¿‡éš§é“ç»“ä¸Šçš„ç”µå‹è¿›è¡Œæ§åˆ¶ï¼Œå¹¶ä¸”åœ¨"æ …æ"ç”µå‹æ§åˆ¶ä¸‹å‘ˆç°å‘¨æœŸæ€§ï¼Œå› æ­¤ç”µå­åº“ç€å¯¹ç®±ç¡®ä¸ºåŒèƒ½çº§ç³»ç»Ÿã€‚

åœ¨å°†é‡å­æ¯”ç‰¹ç¼–ç ä¸ºç”µè·çŠ¶æ€æ—¶å¯¹æ‰€å­˜åœ¨çš„ç”µè·å™ªå£°ï¼ˆ*charge
noise*ï¼‰éå¸¸æ•æ„Ÿï¼Œå…¶ä¹Ÿå¯¹ç”µå­åº“ç€å¯¹ç®±æˆç«‹ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä¸å—ç ”ç©¶äººå‘˜é’ççš„åŸå› ã€‚å¤§å¤šå…¶ä»–é‡å­ç³»ç»Ÿå¹¶éåŒèƒ½çº§ç³»ç»Ÿï¼Œæ¯”å¦‚æ¯ä¸ªåŸå­éƒ½å…·æœ‰ç‹¬ç‰¹çš„è°±çº¿ï¼ˆèƒ½é‡è·ƒè¿ï¼‰ï¼Œå¤©æ–‡å­¦å®¶å°†å…¶ç”¨äºç¡®å®šæˆ‘ä»¬æ‰€å¤„å®‡å®™çš„æ„æˆã€‚é€šè¿‡æœ‰æ•ˆåœ°éš”ç¦»å’Œæ§åˆ¶å…¶ä¸­çš„ä¸¤ä¸ªèƒ½çº§ï¼Œä¾‹å¦‚åŸå­çš„åŸºæ€å’Œç¬¬ä¸€æ¿€å‘æ€ï¼Œå°±å¯å°†å…¶è§†ä¸ºä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚ä½†å¦‚ä½¿ç”¨å…¶ä»–ç±»å‹çš„è¶…å¯¼ç”µè·¯ä½œä¸ºé‡å­æ¯”ç‰¹æ˜¯ä½•æƒ…å†µå‘¢ï¼Ÿè§£å†³æ–¹æ¡ˆæ˜¯è®¾è®¡ä¸€ä¸ªå…·æœ‰é«˜é˜¶èƒ½çº§çš„é‡å­æ¯”ç‰¹å¯¹å†²ç”µå­åº“ç€å¯¹ç®±çš„ç”µè·é­å—é—®é¢˜ï¼Œè¿™ä¸€å…·æœ‰é«˜é˜¶èƒ½çº§çš„é‡å­æ¯”ç‰¹ç§°ä¸ºï¼š[transmon](https://arxiv.org/pdf/cond-mat/0703002.pdf)ï¼ˆå…¨ç§°ï¼š*transmission-line
shunted plasma oscillation*
qubitï¼‰ã€‚é€šè¿‡ç‰ºç‰²éè°æ€§ï¼ˆ$|0\rangle \rightarrow |1\rangle$ä¸$|1\rangle \rightarrow |2\rangle$è½¬æ¢é¢‘ç‡çš„å·®å¼‚ï¼Œè§"6.2
è®¿é—®æ›´é«˜çš„èƒ½æ€"ï¼‰ï¼Œç”µè·å™ªå£°å¾—åˆ°æŠ‘åˆ¶ï¼ŒåŒæ—¶ä»å…è®¸å°†æœ€ä½çš„ä¸¤ä¸ªèƒ½çº§å½“ä½œä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚åœ¨æ­¤å¤„é‡å­æ€è¢«ç¼–ç ä¸ºè·¨ä¸¤ä¸ªè¶…å¯¼å²›ä¹‹é—´éš§é“ç»“çš„åº“ç€å¯¹æŒ¯è¡ï¼Œå…¶ä¸­ç”¨äºæ¿€å‘æ€$|1\rangle$çš„æŒ¯è¡é¢‘ç‡æ¯”åŸºæ€$|0\rangle$çš„é«˜ã€‚

### 2. é‡å­å›è·¯çš„å“ˆå¯†é¡¿é‡

å“ˆå¯†é¡¿é‡æ˜¯ä¸€ä¸ªç­‰äºç³»ç»Ÿæ€»èƒ½é‡ã€åŠ¿èƒ½å’ŒåŠ¨èƒ½çš„å‡½æ•°ã€‚è¿™ä¸€è§‚ç‚¹åœ¨ç»å…¸åŠ›å­¦ä¸­æ­£ç¡®ï¼Œé‡å­å“ˆå¯†é¡¿é‡è¢«å‘ç°äºé€šè¿‡å°†å˜é‡æå‡ä¸ºç®—å­æ—¶ã€‚é€šè¿‡å¯¹æ¯”ç»å…¸æ³Šæ¾æ‹¬å·ï¼ˆPoisson
Backetï¼‰ä¸é‡å­å¯¹æ˜“å¼ï¼ˆquantum
commutatorï¼‰ï¼Œå‘ç°å…¶ä¸èƒ½å¯¹æ˜“ï¼Œå› æ­¤æ— æ³•åŒæ—¶å¯¹å…¶è¿›è¡Œè§‚å¯Ÿï¼Œè¿™ä¸€ç‚¹ä¸æµ·æ£®å ¡ä¸ç¡®å®šæ€§åŸç†ç›¸åŒã€‚

é¦–å…ˆï¼Œå‡è®¾ä¸€ä¸ªçº¿æ€§$\text{LC}$ç”µè·¯ï¼Œå…¶ä¸­$L$æ˜¯ç”µæ„Ÿï¼Œ$C$æ˜¯ç”µå®¹ã€‚å“ˆå¯†é¡¿é‡æ˜¯åŠ¨èƒ½ï¼ˆç”±ç”µè·$Q$è¡¨ç¤ºï¼‰å’ŒåŠ¿èƒ½ï¼ˆç”±ï¼ˆç”µï¼‰é€šé‡$\Phi$è¡¨ç¤ºï¼‰ä¹‹å’Œï¼š

$$\mathcal{H =}\frac{Q^{2}}{2C} + \frac{\Phi^{2}}{2L}$$

**çº¿æ€§ç”µè·¯çš„åˆ†æ”¯é€šé‡æ³•(Branch-Flux Method)**

å“ˆå¯†é¡¿å‡½æ•°å’Œæ‹‰æ ¼æœ—æ—¥å‡½æ•°æ¶‰åŠå¤§è´¨é‡ç‰©ä½“çš„èƒ½é‡ï¼Œåœ¨ç»å…¸ç³»ç»Ÿçš„åŠ¨åŠ›å­¦ä¸­æœ‰ç€ä¸°å¯Œçš„å†å²ã€‚å…¶ä»ä½œä¸º"é‡åŒ–"å¯¹è±¡çš„æ¨¡æ¿ï¼ŒåŒ…æ‹¬transmonã€‚è¯¥æ–¹æ³•åŒ…æ‹¬æ ¹æ®å¹¿ä¹‰åæ ‡å†™å‡ºæ‹‰æ ¼æœ—æ—¥å‡½æ•°ï¼šæˆ‘ä»¬å°†é€‰æ‹©ä¸€ä¸ªç§°ä¸ºé€šé‡ï¼ˆfluxï¼‰çš„é‡ï¼Œè¯¥é‡ç”±å¯¹ç”µå‹çš„è®¤çŸ¥å®šä¹‰ï¼Œä¼ ç»Ÿä¸Šäººä»¬é€šå¸¸ä¼šé€‰æ‹©3ç»´ç©ºé—´ä¸­çš„ä½ç½®ã€‚ç„¶åè®¡ç®—å‡ºä¸å¹¿ä¹‰åæ ‡å¯¹åº”çš„å…±è½­å˜é‡ï¼Œæœ€ç»ˆå¯å°†å…¶è§†ä¸ºç”µè·chargeï¼ˆåœ¨ç»å…¸ç‰©ç†ç§°ä¸ºåŠ¨é‡momentumï¼‰ã€‚é€šè¿‡å‹’è®©å¾·å˜æ¢è®¡ç®—å‡ºå“ˆå¯†é¡¿é‡ï¼Œè¯¥å“ˆå¯†é¡¿é‡è¡¨ç¤ºç³»ç»Ÿçš„èƒ½é‡ä¹‹å’Œã€‚å¯ä»¥ä½¿ç”¨åˆ†æ”¯é€šé‡æ³•è€ƒè™‘ç”µå®¹å’Œç”µæ„Ÿèƒ½é‡æ¥æ‰¾å‡ºç”µè·¯çš„å“ˆå¯†é¡¿é‡ï¼Œæ­¤æ–¹æ³•æœ¬èº«åŸºäºç»å…¸æ‹‰æ ¼æœ—æ—¥åŠ›å­¦ã€‚å°†é€šé‡å’Œç”µè·åˆ†åˆ«å®šä¹‰ä¸ºç”µå‹å’Œç”µæµçš„æ—¶é—´ç§¯åˆ†ï¼š

$$\Phi\left( t \right) = \int_{- \infty}^{t}{V\left( t^{'} \right)dt^{'}}\text{\ and\ }Q(t) = \int_{- \infty}^{t}{I(t^{'})dt^{'}}$$

æˆ‘ä»¬å°†é€šé‡$\Phi$ä½œä¸ºå¹¿ä¹‰åæ ‡ï¼Œå…¶ä¸­$V(t')$å’Œ$I(t')$æ˜¯åœ¨æ—¶é—´$t'$æµè¿‡transmonçš„ç”µå‹å’Œç”µæµã€‚åœ¨æ™®é€šçš„ç”µè·¯ä¸­ï¼Œç”µå‹çš„åŠŸèƒ½éå¸¸åƒåŠ¿èƒ½ï¼Œè€Œç”µæµåˆ™åƒåŠ¨èƒ½ã€‚åœ¨$t$æ—¶ç»è¿‡transmonçš„ç¬æ—¶èƒ½é‡ä¸ºï¼š

$$E(t) = \int_{- \infty}^{t}{V(t^{'})I(t^{'})dt^{'}}$$

ç”µå®¹$C$ä¸ç”µæ„Ÿ$L$ä¸¤ç«¯çš„ç”µå‹å’Œç”µæµåˆ†åˆ«é€šè¿‡$V = LdI/dt$å’Œ$I = CdV/dt$ç›¸äº’å…³è”ã€‚åœ¨æ™®é€šç”µè·¯ä¸­ï¼Œç”µå®¹å™¨å­˜å‚¨ç”µè·è€Œç”µæ„Ÿå™¨å­˜å‚¨é€šé‡ï¼ˆç”µæµï¼‰ã€‚æˆ‘ä»¬å°†ä½¿ç”¨é€šé‡ä½œä¸º"åæ ‡"ï¼Œç„¶å› ç”µæ„Ÿå­˜å‚¨é€šé‡ï¼Œæ‰€ä»¥åŠ¿èƒ½å¯è¡¨ç¤ºä¸ºå„ä¸ªéƒ¨åˆ†çš„ç§¯åˆ†ï¼š

$$U_{L}(t) = \int_{- \infty}^{t}{L\frac{dI(t^{'})}{dt^{'}}I(t^{'})dt^{'}} = \frac{1}{2}LI(t)^{2} = \frac{1}{2L}\Phi^{2}\text{becauseÎ¦}(t) = \int_{- \infty}^{t}{L\frac{dI(t^{'})}{dt^{'}}dt^{'} = LI(t)}$$

**çº¿æ€§ç”µè·¯çš„åˆ†æ”¯é€šé‡æ³•(Branch-Flux Method)ï¼ˆç»­ï¼‰**

ä¸ä¸Šç›¸åŒï¼Œç”µå‹æ˜¯é€šé‡çš„å˜åŒ–ç‡ï¼Œå…¶å¯¹åº”äºåŠ¨èƒ½ï¼š

$$\tau_{C}(t) = \int_{- \infty}^{t}{C\frac{\text{dV}\left( t^{'} \right)}{dt^{'}}V\left( t^{'} \right)dt^{'}} = \frac{1}{2}CV(t)^{2} = \frac{1}{2}C{\dot{\Phi}}^{2}ï¼Œ$$

$å…¶ä¸­\dot{\Phi} = \frac{d\Phi}{\text{dt}}$æ˜¯è¡¨ç¤ºæ‹‰æ ¼æœ—æ—¥åŠ›å­¦ä¸­æ—¶é—´å¯¼æ•°çš„å¸¸ç”¨æ–¹å¼ã€‚æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹å®šä¹‰ä¸ºåŠ¨èƒ½å’ŒåŠ¿èƒ½ä¹‹å·®ï¼Œå› æ­¤ï¼š

$$\mathcal{L =}\tau_{C} - U_{L} = \frac{1}{2L}\Phi^{2} - \frac{1}{2}C{\dot{\Phi}}^{2}$$

åŠ¨åŠ›å­¦æ–¹ç¨‹ç”±Euler-Lagrangeæ–¹ç¨‹ç¡®å®šï¼š

$$0 \equiv \frac{\partial\mathcal{L}}{\partial\Phi} - \frac{d}{\text{dt}}\left( \frac{\partial\mathcal{L}}{\partial\dot{\Phi}} \right) = \frac{\Phi}{L} + C\ddot{\Phi}$$

å…¶æè¿°äº†$\Phi$ä¸­è§’é¢‘ç‡ä¸º$\omega = 1/\sqrt{\text{LC}}$çš„è°æŒ¯å­ï¼ˆharmonic
oscillatorï¼‰ï¼Œå¼ä¸­çš„ä¸¤ä¸ªç‚¹ä¸ºäºŒé˜¶å¯¼æ•°$\ddot{\Phi} = d^{2}\Phi/dt^{2}$ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å¸Œæœ›è½¬å‘æ±‰å¯†å°”é¡¿å¸§å¹¶ä»ä¸­è¿›è¡Œé‡åŒ–ã€‚è€Œé€šé‡$\Phi$çš„å…±è½­åæ ‡å®šä¹‰ä¸ºï¼š

$$\frac{d\mathcal{L}}{d\dot{\Phi}} = C\dot{\Phi} = CV \equiv Q$$

ç”±äºç”µå®¹çš„å®šä¹‰ï¼Œä»¥ä¸Šä¸ç”µè·çš„å®šä¹‰å®Œå…¨ç›¸åŒã€‚ç°åœ¨ï¼Œç”¨æ‹‰æ ¼æœ—æ—¥æ³•å°†å“ˆå¯†é¡¿é‡å®šä¹‰ä¸º$\mathcal{H =}Q\dot{\Phi}\mathcal{- L}$ï¼Œå¾—å‡ºä¸Šè¿°æ–¹ç¨‹å¼ã€‚

### 3. é‡åŒ–å“ˆå¯†é¡¿é‡

é‡å­è°æŒ¯å­ï¼ˆQHOï¼šquantum harmonic
oscillatorï¼‰åœ¨é‡åŒ–$\text{LC}$ç”µè·¯å“ˆå¯†é¡¿é‡æ—¶å¾—å‡ºã€‚å°†å…±è½­å˜é‡æå‡ä¸ºç®—å­ï¼š$Q \rightarrow \widehat{Q}$ã€$\Phi \rightarrow \widehat{\Phi}$ï¼Œå› æ­¤é‡åŒ–çš„å“ˆå¯†é¡¿é‡ä¸ºï¼š

$$\widehat{H} = \frac{{\widehat{Q}}^{2}}{2C} + \frac{{\widehat{\Phi}}^{2}}{2L}$$

å…¶ä¸­$H$ä¸Šç­‰çš„"å¸½å­"æç¤ºæˆ‘ä»¬è¿™äº›æ˜¯é‡å­åŠ›å­¦ç®—å­ã€‚ç„¶åé€šè¿‡å¯¹åº”å…³ç³»å¥–åŠ±ç»å…¸åŠ›å­¦çš„æ³Šæ¾æ‹¬å·å’Œé‡å­åŠ›å­¦å¯¹æ˜“å¼ä¹‹é—´çš„å…³è”ï¼š

$$\{ A,B\} = \frac{\text{Î´A}}{\delta\Phi}\frac{\text{Î´B}}{\text{Î´Q}} - \frac{\text{Î´B}}{\delta\Phi}\frac{\text{Î´A}}{\text{Î´Q}} \Longleftrightarrow \frac{1}{\text{iâ„}}\lbrack\overset{\hat{}}{A},\overset{\hat{}}{B}\rbrack = \frac{1}{\text{iâ„}}(\overset{\hat{}}{A}\overset{\hat{}}{B} - \overset{\hat{}}{B}\overset{\hat{}}{A}),$$

å…¶ä¸­$\delta$ä¸ºå‡½æ•°å¯¼æ•°ï¼Œè€Œå¯¹æ˜“å¼åˆ™åæ˜ å‡ºæ“ä½œé¡ºåºåœ¨é‡å­åŠ›å­¦ä¸­çš„é‡è¦æ€§ã€‚æ’å…¥å˜é‡/ç®—å­ï¼Œå¾—åˆ°ï¼š

$$\{\Phi,Q\} = \frac{\delta\Phi}{\delta\Phi}\frac{\text{Î´Q}}{\text{Î´Q}} - \frac{\text{Î´Q}}{\delta\Phi}\frac{\delta\Phi}{\text{Î´Q}} = 1 - 0 = 1 \Longrightarrow \lbrack\overset{\hat{}}{\Phi},\overset{\hat{}}{Q}\rbrack = i\hslash$$

ä¸Šå¼è¡¨æ˜ï¼šä¸ä½ç½®å’ŒåŠ¨é‡ä¸€æ ·ï¼Œç”µè·å’Œé€šé‡ä¹Ÿéµå®ˆæµ·æ£®å ¡ä¸ç¡®å®šæ€§åŸç†ï¼Œä»¥åŠ$\lbrack\overset{\hat{}}{x},\overset{\hat{}}{p}\rbrack = i\hslash$ã€‚è¡¨æ˜å…¶ä¸å¯è¢«åŒæ—¶è§‚æµ‹ï¼Œå®é™…ä¸Šæ˜¯ä»¥ç›¸åŒæ–¹å¼å®šä¹‰çš„å…·æœ‰ç›¸åŒå±æ€§çš„å…±è½­å˜é‡ã€‚è¯¥ç»“æœå·²è¢«ç”¨äºè¶…å¯¼é‡å­æ¯”ç‰¹ï¼Œç”¨ä»¥è®¾è®¡æ–¹æ¡ˆå¹¶åˆ†ç±»è¶…å¯¼é‡å­æ¯”ç‰¹çš„ç±»å‹ã€‚

ä¸Šé¢çš„å“ˆå¯†é¡¿é‡é€šå¸¸ä½¿ç”¨ç®€åŒ–çš„ç”µè·$\overset{\hat{}}{n} = \overset{\hat{}}{Q}/2e$å’Œç›¸ä½$\overset{\hat{}}{\phi} = 2\pi\overset{\hat{}}{\Phi}/\Phi_{0}$ç¬¦å·ï¼Œä»¥æ›´å‹å¥½çš„å½¢å¼ç¼–å†™ï¼Œå…¶ä¸­$\Phi_{0} = h/2e$æ˜¯é€šé‡ï¼Œåˆ†åˆ«å¯¹åº”äºç®—å­ä¸­åº“ç€å¯¹çš„æ•°é‡å’Œè·¨çº¦ç‘Ÿå¤«æ£®ç»“çš„ç›¸ä½ã€‚ç„¶åï¼Œé‡åŒ–çš„å“ˆå¯†é¡¿é‡å˜ä¸ºï¼š

$${\overset{\hat{}}{H}}_{\text{QHO}} = 4E_{c}{\overset{\hat{}}{n}}^{2} + \frac{1}{2}E_{L}{\overset{\hat{}}{\phi}}^{2}$$

å…¶ä¸­$E_{c} = e^{2}/2C$ä¸ºç”µè·èƒ½é‡ï¼ˆå¼ä¸­çš„$4$å¯¹åº”äºæ­£åœ¨å¤„ç†çš„åº“ç€å¯¹è€Œéå•ä¸ªç”µå­ï¼‰ï¼Œ$E_{L} = (\Phi_{0}/2\pi)^{2}/L$ä¸ºç”µæ„Ÿèƒ½é‡ã€‚

**é‡å­è°æŒ¯å­ï¼ˆQHOï¼šquantum harmonic oscillatorï¼‰**

ä¸Šé¢çš„å“ˆå¯†é¡¿é‡è¡¨ç¤ºä¸€ä¸ªç®€å•çš„æ³¢æŒ¯å­ï¼Œå¹¶ä»¥$\overset{\hat{}}{\phi}$ä½œä¸ºä½ç½®å˜é‡ï¼Œç„¶åæˆ‘ä»¬å¯ä»¥æ ¹æ®ç”µè·å’Œç›¸ä½çš„é›¶ç‚¹æ¶¨è½æ¥å®šä¹‰äº§ç”Ÿç®—ç¬¦å’Œæ¹®æ²¡ç®—ç¬¦ï¼š

$$\overset{\hat{}}{n} = in_{z\text{pf}}(\overset{\hat{}}{a} + {\overset{\hat{}}{a}}^{\dagger})\text{\ \ }ä¸\text{\ \ }\overset{\hat{}}{\phi} = \phi_{z\text{pf}}(\overset{\hat{}}{a} - {\overset{\hat{}}{a}}^{\dagger})$$

å…¶ä¸­$n_{\text{zpf}} = {(\frac{E_{L}}{32E_{c}})}^{1/4}$ï¼Œ$\phi_{\text{zpf}} = {(\frac{2E_{c}}{E_{L}})}^{1/4}$ã€‚

è¿™å°±æ˜¯ä¸€ä¸ªè°æŒ¯å­åœ¨$\omega = \sqrt{8E_{L}E_{c}}/\hslash = 1/\sqrt{\text{LC}}$æ—¶çš„å“ˆå¯†é¡¿é‡$H_{\text{QHO}} = \hslash\omega({\overset{\hat{}}{a}}^{\dagger}\overset{\hat{}}{a} + \frac{1}{2})$ã€‚

åœ¨æ­¤å¤„ï¼Œæˆ‘ä»¬çœ‹åˆ°QHOçš„èƒ½é‡ç©ºé—´å¯¹åº”äº$\text{LC}$æŒ¯å­çš„ç»å…¸è°æŒ¯é¢‘ç‡$\omega = 1/\sqrt{\text{LC}}$ã€‚

**Transmonçš„åˆ†æ”¯é€šé‡æ–¹æ³•**

å°½ç®¡ä¸Šè¿°å†…å®¹æ¶‰åŠé‡åŒ–çº¿æ€§ç”µè·¯ï¼Œä½†Voolä¸Devoretåœ¨å…¶æ–‡ç« ã€Š[Introduction to
Quantum Electromagnetic
Circuits](https://arxiv.org/pdf/1610.03438.pdf)ã€‹ä¸­è®¨è®ºäº†é‡åŒ–ç”µè·¯çš„é€šç”¨åˆ†æ”¯é€šé‡æ–¹æ³•ã€‚è¯¥æ–‡ç« ä»å¤§ä½“ä¸Šç»™å‡ºäº†ä¸€ç§ç³»ç»Ÿåœ°åœ¨ç”µè·¯ä¸­å®æ–½åŸºå°”éœå¤«å®šå¾‹çš„æ–¹æ³•ï¼šèŠ‚ç‚¹ä¸Šçš„ç”µæµæ€»å’Œå¿…ç„¶ç­‰äºé›¶ï¼Œå¹¶ä¸”ä»»ä½•ç¯è·¯å‘¨å›´çš„ç”µå‹ç›¸åŠ ä¹Ÿå¿…ç„¶ç­‰äºé›¶ã€‚åŸºå°”éœå¤«å®šå¾‹ç»™å‡ºäº†ç”µè·¯çš„è¿åŠ¨æ–¹ç¨‹ã€‚çº¦ç‘Ÿå¤«æ£®ç»“ä¸­çš„ç”µæµä¸é€šé‡ä¹‹é—´å­˜åœ¨éå¸¸ç‰¹æ®Šçš„å…³ç³»ï¼Œç”±çº¦ç‘Ÿå¤«æ£®å…³ç³»ï¼ˆJosephson
relationï¼‰ç»™å‡ºï¼š

$$I = I_{0}\sin(2\pi\Phi/\Phi_{0})$$

å…¶ä¸­$I_{0}$æ˜¯åœ¨ä¿æŒè¶…å¯¼çŠ¶æ€æ—¶å¯æµç»çº¦ç‘Ÿå¤«æ£®ç»“çš„æœ€å¤§ç”µæµï¼ˆä¸´ç•Œç”µæµï¼‰ï¼Œ$\Phi_{0} = h/2e$æ˜¯é€šé‡é‡å­ï¼ˆflux
quantumï¼‰ã€‚å®æ–½åŸºå°”éœå¤«ç”µæµå®šå¾‹ï¼Œæµç»çº¦ç‘Ÿå¤«æ£®ç»“çš„ç”µæµä¸æ‰€æœ‰ç”µå®¹ä¸Šçš„ç”µæµä¹‹å’Œä¸º$C = C_{S} + C_{J}$ï¼Œå…¶ä¸­$C_{S}$æ˜¯å¹¶è”ç”µå®¹ï¼Œ$C_{J}$æ˜¯çº¦ç‘Ÿå¤«æ£®ç»“çš„ç”µå®¹ä¸”$C_{S} \gg C_{J}$ï¼Œæ•…å¿…ç„¶æ¶ˆå¤±ã€‚è¿™å°±ç»™å‡ºäº†è¿åŠ¨æ–¹ç¨‹ï¼š

$$I_{0}\sin\left( \frac{2\pi\Phi}{\Phi_{0}} \right) + C\ddot{\Phi} = 0$$

ä¸åœ¨QHOæƒ…å†µä¸‹é€šè¿‡å°†æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹æ”¾å…¥Euler-Lagrangeæ–¹ç¨‹æ¥è®¡ç®—è¿åŠ¨æ–¹ç¨‹çš„å…¸å‹æƒ…å†µä¸åŒï¼Œæ­¤å¤„æˆ‘ä»¬å·²ç»æœ‰äº†å˜é‡$\Phi$çš„è¿åŠ¨æ–¹ç¨‹ã€‚ä½†ç”±äºæˆ‘ä»¬è¦å¯¹å“ˆå¯†é¡¿é‡è¿›è¡Œé‡åŒ–ï¼Œå› æ­¤å°†è¯¥è¿åŠ¨æ–¹ç¨‹å¼è½¬æ¢ä¸ºæ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹ï¼Œç„¶åæ‰§è¡Œå‹’è®©å¾·å˜æ¢æ¥æ‰¾å‡ºå“ˆå¯†é¡¿é‡ï¼Œå¯ä»¥é€šè¿‡å¯¹è¿åŠ¨æ–¹ç¨‹è¿›è¡Œ"ç§¯åˆ†"æ¥å®ç°ï¼š

$$0 = \frac{\partial\mathcal{L}}{\partial\Phi} - \frac{d}{\text{dt}}(\frac{\partial\mathcal{L}}{\partial\dot{\Phi}}) = I_{0}\sin(2\pi\Phi/\Phi_{0}) + C\ddot{\Phi} \Longrightarrow \frac{I_{0}\Phi_{0}}{2\pi}\cos(2\pi\Phi/\Phi_{0}) + \frac{C{\dot{\Phi}}^{2}}{2}\mathcal{= L}$$

æˆ‘ä»¬é€šè¿‡å›æº¯æ‰¾å‡ºäº†æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹ã€‚ç°åœ¨ï¼Œé€šè¿‡æ‰¾åˆ°å…±è½­å˜é‡$Q = \partial\mathcal{L/}\partial\dot{\Phi} = C\dot{\Phi}$æ¥æ‰¾åˆ°å“ˆå¯†é¡¿é‡ï¼Œä¸QHOçš„æƒ…å†µç›¸åŒã€‚

$$\mathcal{H =}Q\dot{\Phi}\mathcal{- L =}\frac{Q^{2}}{2C} - \frac{I_{0}\Phi_{0}}{2\pi}\cos(2\pi\Phi/\Phi_{0})$$

### 4. é‡åŒ–Transmon

è¿›è¡Œä¸QHOç›¸åŒçš„å˜é‡æ›¿ä»£ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥ç†Ÿæ‚‰çš„å½¢å¼é‡å†™transmonçš„å“ˆå¯†é¡¿é‡ã€‚

$${\overset{\hat{}}{H}}_{\text{tr}} = 4E_{c}{\overset{\hat{}}{n}}^{2} - E_{J}\cos\overset{\hat{}}{\phi}$$

å…¶ä¸­çº¦ç‘Ÿå¤«æ£®èƒ½é‡$E_{J} = I_{0}\Phi_{0}/2\pi$æ›¿ä»£äº†QHOçš„ç”µæ„Ÿèƒ½é‡ã€‚å¯ä»¥çœ‹å‡ºï¼šç”±äºçº¦ç‘Ÿå¤«æ£®ç»“ä»£æ›¿äº†çº¿æ€§ç”µæ„Ÿï¼Œå› æ­¤è¯¥ç›¸çš„å‡½æ•°å½¢å¼ä¸QHOæœ‰æ‰€ä¸åŒã€‚é€šå¸¸$\overset{\hat{}}{n} \rightarrow \overset{\hat{}}{n} - n_{g}$åæ˜ æ …æåç½®ç”µè·ï¼Œä½†åœ¨transmonä¸­å¹¶ä¸é‡è¦ã€‚è‡³æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»ä¼¼äºQHOçš„é‡åŒ–æ–¹æ³•ï¼Œå…¶ä¸­ä¸€å¥ç”µè·å’Œç›¸ä½çš„é›¶ç‚¹æ³¢åŠ¨æ¥å®šä¹‰äº§ç”Ÿç®—ç¬¦å’Œæ¹®æ²¡ç®—ç¬¦ï¼š

$$\overset{\hat{}}{n} = in_{z\text{pf}}(\overset{\hat{}}{c} + {\overset{\hat{}}{c}}^{\dagger})\text{\ \ }ä¸\text{\ \ }\overset{\hat{}}{\phi} = \phi_{z\text{pf}}(\overset{\hat{}}{c} - {\overset{\hat{}}{c}}^{\dagger})$$

å…¶ä¸­$n_{\text{zpf}} = {(\frac{E_{J}}{32E_{c}})}^{1/4}$ï¼Œ$\phi_{\text{zpf}} = {(\frac{2E_{c}}{E_{J}})}^{1/4}$ï¼Œçº¦ç‘Ÿå¤«æ£®èƒ½é‡$E_{J}$å–ä»£äº†QHOçš„çº¿æ€§ç”µæ„Ÿèƒ½é‡$E_{L}$ã€‚æ­¤å¤„æˆ‘ä»¬ä½¿ç”¨äº†$\overset{\hat{}}{c} = \sum_{j}^{}{\sqrt{j + 1}|j\rangle\langle j + 1|}$è¡¨ç¤ºtransmonæ¹®æ²¡ç®—ç¬¦ï¼Œå¹¶å°†å…¶ä¸ç­‰é—´éš”èƒ½é‡æ¨¡å¼$\widehat{a}$åŒºåˆ†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æ³¨æ„åˆ°$\phi \ll 1$çš„åŸå› æ˜¯åœ¨transmonä¸­$E_{J}/E_{c} \gg 1$ï¼Œæˆ‘ä»¬å¯ä»¥å°†$\cos\widehat{\phi}$çš„æ³°å‹’å±•å¼€å¼è¿‘ä¼¼ä¸ºå“ˆå¯†é¡¿é‡ï¼š

$$H = 4E_{c}n_{\text{zpf}}^{2}(\overset{\hat{}}{c} + {\overset{\hat{}}{c}}^{\dagger})^{2} - E_{J}(1 - \frac{1}{2}E_{J}\phi_{\text{zpf}}^{2}(\overset{\hat{}}{c} - {\overset{\hat{}}{c}}^{\dagger})^{2} + \frac{1}{24}E_{J}\phi_{\text{zpf}}^{4}(\overset{\hat{}}{c} - {\overset{\hat{}}{c}}^{\dagger})^{4} + \ldots) \approx \sqrt{8E_{c}E_{J}}({\overset{\hat{}}{c}}^{\dagger}\overset{\hat{}}{c} + \frac{1}{2}) - E_{J} - \frac{E_{c}}{12}({\overset{\hat{}}{c}}^{\dagger} + \overset{\hat{}}{c})^{4}$$

å…¶ä¸­æˆ‘ä»¬è§‚å¯Ÿåˆ°$4E_{c}n_{\text{zpf}}^{2} = (1/2)E_{J}\phi_{\text{zpf}}^{2} = \sqrt{2E_{c}E_{J}}$éå¸¸æœ‰ç”¨ã€‚æ‰©å±•transmonè¿ç®—ç¬¦$\widehat{c}$çš„é¡¹å¹¶åˆ é™¤å¿«é€Ÿæ—‹è½¬é¡¹ï¼ˆå³ï¼šæ•°é‡ä¸ç­‰çš„$\widehat{c}$ä¸${\widehat{c}}^{\dagger}$ï¼‰ï¼Œå¿½ç•¥ä¸å½±å“transmonåŠ¨æ€çš„å¸¸æ•°ï¼Œè®¾å®š$\omega_{0} = \sqrt{8E_{c}E_{J}}$å¹¶å°†$\delta = - E_{c}$å®šä¹‰ä¸ºtransmonéè°æ€§ï¼Œå¾—å‡ºï¼š

$${\overset{\hat{}}{H}}_{\text{tr}} = \omega_{0}{\overset{\hat{}}{c}}^{\dagger}\overset{\hat{}}{c} + \frac{\delta}{2}(({\overset{\hat{}}{c}}^{\dagger}\overset{\hat{}}{c})^{2} + {\overset{\hat{}}{c}}^{\dagger}\overset{\hat{}}{c}) = (\omega_{0} + \frac{\delta}{2}){\overset{\hat{}}{c}}^{\dagger}\overset{\hat{}}{c} + \frac{\delta}{2}({\overset{\hat{}}{c}}^{\dagger}\overset{\hat{}}{c})^{2}$$

ä¸Šå¼å°±æ˜¯æœèŠ¬æŒ¯å­ï¼ˆDuffing
oscillatorï¼‰çš„å“ˆå¯†é¡¿é‡ã€‚é€šè¿‡å®šä¹‰$\omega \equiv \omega_{0} + \delta$ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å› $\omega_{j + 1} - \omega_{j} = \omega + \delta j$
transmonèƒ½çº§é—´æ‰€å­˜åœ¨çš„èƒ½é‡é—´éš”å› éè°æ€§è€Œä¸åŒï¼Œå› æ­¤$\omega$å¯¹åº”äºtransmoné‡å­æ¯”ç‰¹çš„"é¢‘ç‡"ï¼ˆ$\omega_{1} - \omega_{0}$ï¼‰ã€‚ä»transmonè¿ç®—ç¬¦çš„å®šä¹‰${\widehat{c}}^{\dagger}\widehat{c} = \sum_{j}^{}{j|j\rangle\langle j|}$å¾—å‡ºï¼š

$${\overset{\hat{}}{H}}_{\text{tr}} = \omega{\overset{\hat{}}{c}}^{\dagger}\overset{\hat{}}{c} + \frac{\delta}{2}{\overset{\hat{}}{c}}^{\dagger}\overset{\hat{}}{c}({\overset{\hat{}}{c}}^{\dagger}\overset{\hat{}}{c} - 1) = \sum_{j}^{}{((\omega - \frac{\delta}{2})j + \frac{\delta}{2}j^{2})|j\rangle\langle j|} \equiv \sum_{j}^{}{\omega_{j}|j\rangle\langle j|}$$

å› æ­¤ï¼Œ

$$\omega_{j} = (\omega - \frac{\delta}{2})j + \frac{\delta}{2}j^{2}$$

å°±æ˜¯transmonçš„èƒ½çº§ã€‚

### 5. Transmonä¸é‡å­è°æŒ¯å­çš„æ¯”è¾ƒ

QHOå…·æœ‰ç­‰é—´éš”èƒ½çº§è€Œtransmonæ²¡æœ‰ï¼Œè¿™å°±æˆ‘ä»¬å¯ä»¥å°†transmonå½“ä½œé‡å­æ¯”ç‰¹çš„åŸå› ã€‚æ­¤å¤„ï¼Œæˆ‘ä»¬é€šè¿‡ä½¿ç”¨[QuTiP](http://www.qutip.org/)ï¼ˆä½¿ç”¨pipå®‰è£…ï¼‰ä¾æ®å…¶å“ˆå¯†é¡¿é‡è®¡ç®—å‡ºèƒ½çº§çš„å·®å¼‚ã€‚

> import numpy as np
>
> import matplotlib.pyplot as plt
>
> E_J = 20e9
>
> w = 5e9
>
> anharm = -300e6
>
> N_phis = 101
>
> phis = np.linspace(-np.pi,np.pi,N_phis)
>
> mid_idx = int((N_phis+1)/2)
>
> \# potential energies of the QHO & transmon
>
> U_QHO = 0.5\*E_J\*phis\*\*2
>
> U_QHO = U_QHO/w
>
> U_transmon = (E_J-E_J\*np.cos(phis))
>
> U_transmon = U_transmon/w
>
> \# import QuTiP, construct Hamiltonians, and solve for energies
>
> from qutip import destroy
>
> N = 35
>
> N_energies = 5
>
> c = destroy(N)
>
> H_QHO = w\*c.dag()\*c
>
> E_QHO = H_QHO.eigenenergies()\[0:N_energies\]
>
> H_transmon = w\*c.dag()\*c + (anharm/2)\*(c.dag()\*c)\*(c.dag()\*c -
> 1)
>
> E_transmon = H_transmon.eigenenergies()\[0:2\*N_energies\]
>
> print(E_QHO\[:4\])
>
> print(E_transmon\[:8\])
>
> è¾“å‡ºï¼š
>
> \[0.0e+00 5.0e+09 1.0e+10 1.5e+10\]
>
> \[0.00e+00 1.70e+09 5.00e+09 6.60e+09 9.70e+09 1.12e+10 1.41e+10
> 1.55e+10\]
>
> fig, axes = plt.subplots(1, 1, figsize=(6,6))
>
> axes.plot(phis, U_transmon, \'-\', color=\'orange\', linewidth=3.0)
>
> axes.plot(phis, U_QHO, \'\--\', color=\'blue\', linewidth=3.0)
>
> for eidx in range(1,N_energies):
>
> delta_E\_QHO = (E_QHO\[eidx\]-E_QHO\[0\])/w
>
> delta_E\_transmon = (E_transmon\[2\*eidx\]-E_transmon\[0\])/w
>
> QHO_lim_idx = min(np.where(U_QHO\[int((N_phis+1)/2):N_phis\] \>
> delta_E\_QHO)\[0\])
>
> trans_lim_idx = min(np.where(U_transmon\[int((N_phis+1)/2):N_phis\] \>
> delta_E\_transmon)\[0\])
>
> trans_label, = axes.plot(\[phis\[mid_idx-trans_lim_idx-1\],
> phis\[mid_idx+trans_lim_idx-1\]\], \\
>
> \[delta_E\_transmon, delta_E\_transmon\], \'-\', color=\'orange\',
> linewidth=3.0)
>
> qho_label, = axes.plot(\[phis\[mid_idx-QHO_lim_idx-1\],
> phis\[mid_idx+QHO_lim_idx-1\]\], \\
>
> \[delta_E\_QHO, delta_E\_QHO\], \'\--\', color=\'blue\',
> linewidth=3.0)
>
> axes.set_xlabel(\'Phase \$\\phi\$\', fontsize=24)
>
> axes.set_ylabel(\'Energy Levels / \$\\hbar\\omega\$\', fontsize=24)
>
> axes.set_ylim(-0.2,5)
>
> qho_label.set_label(\'QHO Energies\')
>
> trans_label.set_label(\'Transmon Energies\')
>
> axes.legend(loc=2, fontsize=14)

![](pics/media/image364.png)

### 6. é‡å­æ¯”ç‰¹é©±åŠ¨ä¸æ—‹è½¬æ³¢è¿‘ä¼¼ï¼ˆRotating Wave Approximationï¼ŒRWAï¼‰

æ–½åŠ ä¸€ä¸ªç”µé©±åŠ¨åœº$\overset{\rightarrow}{E}(t) = {\overset{\rightarrow}{E}}_{0}e^{- i\omega_{d}t} + {\overset{\rightarrow}{E}}_{0}^{*}e^{i\omega_{d}t}$è‡³transmonï¼Œåœ¨transmonå’Œå¾®æ³¢åœºä¹‹é—´å¼•å…¥äº†ä¸€ä¸ªå¶æå­ç›¸äº’ä½œç”¨ï¼ˆdipole
interactionï¼‰ã€‚æˆ‘ä»¬åœ¨æ­¤å¤„å°†transmonç›´æ¥æ˜¯ä¸ºä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼Œå› æ­¤transmonçš„å“ˆå¯†é¡¿é‡æ˜¯é‡å­æ¯”ç‰¹å“ˆå¯†é¡¿é‡${\widehat{H}}_{0}$ä¸é©±åŠ¨å“ˆå¯†é¡¿é‡${\widehat{H}}_{d}$çš„å’Œï¼š

$$\overset{\hat{}}{H} = {\overset{\hat{}}{H}}_{0} + {\overset{\hat{}}{H}}_{d}\text{\ \ }ä»¥åŠ\text{\ \ }{\overset{\hat{}}{H}}_{0} = - \frac{1}{2}\hslash\omega_{q}\sigma^{z}$$

å…¶ä¸­$\sigma^{z}$æ˜¯Pauli$- Z$çŸ©é˜µã€‚æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨Pauliä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦$\sigma^{\pm} = (1/2)(\sigma^{x} \mp i\sigma^{y})$ï¼Œè¿™ä¸¤ä¸ªç®—ç¬¦æœ‰ä½¿å¾—$\sigma^{+}|0\rangle = |1\rangle$ä»¥åŠ$\sigma^{+}|1\rangle = |0\rangle$çš„æ•ˆæœã€‚æ­¤å¤„åº”å½“æ³¨æ„ï¼Œè¯¥å®šä¹‰åæ˜ å‡ºæˆ‘ä»¬æ‰€ä½¿ç”¨çš„æ˜¯é‡å­æ¯”ç‰¹ä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦ï¼Œè€Œéæ—‹è½¬è¿ç®—ç¬¦ã€‚å› åœ¨ç¬¬1èŠ‚ä¸­å·²è®¨è®ºçš„åŸå› ï¼Œ$|0\rangle \equiv | \uparrow \rangle$å’Œ$|1\rangle \equiv | \downarrow \rangle$ä½¿å¾—ä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦åè½¬ã€‚ç°å› åœºèƒ½æ¿€å‘å’Œåˆ¶æ¿€é‡å­æ¯”ç‰¹ï¼Œå®šä¹‰å¶æç®—ç¬¦$\overset{\rightarrow}{d} = {\overset{\rightarrow}{d}}_{0}\sigma^{+} + {\overset{\rightarrow}{d}}_{0}^{*}\sigma^{-}$ã€‚å¶æå­ç›¸äº’ä½œç”¨çš„é©±åŠ¨å“ˆå¯†é¡¿é‡ä¸ºï¼š

$${\overset{\hat{}}{H}}_{d} = - \overset{\rightarrow}{d} \cdot \overset{\rightarrow}{E}(t) = - ({\overset{\rightarrow}{d}}_{0}\sigma^{+} + {\overset{\rightarrow}{d}}_{0}^{*}\sigma^{-}) \cdot ({\overset{\rightarrow}{E}}_{0}e^{- i\omega_{d}t} + {\overset{\rightarrow}{E}}_{0}^{*}e^{i\omega_{d}t}) = - ({\overset{\rightarrow}{d}}_{0} \cdot {\overset{\rightarrow}{E}}_{0}e^{- i\omega_{d}t} + {\overset{\rightarrow}{d}}_{0} \cdot {\overset{\rightarrow}{E}}_{0}^{*}e^{i\omega_{d}t})\sigma^{+} - ({\overset{\rightarrow}{d}}_{0}^{*} \cdot {\overset{\rightarrow}{E}}_{0}e^{- i\omega_{d}t} + {\overset{\rightarrow}{d}}_{0}^{*} \cdot {\overset{\rightarrow}{E}}_{0}^{*}e^{i\omega_{d}t})\sigma^{-} \equiv - \hslash(\Omega e^{- i\omega_{d}t} + \overset{\sim}{\Omega}e^{i\omega_{d}t})\sigma^{+} - \hslash({\overset{\sim}{\Omega}}^{*}e^{- i\omega_{d}t} + \Omega^{*}e^{i\omega_{d}t})\sigma^{-}$$

ä¸ºæè¿°åœºå’Œå¶æå­çš„å¼ºåº¦ï¼Œä¸Šå¼ä¸­è¿›è¡Œäº†$\Omega = {\overset{\rightarrow}{d}}_{0} \cdot {\overset{\rightarrow}{E}}_{0}$ä¸$\overset{\sim}{\Omega} = {\overset{\rightarrow}{d}}_{0} \cdot {\overset{\rightarrow}{E}}_{0}^{*}$çš„æ›¿æ¢ã€‚ç°åœ¨ï¼Œä½¿ç”¨ä¸‹å¼å˜æ¢ç›¸äº’ç»˜æ™¯ï¼ˆç‹„æ‹‰å…‹ç»˜æ™¯Dirac
pictureï¼‰${\overset{\hat{}}{H}}_{d,I} = U{\overset{\hat{}}{H}}_{d}U^{\dagger}$ï¼ˆå…¶ä¸­çœç•¥çš„é€€å‡ºé¡¹ï¼‰ï¼š

$$U = e^{i{\overset{\hat{}}{H}}_{0}t/\hslash} = e^{- i\omega_{q}t\sigma^{z}/2} = I\cos(\omega_{q}t/2) - i\sigma^{z}\sin(\omega_{q}t/2)$$

è®¡ç®—ç®—ç¬¦é¡¹ï¼š

$$\left( \text{Icos}\left( \frac{\omega_{q}t}{2} \right) - i\sigma^{z}\sin\left( \frac{\omega_{q}t}{2} \right) \right)\sigma^{+}\left( \text{Icos}\left( \frac{\omega_{q}t}{2} \right) + i\sigma^{z}\sin\left( \frac{\omega_{q}t}{2} \right) \right) = e^{i\omega_{q}t}\sigma^{+}$$

$$\left( \text{Icos}\left( \frac{\omega_{q}t}{2} \right) - i\sigma^{z}\sin\left( \frac{\omega_{q}t}{2} \right) \right)\sigma^{-}\left( \text{Icos}\left( \frac{\omega_{q}t}{2} \right) + i\sigma^{z}\sin\left( \frac{\omega_{q}t}{2} \right) \right) = e^{- i\omega_{q}t}\sigma^{-}$$

å˜æ¢åçš„å“ˆå¯†é¡¿é‡ä¸ºï¼š

$${\overset{\hat{}}{H}}_{d,I} = U{\overset{\hat{}}{H}}_{d}U^{\dagger} = - \hslash(\Omega e^{- i\omega_{d}t} + \overset{\sim}{\Omega}e^{i\omega_{d}t})e^{i\omega_{q}t}\sigma^{+} - \hslash({\overset{\sim}{\Omega}}^{*}e^{- i\omega_{d}t} + \Omega^{*}e^{i\omega_{d}t})e^{- i\omega_{q}t}\sigma^{-} = - \hslash(\Omega e^{- i\Delta_{q}t} + \overset{\sim}{\Omega}e^{i(\omega_{q} + \omega_{d})t})\sigma^{+} - \hslash({\overset{\sim}{\Omega}}^{*}e^{- i(\omega_{q} + \omega_{d})t} + \Omega^{*}e^{i\Delta_{q}t})\sigma^{-}$$

ç°åœ¨è¿›è¡Œæ—‹è½¬æ³¢è¿‘ä¼¼ï¼šç”±äº$\omega_{q} + \omega_{d}$è¿œå¤§äº$\Delta_{q} = \omega_{q} - \omega_{d}$ï¼Œå¸¦æœ‰æŒ‡æ•°å’Œçš„é¡¹å¿«é€ŸæŒ¯è¡ï¼Œæœ‰æ•ˆåœ°å¹³è¡¡äº†å…¶è´¡çŒ®ï¼Œå› æ­¤æˆ‘ä»¬ä»å¯ä»¥ä»å“ˆå¯†é¡¿é‡ä¸­åˆ é™¤è¿™äº›é¡¹ã€‚è‡³æ­¤RWAäº¤äº’å“ˆå¯†é¡¿é‡å˜ä¸ºï¼š

$${\overset{\hat{}}{H}}_{d,I}^{(\text{RWA})} = - \hslash\Omega e^{- i\Delta_{q}t}\sigma^{+} - \hslash\Omega^{*}e^{i\Delta_{q}t}\sigma^{-}$$

å›åˆ°è–›å®šè°”ç»˜æ™¯ï¼ˆSchrÃ¶dinger pictureï¼‰ï¼š

$${\overset{\hat{}}{H}}_{d}^{(\text{RWA})} = U^{\dagger}{\overset{\hat{}}{H}}_{d,I}^{(\text{RWA})}U = - \hslash\Omega e^{- i\omega_{d}t}\sigma^{+} - \hslash\Omega^{*}e^{i\omega_{d}t}\sigma^{-}$$

å› æ­¤æ‰€æœ‰é‡å­æ¯”ç‰¹å’Œé©±åŠ¨çš„å“ˆå¯†é¡¿é‡ä¸ºï¼š

$${\overset{\hat{}}{H}}^{(\text{RWA})} = - \frac{1}{2}\hslash\omega_{q}\sigma^{z} - \hslash\Omega e^{- i\omega_{d}t}\sigma^{+} - \hslash\Omega^{*}e^{i\omega_{d}t}\sigma^{-}.$$

è¿›å…¥é©±åŠ¨å¸§ï¼Œä½¿ç”¨$U_{d} = \exp\{ - i\omega_{d}t\sigma^{z}/2\}$å˜æ¢ï¼Œå“ˆå¯†é¡¿é‡å˜ä¸ºï¼š

$${\overset{\hat{}}{H}}_{\text{eff}} = U_{d}{\overset{\hat{}}{H}}^{(\text{RWA})}U_{d}^{\dagger} - i\hslash U_{d}{\overset{Ë™}{U}}_{d}^{\dagger}$$

å…¶ä¸­${\overset{Ë™}{U}}_{d} = dU_{d}/dt$æ˜¯$U_{d}$çš„æ—¶é—´å¯¼æ•°ã€‚åœ¨RWAä¸‹çš„é©±åŠ¨å™¨å¸§ä¸­ï¼š

$${\overset{\hat{}}{H}}_{\text{eff}} = - \frac{1}{2}\hslash\omega_{q}\sigma^{z} - \hslash\Omega\sigma^{+} - \hslash\Omega^{*}\sigma^{-} + \frac{1}{2}\hslash\omega_{d}\sigma^{z} = - \frac{1}{2}\hslash\Delta_{q}\sigma^{z} - \hslash\Omega\sigma^{+} - \hslash\Omega^{*}\sigma^{-}$$

å‡è®¾é©±åŠ¨çœŸå®ï¼Œå› æ­¤$\Omega = \Omega^{*}$ï¼Œåˆ™ä¸Šå¼å¯ç®€åŒ–ä¸ºï¼š

$${\overset{\hat{}}{H}}_{\text{eff}} = - \frac{1}{2}\hslash\Delta_{q}\sigma^{z} - \hslash\Omega\sigma^{x}.$$

è¡¨æ˜ï¼šå½“é©±åŠ¨ä¸é‡å­æ¯”ç‰¹è°æŒ¯æ—¶ï¼ˆå³$\Delta_{q} = 0$ï¼‰ï¼Œé©±åŠ¨ä¼šåœ¨Blochçƒä¸­å¼•èµ·$x$æ—‹è½¬ï¼Œè¯¥æ—‹è½¬ç”±$\sigma^{x}$äº§ç”Ÿï¼Œå…¶å¼ºåº¦ä¸º$\Omega$ã€‚æˆ‘ä¹ˆå¯ä»¥åœ¨"é€šè¿‡Qiskitè„‰å†²æ ¡å‡†é‡å­æ¯”ç‰¹"ä¸€èŠ‚çœ‹åˆ°è¿™ä¸€è°æŒ¯é‡å­æ¯”ç‰¹ä¸é©±åŠ¨çš„æ•ˆæœã€‚å¤±è°é©±åŠ¨å…·æœ‰è‡ª$\sigma^{z}$äº§ç”Ÿçš„å…¶ä»–$z$æ—‹è½¬ï¼Œè¿™äº›æ—‹è½¬åœ¨Ramseyå®éªŒä¸­è¡¨ç°ä¸ºæŒ¯è¡ã€‚

6.4 é‡å­å›è·¯çš„é‡å­ç”µåŠ¨åŠ›å­¦
--------------------------

### å†…å®¹

1\. ç®€ä»‹

2\. Schrieffer-Wolffå˜æ¢

3\. Jaynes-Cummingså“ˆå¯†é¡¿é‡çš„å—å¯¹è§’åŒ–

4\. å…¨Transmon

5\. å…·æœ‰cQEDçš„Qubité©±åŠ¨

6\. äº¤å‰è°æŒ¯çº ç¼ é‡å­é—¨

### 1. ç®€ä»‹

é€šè¿‡ç±»æ¯”è…”é‡å­ç”µåŠ¨åŠ›å­¦ï¼ˆCavity Quantum
Electrodynamicsï¼ŒCQEDï¼‰ï¼Œå›è·¯ç”µåŠ¨åŠ›å­¦ï¼ˆcircuit
QEDï¼ŒcQEDï¼‰è¿ç”¨äº†ä½¿ç”¨ç®€å•æ¨¡å‹æ¥æè¿°åŸå­ä¸å…‰å­¦è…”ä»¥åŠé‡å­æ¯”ç‰¹ä¸å¾®æ³¢è°æŒ¯å™¨ç›¸äº’ä½œç”¨çš„åŸç†ã€‚è¯¥æ¨¡å‹åŒ…æ‹¬ç©ºè…”/è°æŒ¯å™¨ä¸­çš„å…‰å­æ•°é‡

ã€åŸå­/é‡å­æ¯”ç‰¹çš„çŠ¶æ€ä»¥åŠåŸå­/é‡å­æ¯”ç‰¹ä¸ç©ºè…”/è°æŒ¯å™¨ä¹‹é—´çš„ç”µå¶æå­ç›¸äº’ä½œç”¨ã€‚æ­£å¦‚åœ¨ä¸Šä¸€èŠ‚ä¸­æ‰€è¿°ï¼Œtransmonå®é™…ä¸Šæ˜¯å¤šèƒ½çº§ç³»ç»Ÿï¼Œä½†æ˜¯ç”±äºtransmonçš„éè°æ€§ï¼Œå¯èƒ½å°†å…¶è‡ªèº«é™åˆ¶åœ¨åŸºæ€$|0\rangle = |g\rangle$å’Œç¬¬ä¸€æ¿€å‘æ€çš„$|1\rangle = |e\rangle$ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†transmonæè¿°ä¸ºPauliè‡ªæ—‹çŸ©é˜µ$\sigma^{x} = (\begin{matrix}
0 & 1 \\
1 & 0 \\
\end{matrix})\text{\ \ Ïƒ}^{y} = (\begin{matrix}
0 & - i \\
i & 0 \\
\end{matrix})\text{\ \ Ïƒ}^{z} = (\begin{matrix}
1 & 0 \\
0 & - 1 \\
\end{matrix})$æ‰€æè¿°çš„ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¾æ®å›´ç»•Blochçƒå„ä¸ªè½´çš„æ—‹è½¬ã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œæè¿°è¿™ç§äº¤äº’ä½œç”¨æœ€ç®€å•çš„æ¨¡å‹æ˜¯æ—‹è½¬æ³¢é€¼è¿‘ä¸­çš„Jaynes-Cummingså“ˆå¯†é¡¿é‡ï¼š

$$H_{\text{JC}}^{(\text{RWA})}/\hslash = \omega_{r}a^{\dagger}a + \frac{1}{2}\omega_{q}\sigma_{z} + g(a^{\dagger}\sigma^{-} + a\sigma^{+}).$$

å…¶ä¸­$\omega_{r}$å’Œ$\omega_{q}$åˆ†åˆ«ä¸ºè°æŒ¯å™¨ï¼ˆresonatorï¼‰å’Œ"é‡å­æ¯”ç‰¹ï¼ˆqubitï¼‰"çš„é¢‘ç‡ï¼Œ$a(a^{\dagger})$æ˜¯è°æŒ¯å™¨å…‰å­æ¹®ç­ï¼ˆäº§ç”Ÿï¼‰ç®—ç¬¦ï¼Œ$g$æ˜¯ç”µå¶æè€¦åˆï¼ˆåŠçœŸç©ºRabiåˆ†è£‚ï¼‰ã€‚è¯·æ³¨æ„æ­¤å¤„çœç•¥äº†ç®—ç¬¦çš„å¸½å­"hat"ã€‚ç¬¬ä¸€é¡¹å¯¹åº”äºè°æŒ¯å™¨ä¸­çš„å…‰å­æ•°ï¼Œç¬¬äºŒé¡¹å¯¹åº”äºé‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œç¬¬ä¸‰é¡¹æ˜¯ç”µå¶æå­ç›¸äº’ä½œç”¨ï¼Œå…¶ä¸­$\sigma^{\pm} = (1/2)(\sigma^{x} \mp i\sigma^{y})$ä¸ºé‡å­æ¯”ç‰¹ä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦ã€‚ï¼ˆå¦‚ä¸Šä¸€ç« æ‰€è¿°ï¼Œæ‰€ä½¿ç”¨çš„ç¬¦å·ä¸æ—‹è½¬ä¸Šä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦çš„ç¬¦å·ç›¸åã€‚ï¼‰

è¿™ä¸€å“ˆå¯†é¡¿é‡å¯ä»¥ç²¾ç¡®æ±‚è§£ï¼Œè§£ä¸ºé‡å­æ¯”ç‰¹/è°æŒ¯å™¨çš„æ··åˆçŠ¶æ€ï¼Œå½“å¤„äºå…±æŒ¯çŠ¶æ€ï¼ˆ$\omega_{r} = \omega_{q}$ï¼‰æ—¶ä¸¤è€…ä¹‹é—´çš„æ¿€å‘ï¼ˆæ— è®ºå…±æŒ¯å™¨ä¸­çš„å…‰å­è¿˜æ˜¯é‡å­æ¯”ç‰¹çš„æ¿€å‘æ€ï¼‰äº¤æ¢é€Ÿç‡ä¸º$g$ã€‚ä¾‹å¦‚ï¼Œåœ¨é¡¹$a^{\dagger}\sigma^{-}$æ¶ˆç­äº†å…±æŒ¯å™¨ä¸­çš„ä¸€ä¸ªå…‰å­æˆ–å°†é‡å­æ¯”ç‰¹ä»æ€$|0\rangle$æ¿€å‘è‡³æ€$|1\rangle$æ—¶ï¼Œç¬¬ä¸‰é¡¹ä¸­çš„$a^{\dagger}\sigma^{-}$åœ¨å…±æŒ¯å™¨ä¸­åˆ›å»ºäº†ä¸€ä¸ªå…‰å­å¹¶å°†é‡å­æ¯”ç‰¹ä»æ€$|1\rangle$æ‹‰ä½ä¸ºæ€$|0\rangle$ã€‚å…¶ä¸­æœ‰è¶£çš„æ˜¯ï¼Œæˆ‘ä»¬å¸Œæœ›ä½¿ç”¨é‡å­è®¡ç®—æœºå¤„ç†é‡å­æ¯”ç‰¹ä¿„æ—¥éæ··åˆçŠ¶æ€ã€‚è¡¨æ˜éœ€è¦å°†è°æŒ¯å™¨å½“ä½œå¯¹äºé‡å­æ¯”ç‰¹çš„æ‘„åŠ¨ï¼ˆåä¹‹äº¦ç„¶ï¼‰ï¼Œå› æ­¤å…¶æ€§è´¨ä»…ä»…å› ä¸ºå¯¹æ–¹çš„å­˜åœ¨è€Œå­˜åœ¨ã€‚ä½¿ç”¨ä¸€ç§ç§°ä¸ºSchrieffer-Wolffï¼ˆS-Wï¼‰å˜æ¢çš„æ‘„åŠ¨ç†è®ºï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æƒ³è¦çš„æ“ä½œçŠ¶æ€ä¸‹è®¡ç®—é‡å­æ¯”ç‰¹å’Œè°æŒ¯å™¨çš„ç‰¹æ€§ã€‚æ­¤å¤„åº”æ³¨æ„ï¼Œå‡ºäºæ•™å­¦ä¸Šçš„åŸå› å°†transmonè§†ä¸ºqubitæ˜¯ä»…é€‚ç”¨äºè§£è¯´ï¼Œä½†å½“è€ƒè™‘transmonçš„æ‰€æœ‰èƒ½çº§æ—¶å¯ä»¥åº”ç”¨ç›¸åŒçš„æŠ€æœ¯ã€‚Transmonçš„è¾ƒé«˜èƒ½çº§çš„ä½œç”¨æ›´åŠ å¹¿æ³›ï¼Œåœ¨å¯¹å…¶è¿›è¡Œè®¾è®¡å’Œæ¨¡æ‹Ÿæ—¶å¿…é¡»åŠ ä»¥è€ƒè™‘ã€‚

### 2. Schrieffer-Wolffå˜æ¢

**è–›å®šè°”æ–¹ç¨‹**

é‡å­åŠ›å­¦ä¸­çš„é—®é¢˜é€šå¸¸æ˜¯å°†å“ˆå¯†é¡¿ç‰¹å¾å€¼æ–¹ç¨‹å¯¹è§’åŒ–çš„é—®é¢˜ï¼š

$$H\psi_{m} = E_{m}\psi_{m}\text{\ \ \ \ \ \ for\ \ \ \ \ \ }1 \leq m \leq n$$

å…¶ä¸­$\psi_{m}$æ˜¯æœ¬å¾å€¼$E_{m}$çš„æœ¬å¾æ€ã€‚å…¶ä¸­åŒ…å«æ‰¾å‡ºä¸€ä¸ªç±»ä¼¼å¯¹è§’çŸ©é˜µ$H^{'} = UHU^{\dagger}$çš„å¹ºæ­£çŸ©é˜µ$U$ã€‚åˆ™æœ¬å¾å€¼çš„æ–¹ç¨‹å˜ä¸ºï¼š

$$\overset{\hat{}}{H}\psi_{m} = E_{m}\psi_{m} \Longrightarrow UHU^{\dagger}U\psi_{m} = E_{m}U\psi_{m} \Longrightarrow H^{'}\psi_{m}^{'} = E_{m}\psi_{m}^{'}$$

å…¶ä¸­$\psi_{m}^{'} = U\psi_{m}$æ˜¯å˜æ¢åçš„æœ¬å¾æ€ï¼Œä»¥åŠ

$$H^{'} = \begin{pmatrix}
E_{1} & 0 & \cdots & 0 \\
0 & E_{2} & \cdots & 0 \\
 \vdots & \vdots & \ddots & 0 \\
0 & 0 & \cdots & E_{n} \\
\end{pmatrix}$$

æ˜¯å¯¹è§’å“ˆå¯†é¡¿é‡ã€‚

é€šè¿‡ç”¨S-Wå˜æ¢ä»£æ›¿å“ˆå¯†é¡¿é‡çš„å¯¹è§’åŒ–ï¼Œæˆ‘ä»¬å¯»æ±‚å°†å…¶å—å¯¹è§’åŒ–ï¼ˆ*block-diagonalize*ï¼‰ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå“ˆå¯†é¡¿é‡ï¼Œå¯ä»¥å°†å…¶åˆ†è§£æˆå¯¹è§’çº¿å’Œæ‘„åŠ¨éƒ¨åˆ†ï¼š

![](pics/media/image365.png)

ç„¶åå°†æ‘„åŠ¨éƒ¨åˆ†å†™ä¸º$H_{1} + H_{2}$ï¼Œå› æ­¤$H = H_{0} + H_{0} + H_{2}$ï¼Œå…¶ä¸­$H_{0}$æ˜¯å¯¹è§’çŸ©é˜µã€$H_{0}$æ˜¯å—å¯¹è§’çŸ©é˜µã€$H_{2}$æ˜¯éå—å¯¹è§’çŸ©é˜µï¼Œåˆ™ï¼š

![](pics/media/image366.png)

å¯ä»å—å¯¹è§’åŒ–$H$ä¸­æ‰¾å‡ºä¸€ä¸ªç®—ç¬¦$S$ï¼š

$$H_{\text{eff}} = e^{\text{iS}}He^{- iS} = \sum_{m = 0}^{\infty}{\frac{1}{m!}\lbrack H,S\rbrack^{(m)}} = \sum_{m = 0}^{\infty}{\lambda^{m}H^{(m)}}$$

å…¶ä¸­$H^{(m)}$æ˜¯$H$çš„é€æ¬¡é€¼è¿‘ï¼ˆ$H^{(0)} = H_{0}$ï¼‰ï¼Œå¹¿ä¹‰å¯¹æ˜“å¼è¢«é€’å½’åœ°å®šä¹‰ä¸ºï¼š

$$\lbrack H,S\rbrack^{\left( m \right)} = \lbrack\left\lbrack H,S\rbrack^{\left( m - 1 \right)},S \right\rbrack\text{\ \ \ \ }\text{with\ \ \ \ }\lbrack H,S\rbrack^{(0)} = H$$

æ­¤å¤„ï¼Œæˆ‘ä»¬å°†$S$æ˜¯ä¸ºä¸€ä¸ªæ³°å‹’çº§æ•°ï¼š

$$S = \sum_{m = 1}^{\infty}{\lambda^{m}S^{(m)}}$$

æ¥æŒç»­è·Ÿè¸ªé˜¶$\lambda$ã€‚ç„¶åå°†æœ‰æ•ˆçš„å“ˆå¯†é¡¿é‡ä½œä¸º$H_{1} + H_{2}$çš„æ‘„åŠ¨æ‰©å±•åˆ°$\lambda$ä¸­çš„ç¬¬äºŒé˜¶ï¼š

$$H_{\text{eff}} = H_{0} + \lambda(H_{1} + H_{2}) + \lbrack H_{0} + \lambda(H_{1} + H_{2}),\lambda S^{(1)}\rbrack + \frac{1}{2}\lbrack\lbrack H_{0} + \lambda(H_{1} + H_{2}),\lambda S^{(1)}\rbrack,\lambda S^{(1)}\rbrack + \lbrack H_{0} + \lambda(H_{1} + H_{2}),\lambda^{2}S^{(2)}\rbrack + \ldots \approx H_{0} + \lambda(H_{1} + H_{2} + \lbrack H_{0},S^{(1)}\rbrack) + \lambda^{2}(\lbrack H_{1} + H_{2},S^{(1)}\rbrack + \frac{1}{2}\lbrack\lbrack H_{0},S^{(1)},\rbrack S^{(1)}\rbrack + \lbrack H_{0},S^{(2)}\rbrack)$$

è‡³æ­¤ï¼Œæˆ‘ä»¬å¾—å‡º$S$å¿…ç„¶ä¸ºå—éå¯¹è§’ï¼ˆblock
off-diagonalï¼‰ä»¥åŠæ–œåŸƒå°”ç±³ç‰¹çŸ©é˜µï¼Œè¿«ä½¿$H_{\text{eff}}$çš„å¯¹è§’çº¿å…ƒç´ æ¶ˆå¤±ã€‚å› æ­¤æˆ‘ä»¬å¾—å‡ºï¼š

$$H_{\text{eff}}^{\text{off} - \text{diag}} = \sum_{m = 0}^{\infty}{\frac{1}{\left( 2m + 1 \right)!}\lbrack\underset{\text{block\ diag}}{\overset{H_{0} + H_{1}}{ï¸¸}},S\rbrack^{\left( 2m + 1 \right)}} + \sum_{m = 0}^{\infty}{\frac{1}{\left( 2m \right)!}\lbrack\underset{\text{block\ off-diag}}{\overset{H_{2}}{ï¸¸}},S\rbrack^{\left( 2m \right)}} \equiv 0$$

å¯ä»¥çœ‹åˆ°ç¬¬ä¸€ä¸ªçº§æ•°ä¸­çš„æ‰€æœ‰é¡¹å‡ä¸ºå—å¯¹è§’ï¼Œè€Œç¬¬äºŒä¸ªçº§æ•°ä¸­çš„æ‰€æœ‰é¡¹å‡ä¸ºå—éå¯¹è§’çº¿ã€‚è¿™æ˜¯å› ä¸ºå—å¯¹è§’çŸ©é˜µå’Œå—éå¯¹è§’çŸ©é˜µçš„å¯¹æ˜“å¼æ˜¯å—éå¯¹è§’çŸ©é˜µï¼Œè€Œä¸¤ä¸ªå—éå¯¹è§’çŸ©é˜µçš„å¯¹æ˜“å¼æ˜¯å—å¯¹è§’çŸ©é˜µã€‚å°†å…¶æ‰©å±•åˆ°å¹¿ä¹‰å¯¹æ˜“å¼åï¼Œæˆ‘ä»¬å°±å¯ä»¥çœ‹åˆ°nä¸ºå¥‡æ•°æ—¶$\lbrack H^{0} + H^{1},S\rbrack^{(n)}$å¿…ä¸ºå—éå¯¹è§’çŸ©é˜µï¼Œnä¸ºå¶æ•°æ—¶$\lbrack H^{2},S\rbrack^{(n)}$å¿…ä¸ºå—å¯¹è§’çŸ©é˜µã€‚ç°åœ¨å°†å“ˆå¯†é¡¿é‡çš„éå¯¹è§’éƒ¨åˆ†æ‰©å±•è‡³å…¶äºŒé˜¶å­å¼ï¼š

$$H_{\text{eff}}^{\text{off} - \text{diag}} = \lbrack H_{0} + \lambda H_{1},\lambda S^{(1)}\rbrack + \lambda H_{2} + \lbrack H_{0} + \lambda H_{1},\lambda^{2}S^{(2)}\rbrack + \frac{1}{3!}{\lbrack H_{0} + \lambda H_{1},\lambda S^{(1)}\rbrack}^{(3)} + \frac{1}{2!}{\lbrack\lambda H_{2},\lambda S^{(1)}\rbrack}^{(2)} = \lambda(\lbrack H_{0},S^{(1)}\rbrack + H_{2}) + \lambda^{2}(\lbrack H_{1},S^{(1)}\rbrack + \lbrack H_{0},S^{(2)}\rbrack) + \ldots$$

ç”±äº$\lambda$çš„æ¯ä¸€é˜¶å¿…ç„¶ç­‰äºé›¶ï¼Œå› æ­¤ä»¥ä¸‹å¼ç¡®å®š$S(m)$ï¼š

$$\lbrack H_{0},S^{(1)}\rbrack = - H_{2}\lbrack H_{0},S^{(2)}\rbrack = - \lbrack H_{1},S^{(1)}\rbrack\lbrack H_{0},S^{(3)}\rbrack = - \lbrack H_{1},S^{(2)}\rbrack - \frac{1}{3}\lbrack\lbrack H_{2},S^{(1)}\rbrack,S^{(1)}\rbrack$$

å…¶ä¸­æˆ‘ä»¬çš„æ‹Ÿè®¾ä¸ºé€šè¿‡Winklerçš„å·¥ä½œä¿è¯è¿™äº›ç­‰å¼å”¯ä¸€ã€‚åˆ™æœ‰æ•ˆå“ˆå¯†é¡¿é‡å˜ä¸ºï¼š

$$H_{\text{eff}} = H_{0} + H_{1} + \lbrack H_{2},S^{(1)}\rbrack + \frac{1}{2}\lbrack\lbrack H_{0},S^{(1)}\rbrack,S^{(1)}\rbrack + \ldots = H_{0} + H_{1} + \frac{1}{2}\lbrack H_{2},S^{(1)}\rbrack + \ldots$$

æ­¤å¤„çš„æœ‰æ•ˆå“ˆå¯†é¡¿é‡æ˜¯å–$\lambda \rightarrow 1$çš„ç¬¬äºŒé˜¶ã€‚

### 3. Jaynes-Cummingså“ˆå¯†é¡¿é‡çš„å—å¯¹è§’åŒ–

ä½¿ç”¨S-Wå˜æ¢ä¼šå¸¦å…¥ä¸¤ä¸ªé—®é¢˜ï¼š

1.  æ‰¾å‡ºæ­£ç¡®çš„æ‹Ÿè®¾ï¼›

2.  æ‰§è¡Œè®¡ç®—ã€‚

åœ¨å¤§éƒ¨åˆ†çš„ç¤ºä¾‹ä¸­ï¼Œæ‹Ÿè®¾ç±»ä¼¼äºç”Ÿæˆéå¯¹è§’éƒ¨åˆ†ä»¥åŠç¡®è®¤å…¶ä¸ºå”¯ä¸€ï¼ˆ$\text{postori}$ï¼‰ã€‚æœ€è¿‘ï¼ŒarXivä¸Šå‡ºç°äº†åä¸ºã€ŠSchrieffer-Wolffå˜æ¢çš„ç³»ç»Ÿæ–¹æ³•åŠå…¶æ¦‚æ‹¬ã€‹çš„æ–‡ç« ï¼Œå…¶ä¸­ç³»ç»Ÿåœ°ç»™å‡ºäº†æ‹Ÿè®¾å¹¶å°†å…¶åº”ç”¨äºå¤§éƒ¨åˆ†ç³»ç»Ÿï¼ˆåŒ…æ‹¬ä¸‹é¢çš„Jaynes-Cumming
Hamiltonianï¼‰ã€‚

è¯¸å¦‚ï¼Œç”Ÿæˆå™¨$\eta = \lbrack H_{0},H_{2}\rbrack$ã€‚åœ¨ä¸ç¡®å®š$\eta$çš„æ ‡é‡ç³»æ•°çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥å°†$S^{(1)}$è®¡ç®—ä¸ºæ»¡è¶³$\lbrack H_{0},\eta\rbrack = H_{2}$çš„ç‰¹å®š$\eta$ã€‚å› è€Œ$H_{0}$å’Œ$H_{2}$çš„å„ç±³æ€§ï¼ˆhermiticityï¼‰ä¿è¯äº†$\eta$çš„éå„ç±³æ€§ï¼ˆanti-hermiticityï¼‰ï¼Œä»è€Œä¿è¯äº†$S^{(1)}$çš„éå„ç±³æ€§ã€‚

ä¸ºäº†ç®€åŒ–ç¹ççš„è®¡ç®—ï¼Œæˆ‘ä»¬å°†ä¼šç”¨åˆ°Pythonè½¯ä»¶åŒ…sympyè¿›è¡Œç¬¦å·è¿ç®—ã€‚

> \# import SymPy and define symbols
>
> import sympy as sp
>
> sp.init_printing(use_unicode=True)
>
> wr = sp.Symbol(\'\\omega_r\') \# resonator frequency
>
> wq = sp.Symbol(\'\\omega_q\') \# qubit frequency
>
> g = sp.Symbol(\'g\', real=True) \# vacuum Rabi coupling
>
> Delta = sp.Symbol(\'Delta\', real=True) \# wr - wq; defined later
>
> \# import operator relations and define them
>
> from sympy.physics.quantum.boson import BosonOp
>
> a = BosonOp(\'a\') \# resonator photon annihilation operator
>
> from sympy.physics.quantum import pauli, Dagger, Commutator
>
> from sympy.physics.quantum.operatorordering import normal_ordered_form
>
> \# Pauli matrices
>
> sx = pauli.SigmaX()
>
> sy = pauli.SigmaY()
>
> sz = pauli.SigmaZ()
>
> \# qubit raising and lowering operators
>
> splus = pauli.SigmaPlus()
>
> sminus = pauli.SigmaMinus()
>
> \# define J-C Hamiltonian in terms of diagonal and non-block diagonal
> terms
>
> H0 = wr\*Dagger(a)\*a - (1/2)\*wq\*sz;
>
> H2 = g\*(Dagger(a)\*sminus + a\*splus);
>
> HJC = H0 + H2; HJC \# print
>
> è¾“å‡ºï¼š

$$- 0.5\omega_{q}\sigma_{z} + \omega_{r}a^{\dagger}a + g(a^{\dagger}\sigma_{-} + a\sigma_{+})$$

> \# using the above method for finding the ansatz
>
> eta = Commutator(H0, H2); eta
>
> è¾“å‡ºï¼š

$$- g\lbrack a^{\dagger}\sigma_{-} + a\sigma_{+}, - 0.5\omega_{q}\sigma_{z} + \omega_{r}a^{\dagger}a\rbrack$$

ä½œä¸ºå¯¹äºsympyçš„è¯´æ˜ï¼Œæˆ‘ä»¬å°†ä¼šä½¿ç”¨æ–¹æ³•doit()ã€expandã€normal_ordered_formä»¥åŠqsimplify_pauliæ¥å®é™…æ‰§è¡Œå¯¹æ˜“å¼ï¼Œå°†å…¶å±•å¼€è‡³å„ä¸ªé¡¹ä¸­ï¼Œå¯¹ç»è‰²å­æ¨¡å¼è¿›è¡Œæ­£å¸¸æ’åºï¼ˆåœ¨æ¹®æ²¡ä¹‹å‰äº§ç”Ÿï¼‰ï¼Œå¹¶ç®€åŒ–Pauliä»£æ•°ã€‚å°è¯•ç”¨$\eta$ç”Ÿæˆï¼š

> pauli.qsimplify_pauli(normal_ordered_form(eta.doit().expand()))
>
> è¾“å‡ºï¼š

$$1.0\omega_{q}ga^{\dagger}\sigma_{-} - 1.0\omega_{q}\text{ga}\sigma_{+} + \omega_{r}ga^{\dagger}\sigma_{-} - \omega_{r}\text{ga}\sigma_{+}$$

åˆ†åˆ«ä»¥$A$å’Œ$B$ä½œä¸º$a^{\dagger}\sigma_{-}$å’Œ$a\sigma_{+}$çš„ç³»æ•°ï¼Œåˆ™å¯¹æ˜“å¼å°†å˜ä¸ºï¼š

> A = sp.Symbol(\'A\')
>
> B = sp.Symbol(\'B\')
>
> eta = A \* Dagger(a) \* sminus - B \* a \* splus;
>
> pauli.qsimplify_pauli(normal_ordered_form(Commutator(H0,
> eta).doit().expand()))
>
> è¾“å‡ºï¼š

$$1.0A\omega_{q}a^{\dagger}\sigma_{-} + A\omega_{r}a^{\dagger}\sigma_{-} + 1.0B\omega_{q}a\sigma_{+} + B\omega_{r}a\sigma_{+}$$

è¯¥è¡¨è¾¾å¼åº”ç­‰äº$H_{2}$ï¼š

> H2
>
> è¾“å‡ºï¼š

$$g(a^{\dagger}\sigma_{-} + a\sigma_{+})$$

è¡¨æ˜$A = B = g/\Delta$ï¼Œå…¶ä¸­$\Delta = \omega_{r} - \omega_{q}$æ˜¯è°æŒ¯å™¨å’Œé‡å­æ¯”ç‰¹é—´çš„é¢‘ç‡å¤±è°ã€‚å› æ­¤$S^{(1)}$è¢«ç¡®å®šä¸ºï¼š

> S1 = eta.subs(A, g/Delta)
>
> S1 = S1.subs(B, g/Delta); S1.factor()
>
> è¾“å‡ºï¼š

$$\frac{g(a^{\dagger}\sigma_{-} - a\sigma_{+})}{\Delta}$$

ç„¶åå°±å¯ä»¥è®¡ç®—å‡ºå¯¹$H_{0}$çš„æœ‰æ•ˆäºŒé˜¶æ ¡æ­£ï¼š

> Heff = H0 +
> 0.5\*pauli.qsimplify_pauli(normal_ordered_form(Commutator(H2,
> S1).doit().expand())).simplify(); Heff
>
> è¾“å‡ºï¼š

$$- 0.5\omega_{q}\sigma_{z} + \omega_{r}a^{\dagger}a + \frac{0.5g^{2}(1 + 2a^{\dagger}a\sigma_{z} + \sigma_{z})}{\Delta}$$

ä¸Šå¼é€šå¸¸å†™æˆï¼š

$$H_{\text{eff}} = (\omega_{r} + \frac{g^{2}}{\Delta}\sigma_{z})a^{\dagger}a - \frac{1}{2}(\omega_{q} - \frac{g^{2}}{\Delta})\sigma_{z}$$

æ˜¾ç¤ºäº†è°æŒ¯å™¨é¢‘ç‡$x \equiv g^{2}/\Delta$çš„çŠ¶æ€ä¾èµ–ç§»ä½ï¼ˆstate-dependent
shiftï¼‰ï¼Œç§°ä¸ºac Stark
shiftã€‚ä»¥åŠç”±äºé‡å­çœŸç©ºæ³¢åŠ¨è€Œå¼•èµ·çš„é‡å­æ¯”ç‰¹é¢‘ç‡çš„ç§»ä½ï¼Œç§°ä¸ºLambç§»ä½ï¼ˆLamb
shiftï¼‰ã€‚

### 4. å…¨Transmon

ç”±äºæˆ‘ä»¬ç”¨transmonä»£æ›¿äº†é‡å­æ¯”ç‰¹ï¼Œæ‰€ä»¥åœ¨è®¾è®¡å’Œæ¨¡æ‹Ÿè®¾å¤‡æ—¶éœ€è¦éå¸¸å°å¿ƒåœ°å¤„ç†é«˜é˜¶èƒ½çº§é¡¹å¸¦å…¥çš„å½±å“ã€‚è€¦åˆè‡³è¯»å–è°æŒ¯å™¨çš„å…¨Transmonå“ˆå¯†é¡¿é‡ä¸ºï¼š

$$H^{\text{tr}} = \omega_{r}a^{\dagger}a + \sum_{j}^{}{\omega_{j}|j\rangle\langle j| + g(a^{\dagger}c + ac^{\dagger})}$$

å…¶ä¸­æ­¤å¤„çš„$c = \sum_{j}^{}{\sqrt{j + 1}|j\rangle\langle j + 1|}$ä¸ºtransmonä¸‹é™ç®—ç¬¦ã€‚åŒæ ·ï¼Œå°†å¼±ä½œç”¨å­é›†$A$ä½œä¸ºå¶æ•°transmonæ¨¡å¼ï¼Œå°†$B$ä½œä¸ºå¥‡æ•°transmonæ¨¡å¼ã€‚é‡‡ç”¨æ‹Ÿè®¾ï¼š

$$S^{(1)} = \sum_{j}^{}{\alpha_{j}a^{\dagger}\sqrt{j + 1}|j\rangle\langle j + 1| - \alpha_{j}^{*}a\sqrt{j + 1}|j + 1\rangle\langle j|}$$

æœ‰äººèƒ½ä¼šæ²¿ç”¨Jaynes-Cummingså“ˆå¯†é¡¿é‡çš„æ‚ä¹±ç‰ˆæœ¬ã€‚é€šè¿‡ä¸€äº›åŠªåŠ›ï¼Œå¯ä»¥è¯æ˜äºŒé˜¶æœ‰æ•ˆå“ˆå¯†é¡¿é‡ä¸ºï¼š

$$H_{\text{eff}}^{\text{tr}} = (\omega_{r} + \sum_{j}^{}{\frac{g^{2}(\omega_{r} - \omega + \delta)}{(\omega_{r} - \omega - \delta j)(\omega_{r} - \omega - \delta(j - 1))}|j\rangle\langle j|)a^{\dagger}a} + \sum_{j}^{}{\lbrack j\omega + \frac{\delta}{2}(j - 1)j + \frac{jg^{2}}{\omega - \omega_{r} + (j - 1)\delta}\rbrack}|j\rangle\langle j|$$

### 5. å…·æœ‰cQEDçš„Qubité©±åŠ¨

ä¾æ®Blaisç­‰äººäº2004å‘è¡¨çš„[æ–‡ç« ](https://arxiv.org/pdf/cond-mat/0402216.pdf)ï¼Œæˆ‘ä»¬å°†é©±åŠ¨çš„å“ˆå¯†é¡¿é‡å»ºæ¨¡ä¸ºï¼š

$$H^{d}(t) = \xi(t)(a^{\dagger}e^{- i\omega_{d}t} + ae^{i\omega_{d}t})$$

ä¾æ®Lev
Bishopåšå£«[è®ºæ–‡](https://arxiv.org/ftp/arxiv/papers/1007/1007.3520.pdf)ä¸­çš„å¤„ç†æ–¹æ³•ï¼Œé©±åŠ¨é€šè¿‡Glauberç®—ç¬¦ä½œç”¨äºé‡å­æ¯”ç‰¹ï¼š

$$D(\alpha) = e^{\alpha(t)a^{\dagger} - \alpha^{*}(t)a}$$

æˆ‘ä»¬æ¥çœ‹çœ‹åœ¨é©±åŠ¨é¢‘ç‡ä¸‹æ—‹è½¬çš„Jaynes-Cummingå“ˆå¯†é¡¿é‡ï¼š

$$H = \Delta_{r}a^{\dagger}a - \frac{1}{2}\Delta_{q}\sigma^{z} + g(a^{\dagger}\sigma^{-} + a\sigma^{+}) + \xi(t)(a^{\dagger} + a)$$

å…¶ä¸­$\Delta_{r} = \omega_{r} - \omega_{d}$ï¼Œ$\Delta_{q} = \omega_{q} - \omega_{d}$ã€‚å°†é˜¿è¾¾ç›å¼•ç†åº”ç”¨äºåµŒå¥—å¯¹æ˜“å¼ï¼š

$$e^{A}BA^{- A} = B + \lbrack A,B\rbrack + \frac{1}{2!}\lbrack A,\lbrack A,B\rbrack\rbrack + \frac{1}{3!}\lbrack A,\lbrack A,\lbrack A,B\rbrack\rbrack\rbrack + \ldots$$

æˆ‘ä»¬ä¼šçœ‹åˆ°ï¼š

$$D^{\dagger}a^{( \dagger )}D = \exp\{ - \alpha(t)a^{\dagger} + \alpha^{*}(t)a\} a^{( \dagger )}\exp\{\alpha(t)a^{\dagger} - \alpha^{*}(t)a\} = a^{( \dagger )} + \lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,a^{( \dagger )}\rbrack + \frac{1}{2!}\lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,\lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,a^{( \dagger )}\rbrack\rbrack + \ldots = a^{( \dagger )} + \alpha^{(*)}$$

ä»¥åŠï¼š

$$D^{\dagger}a^{\dagger}aD = a^{\dagger}a + \lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,a^{\dagger}a\rbrack + \frac{1}{2!}\lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,\lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,a^{\dagger}a\rbrack\rbrack + \ldots = a^{\dagger}a + \alpha(t)a^{\dagger} + \alpha^{*}(t)a + |\alpha(t)|^{2}$$

å› æ­¤æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸€å“ˆå¯†é¡¿é‡å˜æ¢ä¸ºï¼š

$$\overset{\sim}{H} = D^{\dagger}HD - iD^{\dagger}\overset{Ë™}{D} = \Delta_{r}(a^{\dagger}a + \alpha(t)a^{\dagger} + \alpha^{*}(t)a + |\alpha(t)|^{2}) - \frac{1}{2}\Delta_{q}\sigma^{z} + g((a^{\dagger} + \alpha^{*}(t))\sigma^{-} + (a + \alpha(t))\sigma^{+}) + \xi(t)(a^{\dagger} + \alpha^{*}(t) + a + \alpha(t)) - i(\overset{Ë™}{\alpha}(t)a^{\dagger} - {\overset{Ë™}{\alpha}}^{*}(t)a) = \Delta_{r}a^{\dagger}a - \frac{1}{2}\Delta_{q}\sigma^{z} + g((a^{\dagger} + \alpha^{*}(t))\sigma^{-} + (a + \alpha(t))\sigma^{+}) + \xi(t)(a^{\dagger} + a) + \Delta_{r}(\alpha(t)a^{\dagger} + \alpha^{*}(t)a) - i(\overset{Ë™}{\alpha}(t)a^{\dagger} - {\overset{Ë™}{\alpha}}^{*}(t)a)$$

å»æ‰äº†éç®—ç¬¦é¡¹ã€‚æœ€åä¸€è¡Œå¯ä»¥è®¾ç½®ä¸ºé›¶ï¼Œå¦‚ï¼š

$$- i\overset{Ë™}{\alpha}(t) + \Delta_{r}\alpha(t) + \xi(t) = 0$$

å¼•å…¥Rabié¢‘ç‡$\Omega(t) = 2g\alpha(t)$åå¾—åˆ°ï¼š

$$\overset{\sim}{H} = \Delta_{r}a^{\dagger}a - \frac{1}{2}\Delta_{q}\sigma^{z} + g(a^{\dagger}\sigma^{-} + a\sigma^{+}) + \frac{1}{2}(\Omega^{*}(t)\sigma^{-} + \Omega(t)\sigma^{+})$$

ç”±äºå“ˆå¯†é¡¿é‡çš„é©±åŠ¨éƒ¨åˆ†æ˜¯å—éå¯¹è§’çº¿çŸ©é˜µï¼Œå› æ­¤å¯¹äºçœŸå®é©±åŠ¨$\Omega^{*}(t) = \Omega(t)$æˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡ŒSchrieffer-Wolffå˜æ¢ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°æœ‰æ•ˆå“ˆå¯†é¡¿é‡ä¸­ï¼š

$$\lbrack{\overset{\sim}{H}}^{d},S^{(1)}\rbrack = - \frac{\Omega(t)}{2}\lbrack(\sigma^{-} + \sigma^{+}),\frac{g}{\Delta}(a^{\dagger}\sigma^{-} - a\sigma^{+})\rbrack = \frac{g\Omega(t)}{2\Delta}(a + a^{\dagger})\sigma^{z}$$

å› è€Œï¼Œæœ‰æ•ˆå“ˆå¯†é¡¿é‡å°±å˜ä¸ºï¼š

$${\overset{\sim}{H}}_{\text{eff}} = (\Delta_{r} + \frac{g^{2}}{\Delta}\sigma^{z})a^{\dagger}a - \frac{1}{2}(\Delta_{q} - \frac{g^{2}}{\Delta})\sigma^{z} + \frac{\Omega(t)}{2}\sigma^{x} + \frac{g\Omega(t)}{4\Delta}(a + a^{\dagger})\sigma^{z}$$

æ­¤å¤„å¯ä»¥çœ‹åˆ°è‹¥è¦æ¶ˆé™¤$z$æ—‹è½¬ï¼Œéœ€è¦åœ¨ç»Lambç§»ä½ï¼ˆLamb-shiftedï¼‰çš„é‡å­æ¯”ç‰¹é¢‘ç‡ä¸Šæ–½åŠ é©±åŠ¨ã€‚ç”±äºåœ¨é¢‘æ•£çŠ¶å†µä¸‹$\Delta \gg g$ï¼Œé™„åŠ é¡¹$\sigma^{z}$å¾ˆå°ã€‚

### 6. äº¤å‰è°æŒ¯çº ç¼ é‡å­é—¨

ä»¥é‡å­æ€æ¯”ç‰¹2çš„é¢‘ç‡é©±åŠ¨é‡å­æ¯”1å¯ä»¥å†™æˆï¼š

$$H^{d}(t) = \frac{\Omega(t)}{2}(\sigma_{1}^{+}e^{- i{\overset{\sim}{\omega}}_{2}t} + \sigma_{1}^{-}e^{i{\overset{\sim}{\omega}}_{2}t}).$$

ç°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦å°†Schrieffer-Wolffæ–½åŠ åœ¨é©±åŠ¨é¡¹ä¸Šæ¥è·å¾—æœ‰æ•ˆçš„å“ˆå¯†é¡¿é‡ï¼Œç„¶ååœ¨é¢‘ç‡${\overset{\sim}{\omega}}_{2}$å¤„è¿›è¡ŒRWAï¼ˆæ—‹è½¬æ³¢è¿‘ä¼¼
Rotating Wave Approximationï¼‰ã€‚

$$\lbrack{\overset{\sim}{H}}^{d},S^{(1)}\rbrack = - \frac{J\Omega(t)}{2\Delta_{12}}\lbrack\sigma_{1}^{+}e^{- i{\overset{\sim}{\omega}}_{2}t} + \sigma_{1}^{-}e^{i{\overset{\sim}{\omega}}_{2}t},\sigma_{1}^{+}\sigma_{2}^{-} - \sigma_{2}^{+}\sigma_{1}^{-}\rbrack = - \frac{J\Omega(t)}{2\Delta_{12}}(\sigma_{1}^{z}\sigma_{2}^{+}e^{- i{\overset{\sim}{\omega}}_{2}t} + \sigma_{1}^{z}\sigma_{2}^{-}e^{i{\overset{\sim}{\omega}}_{2}t})$$

é€šè¿‡åœ¨$\omega_{2}$å‡ºå˜æ¢ä¼šæ—‹è½¬å¸§ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°æœ‰æ•ˆçš„é‡å­æ¯”ç‰¹äº¤å‰è°æŒ¯å“ˆå¯†é¡¿é‡ï¼š

$${\overset{\sim}{H}}_{\text{eff}}^{\text{CR}} = - \frac{{\overset{\sim}{\omega}}_{1} - {\overset{\sim}{\omega}}_{2}}{2}\sigma_{1}^{z} + \frac{\Omega(t)}{2}(\sigma_{2}^{x} - \frac{J}{2\Delta_{12}}\sigma_{1}^{z}\sigma_{2}^{x}).$$

å‰ä¸¤é¡¹æ¶‰åŠç”±äºé‡å­æ¯”ç‰¹1ä¸Šçš„Starkç§»ä½å’Œé‡å­æ¯”ç‰¹2ä¸Šçš„æ— æ¡ä»¶$\text{IX}$æ—‹è½¬è€Œå¼•èµ·çš„$\text{ZI}$äº¤äº’ï¼Œä½†æ˜¯æœ€åä¸€é¡¹å‘ˆç°äº†äº§ç”Ÿçº ç¼ çš„$\text{ZX}$-äº¤äº’ã€‚é€šè¿‡å°†é‡å­æ¯”ç‰¹1ç½®äº$|0\rangle$å’Œ$|1\rangle$çš„ç­‰åŒå åŠ ï¼Œå¹¶åœ¨ä¸ç»•$x$è½´è¿›è¡Œ$\pi/2$æ—‹è½¬ç›¸å¯¹åº”çš„æŒç»­æ—¶é—´å†…æ–½åŠ äº¤å‰è°æŒ¯é—¨ï¼Œä¾¿äº§ç”Ÿäº†æœ€å¤§çš„çº ç¼ æ€ã€‚ç”¨Qiskitè¡¨å¾transmonçš„åŒé‡å­æ¯”ç‰¹äº¤å‰è°æŒ¯å“ˆå¯†é¡¿é‡çš„è¿‡ç¨‹å¯åœ¨[Github](https://github.com/Qiskit/qiskit-tutorials/blob/9405254b38312771f8d5c2dd6f451cec35307995/tutorials/noise/1_hamiltonian_and_gate_characterization.ipynb)ä¸Šæ‰¾åˆ°ã€‚å…³äºäº¤å‰è°æŒ¯é‡å­é—¨çš„è¡¥å……é˜…è¯»èµ„æ–™ï¼š

1\. [A simple all-microwave entangling gate for fixed-frequency
superconducting qubits](https://arxiv.org/abs/1106.0553)

2\. [Procedure for systematically tuning up crosstalk in the cross
resonance gate](https://arxiv.org/abs/1603.04821)

7. é—®é¢˜é›†ä¸ç»ƒä¹ 
===============

è‹¥è¦å®Œå…¨ç†è§£æœ¬æ•™ç¨‹ä¸­çš„æ¦‚å¿µï¼Œå°±éœ€è¦è§£ç­”å°½å¯èƒ½å¤šçš„é—®é¢˜ã€‚é™¤äº†è´¯ç©¿å„ç« çš„å¿«é€Ÿç»ƒä¹ ä¹‹å¤–ï¼Œæœ¬æ•™ç¨‹è¿˜æä¾›äº†æ¶µç›–æ‰€æ¶‰åŠä¸»é¢˜çš„é—®é¢˜é›†ã€‚æˆ‘ä»¬å°†åœ¨ç›¸å…³ç« èŠ‚çš„æœ«å°¾ç»™å‡ºè¿™äº›æ–‡ä»¶çš„é“¾æ¥ï¼Œä¸ºäº†æ‚¨å¯ä»¥è½»æ¾åœ°è¿›è¡ŒæŸ¥æ‰¾ï¼Œæ­¤å¤„å°†å…¶å†æ¬¡åˆ—å‡ºã€‚

é—®é¢˜é›†1ï¼šå¸¦æœ‰é‡å­å›è·¯çš„ç»å…¸é€»è¾‘é—¨
---------------------------------

> from qiskit import \*
>
> from qiskit.tools.visualization import plot_histogram
>
> import numpy as np

ä½¿ç”¨éé—¨ï¼ˆåœ¨Qiskitä¸­è¡¨ç¤ºä¸ºxï¼‰ï¼Œå—æ§éé—¨ï¼ˆåœ¨Qiskitä¸­è¡¨ç¤ºä¸ºcxï¼‰å’ŒToffolié—¨ï¼ˆåœ¨Qiskitä¸­è¡¨ç¤ºä¸ºccxï¼‰åˆ›å»ºå¯ä»¥å®ç°å¼‚æˆ–ã€ä¸ã€ä¸éä»¥åŠæˆ–é—¨çš„å‡½æ•°ã€‚

ä»¥éé—¨çš„å®ç°ä¸ºä¾‹ã€‚

### NOT gateï¼ˆéé—¨ï¼‰

æ­¤å‡½æ•°æ¥å—äºŒè¿›åˆ¶å­—ç¬¦ä¸²è¾“å…¥ï¼ˆ"0"æˆ–"1"ï¼‰å¹¶è¿”å›ç›¸åçš„äºŒè¿›åˆ¶è¾“å‡ºã€‚

> def NOT(input):
>
> q = QuantumRegister(1) \# a qubit in which to encode and manipulate
> the input
>
> c = ClassicalRegister(1) \# a bit to store the output
>
> qc = QuantumCircuit(q, c) \# this is where the quantum program goes
>
> \# We encode \'0\' as the qubit state \|0âŸ©, and \'1\' as \|1âŸ©
>
> \# Since the qubit is initially \|0âŸ©, we don\'t need to do anything
> for an input of \'0\'
>
> \# For an input of \'1\', we do an x to rotate the \|0âŸ© to \|1âŸ©
>
> if input==\'1\':
>
> qc.x( q\[0\] )
>
> \# Now we\'ve encoded the input, we can do a NOT on it using x
>
> qc.x( q\[0\] )
>
> \# Finally, we extract the \|0âŸ©/\|1âŸ© output of the qubit and encode it
> in the bit c\[0\]
>
> qc.measure( q\[0\], c\[0\] )
>
> \# We\'ll run the program on a simulator
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> \# Since the output will be deterministic, we can use just a single
> shot to get it
>
> job = execute(qc,backend,shots=1)
>
> output = next(iter(job.result().get_counts()))
>
> return output

### å¼‚æˆ–é—¨ï¼ˆXOR gateï¼‰

æ¥å—ä¸¤ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²ä½œä¸ºè¾“å…¥ï¼Œå¹¶ç»™å‡ºä¸€ä¸ªè¾“å‡ºã€‚

å½“è¾“å…¥ç›¸ç­‰æ—¶ï¼Œè¾“å‡ºä¸º"0"ï¼Œå¦åˆ™ä¸º"1"ã€‚

> def XOR(input1,input2):
>
> q = QuantumRegister(2) \# two qubits in which to encode and manipulate
> the input
>
> c = ClassicalRegister(1) \# a bit to store the output
>
> qc = QuantumCircuit(q, c) \# this is where the quantum program goes
>
> \# YOUR QUANTUM PROGRAM GOES HERE
>
> qc.measure(q\[1\],c\[0\]) \# YOU CAN CHANGE THIS IF YOU WANT TO
>
> \# We\'ll run the program on a simulator
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> \# Since the output will be deterministic, we can use just a single
> shot to get it
>
> job = execute(qc,backend,shots=1,memory=True)
>
> output = job.result().get_memory()\[0\]
>
> return output

### ä¸é—¨ï¼ˆAND gateï¼‰

æ¥å—ä¸¤ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²ä½œä¸ºè¾“å…¥ï¼Œå¹¶ç»™å‡ºä¸€ä¸ªè¾“å‡ºã€‚

åªæœ‰å½“ä¸¤ä¸ªè¾“å…¥éƒ½ä¸º"1"æ—¶ï¼Œè¾“å‡ºæ‰ä¸º"1"ã€‚

> def AND(input1,input2):
>
> q = QuantumRegister(3) \# two qubits in which to encode the input, and
> one for the output
>
> c = ClassicalRegister(1) \# a bit to store the output
>
> qc = QuantumCircuit(q, c) \# this is where the quantum program goes
>
> \# YOUR QUANTUM PROGRAM GOES HERE
>
> qc.measure(q\[2\],c\[0\]) \# YOU CAN CHANGE THIS IF YOU WANT TO
>
> \# We\'ll run the program on a simulator
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> \# Since the output will be deterministic, we can use just a single
> shot to get it
>
> job = execute(qc,backend,shots=1,memory=True)
>
> output = job.result().get_memory()\[0\]
>
> return output

### ä¸éé—¨ï¼ˆNAND gateï¼‰

æ¥å—ä¸¤ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²ä½œä¸ºè¾“å…¥ï¼Œå¹¶ç»™å‡ºä¸€ä¸ªè¾“å‡ºã€‚

åªæœ‰å½“ä¸¤ä¸ªè¾“å…¥éƒ½ä¸º"1"æ—¶ï¼Œè¾“å‡ºæ‰ä¸º"0"ã€‚

> def NAND(input1,input2):
>
> q = QuantumRegister(3) \# two qubits in which to encode the input, and
> one for the output
>
> c = ClassicalRegister(1) \# a bit to store the output
>
> qc = QuantumCircuit(q, c) \# this is where the quantum program goes
>
> \# YOUR QUANTUM PROGRAM GOES HERE
>
> qc.measure(q\[2\],c\[0\]) \# YOU CAN CHANGE THIS IF YOU WANT TO
>
> \# We\'ll run the program on a simulator
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> \# Since the output will be deterministic, we can use just a single
> shot to get it
>
> job = execute(qc,backend,shots=1,memory=True)
>
> output = job.result().get_memory()\[0\]
>
> return output

### æˆ–é—¨ï¼ˆOR gateï¼‰

æ¥å—ä¸¤ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²ä½œä¸ºè¾“å…¥ï¼Œå¹¶ç»™å‡ºä¸€ä¸ªè¾“å‡ºã€‚

å¦‚æœæœ‰ä¸€ä¸ªè¾“å…¥æ˜¯"1"ï¼Œåˆ™è¾“å‡ºæ˜¯"1"ã€‚

> def OR(input1,input2):
>
> q = QuantumRegister(3) \# two qubits in which to encode the input, and
> one for the output
>
> c = ClassicalRegister(1) \# a bit to store the output
>
> qc = QuantumCircuit(q, c) \# this is where the quantum program goes
>
> \# YOUR QUANTUM PROGRAM GOES HERE
>
> qc.measure(q\[2\],c\[0\]) \# YOU CAN CHANGE THIS IF YOU WANT TO
>
> \# We\'ll run the program on a simulator
>
> backend = Aer.get_backend(\'qasm_simulator\')
>
> \# Since the output will be deterministic, we can use just a single
> shot to get it
>
> job = execute(qc,backend,shots=1,memory=True)
>
> output = job.result().get_memory()\[0\]
>
> return output

### æµ‹è¯•

ä¸‹é¢çš„ä»£ç é€šè¿‡å¯¹ä¸Šè¿°å‡½æ•°å¯¼å…¥æ‰€æœ‰å¯èƒ½è¾“å…¥æ¥æ£€å…¶æ˜¯å¦æœ‰æ•ˆã€‚

> print(\'\\nResults for the NOT gate\')
>
> for input in \[\'0\',\'1\'\]:
>
> print(\' Input\',input,\'gives output\',NOT(input))
>
> print(\'\\nResults for the XOR gate\')
>
> for input1 in \[\'0\',\'1\'\]:
>
> for input2 in \[\'0\',\'1\'\]:
>
> print(\' Inputs\',input1,input2,\'give output\',XOR(input1,input2))
>
> print(\'\\nResults for the AND gate\')
>
> for input1 in \[\'0\',\'1\'\]:
>
> for input2 in \[\'0\',\'1\'\]:
>
> print(\' Inputs\',input1,input2,\'give output\',AND(input1,input2))
>
> print(\'\\nResults for the NAND gate\')
>
> for input1 in \[\'0\',\'1\'\]:
>
> for input2 in \[\'0\',\'1\'\]:
>
> print(\' Inputs\',input1,input2,\'give output\',NAND(input1,input2))
>
> print(\'\\nResults for the OR gate\')
>
> for input1 in \[\'0\',\'1\'\]:
>
> for input2 in \[\'0\',\'1\'\]:
>
> print(\' Inputs\',input1,input2,\'give output\',OR(input1,input2))
>
> è¾“å‡ºï¼š
>
> ç•¥
>
> import qiskit
>
> qiskit.\_\_qiskit_version\_\_

é—®é¢˜é›†2ï¼šå•é‡å­æ¯”ç‰¹é—¨çš„åŸºæœ¬åˆæˆ
-------------------------------

> from qiskit import \*
>
> from qiskit.tools.visualization import plot_histogram
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images look
> nice
>
> import numpy as np

### 1

é˜¿è¾¾ç›é—¨ï¼ˆHadamard gateï¼‰å¯ä»¥å†™æˆä»¥ä¸‹ä¸¤ç§å½¢å¼ï¼š

$$H = \frac{X + Z}{\sqrt{2}} \equiv \exp(i\frac{\pi}{2}\frac{X + Z}{\sqrt{2}})$$

æ­¤å¤„çš„$\equiv$è¢«ç”¨æ¥è¡¨ç¤ºåœ¨å…¨å±€ç›¸ä½ä¹‹å‰ç­‰å¼æœ‰æ•ˆï¼Œå› æ­¤æ‰€äº§ç”Ÿçš„é‡å­é—¨åœ¨ç‰©ç†ä¸Šç­‰æ•ˆã€‚

æç¤ºï¼šå¯¹äºä»»ä½•æœ¬å¾å€¼å‡ä¸ºÂ±1çš„çŸ©é˜µï¼Œå¾ˆå®¹æ˜“è¯æ˜$e^{i\frac{\pi}{2}M} \equiv M$ï¼Œå¹¶ä¸”æ­¤ç±»çŸ©é˜µå”¯ä¸€æ»¡è¶³$M^{2} = I$ã€‚

### 2

Hadamardé—¨å¯ä»¥é€šè¿‡rxå’Œrzæ“ä½œæ„é€ ï¼š

$$R_{x}\left( \theta \right) = e^{i\frac{\theta}{2}X}\ ,\text{\ R}_{z}\left( \theta \right) = e^{i\frac{\theta}{2}Z}$$

$$H \equiv \lim_{n \rightarrow \infty}\left( R_{x}\left( \frac{\theta}{n} \right)R_{z}\left( \frac{\theta}{n} \right) \right)^{n}$$

å¯¹äºä¸€äº›é€‚å½“é€‰æ‹©çš„$\theta$,å½“å®ç°ä¸ºæœ‰é™çš„$n$æ—¶ï¼Œæœ€ç»ˆçš„é‡å­é—¨å°†è¿‘ä¼¼äºHadamardé—¨ï¼Œå…¶è¯¯å·®éš$n$å‡å°è€Œå‡å°‘ã€‚

ä¸‹é¢å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨Qiskitå®æ–½çš„ç¤ºä¾‹ï¼Œè¯¥ç¤ºä¾‹ä½¿ç”¨é”™è¯¯é€‰æ‹©çš„$\theta$å€¼å¹¶ä¸”å¿½ç•¥äº†å…¨å±€ç›¸ä½ã€‚

-   ç¡®å®š$\theta$çš„æ­£ç¡®å€¼

-   å½“ä½¿ç”¨æ­£ç¡®çš„$\theta$å€¼æ—¶ï¼Œè¯æ˜è¯¯å·®ä»¥$n$çš„äºŒæ¬¡æ–¹å‡å°ã€‚

> q = QuantumRegister(1)
>
> c = ClassicalRegister(1)
>
> error = {}
>
> for n in range(1,11):
>
> \# Create a blank circuit
>
> qc = QuantumCircuit(q,c)
>
> \# Implement an approximate Hadamard
>
> theta = np.pi \# here we incorrectly choose theta=pi
>
> for j in range(n):
>
> qc.rx(theta/n,q\[0\])
>
> qc.rz(theta/n,q\[0\])
>
> \# We need to measure how good the above approximation is. Here\'s a
> simple way to do this.
>
> \# Step 1: Use a real hadamard to cancel the above approximation.
>
> \# For a good approximation, the qubit will return to state 0. For a
> bad one, it will end up as some superposition.
>
> qc.h(q\[0\])
>
> \# Step 2: Run the circuit, and see how many times we get the outcome
> 1.
>
> \# Since it should return 0 with certainty, the fraction of 1s is a
> measure of the error.
>
> qc.measure(q,c)
>
> shots = 20000
>
> job = execute(qc, Aer.get_backend(\'qasm_simulator\'),shots=shots)
>
> try:
>
> error\[n\] = (job.result().get_counts()\[\'1\'\]/shots)
>
> except:
>
> pass
>
> plot_histogram(error)

![](pics/media/image367.png)

### 3

å¯ä»¥ä»ä»¥ä¸‹å…¬å¼ä¸­æ‰¾åˆ°è¿‘ä¼¼å€¼çš„æ”¹è¿›ç‰ˆæœ¬ï¼š

$$H \equiv \lim_{n \rightarrow \infty}\left( R_{z}\left( \frac{\theta}{2n} \right)R_{x}\left( \frac{\theta}{n} \right)R_{z}\left( \frac{\theta}{2n} \right) \right)^{n}\ $$

å°†å…¶å®ç°ï¼Œå¹¶ç ”ç©¶è¯¯å·®çš„ç¼©æ”¾æ¯”ä¾‹ã€‚

> import qiskit
>
> qiskit.\_\_qiskit_version\_\_

é—®é¢˜é›†3ï¼šæ„å»ºæœ€ä½³ä¸é—¨
---------------------

> from qiskit import \*
>
> from qiskit.tools.visualization import plot_histogram
>
> %config InlineBackend.figure_format = \'svg\' \# Makes the images look
> nice
>
> from qiskit.providers.aer import noise
>
> import numpy as np

åœ¨é—®é¢˜é›†1ä¸­åˆ›å»ºäº†å¸¦æœ‰é‡å­é—¨çš„ä¸é—¨ã€‚åœ¨è¿™é‡Œæ‚¨å°†åœ¨çœŸå®è®¾å¤‡ä¸Šå†æ¬¡æ‰§è¡Œç›¸åŒæ“ä½œã€‚çœŸå®é‡å­è®¾å¤‡åŒ…å«ä¸¤ä¸ªä¸»è¦çš„é™åˆ¶ï¼šè¿é€šæ€§ã€å™ªå£°ã€‚

è¿é€šæ€§å‘Šè¯‰æ‚¨å¯ä»¥ç›´æ¥æ‰§è¡Œå“ªäº›cxé—¨ã€‚ä¾‹å¦‚ï¼Œè®¾å¤‡ibmq_5\_tenerifeå…·æœ‰ä»0åˆ°4ç¼–å·çš„äº”ä¸ªé‡å­æ¯”ç‰¹ã€‚å…¶è¿é€šæ€§ç”±ä¸‹å¼å®šä¹‰ï¼š

$$coupling\_ map = \lbrack\lbrack 1,\ 0\rbrack,\ \lbrack 2,\ 0\rbrack,\ \lbrack 2,\ 1\rbrack,\ \lbrack 3,\ 2\rbrack,\ \lbrack 3,\ 4\rbrack,\ \lbrack 4,\ 2\rbrack\rbrack$$

æ­¤å¤„çš„\[1,0\]å‘Šè¯‰æˆ‘ä»¬å¯ä»¥å®ç°ä»¥é‡å­æ¯”ç‰¹1ä½œä¸ºæ§åˆ¶ï¼Œä»¥é‡å­æ¯”ç‰¹0ä¸ºç›®æ ‡çš„cxï¼ˆå—æ§éé—¨ï¼‰ï¼Œ\[2,0\]å‘Šè¯‰æˆ‘ä»¬å¯ä»¥ä»¥é‡å­æ¯”ç‰¹2ä½œä¸ºæ§åˆ¶ï¼Œä»¥é‡å­æ¯”ç‰¹0ä¸ºç›®æ ‡ï¼Œä¾æ­¤ç±»æ¨ã€‚ä»¥ä¸Šè®¾å¤‡éƒ½å¯ä»¥ç›´æ¥å®ç°cxé—¨ã€‚

*è®¾å¤‡çš„"å™ªéŸ³"æ˜¯æ‰€æœ‰ä¸è¯¥å‘ç”Ÿä½†ä»ä¼šå‘ç”Ÿäº‹ç‰©çš„é›†ä½“æ•ˆåº”ã€‚*å™ªå£°å¯¼è‡´è¾“å‡ºç»“æœå¹¶ä¸æ€»å¦‚æˆ‘ä»¬æ‰€æœŸæœ›ã€‚é‡å­å›è·¯ä¸­çš„æ‰€æœ‰è¿‡ç¨‹ï¼ˆå‡†å¤‡åˆå§‹çŠ¶æ€ï¼Œåº”ç”¨é‡å­é—¨å’Œæµ‹é‡è¾“å‡ºï¼‰éƒ½åŒ…å«å™ªå£°ã€‚å¯¹äºé‡å­é—¨æ¥è¯´ï¼Œå™ªå£°æ°´å¹³å¯ä»¥åœ¨ä¸åŒçš„é—¨ä¹‹é—´ä»¥åŠåœ¨ä¸åŒçš„é‡å­æ¯”ç‰¹ä¹‹é—´å˜åŒ–ã€‚é€šå¸¸è€Œè¨€ï¼Œcxé—¨æ¯”ä»»ä½•å•é‡å­æ¯”ç‰¹é—¨éƒ½æ›´å˜ˆæ‚ã€‚

æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨å™ªå£°æ¨¡å‹æ¥æ¨¡æ‹Ÿå™ªå£°ã€‚è€Œä¸”ï¼Œæˆ‘ä»¬å¯ä»¥ä¾æ®å¯¹çœŸå®è®¾å¤‡å™ªå£°çš„æµ‹é‡æ¥è®¾ç½®å™ªå£°æ¨¡å‹ã€‚ä»¥ä¸‹çš„å™ªå£°æ¨¡å‹åŸºäºibmq_5\_tenerifeã€‚

noise_dict = {\'errors\': \[{\'type\': \'qerror\', \'operations\':
\[\'u2\'\], \'instructions\': \[\[{\'name\': \'x\', \'qubits\':
\[0\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'id\', \'qubits\': \[0\]}\]\],
\'probabilities\': \[0.0004721766167523067, 0.0004721766167523067,
0.0004721766167523067, 0.9985834701497431\], \'gate_qubits\':
\[\[0\]\]}, {\'type\': \'qerror\', \'operations\': \[\'u2\'\],
\'instructions\': \[\[{\'name\': \'x\', \'qubits\': \[0\]}\],
\[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'id\', \'qubits\': \[0\]}\]\],
\'probabilities\': \[0.0005151090708174488, 0.0005151090708174488,
0.0005151090708174488, 0.9984546727875476\], \'gate_qubits\':
\[\[1\]\]}, {\'type\': \'qerror\', \'operations\': \[\'u2\'\],
\'instructions\': \[\[{\'name\': \'x\', \'qubits\': \[0\]}\],
\[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'id\', \'qubits\': \[0\]}\]\],
\'probabilities\': \[0.0005151090708174488, 0.0005151090708174488,
0.0005151090708174488, 0.9984546727875476\], \'gate_qubits\':
\[\[2\]\]}, {\'type\': \'qerror\', \'operations\': \[\'u2\'\],
\'instructions\': \[\[{\'name\': \'x\', \'qubits\': \[0\]}\],
\[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'id\', \'qubits\': \[0\]}\]\],
\'probabilities\': \[0.000901556048412383, 0.000901556048412383,
0.000901556048412383, 0.9972953318547628\], \'gate_qubits\': \[\[3\]\]},
{\'type\': \'qerror\', \'operations\': \[\'u2\'\], \'instructions\':
\[\[{\'name\': \'x\', \'qubits\': \[0\]}\], \[{\'name\': \'y\',
\'qubits\': \[0\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}\],
\[{\'name\': \'id\', \'qubits\': \[0\]}\]\], \'probabilities\':
\[0.0011592423249461303, 0.0011592423249461303, 0.0011592423249461303,
0.9965222730251616\], \'gate_qubits\': \[\[4\]\]}, {\'type\':
\'qerror\', \'operations\': \[\'u3\'\], \'instructions\': \[\[{\'name\':
\'x\', \'qubits\': \[0\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}\],
\[{\'name\': \'z\', \'qubits\': \[0\]}\], \[{\'name\': \'id\',
\'qubits\': \[0\]}\]\], \'probabilities\': \[0.0009443532335046134,
0.0009443532335046134, 0.0009443532335046134, 0.9971669402994862\],
\'gate_qubits\': \[\[0\]\]}, {\'type\': \'qerror\', \'operations\':
\[\'u3\'\], \'instructions\': \[\[{\'name\': \'x\', \'qubits\':
\[0\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'id\', \'qubits\': \[0\]}\]\],
\'probabilities\': \[0.0010302181416348977, 0.0010302181416348977,
0.0010302181416348977, 0.9969093455750953\], \'gate_qubits\':
\[\[1\]\]}, {\'type\': \'qerror\', \'operations\': \[\'u3\'\],
\'instructions\': \[\[{\'name\': \'x\', \'qubits\': \[0\]}\],
\[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'id\', \'qubits\': \[0\]}\]\],
\'probabilities\': \[0.0010302181416348977, 0.0010302181416348977,
0.0010302181416348977, 0.9969093455750953\], \'gate_qubits\':
\[\[2\]\]}, {\'type\': \'qerror\', \'operations\': \[\'u3\'\],
\'instructions\': \[\[{\'name\': \'x\', \'qubits\': \[0\]}\],
\[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'id\', \'qubits\': \[0\]}\]\],
\'probabilities\': \[0.001803112096824766, 0.001803112096824766,
0.001803112096824766, 0.9945906637095256\], \'gate_qubits\': \[\[3\]\]},
{\'type\': \'qerror\', \'operations\': \[\'u3\'\], \'instructions\':
\[\[{\'name\': \'x\', \'qubits\': \[0\]}\], \[{\'name\': \'y\',
\'qubits\': \[0\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}\],
\[{\'name\': \'id\', \'qubits\': \[0\]}\]\], \'probabilities\':
\[0.0023184846498922607, 0.0023184846498922607, 0.0023184846498922607,
0.9930445460503232\], \'gate_qubits\': \[\[4\]\]}, {\'type\':
\'qerror\', \'operations\': \[\'cx\'\], \'instructions\': \[\[{\'name\':
\'x\', \'qubits\': \[0\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}\],
\[{\'name\': \'z\', \'qubits\': \[0\]}\], \[{\'name\': \'x\',
\'qubits\': \[1\]}\], \[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\':
\'x\', \'qubits\': \[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]},
{\'name\': \'x\', \'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\':
\[0\]}, {\'name\': \'x\', \'qubits\': \[1\]}\], \[{\'name\': \'y\',
\'qubits\': \[1\]}\], \[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\':
\'y\', \'qubits\': \[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]},
{\'name\': \'y\', \'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\':
\[0\]}, {\'name\': \'y\', \'qubits\': \[1\]}\], \[{\'name\': \'z\',
\'qubits\': \[1\]}\], \[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\':
\'z\', \'qubits\': \[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]},
{\'name\': \'z\', \'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\':
\[0\]}, {\'name\': \'z\', \'qubits\': \[1\]}\], \[{\'name\': \'id\',
\'qubits\': \[0\]}\]\], \'probabilities\': \[0.002182844139394187,
0.002182844139394187, 0.002182844139394187, 0.002182844139394187,
0.002182844139394187, 0.002182844139394187, 0.002182844139394187,
0.002182844139394187, 0.002182844139394187, 0.002182844139394187,
0.002182844139394187, 0.002182844139394187, 0.002182844139394187,
0.002182844139394187, 0.002182844139394187, 0.9672573379090872\],
\'gate_qubits\': \[\[1, 0\]\]}, {\'type\': \'qerror\', \'operations\':
\[\'cx\'\], \'instructions\': \[\[{\'name\': \'x\', \'qubits\':
\[0\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'x\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'x\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'x\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'x\', \'qubits\': \[1\]}\], \[{\'name\': \'y\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'y\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'y\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'y\', \'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'z\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'z\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'z\', \'qubits\': \[1\]}\], \[{\'name\': \'id\', \'qubits\':
\[0\]}\]\], \'probabilities\': \[0.0020007412998552473,
0.0020007412998552473, 0.0020007412998552473, 0.0020007412998552473,
0.0020007412998552473, 0.0020007412998552473, 0.0020007412998552473,
0.0020007412998552473, 0.0020007412998552473, 0.0020007412998552473,
0.0020007412998552473, 0.0020007412998552473, 0.0020007412998552473,
0.0020007412998552473, 0.0020007412998552473, 0.9699888805021712\],
\'gate_qubits\': \[\[2, 0\]\]}, {\'type\': \'qerror\', \'operations\':
\[\'cx\'\], \'instructions\': \[\[{\'name\': \'x\', \'qubits\':
\[0\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'x\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'x\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'x\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'x\', \'qubits\': \[1\]}\], \[{\'name\': \'y\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'y\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'y\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'y\', \'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'z\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'z\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'z\', \'qubits\': \[1\]}\], \[{\'name\': \'id\', \'qubits\':
\[0\]}\]\], \'probabilities\': \[0.002485439516158936,
0.002485439516158936, 0.002485439516158936, 0.002485439516158936,
0.002485439516158936, 0.002485439516158936, 0.002485439516158936,
0.002485439516158936, 0.002485439516158936, 0.002485439516158936,
0.002485439516158936, 0.002485439516158936, 0.002485439516158936,
0.002485439516158936, 0.002485439516158936, 0.9627184072576159\],
\'gate_qubits\': \[\[2, 1\]\]}, {\'type\': \'qerror\', \'operations\':
\[\'cx\'\], \'instructions\': \[\[{\'name\': \'x\', \'qubits\':
\[0\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'x\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'x\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'x\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'x\', \'qubits\': \[1\]}\], \[{\'name\': \'y\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'y\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'y\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'y\', \'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'z\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'z\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'z\', \'qubits\': \[1\]}\], \[{\'name\': \'id\', \'qubits\':
\[0\]}\]\], \'probabilities\': \[0.0037502825428055767,
0.0037502825428055767, 0.0037502825428055767, 0.0037502825428055767,
0.0037502825428055767, 0.0037502825428055767, 0.0037502825428055767,
0.0037502825428055767, 0.0037502825428055767, 0.0037502825428055767,
0.0037502825428055767, 0.0037502825428055767, 0.0037502825428055767,
0.0037502825428055767, 0.0037502825428055767, 0.9437457618579164\],
\'gate_qubits\': \[\[3, 2\]\]}, {\'type\': \'qerror\', \'operations\':
\[\'cx\'\], \'instructions\': \[\[{\'name\': \'x\', \'qubits\':
\[0\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'x\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'x\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'x\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'x\', \'qubits\': \[1\]}\], \[{\'name\': \'y\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'y\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'y\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'y\', \'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'z\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'z\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'z\', \'qubits\': \[1\]}\], \[{\'name\': \'id\', \'qubits\':
\[0\]}\]\], \'probabilities\': \[0.004401224333760022,
0.004401224333760022, 0.004401224333760022, 0.004401224333760022,
0.004401224333760022, 0.004401224333760022, 0.004401224333760022,
0.004401224333760022, 0.004401224333760022, 0.004401224333760022,
0.004401224333760022, 0.004401224333760022, 0.004401224333760022,
0.004401224333760022, 0.004401224333760022, 0.9339816349935997\],
\'gate_qubits\': \[\[3, 4\]\]}, {\'type\': \'qerror\', \'operations\':
\[\'cx\'\], \'instructions\': \[\[{\'name\': \'x\', \'qubits\':
\[0\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}\], \[{\'name\': \'z\',
\'qubits\': \[0\]}\], \[{\'name\': \'x\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'x\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'x\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'x\', \'qubits\': \[1\]}\], \[{\'name\': \'y\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'y\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'y\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'y\', \'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[1\]}\],
\[{\'name\': \'x\', \'qubits\': \[0\]}, {\'name\': \'z\', \'qubits\':
\[1\]}\], \[{\'name\': \'y\', \'qubits\': \[0\]}, {\'name\': \'z\',
\'qubits\': \[1\]}\], \[{\'name\': \'z\', \'qubits\': \[0\]}, {\'name\':
\'z\', \'qubits\': \[1\]}\], \[{\'name\': \'id\', \'qubits\':
\[0\]}\]\], \'probabilities\': \[0.0046188825262438934,
0.0046188825262438934, 0.0046188825262438934, 0.0046188825262438934,
0.0046188825262438934, 0.0046188825262438934, 0.0046188825262438934,
0.0046188825262438934, 0.0046188825262438934, 0.0046188825262438934,
0.0046188825262438934, 0.0046188825262438934, 0.0046188825262438934,
0.0046188825262438934, 0.0046188825262438934, 0.9307167621063416\],
\'gate_qubits\': \[\[4, 2\]\]}, {\'type\': \'roerror\', \'operations\':
\[\'measure\'\], \'probabilities\': \[\[0.9372499999999999,
0.06275000000000008\], \[0.06275000000000008, 0.9372499999999999\]\],
\'gate_qubits\': \[\[0\]\]}, {\'type\': \'roerror\', \'operations\':
\[\'measure\'\], \'probabilities\': \[\[0.9345, 0.0655\], \[0.0655,
0.9345\]\], \'gate_qubits\': \[\[1\]\]}, {\'type\': \'roerror\',
\'operations\': \[\'measure\'\], \'probabilities\': \[\[0.97075,
0.029249999999999998\], \[0.029249999999999998, 0.97075\]\],
\'gate_qubits\': \[\[2\]\]}, {\'type\': \'roerror\', \'operations\':
\[\'measure\'\], \'probabilities\': \[\[0.9742500000000001,
0.02574999999999994\], \[0.02574999999999994, 0.9742500000000001\]\],
\'gate_qubits\': \[\[3\]\]}, {\'type\': \'roerror\', \'operations\':
\[\'measure\'\], \'probabilities\': \[\[0.8747499999999999,
0.12525000000000008\], \[0.12525000000000008, 0.8747499999999999\]\],
\'gate_qubits\': \[\[4\]\]}\], \'x90_gates\': \[\]}

noise_model = noise.noise_model.NoiseModel.from_dict( noise_dict )

ç›´æ¥åœ¨çœŸå®è®¾å¤‡ä¸Šè¿è¡Œéœ€è¦æœ‰ä¸€ä¸ªIBMQå¸æˆ·ï¼Œå¹¶åœ¨ç¨‹åºä¸­ç™»å½•è¯¥å¸æˆ·ã€‚ä¸ºäº†ä¸ç”¨æ‹…å¿ƒè¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç”±ä¸Šè¿°çº¦æŸå®šä¹‰çš„5-qubitè®¾å¤‡çš„æ¨¡æ‹Ÿï¼ˆæœ¬åœ°è¿è¡Œï¼‰ã€‚

> qr = QuantumRegister(5, \'qr\')
>
> cr = ClassicalRegister(1, \'cr\')
>
> backend = Aer.get_backend(\'qasm_simulator\')

ç°åœ¨å®šä¹‰ANDå‡½æ•°ï¼Œæ­¤å¤„ä¸ç»ƒä¹ 1ä¸­çš„ç‰ˆæœ¬æœ‰ä¸€äº›åŒºåˆ«ã€‚é¦–å…ˆï¼Œç”±äºæ˜¯åœ¨5-qubitå›è·¯ä¸Šå®šä¹‰ï¼Œå› æ­¤éœ€è¦ç¡®å®š5-qubitä¸­çš„å“ªä¸€ä¸ªç”¨äºç¼–ç input1ï¼Œinput2ä»¥åŠoutputã€‚å…¶æ¬¡ï¼Œè¾“å‡ºä¸ºé‡å¤è¿è¡Œ10000æ¬¡æ‰€å‘ç°è¾“å‡ºçš„æ¬¡æ•°ç›´æ–¹å›¾ã€‚

> def AND (input1,input2, q_1=0,q_2=1,q_out=2):
>
> \# The keyword q_1 specifies the qubit used to encode input1
>
> \# The keyword q_2 specifies qubit used to encode input2
>
> \# The keyword q_out specifies qubit to be as output
>
> qc = QuantumCircuit(qr, cr)
>
> \# prepare input on qubits q1 and q2
>
> if input1==\'1\':
>
> qc.x( qr\[ q_1 \] )
>
> if input2==\'1\':
>
> qc.x( qr\[ q_2 \] )
>
> qc.ccx(qr\[ q_1 \],qr\[ q_2 \],qr\[ q_out \]) \# the AND just needs a
> c
>
> qc.measure(qr\[ q_out \],cr\[0\]) \# output from qubit 1 is measured
>
> \# the circuit is run on a simulator, but we do it so that the noise
> and connectivity of Tenerife are also reproduced
>
> job = execute(qc, backend, shots=10000, noise_model=noise_model,
>
> coupling_map=coupling_map,
>
> basis_gates=noise_model.basis_gates)
>
> output = job.result().get_counts()
>
> return output

ä¾‹å¦‚ï¼Œè¿™æ˜¯ä¸¤ä¸ªè¾“å…¥å‡ä¸º0æ—¶çš„ç»“æœã€‚

> result = AND(\'0\',\'0\')
>
> print( result )
>
> plot_histogram( result )
>
> è¾“å‡ºï¼š
>
> {\'1\': 991, \'0\': 9009}

![](pics/media/image368.png)

æ¯”è¾ƒæ‰€æœ‰ç»“æœï¼Œä»¥ä¾¿æ‰¾å‡ºæœ€ä¸å¯é çš„ä¸€ä¸ªã€‚

> worst = 1
>
> for input1 in \[\'0\',\'1\'\]:
>
> for input2 in \[\'0\',\'1\'\]:
>
> print(\'\\nProbability of correct answer for inputs\',input1,input2)
>
> prob = AND(input1,input2, q_1=0,q_2=1,q_out=2)\[str(int( input1==\'1\'
> and input2==\'1\' ))\]/10000
>
> print( prob )
>
> worst = min(worst,prob)
>
> print(\'\\nThe lowest of these probabilities was\',worst)
>
> è¾“å‡ºï¼š
>
> Probability of correct answer for inputs 0 0
>
> 0.9035
>
> Probability of correct answer for inputs 0 1
>
> 0.8978
>
> Probability of correct answer for inputs 1 0
>
> 0.8995
>
> Probability of correct answer for inputs 1 1
>
> 0.9046
>
> The lowest of these probabilities was 0.8978

ä¸Šé¢çš„ANDå‡½æ•°ä½¿ç”¨ccxé—¨æ¥æ‰§è¡Œæ‰€éœ€çš„æ“ä½œã€‚ä½†æ‚¨ç°åœ¨å·²ç»çŸ¥é“å¦‚ä½•æ„å»ºæ‰€éœ€ï¼Œæ‰¾å‡ºå¦ä¸€ç§å®ç°ANDçš„æ–¹æ³•ï¼Œå…¶æœ€ä½æ¦‚ç‡è¦é«˜äºccxã€‚

é™„å½•
====

æœ¬é™„å½•ä¸­åŒ…å«çº¿æ€§ä»£æ•°æ¦‚å¿µçš„æ·±å…¥æ¦‚è¿°ä»¥åŠqiskitä¸­çš„é€Ÿæˆè¯¾ç¨‹ï¼Œé€‚ç”¨äºé‚£äº›å·²ç»ç†Ÿæ‚‰é‡å­çš„äººå‘˜ã€‚

çº¿æ€§ä»£æ•°
--------

è§å‰æ–‡ä¸­çš„"0.3 çº¿æ€§ä»£æ•°"ä¸€èŠ‚ã€‚

Qiskit
------

è§å‰æ–‡ä¸­çš„"0.2 Qiskit"ä¸€èŠ‚ã€‚

æ¸¸æˆä¸æ¼”ç¤º
==========

æ¸¸æˆå’Œæ¼”ç¤ºæ˜¯ä¸€ç§å¯ä»¥å¢å¼ºæ‚¨åœ¨é‡å­è®¡ç®—è¿‡ç¨‹ä¸­æ‰€å­¦æ¦‚å¿µçš„æœ‰è¶£æ–¹å¼ã€‚æˆ‘ä»¬å·²åœ¨æœ¬æ•™ç¨‹çš„é€‚å½“ä½ç½®ç»™å‡ºäº†ç›¸åº”çš„å†…å®¹ä¸ºäº†æ‚¨å¯ä»¥è½»æ¾åœ°è¿›è¡ŒæŸ¥æ‰¾ï¼Œæ­¤å¤„å°†å…¶å†æ¬¡åˆ—å‡ºã€‚

Hello Qiskit Gameï¼šé‡å­æ¯”ç‰¹ä¸é‡å­æ¸¸æˆå…¥é—¨çš„ç®€å•æ‹¼å›¾ã€‚

ä½¿ç”¨QPEä¼°è®¡$\pi$çš„å€¼ï¼šä½¿ç”¨é‡å­ç›¸ä½ä¼°è®¡ç®—æ³•æ¥ä¼°è®¡$\pi$çš„å€¼ã€‚

Hello Qiskit Game
-----------------

**æ³¨ï¼šæœ¬èŠ‚å†…å®¹æ¯”è¾ƒç®€å•ä¸”éœ€è¦æ“ä½œï¼Œå»ºè®®è¯»è€…è‡ªè¡Œé˜…è¯»åŸç‰ˆçº¿ä¸Šæ•™ç¨‹ã€‚**

ä½¿ç”¨é‡å­ç›¸ä½ä¼°è®¡ç®—æ³•æ¥ä¼°è®¡$\mathbf{\pi}$çš„å€¼
--------------------------------------------

### 1 é‡å­ç›¸ä½ä¼°è®¡ç®—æ³•æ¦‚è¿°

é‡å­ç›¸ä½ä¼°è®¡ï¼ˆQPEï¼‰æ˜¯ä¸€ç§é‡å­ç®—æ³•ï¼Œå…¶æ„æˆäº†è®¸å¤šæ›´å¤æ‚é‡å­ç®—æ³•çš„åŸºç¡€ã€‚QPEçš„æ ¸å¿ƒæ˜¯è§£å†³ä¸€ä¸ªç›¸å½“ç®€å•çš„é—®é¢˜ï¼šç»™å®šç®—ç¬¦$U$ä»¥åŠåœ¨$U|\psi\rangle = \exp(2\pi i\theta)|\psi\rangle$æ—¶$U$çš„æœ¬å¾å€¼é‡å­æ€$|\psi\rangle$ï¼Œèƒ½å¤Ÿè·å¾—$\theta$çš„ä¸€ä¸ªä¼°è®¡ï¼Ÿ

ç­”æ¡ˆå½“ç„¶æ˜¯è‚¯å®šã€‚QPEç®—æ³•ç»™å‡ºäº†$2^{n}\theta$ï¼Œå…¶ä¸­$n$æ˜¯ç”¨äºä¼°è®¡ç›¸ä½$\theta$çš„é‡å­æ¯”ç‰¹æ•°é‡ã€‚

### 2 ä¼°è®¡$\mathbf{\pi}$

åœ¨æœ¬æ¬¡æ¼”ç¤ºä¸­ï¼Œæˆ‘ä»¬é€‰ä¸­ï¼š

$$U = u_{1}(\theta),|\psi\rangle = |1\rangle$$

å…¶ä¸­ï¼š

$$u_{1}(\theta) = \begin{bmatrix}
1 & 0 \\
0 & \exp\left( \text{iÎ¸} \right) \\
\end{bmatrix}$$

æ˜¯Qiskitä¸­å¯ç”¨çš„é‡å­é—¨ä¹‹ä¸€ï¼Œå¹¶ä¸”ï¼š

$$u_{1}(\theta)|1\rangle = \exp(i\theta)|1\rangle$$

é€šè¿‡å°†é‡å­é—¨çš„ç›¸ä½è®¾å®šä¸º$\theta = 1$ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä¸¤ä¸ªå…³ç³»å¼æ¥æ±‚è§£$\pi$ï¼š

1.  ä»QPEç®—æ³•çš„è¾“å‡ºä¸­æµ‹é‡å¯¹$2^{n}\theta$çš„ä¼°è®¡ã€‚ç„¶å$\theta = \text{measured}/2^{n}$

2.  ä»ä¸Šè¿°$u_{1}(\theta)$çš„å®šä¹‰ä¸­å¾—çŸ¥$2\pi\theta = 1 \Rightarrow \pi = 1/2\theta$

ç»„åˆæ­¤ä¸¤ä¸ªå…³ç³»ï¼š$\pi = 1/(2 \times (\text{(measured)}/2^{n}))$ã€‚

è‹¥è¦è¯¦ç»†äº†è§£QPEç®—æ³•ï¼Œè¯·æœ¬æ•™ç¨‹ä¸­çš„ç›¸å…³ç« èŠ‚ã€‚

### 3 ç¼–å†™ä»£ç 

å¯¼å…¥è¿è¡Œä»£ç æ—¶å¿…è¦çš„åº“ã€‚

> \#\# import the necessary tools for our work
>
> from IPython.display import clear_output
>
> from qiskit import \*
>
> from qiskit.visualization import plot_histogram
>
> import numpy as np
>
> import matplotlib.pyplot as plotter
>
> from qiskit.tools.monitor import job_monitor
>
> \# Visualisation settings
>
> import seaborn as sns, operator
>
> sns.set_style(\"dark\")
>
> pi = np.pi

å‡½æ•°qft_daggerè®¡ç®—é€†é‡å­å‚…ç«‹å¶å˜æ¢ã€‚æœ‰å…³æ­¤ç®—æ³•çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·é˜…è¯»æœ¬æ•™ç¨‹çš„ç›¸å…³ç« èŠ‚ã€‚

> \#\# Code for inverse Quantum Fourier Transform
>
> \#\# adapted from Qiskit Textbook at
>
> \#\# qiskit.org/textbook
>
> def qft_dagger(circ\_, n_qubits):
>
> \"\"\"n-qubit QFTdagger the first n qubits in circ\"\"\"
>
> for qubit in range(int(n_qubits/2)):
>
> circ\_.swap(qubit, n_qubits-qubit-1)
>
> for j in range(0,n_qubits):
>
> for m in range(j):
>
> circ\_.cu1(-np.pi/float(2\*\*(j-m)), m, j)
>
> circ\_.h(j)

ä¸‹ä¸€ä¸ªå‡½æ•°qpe_preç”¨äºä¸ºä¼°è®¡å‡†å¤‡åˆå§‹æ€ã€‚æ­¤å¤„éœ€è¦æ³¨æ„ï¼Œé€šè¿‡åœ¨é™¤æœ€åä¸€ä¸ªé‡å­æ¯”ç‰¹ä¹‹å¤–çš„æ‰€æœ‰é‡å­æ¯”ç‰¹ä¸Šåº”ç”¨ä¸€ä¸ªHadamardé—¨ï¼Œå¹¶å°†æœ€åä¸€ä¸ªé‡å­æ¯”ç‰¹çš„çŠ¶æ€è®¾ç½®ä¸º$|1\rangle$ï¼Œæ¥åˆ›å»ºåˆå§‹æ€ã€‚

> \#\# Code for initial state of Quantum Phase Estimation
>
> \#\# adapted from Qiskit Textbook at qiskit.org/textbook
>
> \#\# Note that the starting state is created by applying
>
> \#\# H on the first n_qubits, and setting the last qubit to \|psi\> =
> \|1\>
>
> def qpe_pre(circ\_, n_qubits):
>
> circ\_.h(range(n_qubits))
>
> circ\_.x(n_qubits)
>
> for x in reversed(range(n_qubits)):
>
> for \_ in range(2\*\*(n_qubits-1-x)):
>
> circ\_.cu1(1, n_qubits-1-x, n_qubits)

æ¥ä¸‹æ¥ï¼Œç¼–å†™ä¸€ä¸ªå¿«æ·å‡½æ•°run_jobæ¥è¿è¡Œé‡å­å›è·¯å¹¶è¿”å›ç»“æœã€‚

\#\# Run a Qiskit job on either hardware or simulators

> def run_job(circ\_, backend\_, shots\_=1000, optimization_level\_=0):
>
> job = execute(circ\_, backend=backend\_, shots=shots\_,
> optimization_level=optimization_level\_)
>
> job_monitor(job)
>
> return job.result().get_counts(circ\_)

ç„¶åï¼ŒåŠ è½½æ‚¨çš„IBMå¸æˆ·ä»¥ä¾¿ä½¿ç”¨äº‘æ¨¡æ‹Ÿå™¨æˆ–çœŸå®é‡å­è®¾å¤‡ã€‚

> \#\# Load your IBMQ account if
>
> \#\# you\'d like to use the cloud simulator or real quantum devices
>
> IBMQ.save_account(\"your api\", overwrite=True)
>
> IBMQ.load_account()
>
> my_provider = IBMQ.get_provider()
>
> simulator_cloud = my_provider.get_backend(\'ibmq_qasm_simulator\')
>
> device = my_provider.get_backend(\'ibmq_16_melbourne\')
>
> simulator = Aer.get_backend(\'qasm_simulator\')

æœ€åï¼Œå°†æ‰€æœ‰å†…å®¹æ±‡æ€»åˆ°ä¸€ä¸ªåä¸ºget_pi_estimateçš„å‡½æ•°ä¸­ï¼Œè¯¥å‡½æ•°ä½¿ç”¨n_qubitsæ¥è·å–$\pi$çš„ä¼°è®¡å€¼ã€‚

> \#\# Function to estimate pi
>
> \#\# Summary: using the notation in the Qiskit textbook
> (qiskit.org/textbook),
>
> \#\# do quantum phase estimation with the operator U = u1(theta) and
> \|psi\> = \|1\>
>
> \#\# such that u1(theta)\|1\> = exp(2 x pi x i x theta)\|1\>
>
> \#\# By setting theta = 1 radian, we can solve for pi
>
> \#\# using 2\^n x 1 radian = most frequently measured count = 2 x pi
>
> def get_pi_estimate(n_qubits):
>
> \# create the circuit
>
> circ = QuantumCircuit(n_qubits + 1, n_qubits)
>
> \# create the input state
>
> qpe_pre(circ, n_qubits)
>
> \# apply a barrier
>
> circ.barrier()
>
> \# apply the inverse fourier transform
>
> qft_dagger(circ, n_qubits)
>
> \# apply a barrier
>
> circ.barrier()
>
> \# measure all but the last qubits
>
> circ.measure(range(n_qubits), range(n_qubits))
>
> \# run the job and get the results
>
> counts = run_job(circ, backend\_=simulator, shots\_=10000,
> optimization_level\_=0)
>
> \# print(counts)
>
> \# get the count that occurred most frequently
>
> max_counts_result = max(counts, key=counts.get)
>
> max_counts_result = int(max_counts_result, 2)
>
> \# solve for pi from the measured counts
>
> theta = max_counts_result/2\*\*n_qubits
>
> return (1./(2\*theta))

ç°åœ¨ï¼Œä½¿ç”¨ä¸åŒæ•°é‡çš„é‡å­æ¯”ç‰¹è¿è¡Œget_pi_estimateå‡½æ•°å¹¶æ‰“å°ä¼°è®¡å€¼ã€‚

> \# estimate pi using different numbers of qubits
>
> nqs = list(range(2,12+1))
>
> pi_estimates = \[\]
>
> for nq in nqs:
>
> thisnq_pi_estimate = get_pi_estimate(nq)
>
> pi_estimates.append(thisnq_pi_estimate)
>
> print(f\"{nq} qubits, pi â‰ˆ {thisnq_pi_estimate}\")
>
> è¾“å‡ºï¼š
>
> ç•¥

å°†æ‰€æœ‰ç»“æœç»˜åˆ¶ä¸ºä¸€ä¸ªæŠ˜çº¿å›¾ã€‚

> plotter.plot(nqs, \[pi\]\*len(nqs), \'\--r\')
>
> plotter.plot(nqs, pi_estimates, \'.-\', markersize=12)
>
> plotter.xlim(\[1.5, 12.5\])
>
> plotter.ylim(\[1.5, 4.5\])
>
> plotter.legend(\[\'\$\\pi\$\', \'estimate of \$\\pi\$\'\])
>
> plotter.xlabel(\'Number of qubits\', fontdict={\'size\':20})
>
> plotter.ylabel(\'\$\\pi\$ and estimate of \$\\pi\$\',
> fontdict={\'size\':20})
>
> plotter.tick_params(axis=\'x\', labelsize=12)
>
> plotter.tick_params(axis=\'y\', labelsize=12)
>
> plotter.show()

![](pics/media/image369.png)

äº¤äº’æ€§ç´¢å¼•
----------

é™¤äº†æä¾›è¯»è€…å¯ä»¥å°è¯•è¿è¡Œçš„ä»£ç ä¹‹å¤–ï¼Œæœ¬æ•™ç¨‹è¿˜æä¾›äº†è®¸å¤šå°éƒ¨ä»¶æ¥å¸®åŠ©è§£é‡Šç‰¹å®šæ¦‚å¿µã€‚æœ¬èŠ‚åŒ…å«è¿™äº›å†…å®¹çš„éƒ¨åˆ†ä½œä¸ºç´¢å¼•ã€‚è¯»è€…å¯ä»¥é€šè¿‡è¿è¡Œæ¯ä¸ªcellä¸å°éƒ¨ä»¶è¿›è¡Œäº¤äº’ã€‚

**æ³¨ï¼š**æ‚¨å¯ä»¥é€šè¿‡é¼ æ ‡ç‚¹å‡»ä»£ç å•å…ƒå·¦ä¸‹è§’çš„"Try"æ¥å¯ç”¨äº¤äº’ï¼Œæˆ–åœ¨IBM
Quantum Experienceä¸­æŸ¥çœ‹æœ¬é¡µé¢æ¥å¯ç”¨äº¤äº’ã€‚

### äº¤äº’å¼ç¼–ç 

æœ¬æ•™ç¨‹ä¸­æœ€é‡è¦çš„äº¤äº’å…ƒç´ æ˜¯æ›´æ”¹å’Œè¯•éªŒä»£ç çš„èƒ½åŠ›ã€‚è¿™ä¸€ç‚¹å¯ä»¥ç›´æ¥åœ¨æœ¬æ•™ç¨‹çš„ç½‘é¡µä¸Šå®ç°ï¼Œä½†è¯»è€…ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨Jupyter
NotebookæŸ¥çœ‹æœ¬æ•™ç¨‹ï¼Œåœ¨å…¶ä¸­å¯å¡«æ·»åŠ æ›´å¤šçš„å•å…ƒä»¥åŠä¿å­˜ä¿®æ”¹ã€‚äº¤äº’å¼Pythonç¼–ç ä¹Ÿå…è®¸é€šè¿‡[ipywidgets](https://ipywidgets.readthedocs.io/en/latest/)ä½¿ç”¨å°éƒ¨ä»¶ï¼Œæœ¬èŠ‚çš„å…¶ä½™éƒ¨åˆ†å°†ä¸“é—¨æ¼”ç¤ºQiskit
TextBookç»™å‡ºçš„ä¸€äº›å°éƒ¨ä»¶ã€‚

å°éƒ¨ä»¶ä½äºqiskit_textbook.widgetsä¸­ï¼Œå¯ä»¥é€šè¿‡å¦‚ä¸‹ä»£ç å¯¼å…¥ï¼š

from qiskit_textbook.widgets import gate_demo

gate_demo()

from qiskit_textbook.widgets import binary_widget

binary_widget(nbits=5)

from qiskit_textbook.widgets import scalable_circuit

from numpy import pi

def qft_rotations(circuit, n):

\"\"\"Performs qft on the first n qubits in circuit (without
swaps)\"\"\"

if n == 0:

return circuit

n -= 1

circuit.h(n)

for qubit in range(n):

circuit.cu1(pi/2\*\*(n-qubit), qubit, n)

\# At the end of our function, we call the same function again on

\# the next qubits (we reduced n by one earlier in the function)

qft_rotations(circuit, n)

def swap_qubits(circuit, n):

\"\"\"Reverse the order of qubits\"\"\"

for qubit in range(n//2):

circuit.swap(qubit, n-qubit-1)

return circuit

def qft(circuit, n):

\"\"\"QFT on the first n qubits in circuit\"\"\"

qft_rotations(circuit, n)

swap_qubits(circuit, n)

return circuit

scalable_circuit(qft)

from qiskit_textbook.widgets import bv_widget

bv_widget(2, \"11\", hide_oracle=True)

from qiskit_textbook.widgets import dj_widget

dj_widget(size=\"large\", case=\"balanced\", hide_oracle=True)

é™„ä»¶ï¼šåœ¨æœ¬åœ°å®Œå…¨å®ç°Qiskit TextBook
===================================

å› ä¸ºpyscfåº“æ²¡æœ‰åœ¨Windowsä¸Šå®ç°ï¼Œæ‚¨å¯ä»¥åˆ©ç”¨Linuxçš„Windowså­ç³»ç»Ÿï¼ˆWSLï¼‰åœ¨æœ¬åœ°å®Œå…¨å®ç°Qiskit
TextBookã€‚

WSLçš„å®‰è£…è¿‡ç¨‹è¯·æŸ¥é˜…ï¼š<https://docs.microsoft.com/zh-cn/windows/wsl/install-win10>

å»ºè®®åœ¨WSLä¸­å®‰è£…[Miniconda](https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/)ï¼Œåœ¨å®‰è£…å®Œæˆåå…ˆä¸ç”¨æ›´æ”¹è½¯ä»¶åŒ…çš„å®‰è£…æºã€‚é¦–å…ˆï¼Œå®‰è£…pyscfï¼š

conda install -c pyscf pyscf

ç„¶åæ›´æ”¹condaçš„å®‰è£…æºä¸ºæ¸…åæºï¼š

conda config \--set show_channel_urls yes \#ç”Ÿæˆ.condarc

conda clean -i \#æ¸…é™¤ç¼“å­˜

nano .condarc \#ä¿®æ”¹.condarc

æ¸…é™¤.condarcæ–‡ä»¶ä¸­çš„å†…å®¹åï¼Œå°†ä¸‹é¢çš„å†…å®¹å¤åˆ¶è¿›.condarcä¸­ã€‚

> channels:
>
> \- defaults
>
> show_channel_urls: true
>
> channel_alias: https://mirrors.tuna.tsinghua.edu.cn/anaconda
>
> default_channels:
>
> \- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main
>
> \- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free
>
> \- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r
>
> \- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro
>
> \- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2
>
> custom_channels:
>
> conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
>
> msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
>
> bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
>
> menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
>
> pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
>
> simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud

ç”¨condaå®‰è£…å…¶ä»–åŒ…ï¼š

conda install -c conda-forge qutip

conda install jupyter matplotlib scikit-learn cython lxml sympy
ipywidgets

ä½¿ç”¨pipå®‰è£…Qiskitï¼š

pip config set global.index-url
<https://mirrors.aliyun.com/pypi/simple/>

æˆ–

pip config set global.index-url
<https://pypi.tuna.tsinghua.edu.cn/simple>

pip install qiskit

æœ€åæŒ‰ç…§"0.0 è®¾ç½®ç¯å¢ƒ"ä¸­çš„æ–¹å¼å®‰è£…qiskit_textbookè½¯ä»¶åŒ…ã€‚
